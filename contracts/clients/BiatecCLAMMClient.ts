/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^2
 */
import * as algokit from '@algorandfoundation/algokit-utils'
import type {
  ABIAppCallArg,
  AppCallTransactionResult,
  AppCallTransactionResultOfType,
  AppCompilationResult,
  AppReference,
  AppState,
  CoreAppCallArgs,
  RawAppCallArgs,
  TealTemplateParams,
} from '@algorandfoundation/algokit-utils/types/app'
import type {
  AppClientCallCoreParams,
  AppClientCompilationParams,
  AppClientDeployCoreParams,
  AppDetails,
  ApplicationClient,
} from '@algorandfoundation/algokit-utils/types/app-client'
import type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'
import type { SendTransactionResult, TransactionToSign, SendTransactionFrom } from '@algorandfoundation/algokit-utils/types/transaction'
import type { ABIResult, TransactionWithSigner } from 'algosdk'
import { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer, modelsv2 } from 'algosdk'
export const APP_SPEC: AppSpec = {
  "hints": {
    "createApplication()void": {
      "call_config": {
        "no_op": "CREATE"
      }
    },
    "getCurrentPrice()uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "getHypotheticPrice(uint64,uint64)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "getPriceDivider()uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "getLPTokenId()uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "bootstrap(pay,uint64,uint64,uint32,uint64,uint64,uint64,uint8,uint64,uint64)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "addLiquidity(txn,txn,uint64,uint64,uint64)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "removeLiquidity(axfer,uint64,uint64,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "swap(axfer,uint64,uint64,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "calculateAssetBWithdrawOnAssetADeposit(uint64,uint64,uint64)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    }
  },
  "bare_call_config": {
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "close_out": "NEVER",
    "update_application": "NEVER",
    "delete_application": "NEVER"
  },
  "schema": {
    "local": {
      "declared": {},
      "reserved": {}
    },
    "global": {
      "declared": {
        "assetA": {
          "type": "uint64",
          "key": "a"
        },
        "assetB": {
          "type": "uint64",
          "key": "b"
        },
        "assetABalance": {
          "type": "uint64",
          "key": "ab"
        },
        "assetBBalance": {
          "type": "uint64",
          "key": "bb"
        },
        "priceMaxA": {
          "type": "uint64",
          "key": "pa"
        },
        "priceMaxB": {
          "type": "uint64",
          "key": "pb"
        },
        "priceMaxASqrt": {
          "type": "uint64",
          "key": "pas"
        },
        "priceMaxBSqrt": {
          "type": "uint64",
          "key": "pbs"
        },
        "poolToken": {
          "type": "uint64",
          "key": "p"
        },
        "feeB100000": {
          "type": "bytes",
          "key": "f"
        },
        "ratio": {
          "type": "uint64",
          "key": "r"
        },
        "scale": {
          "type": "uint64",
          "key": "scale"
        },
        "identityProvider": {
          "type": "uint64",
          "key": "i"
        },
        "poolProvider": {
          "type": "uint64",
          "key": "pp"
        },
        "governor": {
          "type": "bytes",
          "key": "g"
        },
        "verificationClass": {
          "type": "bytes",
          "key": "c"
        },
        "engagementClass": {
          "type": "bytes",
          "key": "e"
        }
      },
      "reserved": {}
    }
  },
  "state": {
    "global": {
      "num_byte_slices": 4,
      "num_uints": 13
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0
    }
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCgovLyBUaGlzIFRFQUwgd2FzIGdlbmVyYXRlZCBieSBURUFMU2NyaXB0IHYwLjg2LjAKLy8gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29yYW5kZm91bmRhdGlvbi9URUFMU2NyaXB0CgovLyBUaGlzIGNvbnRyYWN0IGlzIGNvbXBsaWFudCB3aXRoIGFuZC9vciBpbXBsZW1lbnRzIHRoZSBmb2xsb3dpbmcgQVJDczogWyBBUkM0IF0KCi8vIFRoZSBmb2xsb3dpbmcgdGVuIGxpbmVzIG9mIFRFQUwgaGFuZGxlIGluaXRpYWwgcHJvZ3JhbSBmbG93Ci8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIHRvIG1ha2UgaXQgZWFzeSBmb3IgYW55b25lIHRvIHBhcnNlIHRoZSBzdGFydCBvZiB0aGUgcHJvZ3JhbSBhbmQgZGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgYWN0aW9uIGlzIGFsbG93ZWQKLy8gSGVyZSwgYWN0aW9uIHJlZmVycyB0byB0aGUgT25Db21wbGV0ZSBpbiBjb21iaW5hdGlvbiB3aXRoIHdoZXRoZXIgdGhlIGFwcCBpcyBiZWluZyBjcmVhdGVkIG9yIGNhbGxlZAovLyBFdmVyeSBwb3NzaWJsZSBhY3Rpb24gZm9yIHRoaXMgY29udHJhY3QgaXMgcmVwcmVzZW50ZWQgaW4gdGhlIHN3aXRjaCBzdGF0ZW1lbnQKLy8gSWYgdGhlIGFjdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIGNvbnRyYWN0LCBpdHMgcmVzcGVjdGl2ZSBicmFuY2ggd2lsbCBiZSAiKk5PVF9JTVBMRU1FTlRFRCIgd2hpY2gganVzdCBjb250YWlucyAiZXJyIgp0eG4gQXBwbGljYXRpb25JRAohCmludCA2CioKdHhuIE9uQ29tcGxldGlvbgorCnN3aXRjaCAqY2FsbF9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqY3JlYXRlX05vT3AgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVECgoqTk9UX0lNUExFTUVOVEVEOgoJZXJyCgovLyBjcmVhdGVBcHBsaWNhdGlvbigpdm9pZAoqYWJpX3JvdXRlX2NyZWF0ZUFwcGxpY2F0aW9uOgoJLy8gZXhlY3V0ZSBjcmVhdGVBcHBsaWNhdGlvbigpdm9pZAoJY2FsbHN1YiBjcmVhdGVBcHBsaWNhdGlvbgoJaW50IDEKCXJldHVybgoKLy8gY3JlYXRlQXBwbGljYXRpb24oKTogdm9pZAovLwovLyBJbml0aWFsIHNldHVwCmNyZWF0ZUFwcGxpY2F0aW9uOgoJcHJvdG8gMCAwCgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NzYKCS8vIGxvZyh2ZXJzaW9uKQoJYnl0ZSAiQ0xBTU0tMDEtMDEtMDEiCglsb2cKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo3NwoJLy8gdGhpcy5nb3Zlcm5vci52YWx1ZSA9IEFkZHJlc3MuZnJvbUJ5dGVzKGdvdmVybm9yKQoJYnl0ZSAweDY3IC8vICJnIgoJYnl0ZSAiQUxHT05BVVRTUElVSERDWDNTTEZYT0ZEVUtPRTRWWTM2WFY0SlgySkhRVFdKTktWQktQRUJRQUNSWSIKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NzgKCS8vIHRoaXMuc2NhbGUudmFsdWUgPSBTQ0FMRQoJYnl0ZSAweDczNjM2MTZjNjUgLy8gInNjYWxlIgoJaW50IDEwMDAwMDAwMDAKCWFwcF9nbG9iYWxfcHV0CglyZXRzdWIKCi8vIGdldEN1cnJlbnRQcmljZSgpdWludDY0CiphYmlfcm91dGVfZ2V0Q3VycmVudFByaWNlOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBleGVjdXRlIGdldEN1cnJlbnRQcmljZSgpdWludDY0CgljYWxsc3ViIGdldEN1cnJlbnRQcmljZQoJaXRvYgoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGdldEN1cnJlbnRQcmljZSgpOiB1aW50NjQKZ2V0Q3VycmVudFByaWNlOgoJcHJvdG8gMCAxCgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6ODMKCS8vIHJldHVybiB0aGlzLnJhdGlvLnZhbHVlOwoJYnl0ZSAweDcyIC8vICJyIgoJYXBwX2dsb2JhbF9nZXQKCXJldHN1YgoKLy8gZ2V0SHlwb3RoZXRpY1ByaWNlKHVpbnQ2NCx1aW50NjQpdWludDY0CiphYmlfcm91dGVfZ2V0SHlwb3RoZXRpY1ByaWNlOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBhc3NldEJRdWFudGl0eTogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gYXNzZXRBUXVhbnRpdHk6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgZ2V0SHlwb3RoZXRpY1ByaWNlKHVpbnQ2NCx1aW50NjQpdWludDY0CgljYWxsc3ViIGdldEh5cG90aGV0aWNQcmljZQoJaXRvYgoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGdldEh5cG90aGV0aWNQcmljZShhc3NldEFRdWFudGl0eTogdWludDY0LCBhc3NldEJRdWFudGl0eTogdWludDY0KTogdWludDY0CmdldEh5cG90aGV0aWNQcmljZToKCXByb3RvIDIgMQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjg4CgkvLyByZXR1cm4gdGhpcy5nZXRQcmljZShhc3NldEFRdWFudGl0eSwgYXNzZXRCUXVhbnRpdHkpOwoJZnJhbWVfZGlnIC0yIC8vIGFzc2V0QlF1YW50aXR5OiB1aW50NjQKCWZyYW1lX2RpZyAtMSAvLyBhc3NldEFRdWFudGl0eTogdWludDY0CgljYWxsc3ViIGdldFByaWNlCglyZXRzdWIKCi8vIGdldFByaWNlRGl2aWRlcigpdWludDY0CiphYmlfcm91dGVfZ2V0UHJpY2VEaXZpZGVyOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBleGVjdXRlIGdldFByaWNlRGl2aWRlcigpdWludDY0CgljYWxsc3ViIGdldFByaWNlRGl2aWRlcgoJaXRvYgoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGdldFByaWNlRGl2aWRlcigpOiB1aW50NjQKZ2V0UHJpY2VEaXZpZGVyOgoJcHJvdG8gMCAxCgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6OTMKCS8vIHJldHVybiB0aGlzLnNjYWxlLnZhbHVlOwoJYnl0ZSAweDczNjM2MTZjNjUgLy8gInNjYWxlIgoJYXBwX2dsb2JhbF9nZXQKCXJldHN1YgoKLy8gZ2V0TFBUb2tlbklkKCl1aW50NjQKKmFiaV9yb3V0ZV9nZXRMUFRva2VuSWQ6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIGV4ZWN1dGUgZ2V0TFBUb2tlbklkKCl1aW50NjQKCWNhbGxzdWIgZ2V0TFBUb2tlbklkCglpdG9iCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gZ2V0TFBUb2tlbklkKCk6IHVpbnQ2NApnZXRMUFRva2VuSWQ6Cglwcm90byAwIDEKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo5OAoJLy8gcmV0dXJuIHRoaXMucG9vbFRva2VuLnZhbHVlLmlkOwoJYnl0ZSAweDcwIC8vICJwIgoJYXBwX2dsb2JhbF9nZXQKCXJldHN1YgoKLy8gYm9vdHN0cmFwKHBheSx1aW50NjQsdWludDY0LHVpbnQzMix1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0KXVpbnQ2NAoqYWJpX3JvdXRlX2Jvb3RzdHJhcDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gcG9vbFByb3ZpZGVyOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDkKCWJ0b2kKCgkvLyBpZGVudGl0eVByb3ZpZGVyOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDgKCWJ0b2kKCgkvLyB2ZXJpZmljYXRpb25DbGFzczogdWludDgKCXR4bmEgQXBwbGljYXRpb25BcmdzIDcKCWR1cAoJbGVuCglpbnQgMQoJPT0KCWFzc2VydAoJYnRvaQoKCS8vIGN1cnJlbnRQcmljZTogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA2CglidG9pCgoJLy8gcHJpY2VNYXhCOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDUKCWJ0b2kKCgkvLyBwcmljZU1heEE6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAoJYnRvaQoKCS8vIGZlZUIxMDAwMDA6IHVpbnQzMgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZHVwCglsZW4KCWludCA0Cgk9PQoJYXNzZXJ0CglidG9pCgoJLy8gYXNzZXRCOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyBhc3NldEE6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIHR4U2VlZDogcGF5Cgl0eG4gR3JvdXBJbmRleAoJaW50IDEKCS0KCWR1cAoJZ3R4bnMgVHlwZUVudW0KCWludCBwYXkKCT09Cglhc3NlcnQKCgkvLyBleGVjdXRlIGJvb3RzdHJhcChwYXksdWludDY0LHVpbnQ2NCx1aW50MzIsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDgsdWludDY0LHVpbnQ2NCl1aW50NjQKCWNhbGxzdWIgYm9vdHN0cmFwCglpdG9iCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gYm9vdHN0cmFwKHR4U2VlZDogUGF5VHhuLCBhc3NldEE6IEFzc2V0SUQsIGFzc2V0QjogQXNzZXRJRCwgZmVlQjEwMDAwMDogdWludDMyLCBwcmljZU1heEE6IHVpbnQ2NCwgcHJpY2VNYXhCOiB1aW50NjQsIGN1cnJlbnRQcmljZTogdWludDY0LCB2ZXJpZmljYXRpb25DbGFzczogdWludDgsIGlkZW50aXR5UHJvdmlkZXI6IEFwcElELCBwb29sUHJvdmlkZXI6IEFwcElEKTogQXNzZXRJRAovLwovLyBBbnlib2R5IGNhbiBkZXBsb3kgdGhlIGNsYW1tIHNtYXJ0IGNvbnRyYWN0Ci8vIEBwYXJhbSB0eFNlZWQgU2VlZCB0cmFuc2FjdGlvbiBzbyB0aGF0IHNtYXJ0IGNvbnRyYWN0IGNhbiBvcHQgaW4gdG8gdGhlIGFzc2V0cwovLyBAcGFyYW0gYXNzZXRBIEFzc2V0IEEgSUQgbXVzdCBiZSBsb3dlciB0aGVuIEFzc2V0IEIgSUQKLy8gQHBhcmFtIGFzc2V0QiBBc3NldCBCCi8vIEBwYXJhbSBmZWVCMTAwMDAwIEZlZSBpbiAxMDAwMDAgYmFzZSBsZXZlbC4gdmFsdWUgMTAwMDAgPSAxMDAwMC8xMDAwMDAgPSAwLDEgPSAxMCUgZmVlLiAxMDAwID0gMSUuIDEwMCA9IDAsMSUuIDEwID0gMCwwMSUgPSAxIGJhc2UgcG9pbnQKLy8gQHBhcmFtIHZlcmlmaWNhdGlvbkNsYXNzIEFzc2V0IEIKLy8gQHJldHVybnMgTFAgdG9rZW4gSUQKYm9vdHN0cmFwOgoJcHJvdG8gMTAgMQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjEyMgoJLy8gdmVyaWZ5UGF5VHhuKHR4U2VlZCwgeyByZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcywgYW1vdW50OiB7IGdyZWF0ZXJUaGFuRXF1YWxUbzogMzAwXzAwMCB9IH0pCgkvLyB2ZXJpZnkgcmVjZWl2ZXIKCWZyYW1lX2RpZyAtMSAvLyB0eFNlZWQ6IFBheVR4bgoJZ3R4bnMgUmVjZWl2ZXIKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IGFtb3VudAoJZnJhbWVfZGlnIC0xIC8vIHR4U2VlZDogUGF5VHhuCglndHhucyBBbW91bnQKCWludCAzMDBfMDAwCgk+PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTIzCgkvLyBhc3NlcnQodGhpcy5nb3Zlcm5vci52YWx1ZSA9PT0gQWRkcmVzcy5mcm9tQnl0ZXMoZ292ZXJub3IpKQoJYnl0ZSAweDY3IC8vICJnIgoJYXBwX2dsb2JhbF9nZXQKCWJ5dGUgIkFMR09OQVVUU1BJVUhEQ1gzU0xGWE9GRFVLT0U0VlkzNlhWNEpYMkpIUVRXSk5LVkJLUEVCUUFDUlkiCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTI0CgkvLyBhc3NlcnQoYXNzZXRBIDwgYXNzZXRCKQoJZnJhbWVfZGlnIC0yIC8vIGFzc2V0QTogQXNzZXRJRAoJZnJhbWVfZGlnIC0zIC8vIGFzc2V0QjogQXNzZXRJRAoJPAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTI1CgkvLyBhc3NlcnQoZmVlQjEwMDAwMCA8IDEwMDAwMDApCglmcmFtZV9kaWcgLTQgLy8gZmVlQjEwMDAwMDogdWludDMyCglpbnQgMTAwMDAwMAoJPAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTI2CgkvLyBhc3NlcnQodmVyaWZpY2F0aW9uQ2xhc3MgPCA0KQoJZnJhbWVfZGlnIC04IC8vIHZlcmlmaWNhdGlvbkNsYXNzOiB1aW50OAoJaW50IDQKCTwKCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjEyNwoJLy8gYXNzZXJ0KCF0aGlzLnJhdGlvLmV4aXN0cykKCXR4bmEgQXBwbGljYXRpb25zIDAKCWJ5dGUgMHg3MiAvLyAiciIKCWFwcF9nbG9iYWxfZ2V0X2V4Cglzd2FwCglwb3AKCSEKCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjEyOAoJLy8gYXNzZXJ0KGFzc2V0QS5kZWNpbWFscyA8PSBTQ0FMRV9ERUNJTUFMUykKCWZyYW1lX2RpZyAtMiAvLyBhc3NldEE6IEFzc2V0SUQKCWFzc2V0X3BhcmFtc19nZXQgQXNzZXREZWNpbWFscwoJcG9wCglpbnQgOQoJPD0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjEyOQoJLy8gYXNzZXJ0KGFzc2V0Qi5kZWNpbWFscyA8PSBTQ0FMRV9ERUNJTUFMUykKCWZyYW1lX2RpZyAtMyAvLyBhc3NldEI6IEFzc2V0SUQKCWFzc2V0X3BhcmFtc19nZXQgQXNzZXREZWNpbWFscwoJcG9wCglpbnQgOQoJPD0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjEzMQoJLy8gdGhpcy5pZGVudGl0eVByb3ZpZGVyLnZhbHVlID0gaWRlbnRpdHlQcm92aWRlcgoJYnl0ZSAweDY5IC8vICJpIgoJZnJhbWVfZGlnIC05IC8vIGlkZW50aXR5UHJvdmlkZXI6IEFwcElECglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjEzMgoJLy8gdGhpcy5wb29sUHJvdmlkZXIudmFsdWUgPSBwb29sUHJvdmlkZXIKCWJ5dGUgMHg3MDcwIC8vICJwcCIKCWZyYW1lX2RpZyAtMTAgLy8gcG9vbFByb3ZpZGVyOiBBcHBJRAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxMzQKCS8vIHRoaXMucHJpY2VNYXhBLnZhbHVlID0gcHJpY2VNYXhBCglieXRlIDB4NzA2MSAvLyAicGEiCglmcmFtZV9kaWcgLTUgLy8gcHJpY2VNYXhBOiB1aW50NjQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTM1CgkvLyB0aGlzLnByaWNlTWF4Qi52YWx1ZSA9IHByaWNlTWF4QgoJYnl0ZSAweDcwNjIgLy8gInBiIgoJZnJhbWVfZGlnIC02IC8vIHByaWNlTWF4QjogdWludDY0CglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjEzNgoJLy8gdGhpcy5wcmljZU1heEFTcXJ0LnZhbHVlID0gc3FydChwcmljZU1heEEgKiBTQ0FMRSkKCWJ5dGUgMHg3MDYxNzMgLy8gInBhcyIKCWZyYW1lX2RpZyAtNSAvLyBwcmljZU1heEE6IHVpbnQ2NAoJaW50IDEwMDAwMDAwMDAKCSoKCXNxcnQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTM3CgkvLyB0aGlzLnByaWNlTWF4QlNxcnQudmFsdWUgPSBzcXJ0KHByaWNlTWF4QiAqIFNDQUxFKQoJYnl0ZSAweDcwNjI3MyAvLyAicGJzIgoJZnJhbWVfZGlnIC02IC8vIHByaWNlTWF4QjogdWludDY0CglpbnQgMTAwMDAwMDAwMAoJKgoJc3FydAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxMzgKCS8vIHRoaXMuYXNzZXRBQmFsYW5jZS52YWx1ZSA9IDAKCWJ5dGUgMHg2MTYyIC8vICJhYiIKCWludCAwCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjEzOQoJLy8gdGhpcy5hc3NldEJCYWxhbmNlLnZhbHVlID0gMAoJYnl0ZSAweDYyNjIgLy8gImJiIgoJaW50IDAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTQwCgkvLyB0aGlzLnJhdGlvLnZhbHVlID0gY3VycmVudFByaWNlCglieXRlIDB4NzIgLy8gInIiCglmcmFtZV9kaWcgLTcgLy8gY3VycmVudFByaWNlOiB1aW50NjQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTQyCgkvLyB0aGlzLmFzc2V0QS52YWx1ZSA9IGFzc2V0QQoJYnl0ZSAweDYxIC8vICJhIgoJZnJhbWVfZGlnIC0yIC8vIGFzc2V0QTogQXNzZXRJRAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxNDMKCS8vIHRoaXMuYXNzZXRCLnZhbHVlID0gYXNzZXRCCglieXRlIDB4NjIgLy8gImIiCglmcmFtZV9kaWcgLTMgLy8gYXNzZXRCOiBBc3NldElECglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjE0NAoJLy8gdGhpcy5wb29sVG9rZW4udmFsdWUgPSB0aGlzLmRvQ3JlYXRlUG9vbFRva2VuKGFzc2V0QSwgYXNzZXRCKQoJYnl0ZSAweDcwIC8vICJwIgoJZnJhbWVfZGlnIC0zIC8vIGFzc2V0QjogQXNzZXRJRAoJZnJhbWVfZGlnIC0yIC8vIGFzc2V0QTogQXNzZXRJRAoJY2FsbHN1YiBkb0NyZWF0ZVBvb2xUb2tlbgoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxNDUKCS8vIHRoaXMuZmVlQjEwMDAwMC52YWx1ZSA9IGZlZUIxMDAwMDAKCWJ5dGUgMHg2NiAvLyAiZiIKCWZyYW1lX2RpZyAtNCAvLyBmZWVCMTAwMDAwOiB1aW50MzIKCWl0b2IKCWV4dHJhY3QgNCA0CglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjE0NwoJLy8gdGhpcy5kb09wdEluKGFzc2V0QSkKCWZyYW1lX2RpZyAtMiAvLyBhc3NldEE6IEFzc2V0SUQKCWNhbGxzdWIgZG9PcHRJbgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjE0OAoJLy8gdGhpcy5kb09wdEluKGFzc2V0QikKCWZyYW1lX2RpZyAtMyAvLyBhc3NldEI6IEFzc2V0SUQKCWNhbGxzdWIgZG9PcHRJbgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjE1MAoJLy8gcmV0dXJuIHRoaXMucG9vbFRva2VuLnZhbHVlOwoJYnl0ZSAweDcwIC8vICJwIgoJYXBwX2dsb2JhbF9nZXQKCXJldHN1YgoKLy8gZG9BeGZlcihyZWNlaXZlcjogQWRkcmVzcywgYXNzZXQ6IEFzc2V0SUQsIGFtb3VudDogdWludDY0KTogdm9pZApkb0F4ZmVyOgoJcHJvdG8gMyAwCgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTU0CgkvLyBzZW5kQXNzZXRUcmFuc2Zlcih7CgkvLyAgICAgICBhc3NldFJlY2VpdmVyOiByZWNlaXZlciwKCS8vICAgICAgIHhmZXJBc3NldDogYXNzZXQsCgkvLyAgICAgICBhc3NldEFtb3VudDogYW1vdW50LAoJLy8gICAgICAgZmVlOiAwLAoJLy8gICAgIH0pCglpdHhuX2JlZ2luCglpbnQgYXhmZXIKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxNTUKCS8vIGFzc2V0UmVjZWl2ZXI6IHJlY2VpdmVyCglmcmFtZV9kaWcgLTEgLy8gcmVjZWl2ZXI6IEFkZHJlc3MKCWl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjE1NgoJLy8geGZlckFzc2V0OiBhc3NldAoJZnJhbWVfZGlnIC0yIC8vIGFzc2V0OiBBc3NldElECglpdHhuX2ZpZWxkIFhmZXJBc3NldAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjE1NwoJLy8gYXNzZXRBbW91bnQ6IGFtb3VudAoJZnJhbWVfZGlnIC0zIC8vIGFtb3VudDogdWludDY0CglpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTU4CgkvLyBmZWU6IDAKCWludCAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCXJldHN1YgoKLy8gZG9PcHRJbihhc3NldDogQXNzZXRJRCk6IHZvaWQKZG9PcHRJbjoKCXByb3RvIDEgMAoKCS8vICppZjBfY29uZGl0aW9uCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxNjMKCS8vIGFzc2V0LmlkID4gMAoJZnJhbWVfZGlnIC0xIC8vIGFzc2V0OiBBc3NldElECglpbnQgMAoJPgoJYnogKmlmMF9lbmQKCgkvLyAqaWYwX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjE2NQoJLy8gdGhpcy5kb0F4ZmVyKHRoaXMuYXBwLmFkZHJlc3MsIGFzc2V0LCAwKQoJaW50IDAKCWZyYW1lX2RpZyAtMSAvLyBhc3NldDogQXNzZXRJRAoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWNhbGxzdWIgZG9BeGZlcgoKKmlmMF9lbmQ6CglyZXRzdWIKCi8vIGRvQ3JlYXRlUG9vbFRva2VuKGFzc2V0QTogQXNzZXRJRCwgYXNzZXRCOiBBc3NldElEKTogQXNzZXRJRApkb0NyZWF0ZVBvb2xUb2tlbjoKCXByb3RvIDIgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTczCgkvLyBuYW1lID0gJ0ItJyArIGFzc2V0QS51bml0TmFtZSArICctJyArIGFzc2V0Qi51bml0TmFtZQoJYnl0ZSAweDQyMmQgLy8gIkItIgoJZnJhbWVfZGlnIC0xIC8vIGFzc2V0QTogQXNzZXRJRAoJYXNzZXRfcGFyYW1zX2dldCBBc3NldFVuaXROYW1lCglwb3AKCWNvbmNhdAoJYnl0ZSAweDJkIC8vICItIgoJY29uY2F0CglmcmFtZV9kaWcgLTIgLy8gYXNzZXRCOiBBc3NldElECglhc3NldF9wYXJhbXNfZ2V0IEFzc2V0VW5pdE5hbWUKCXBvcAoJY29uY2F0CglmcmFtZV9idXJ5IDAgLy8gbmFtZTogYnl0ZVtdCgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTc1CgkvLyByZXR1cm4gc2VuZEFzc2V0Q3JlYXRpb24oewoJLy8gICAgICAgY29uZmlnQXNzZXROYW1lOiBuYW1lLAoJLy8gICAgICAgY29uZmlnQXNzZXRVbml0TmFtZTogJ0JMUCcsCgkvLyAgICAgICBjb25maWdBc3NldFRvdGFsOiBUT1RBTF9TVVBQTFksCgkvLyAgICAgICBjb25maWdBc3NldERlY2ltYWxzOiBMUF9UT0tFTl9ERUNJTUFMUywKCS8vICAgICAgIGNvbmZpZ0Fzc2V0TWFuYWdlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgIGNvbmZpZ0Fzc2V0UmVzZXJ2ZTogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICB9KTsKCWl0eG5fYmVnaW4KCWludCBhY2ZnCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTc2CgkvLyBjb25maWdBc3NldE5hbWU6IG5hbWUKCWZyYW1lX2RpZyAwIC8vIG5hbWU6IGJ5dGVbXQoJaXR4bl9maWVsZCBDb25maWdBc3NldE5hbWUKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxNzcKCS8vIGNvbmZpZ0Fzc2V0VW5pdE5hbWU6ICdCTFAnCglieXRlIDB4NDI0YzUwIC8vICJCTFAiCglpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0VW5pdE5hbWUKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxNzgKCS8vIGNvbmZpZ0Fzc2V0VG90YWw6IFRPVEFMX1NVUFBMWQoJaW50IDEwMDAwMDAwMDAwMDAwMDAwCglpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0VG90YWwKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxNzkKCS8vIGNvbmZpZ0Fzc2V0RGVjaW1hbHM6IExQX1RPS0VOX0RFQ0lNQUxTCglpbnQgNgoJaXR4bl9maWVsZCBDb25maWdBc3NldERlY2ltYWxzCgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTgwCgkvLyBjb25maWdBc3NldE1hbmFnZXI6IHRoaXMuYXBwLmFkZHJlc3MKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0TWFuYWdlcgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjE4MQoJLy8gY29uZmlnQXNzZXRSZXNlcnZlOiB0aGlzLmFwcC5hZGRyZXNzCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJaXR4bl9maWVsZCBDb25maWdBc3NldFJlc2VydmUKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CglpdHhuIENyZWF0ZWRBc3NldElECgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCglyZXRzdWIKCi8vIGFkZExpcXVpZGl0eSh0eG4sdHhuLHVpbnQ2NCx1aW50NjQsdWludDY0KXVpbnQ2NAoqYWJpX3JvdXRlX2FkZExpcXVpZGl0eToKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gYXNzZXRCOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWJ0b2kKCgkvLyBhc3NldEE6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIHBvb2xBc3NldDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gdHhBc3NldEJEZXBvc2l0OiB0eG4KCXR4biBHcm91cEluZGV4CglpbnQgMQoJLQoKCS8vIHR4QXNzZXRBRGVwb3NpdDogdHhuCgl0eG4gR3JvdXBJbmRleAoJaW50IDIKCS0KCgkvLyBleGVjdXRlIGFkZExpcXVpZGl0eSh0eG4sdHhuLHVpbnQ2NCx1aW50NjQsdWludDY0KXVpbnQ2NAoJY2FsbHN1YiBhZGRMaXF1aWRpdHkKCWl0b2IKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBhZGRMaXF1aWRpdHkodHhBc3NldEFEZXBvc2l0OiBUeG4sIHR4QXNzZXRCRGVwb3NpdDogVHhuLCBwb29sQXNzZXQ6IEFzc2V0SUQsIGFzc2V0QTogQXNzZXRJRCwgYXNzZXRCOiBBc3NldElEKTogdWludDY0Ci8vCi8vIFRoaXMgbWV0aG9kIGFkZHMgQXNzZXQgQSBhbmQgQXNzZXQgQiB0byB0aGUgQXV0b21hdGVkIE1hcmtldCBNYWtlciBDb25jZW50cmF0ZWQgTGlxdWRpZGl0eSBQb29sIGFuZCBzZW5kIHRvIHRoZSBsaXF1ZGlkdHkgcHJvdmlkZXIgdGhlIGxpcXVkaXR5IHRva2VuCi8vIEBwYXJhbSB0eEFzc2V0QURlcG9zaXQgVHJhbnNmZXIgb2YgYXNzZXQgQSB0byB0aGUgTFAgcG9vbAovLyBAcGFyYW0gdHhBc3NldEJEZXBvc2l0IFRyYW5zZmVyIG9mIGFzc2V0IEIgdG8gdGhlIExQIHBvb2wKLy8gQHBhcmFtIHBvb2xBc3NldCBMUCBwb29sIGFzc2V0Ci8vIEBwYXJhbSBhc3NldEEgQXNzZXQgQQovLyBAcGFyYW0gYXNzZXRCIEFzc2V0IEIKLy8gQHJldHVybnMgTFAgVG9rZW4gcXVhbnRpdHkgZGlzdHJpYnV0ZWQKYWRkTGlxdWlkaXR5OgoJcHJvdG8gNSAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gMgoKCS8vIHdlbGwgZm9ybWVkIG1pbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjIwNAoJLy8gYXNzZXJ0KGFzc2V0QSA9PT0gdGhpcy5hc3NldEEudmFsdWUpCglmcmFtZV9kaWcgLTQgLy8gYXNzZXRBOiBBc3NldElECglieXRlIDB4NjEgLy8gImEiCglhcHBfZ2xvYmFsX2dldAoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjIwNQoJLy8gYXNzZXJ0KGFzc2V0QiA9PT0gdGhpcy5hc3NldEIudmFsdWUpCglmcmFtZV9kaWcgLTUgLy8gYXNzZXRCOiBBc3NldElECglieXRlIDB4NjIgLy8gImIiCglhcHBfZ2xvYmFsX2dldAoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjIwNgoJLy8gYXNzZXJ0KHBvb2xBc3NldCA9PT0gdGhpcy5wb29sVG9rZW4udmFsdWUpCglmcmFtZV9kaWcgLTMgLy8gcG9vbEFzc2V0OiBBc3NldElECglieXRlIDB4NzAgLy8gInAiCglhcHBfZ2xvYmFsX2dldAoJPT0KCWFzc2VydAoKCS8vICppZjFfY29uZGl0aW9uCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoyMTQKCS8vIHRydWUKCWludCAxCglieiAqaWYxX2VuZAoKCS8vICppZjFfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MjE1CgkvLyB4ZmVyID0gdHhBc3NldEFEZXBvc2l0IGFzIEFzc2V0VHJhbnNmZXJUeG4KCWZyYW1lX2RpZyAtMSAvLyB0eEFzc2V0QURlcG9zaXQ6IFR4bgoJZHVwCglndHhucyBUeXBlRW51bQoJaW50IGF4ZmVyCgk9PQoJYXNzZXJ0CglmcmFtZV9idXJ5IDAgLy8geGZlcjogYXhmZXIKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoyMTYKCS8vIHZlcmlmeUFzc2V0VHJhbnNmZXJUeG4oeGZlciwgewoJLy8gICAgICAgICBhc3NldFJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gICAgICAgICB4ZmVyQXNzZXQ6IGFzc2V0QSwKCS8vICAgICAgICAgYXNzZXRBbW91bnQ6IHsgZ3JlYXRlclRoYW5FcXVhbFRvOiAwIH0sCgkvLyAgICAgICB9KQoJLy8gdmVyaWZ5IGF4ZmVyCglmcmFtZV9kaWcgMCAvLyB4ZmVyOiBheGZlcgoJZ3R4bnMgVHlwZUVudW0KCWludCBheGZlcgoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSBhc3NldFJlY2VpdmVyCglmcmFtZV9kaWcgMCAvLyB4ZmVyOiBheGZlcgoJZ3R4bnMgQXNzZXRSZWNlaXZlcgoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCT09Cglhc3NlcnQKCgkvLyB2ZXJpZnkgeGZlckFzc2V0CglmcmFtZV9kaWcgMCAvLyB4ZmVyOiBheGZlcgoJZ3R4bnMgWGZlckFzc2V0CglmcmFtZV9kaWcgLTQgLy8gYXNzZXRBOiBBc3NldElECgk9PQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IGFzc2V0QW1vdW50CglmcmFtZV9kaWcgMCAvLyB4ZmVyOiBheGZlcgoJZ3R4bnMgQXNzZXRBbW91bnQKCWludCAwCgk+PQoJYXNzZXJ0CgoqaWYxX2VuZDoKCS8vICppZjJfY29uZGl0aW9uCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoyMzEKCS8vIHRydWUKCWludCAxCglieiAqaWYyX2VuZAoKCS8vICppZjJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MjMyCgkvLyB4ZmVyID0gdHhBc3NldEJEZXBvc2l0IGFzIEFzc2V0VHJhbnNmZXJUeG4KCWZyYW1lX2RpZyAtMiAvLyB0eEFzc2V0QkRlcG9zaXQ6IFR4bgoJZHVwCglndHhucyBUeXBlRW51bQoJaW50IGF4ZmVyCgk9PQoJYXNzZXJ0CglmcmFtZV9idXJ5IDEgLy8geGZlcjogYXhmZXIKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoyMzMKCS8vIHZlcmlmeUFzc2V0VHJhbnNmZXJUeG4oeGZlciwgewoJLy8gICAgICAgICBhc3NldFJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gICAgICAgICB4ZmVyQXNzZXQ6IGFzc2V0QiwKCS8vICAgICAgICAgYXNzZXRBbW91bnQ6IHsgZ3JlYXRlclRoYW5FcXVhbFRvOiAwIH0sCgkvLyAgICAgICB9KQoJLy8gdmVyaWZ5IGF4ZmVyCglmcmFtZV9kaWcgMSAvLyB4ZmVyOiBheGZlcgoJZ3R4bnMgVHlwZUVudW0KCWludCBheGZlcgoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSBhc3NldFJlY2VpdmVyCglmcmFtZV9kaWcgMSAvLyB4ZmVyOiBheGZlcgoJZ3R4bnMgQXNzZXRSZWNlaXZlcgoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCT09Cglhc3NlcnQKCgkvLyB2ZXJpZnkgeGZlckFzc2V0CglmcmFtZV9kaWcgMSAvLyB4ZmVyOiBheGZlcgoJZ3R4bnMgWGZlckFzc2V0CglmcmFtZV9kaWcgLTUgLy8gYXNzZXRCOiBBc3NldElECgk9PQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IGFzc2V0QW1vdW50CglmcmFtZV9kaWcgMSAvLyB4ZmVyOiBheGZlcgoJZ3R4bnMgQXNzZXRBbW91bnQKCWludCAwCgk+PQoJYXNzZXJ0CgoqaWYyX2VuZDoKCS8vICppZjNfY29uZGl0aW9uCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoyNDIKCS8vIHRoaXMuYXBwLmFkZHJlc3MuYXNzZXRCYWxhbmNlKGFzc2V0QSkgPT09IHR4QXNzZXRBRGVwb3NpdC5hc3NldEFtb3VudCAmJgoJLy8gICAgICAgdGhpcy5hcHAuYWRkcmVzcy5hc3NldEJhbGFuY2UoYXNzZXRCKSA9PT0gdHhBc3NldEJEZXBvc2l0LmFzc2V0QW1vdW50CglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJZnJhbWVfZGlnIC00IC8vIGFzc2V0QTogQXNzZXRJRAoJYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCglwb3AKCWZyYW1lX2RpZyAtMSAvLyB0eEFzc2V0QURlcG9zaXQ6IFR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCT09CglkdXAKCWJ6ICpza2lwX2FuZDAKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglmcmFtZV9kaWcgLTUgLy8gYXNzZXRCOiBBc3NldElECglhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKCXBvcAoJZnJhbWVfZGlnIC0yIC8vIHR4QXNzZXRCRGVwb3NpdDogVHhuCglndHhucyBBc3NldEFtb3VudAoJPT0KCSYmCgoqc2tpcF9hbmQwOgoJYnogKmlmM19lbmQKCgkvLyAqaWYzX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjI0OQoJLy8gdGhpcy5hc3NldEFCYWxhbmNlLnZhbHVlID0gdHhBc3NldEFEZXBvc2l0LmFzc2V0QW1vdW50CglieXRlIDB4NjE2MiAvLyAiYWIiCglmcmFtZV9kaWcgLTEgLy8gdHhBc3NldEFEZXBvc2l0OiBUeG4KCWd0eG5zIEFzc2V0QW1vdW50CglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjI1MAoJLy8gdGhpcy5hc3NldEJCYWxhbmNlLnZhbHVlID0gdHhBc3NldEJEZXBvc2l0LmFzc2V0QW1vdW50CglieXRlIDB4NjI2MiAvLyAiYmIiCglmcmFtZV9kaWcgLTIgLy8gdHhBc3NldEJEZXBvc2l0OiBUeG4KCWd0eG5zIEFzc2V0QW1vdW50CglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjI1MQoJLy8gdG9NaW50ID0gdGhpcy5jYWxjdWxhdGVMKHRoaXMuYXNzZXRBQmFsYW5jZS52YWx1ZSwgdGhpcy5hc3NldEJCYWxhbmNlLnZhbHVlKQoJYnl0ZSAweDYyNjIgLy8gImJiIgoJYXBwX2dsb2JhbF9nZXQKCWJ5dGUgMHg2MTYyIC8vICJhYiIKCWFwcF9nbG9iYWxfZ2V0CgljYWxsc3ViIGNhbGN1bGF0ZUwKCWZyYW1lX2J1cnkgMiAvLyB0b01pbnQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjI1NQoJLy8gcmV0dXJuIHRvTWludDsKCWZyYW1lX2RpZyAyIC8vIHRvTWludDogdWludDY0CgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMgoJcmV0c3ViCgoqaWYzX2VuZDoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjI1NwoJLy8gcmV0dXJuIDA7CglpbnQgMAoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDIKCXJldHN1YgoKLy8gY2FsY3VsYXRlTCh4OiB1aW50NjQsIHk6IHVpbnQ2NCk6IHVpbnQ2NApjYWxjdWxhdGVMOgoJcHJvdG8gMiAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gMTUKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoyODkKCS8vIEQxOiB1aW50NjQgPSAoKCh4ICogeCkgLyBTQ0FMRSkgKiB0aGlzLnByaWNlTWF4QS52YWx1ZSkgLyBTQ0FMRQoJZnJhbWVfZGlnIC0xIC8vIHg6IHVpbnQ2NAoJZnJhbWVfZGlnIC0xIC8vIHg6IHVpbnQ2NAoJKgoJaW50IDEwMDAwMDAwMDAKCS8KCWJ5dGUgMHg3MDYxIC8vICJwYSIKCWFwcF9nbG9iYWxfZ2V0CgkqCglpbnQgMTAwMDAwMDAwMAoJLwoJZnJhbWVfYnVyeSAwIC8vIEQxOiB1aW50NjQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoyOTEKCS8vIEQyOiB1aW50NjQgPSAoeSAqIHkpIC8gdGhpcy5wcmljZU1heEIudmFsdWUKCWZyYW1lX2RpZyAtMiAvLyB5OiB1aW50NjQKCWZyYW1lX2RpZyAtMiAvLyB5OiB1aW50NjQKCSoKCWJ5dGUgMHg3MDYyIC8vICJwYiIKCWFwcF9nbG9iYWxfZ2V0CgkvCglmcmFtZV9idXJ5IDEgLy8gRDI6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjI5MwoJLy8gRDM6IHVpbnQ2NCA9ICgoKDIgKiB4ICogeSkgLyBTQ0FMRSkgKiB0aGlzLnByaWNlTWF4QVNxcnQudmFsdWUpIC8gU0NBTEUgLyB0aGlzLnByaWNlTWF4QlNxcnQudmFsdWUKCWludCAyCglmcmFtZV9kaWcgLTEgLy8geDogdWludDY0CgkqCglmcmFtZV9kaWcgLTIgLy8geTogdWludDY0CgkqCglpbnQgMTAwMDAwMDAwMAoJLwoJYnl0ZSAweDcwNjE3MyAvLyAicGFzIgoJYXBwX2dsb2JhbF9nZXQKCSoKCWludCAxMDAwMDAwMDAwCgkvCglieXRlIDB4NzA2MjczIC8vICJwYnMiCglhcHBfZ2xvYmFsX2dldAoJLwoJZnJhbWVfYnVyeSAyIC8vIEQzOiB1aW50NjQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoyOTYKCS8vIEQ0OiB1aW50NjQgPSAoNCAqIHggKiB5KSAvIFNDQUxFCglpbnQgNAoJZnJhbWVfZGlnIC0xIC8vIHg6IHVpbnQ2NAoJKgoJZnJhbWVfZGlnIC0yIC8vIHk6IHVpbnQ2NAoJKgoJaW50IDEwMDAwMDAwMDAKCS8KCWZyYW1lX2J1cnkgMyAvLyBENDogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6Mjk4CgkvLyBENTogdWludDY0ID0gKCgoNCAqIHggKiB5KSAvIFNDQUxFKSAqIHRoaXMucHJpY2VNYXhBU3FydC52YWx1ZSkgLyBTQ0FMRSAvIHRoaXMucHJpY2VNYXhCU3FydC52YWx1ZQoJaW50IDQKCWZyYW1lX2RpZyAtMSAvLyB4OiB1aW50NjQKCSoKCWZyYW1lX2RpZyAtMiAvLyB5OiB1aW50NjQKCSoKCWludCAxMDAwMDAwMDAwCgkvCglieXRlIDB4NzA2MTczIC8vICJwYXMiCglhcHBfZ2xvYmFsX2dldAoJKgoJaW50IDEwMDAwMDAwMDAKCS8KCWJ5dGUgMHg3MDYyNzMgLy8gInBicyIKCWFwcF9nbG9iYWxfZ2V0CgkvCglmcmFtZV9idXJ5IDQgLy8gRDU6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjI5OQoJLy8gRCA9IEQxICsgRDIgKyBEMyArIEQ0IC0gRDUKCWZyYW1lX2RpZyAwIC8vIEQxOiB1aW50NjQKCWZyYW1lX2RpZyAxIC8vIEQyOiB1aW50NjQKCSsKCWZyYW1lX2RpZyAyIC8vIEQzOiB1aW50NjQKCSsKCWZyYW1lX2RpZyAzIC8vIEQ0OiB1aW50NjQKCSsKCWZyYW1lX2RpZyA0IC8vIEQ1OiB1aW50NjQKCS0KCWZyYW1lX2J1cnkgNSAvLyBEOiB1aW50NjQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozMDQKCS8vIEwxOiB1aW50NjQgPSAoeCAqIHRoaXMucHJpY2VNYXhBU3FydC52YWx1ZSkgLyBTQ0FMRQoJZnJhbWVfZGlnIC0xIC8vIHg6IHVpbnQ2NAoJYnl0ZSAweDcwNjE3MyAvLyAicGFzIgoJYXBwX2dsb2JhbF9nZXQKCSoKCWludCAxMDAwMDAwMDAwCgkvCglmcmFtZV9idXJ5IDYgLy8gTDE6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjMwNgoJLy8gTDI6IHVpbnQ2NCA9ICh5ICogU0NBTEUpIC8gdGhpcy5wcmljZU1heEJTcXJ0LnZhbHVlCglmcmFtZV9kaWcgLTIgLy8geTogdWludDY0CglpbnQgMTAwMDAwMDAwMAoJKgoJYnl0ZSAweDcwNjI3MyAvLyAicGJzIgoJYXBwX2dsb2JhbF9nZXQKCS8KCWZyYW1lX2J1cnkgNyAvLyBMMjogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MzA4CgkvLyBMMzogdWludDY0ID0gKDIgKiB0aGlzLnByaWNlTWF4QVNxcnQudmFsdWUgKiBTQ0FMRSkgLyB0aGlzLnByaWNlTWF4QlNxcnQudmFsdWUKCWludCAyCglieXRlIDB4NzA2MTczIC8vICJwYXMiCglhcHBfZ2xvYmFsX2dldAoJKgoJaW50IDEwMDAwMDAwMDAKCSoKCWJ5dGUgMHg3MDYyNzMgLy8gInBicyIKCWFwcF9nbG9iYWxfZ2V0CgkvCglmcmFtZV9idXJ5IDggLy8gTDM6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjMxMQoJLy8gRF9TUVJUID0gc3FydChTQ0FMRSAqIEQpCglpbnQgMTAwMDAwMDAwMAoJZnJhbWVfZGlnIDUgLy8gRDogdWludDY0CgkqCglzcXJ0CglmcmFtZV9idXJ5IDkgLy8gRF9TUVJUOiB1aW50NjQKCgkvLyAqaWY0X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MzEzCgkvLyAyICogU0NBTEUgPiBMMwoJaW50IDIwMDAwMDAwMDAKCWZyYW1lX2RpZyA4IC8vIEwzOiB1aW50NjQKCT4KCWJ6ICppZjRfZW5kCgoJLy8gKmlmNF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozMTQKCS8vIG5vbTogdWludDY0ID0gTDEgKyBMMiArIERfU1FSVAoJZnJhbWVfZGlnIDYgLy8gTDE6IHVpbnQ2NAoJZnJhbWVfZGlnIDcgLy8gTDI6IHVpbnQ2NAoJKwoJZnJhbWVfZGlnIDkgLy8gRF9TUVJUOiB1aW50NjQKCSsKCWZyYW1lX2J1cnkgMTAgLy8gbm9tOiB1aW50NjQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozMTUKCS8vIGRlbjogdWludDY0ID0gMiAqIFNDQUxFIC0gTDMKCWludCAyMDAwMDAwMDAwCglmcmFtZV9kaWcgOCAvLyBMMzogdWludDY0CgktCglmcmFtZV9idXJ5IDExIC8vIGRlbjogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MzE2CgkvLyByZXQ6IHVpbnQ2NCA9IChTQ0FMRSAqIG5vbSkgLyBkZW4KCWludCAxMDAwMDAwMDAwCglmcmFtZV9kaWcgMTAgLy8gbm9tOiB1aW50NjQKCSoKCWZyYW1lX2RpZyAxMSAvLyBkZW46IHVpbnQ2NAoJLwoJZnJhbWVfYnVyeSAxMiAvLyByZXQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjMxNwoJLy8gcmV0dXJuIHJldDsKCWZyYW1lX2RpZyAxMiAvLyByZXQ6IHVpbnQ2NAoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDEyCglyZXRzdWIKCippZjRfZW5kOgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MzE5CgkvLyBub206IHVpbnQ2NCA9IEwxICsgTDIgLSBEX1NRUlQKCWZyYW1lX2RpZyA2IC8vIEwxOiB1aW50NjQKCWZyYW1lX2RpZyA3IC8vIEwyOiB1aW50NjQKCSsKCWZyYW1lX2RpZyA5IC8vIERfU1FSVDogdWludDY0CgktCglmcmFtZV9idXJ5IDEzIC8vIG5vbTogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MzIwCgkvLyBkZW46IHVpbnQ2NCA9IEwzIC0gMiAqIFNDQUxFCglmcmFtZV9kaWcgOCAvLyBMMzogdWludDY0CglpbnQgMjAwMDAwMDAwMAoJLQoJZnJhbWVfYnVyeSAxNCAvLyBkZW46IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjMyMQoJLy8gcmV0OiB1aW50NjQgPSAoU0NBTEUgKiBub20pIC8gZGVuCglpbnQgMTAwMDAwMDAwMAoJZnJhbWVfZGlnIDEzIC8vIG5vbTogdWludDY0CgkqCglmcmFtZV9kaWcgMTQgLy8gZGVuOiB1aW50NjQKCS8KCWZyYW1lX2J1cnkgMTUgLy8gcmV0OiB1aW50NjQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozMjIKCS8vIHJldHVybiByZXQ7CglmcmFtZV9kaWcgMTUgLy8gcmV0OiB1aW50NjQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiAxNQoJcmV0c3ViCgovLyBnZXRQcmljZShhc3NldEFRdWFudGl0eTogdWludDY0LCBhc3NldEJRdWFudGl0eTogdWludDY0KTogdWludDY0Ci8vCi8vIEdldCB0aGUgY3VycmVudCBwcmljZSB3aGVuIGFzc2V0IGEgaGFzIHgKLy8gQHBhcmFtIGFzc2V0QVF1YW50aXR5IHgKLy8gQHBhcmFtIGFzc2V0QlF1YW50aXR5IHkKLy8gQHJldHVybnMgdGhlIHByaWNlIHdpdGggc3BlY2lmaWVkIHF1YW50aXR5IHdpdGggdGhlIHByaWNlIHJhbmdlIHNldCBpbiB0aGUgY29udHJhY3QKZ2V0UHJpY2U6Cglwcm90byAyIDEKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozMzUKCS8vIHJldHVybiBhc3NldEFRdWFudGl0eTsKCWZyYW1lX2RpZyAtMSAvLyBhc3NldEFRdWFudGl0eTogdWludDY0CglyZXRzdWIKCi8vIHJlbW92ZUxpcXVpZGl0eShheGZlcix1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkCiphYmlfcm91dGVfcmVtb3ZlTGlxdWlkaXR5OgoJLy8gYXNzZXRCOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWJ0b2kKCgkvLyBhc3NldEE6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIHBvb2xBc3NldDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gdHhMUFhmZXI6IGF4ZmVyCgl0eG4gR3JvdXBJbmRleAoJaW50IDEKCS0KCWR1cAoJZ3R4bnMgVHlwZUVudW0KCWludCBheGZlcgoJPT0KCWFzc2VydAoKCS8vIGV4ZWN1dGUgcmVtb3ZlTGlxdWlkaXR5KGF4ZmVyLHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQKCWNhbGxzdWIgcmVtb3ZlTGlxdWlkaXR5CglpbnQgMQoJcmV0dXJuCgovLyByZW1vdmVMaXF1aWRpdHkodHhMUFhmZXI6IEFzc2V0VHJhbnNmZXJUeG4sIHBvb2xBc3NldDogQXNzZXRJRCwgYXNzZXRBOiBBc3NldElELCBhc3NldEI6IEFzc2V0SUQpOiB2b2lkCi8vCi8vIFRoaXMgbWV0aG9kIHJldHJpZXZlcyBmcm9tIHRoZSBsaXF1aWRpdHkgcHJvdmlkZXIgTFAgdG9rZW4gYW5kIHJldHVybnMgQXNzZXQgQSBhbmQgQXNzZXQgQiBmcm9tIHRoZSBBdXRvbWF0ZWQgTWFya2V0IE1ha2VyIENvbmNlbnRyYXRlZCBMaXF1ZGlkaXR5IFBvb2wKLy8gQHBhcmFtIHR4TFBYZmVyIFRyYW5zZmVyIG9mIHRoZSBMUCB0b2tlbgovLyBAcGFyYW0gcG9vbEFzc2V0IExQIHBvb2wgYXNzZXQKLy8gQHBhcmFtIGFzc2V0QSBBc3NldCBBCi8vIEBwYXJhbSBhc3NldEIgQXNzZXQgQgpyZW1vdmVMaXF1aWRpdHk6Cglwcm90byA0IDAKCgkvLyB3ZWxsIGZvcm1lZCBtaW50CgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozNDcKCS8vIGFzc2VydChhc3NldEEgPT09IHRoaXMuYXNzZXRBLnZhbHVlKQoJZnJhbWVfZGlnIC0zIC8vIGFzc2V0QTogQXNzZXRJRAoJYnl0ZSAweDYxIC8vICJhIgoJYXBwX2dsb2JhbF9nZXQKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozNDgKCS8vIGFzc2VydChhc3NldEIgPT09IHRoaXMuYXNzZXRCLnZhbHVlKQoJZnJhbWVfZGlnIC00IC8vIGFzc2V0QjogQXNzZXRJRAoJYnl0ZSAweDYyIC8vICJiIgoJYXBwX2dsb2JhbF9nZXQKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozNDkKCS8vIGFzc2VydChwb29sQXNzZXQgPT09IHRoaXMucG9vbFRva2VuLnZhbHVlKQoJZnJhbWVfZGlnIC0yIC8vIHBvb2xBc3NldDogQXNzZXRJRAoJYnl0ZSAweDcwIC8vICJwIgoJYXBwX2dsb2JhbF9nZXQKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozNTEKCS8vIHZlcmlmeUFzc2V0VHJhbnNmZXJUeG4odHhMUFhmZXIsIHsKCS8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MsCgkvLyAgICAgICB4ZmVyQXNzZXQ6IHBvb2xBc3NldCwKCS8vICAgICAgIGFzc2V0QW1vdW50OiB7IGdyZWF0ZXJUaGFuRXF1YWxUbzogMCB9LAoJLy8gICAgIH0pCgkvLyB2ZXJpZnkgYXNzZXRSZWNlaXZlcgoJZnJhbWVfZGlnIC0xIC8vIHR4TFBYZmVyOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBBc3NldFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSB4ZmVyQXNzZXQKCWZyYW1lX2RpZyAtMSAvLyB0eExQWGZlcjogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgWGZlckFzc2V0CglmcmFtZV9kaWcgLTIgLy8gcG9vbEFzc2V0OiBBc3NldElECgk9PQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IGFzc2V0QW1vdW50CglmcmFtZV9kaWcgLTEgLy8gdHhMUFhmZXI6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIEFzc2V0QW1vdW50CglpbnQgMAoJPj0KCWFzc2VydAoJZXJyCgovLyBzd2FwKGF4ZmVyLHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQKKmFiaV9yb3V0ZV9zd2FwOgoJLy8gbWluaW11bVRvUmVjZWl2ZTogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglidG9pCgoJLy8gYXNzZXRCOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyBhc3NldEE6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIHR4U3dhcDogYXhmZXIKCXR4biBHcm91cEluZGV4CglpbnQgMQoJLQoJZHVwCglndHhucyBUeXBlRW51bQoJaW50IGF4ZmVyCgk9PQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBzd2FwKGF4ZmVyLHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQKCWNhbGxzdWIgc3dhcAoJaW50IDEKCXJldHVybgoKLy8gc3dhcCh0eFN3YXA6IEFzc2V0VHJhbnNmZXJUeG4sIGFzc2V0QTogQXNzZXRJRCwgYXNzZXRCOiBBc3NldElELCBtaW5pbXVtVG9SZWNlaXZlOiB1aW50NjQpOiB2b2lkCi8vCi8vIFN3YXAgQXNzZXQgQSB0byBBc3NldCBCIG9yIEFzc2V0IEIgdG8gQXNzdCBBCi8vIEBwYXJhbSB0eFN3YXAgVHJhbnNmZXIgb2YgdGhlIHRva2VuIHRvIGJlIGRlcG9zaXRlZCB0byB0aGUgcG9vbC4gVG8gdGhlIG93bmVyIHRoZSBvdGhlciBhc3NldCB3aWxsIGJlIHNlbnQuCi8vIEBwYXJhbSBhc3NldEEgQXNzZXQgQQovLyBAcGFyYW0gYXNzZXRCIEFzc2V0IEIKLy8gQHBhcmFtIG1pbmltdW1Ub1JlY2VpdmUgSWYgbnVtYmVyIGdyZWF0ZXIgdGhlbiB6ZXJvLCB0aGUgY2hlY2sgaXMgcGVyZm9ybWVkIGZvciB0aGUgb3V0cHV0IG9mIHRoZSBvdGhlciBhc3NldApzd2FwOgoJcHJvdG8gNCAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCgkvLyB3ZWxsIGZvcm1lZCBzd2FwCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozNjkKCS8vIGFzc2VydChhc3NldEEgPT09IHRoaXMuYXNzZXRBLnZhbHVlKQoJZnJhbWVfZGlnIC0yIC8vIGFzc2V0QTogQXNzZXRJRAoJYnl0ZSAweDYxIC8vICJhIgoJYXBwX2dsb2JhbF9nZXQKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozNzAKCS8vIGFzc2VydChhc3NldEIgPT09IHRoaXMuYXNzZXRCLnZhbHVlKQoJZnJhbWVfZGlnIC0zIC8vIGFzc2V0QjogQXNzZXRJRAoJYnl0ZSAweDYyIC8vICJiIgoJYXBwX2dsb2JhbF9nZXQKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozNzIKCS8vIHZlcmlmeUFzc2V0VHJhbnNmZXJUeG4odHhTd2FwLCB7CgkvLyAgICAgICBhc3NldEFtb3VudDogeyBncmVhdGVyVGhhbjogMCB9LAoJLy8gICAgICAgYXNzZXRSZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgIHNlbmRlcjogdGhpcy50eG4uc2VuZGVyLAoJLy8gICAgICAgeGZlckFzc2V0OiB7IGluY2x1ZGVkSW46IFthc3NldEEsIGFzc2V0Ql0gfSwKCS8vICAgICB9KQoJLy8gdmVyaWZ5IGFzc2V0QW1vdW50CglmcmFtZV9kaWcgLTEgLy8gdHhTd2FwOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBBc3NldEFtb3VudAoJaW50IDAKCT4KCWFzc2VydAoKCS8vIHZlcmlmeSBhc3NldFJlY2VpdmVyCglmcmFtZV9kaWcgLTEgLy8gdHhTd2FwOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBBc3NldFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSBzZW5kZXIKCWZyYW1lX2RpZyAtMSAvLyB0eFN3YXA6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIFNlbmRlcgoJdHhuIFNlbmRlcgoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSB4ZmVyQXNzZXQKCWZyYW1lX2RpZyAtMSAvLyB0eFN3YXA6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIFhmZXJBc3NldAoJZnJhbWVfZGlnIC0yIC8vIGFzc2V0QTogQXNzZXRJRAoJPT0KCWZyYW1lX2RpZyAtMSAvLyB0eFN3YXA6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIFhmZXJBc3NldAoJZnJhbWVfZGlnIC0zIC8vIGFzc2V0QjogQXNzZXRJRAoJPT0KCXx8Cglhc3NlcnQKCgkvLyAqaWY1X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6Mzc5CgkvLyB0eFN3YXAueGZlckFzc2V0ID09PSBhc3NldEEKCWZyYW1lX2RpZyAtMSAvLyB0eFN3YXA6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIFhmZXJBc3NldAoJZnJhbWVfZGlnIC0yIC8vIGFzc2V0QTogQXNzZXRJRAoJPT0KCWJ6ICppZjVfZW5kCgoJLy8gKmlmNV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozODAKCS8vIHRvU3dhcCA9IHRoaXMuY2FsY3VsYXRlQXNzZXRCV2l0aGRyYXdPbkFzc2V0QURlcG9zaXQodHhTd2FwLmFzc2V0QW1vdW50LCBhc3NldEEuZGVjaW1hbHMsIGFzc2V0Qi5kZWNpbWFscykKCWZyYW1lX2RpZyAtMyAvLyBhc3NldEI6IEFzc2V0SUQKCWFzc2V0X3BhcmFtc19nZXQgQXNzZXREZWNpbWFscwoJcG9wCglmcmFtZV9kaWcgLTIgLy8gYXNzZXRBOiBBc3NldElECglhc3NldF9wYXJhbXNfZ2V0IEFzc2V0RGVjaW1hbHMKCXBvcAoJZnJhbWVfZGlnIC0xIC8vIHR4U3dhcDogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCWNhbGxzdWIgY2FsY3VsYXRlQXNzZXRCV2l0aGRyYXdPbkFzc2V0QURlcG9zaXQKCWZyYW1lX2J1cnkgMCAvLyB0b1N3YXA6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjM4MQoJLy8gYXNzZXJ0KG1pbmltdW1Ub1JlY2VpdmUgPj0gdG9Td2FwKQoJZnJhbWVfZGlnIC00IC8vIG1pbmltdW1Ub1JlY2VpdmU6IHVpbnQ2NAoJZnJhbWVfZGlnIDAgLy8gdG9Td2FwOiB1aW50NjQKCT49Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozODIKCS8vIHRoaXMuZG9BeGZlcih0aGlzLnR4bi5zZW5kZXIsIGFzc2V0QiwgdG9Td2FwKQoJZnJhbWVfZGlnIDAgLy8gdG9Td2FwOiB1aW50NjQKCWZyYW1lX2RpZyAtMyAvLyBhc3NldEI6IEFzc2V0SUQKCXR4biBTZW5kZXIKCWNhbGxzdWIgZG9BeGZlcgoKKmlmNV9lbmQ6CglyZXRzdWIKCi8vIGNhbGN1bGF0ZUFzc2V0QldpdGhkcmF3T25Bc3NldEFEZXBvc2l0KHVpbnQ2NCx1aW50NjQsdWludDY0KXVpbnQ2NAoqYWJpX3JvdXRlX2NhbGN1bGF0ZUFzc2V0QldpdGhkcmF3T25Bc3NldEFEZXBvc2l0OgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBhc3NldEJEZWNpbWFsczogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglidG9pCgoJLy8gYXNzZXRBRGVjaW1hbHM6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIGluQW1vdW50OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGNhbGN1bGF0ZUFzc2V0QldpdGhkcmF3T25Bc3NldEFEZXBvc2l0KHVpbnQ2NCx1aW50NjQsdWludDY0KXVpbnQ2NAoJY2FsbHN1YiBjYWxjdWxhdGVBc3NldEJXaXRoZHJhd09uQXNzZXRBRGVwb3NpdAoJaXRvYgoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGNhbGN1bGF0ZUFzc2V0QldpdGhkcmF3T25Bc3NldEFEZXBvc2l0KGluQW1vdW50OiB1aW50NjQsIGFzc2V0QURlY2ltYWxzOiB1aW50NjQsIGFzc2V0QkRlY2ltYWxzOiB1aW50NjQpOiB1aW50NjQKY2FsY3VsYXRlQXNzZXRCV2l0aGRyYXdPbkFzc2V0QURlcG9zaXQ6Cglwcm90byAzIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwbiAxNQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQwNwoJLy8gYXNzZXRBMlNjYWxlOiB1aW50NjQgPSAxMCAqKiAoU0NBTEVfREVDSU1BTFMgLSBhc3NldEFEZWNpbWFscykKCWludCAxMAoJaW50IDkKCWZyYW1lX2RpZyAtMiAvLyBhc3NldEFEZWNpbWFsczogdWludDY0CgktCglleHAKCWZyYW1lX2J1cnkgMCAvLyBhc3NldEEyU2NhbGU6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQwOAoJLy8gYXNzZXRCMlNjYWxlOiB1aW50NjQgPSAxMCAqKiAoU0NBTEVfREVDSU1BTFMgLSBhc3NldEJEZWNpbWFscykKCWludCAxMAoJaW50IDkKCWZyYW1lX2RpZyAtMyAvLyBhc3NldEJEZWNpbWFsczogdWludDY0CgktCglleHAKCWZyYW1lX2J1cnkgMSAvLyBhc3NldEIyU2NhbGU6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQwOQoJLy8gYXNzZXRBMlNjYWxlTmVnOiB1aW50NjQgPSAxMCAqKiBhc3NldEFEZWNpbWFscwoJaW50IDEwCglmcmFtZV9kaWcgLTIgLy8gYXNzZXRBRGVjaW1hbHM6IHVpbnQ2NAoJZXhwCglmcmFtZV9idXJ5IDIgLy8gYXNzZXRBMlNjYWxlTmVnOiB1aW50NjQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo0MTAKCS8vIGFzc2V0QjJTY2FsZU5lZzogdWludDY0ID0gMTAgKiogYXNzZXRCRGVjaW1hbHMKCWludCAxMAoJZnJhbWVfZGlnIC0zIC8vIGFzc2V0QkRlY2ltYWxzOiB1aW50NjQKCWV4cAoJZnJhbWVfYnVyeSAzIC8vIGFzc2V0QjJTY2FsZU5lZzogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NDEyCgkvLyB4OiB1aW50NjQgPSB0aGlzLmFzc2V0QUJhbGFuY2UudmFsdWUKCWJ5dGUgMHg2MTYyIC8vICJhYiIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9idXJ5IDQgLy8geDogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NDEzCgkvLyB5OiB1aW50NjQgPSB0aGlzLmFzc2V0QkJhbGFuY2UudmFsdWUKCWJ5dGUgMHg2MjYyIC8vICJiYiIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9idXJ5IDUgLy8geTogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NDE0CgkvLyBhOiB1aW50NjQgPSB0aGlzLnByaWNlTWF4QVNxcnQudmFsdWUKCWJ5dGUgMHg3MDYxNzMgLy8gInBhcyIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9idXJ5IDYgLy8gYTogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NDE1CgkvLyBiOiB1aW50NjQgPSB0aGlzLnByaWNlTWF4QlNxcnQudmFsdWUKCWJ5dGUgMHg3MDYyNzMgLy8gInBicyIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9idXJ5IDcgLy8gYjogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NDE2CgkvLyBMOiB1aW50NjQgPSB0aGlzLmNhbGN1bGF0ZUwoeCwgeSkKCWZyYW1lX2RpZyA1IC8vIHk6IHVpbnQ2NAoJZnJhbWVfZGlnIDQgLy8geDogdWludDY0CgljYWxsc3ViIGNhbGN1bGF0ZUwKCWZyYW1lX2J1cnkgOCAvLyBMOiB1aW50NjQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo0MTgKCS8vIFAxOiB1aW50NjQgPQoJLy8gICAgICAgKCgoKChhIC8qIDEwRCAqLyAqIGIpIC8qIDEwRCAqLyAvIFNDQUxFKSAqIGluQW1vdW50KSAvKiBBRCAqLyAvIFNDQUxFKSAqIEwpIC8qIDEwRCAqLyAvIGFzc2V0QTJTY2FsZU5lZwoJZnJhbWVfZGlnIDYgLy8gYTogdWludDY0CglmcmFtZV9kaWcgNyAvLyBiOiB1aW50NjQKCSoKCWludCAxMDAwMDAwMDAwCgkvCglmcmFtZV9kaWcgLTEgLy8gaW5BbW91bnQ6IHVpbnQ2NAoJKgoJaW50IDEwMDAwMDAwMDAKCS8KCWZyYW1lX2RpZyA4IC8vIEw6IHVpbnQ2NAoJKgoJZnJhbWVfZGlnIDIgLy8gYXNzZXRBMlNjYWxlTmVnOiB1aW50NjQKCS8KCWZyYW1lX2J1cnkgOSAvLyBQMTogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NDIxCgkvLyBQMjogdWludDY0ID0gKCgoYiAvKiAxMEQgKi8gKiBpbkFtb3VudCkgLyogQUQgKi8gLyBhc3NldEEyU2NhbGVOZWcpICogeSkgLyogQkQgKi8gLyBTQ0FMRQoJZnJhbWVfZGlnIDcgLy8gYjogdWludDY0CglmcmFtZV9kaWcgLTEgLy8gaW5BbW91bnQ6IHVpbnQ2NAoJKgoJZnJhbWVfZGlnIDIgLy8gYXNzZXRBMlNjYWxlTmVnOiB1aW50NjQKCS8KCWZyYW1lX2RpZyA1IC8vIHk6IHVpbnQ2NAoJKgoJaW50IDEwMDAwMDAwMDAKCS8KCWZyYW1lX2J1cnkgMTAgLy8gUDI6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQyMwoJLy8gUDM6IHVpbnQ2NCA9IChiIC8qIDEwRCAqLyAqIGluQW1vdW50KSAvKiBBRCAqLyAvIGFzc2V0QTJTY2FsZU5lZwoJZnJhbWVfZGlnIDcgLy8gYjogdWludDY0CglmcmFtZV9kaWcgLTEgLy8gaW5BbW91bnQ6IHVpbnQ2NAoJKgoJZnJhbWVfZGlnIDIgLy8gYXNzZXRBMlNjYWxlTmVnOiB1aW50NjQKCS8KCWZyYW1lX2J1cnkgMTEgLy8gUDM6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQyNQoJLy8gUDQ6IHVpbnQ2NCA9IChiIC8qIDEwRCAqLyAqIHgpIC8qIDEwRCAqLyAvIFNDQUxFCglmcmFtZV9kaWcgNyAvLyBiOiB1aW50NjQKCWZyYW1lX2RpZyA0IC8vIHg6IHVpbnQ2NAoJKgoJaW50IDEwMDAwMDAwMDAKCS8KCWZyYW1lX2J1cnkgMTIgLy8gUDQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQyNwoJLy8gUDEyOiB1aW50NjQgPSBQMSArIFAyCglmcmFtZV9kaWcgOSAvLyBQMTogdWludDY0CglmcmFtZV9kaWcgMTAgLy8gUDI6IHVpbnQ2NAoJKwoJZnJhbWVfYnVyeSAxMyAvLyBQMTI6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQyOQoJLy8gUDM0NTogdWludDY0ID0gUDMgKyBQNCArIEwKCWZyYW1lX2RpZyAxMSAvLyBQMzogdWludDY0CglmcmFtZV9kaWcgMTIgLy8gUDQ6IHVpbnQ2NAoJKwoJZnJhbWVfZGlnIDggLy8gTDogdWludDY0CgkrCglmcmFtZV9idXJ5IDE0IC8vIFAzNDU6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQzMQoJLy8gcmV0OiB1aW50NjQgPSAoUDEyICogYXNzZXRCMlNjYWxlTmVnKSAvIFAzNDUKCWZyYW1lX2RpZyAxMyAvLyBQMTI6IHVpbnQ2NAoJZnJhbWVfZGlnIDMgLy8gYXNzZXRCMlNjYWxlTmVnOiB1aW50NjQKCSoKCWZyYW1lX2RpZyAxNCAvLyBQMzQ1OiB1aW50NjQKCS8KCWZyYW1lX2J1cnkgMTUgLy8gcmV0OiB1aW50NjQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo0MzIKCS8vIHJldHVybiByZXQ7CglmcmFtZV9kaWcgMTUgLy8gcmV0OiB1aW50NjQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiAxNQoJcmV0c3ViCgoqY3JlYXRlX05vT3A6CgltZXRob2QgImNyZWF0ZUFwcGxpY2F0aW9uKCl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbgoJZXJyCgoqY2FsbF9Ob09wOgoJbWV0aG9kICJnZXRDdXJyZW50UHJpY2UoKXVpbnQ2NCIKCW1ldGhvZCAiZ2V0SHlwb3RoZXRpY1ByaWNlKHVpbnQ2NCx1aW50NjQpdWludDY0IgoJbWV0aG9kICJnZXRQcmljZURpdmlkZXIoKXVpbnQ2NCIKCW1ldGhvZCAiZ2V0TFBUb2tlbklkKCl1aW50NjQiCgltZXRob2QgImJvb3RzdHJhcChwYXksdWludDY0LHVpbnQ2NCx1aW50MzIsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDgsdWludDY0LHVpbnQ2NCl1aW50NjQiCgltZXRob2QgImFkZExpcXVpZGl0eSh0eG4sdHhuLHVpbnQ2NCx1aW50NjQsdWludDY0KXVpbnQ2NCIKCW1ldGhvZCAicmVtb3ZlTGlxdWlkaXR5KGF4ZmVyLHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQiCgltZXRob2QgInN3YXAoYXhmZXIsdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZCIKCW1ldGhvZCAiY2FsY3VsYXRlQXNzZXRCV2l0aGRyYXdPbkFzc2V0QURlcG9zaXQodWludDY0LHVpbnQ2NCx1aW50NjQpdWludDY0IgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV9nZXRDdXJyZW50UHJpY2UgKmFiaV9yb3V0ZV9nZXRIeXBvdGhldGljUHJpY2UgKmFiaV9yb3V0ZV9nZXRQcmljZURpdmlkZXIgKmFiaV9yb3V0ZV9nZXRMUFRva2VuSWQgKmFiaV9yb3V0ZV9ib290c3RyYXAgKmFiaV9yb3V0ZV9hZGRMaXF1aWRpdHkgKmFiaV9yb3V0ZV9yZW1vdmVMaXF1aWRpdHkgKmFiaV9yb3V0ZV9zd2FwICphYmlfcm91dGVfY2FsY3VsYXRlQXNzZXRCV2l0aGRyYXdPbkFzc2V0QURlcG9zaXQKCWVycg==",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEw"
  },
  "contract": {
    "name": "BiatecCLAMM",
    "desc": "",
    "methods": [
      {
        "name": "createApplication",
        "desc": "Initial setup",
        "args": [],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "getCurrentPrice",
        "readonly": true,
        "args": [],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "getHypotheticPrice",
        "readonly": true,
        "args": [
          {
            "name": "assetAQuantity",
            "type": "uint64"
          },
          {
            "name": "assetBQuantity",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "getPriceDivider",
        "readonly": true,
        "args": [],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "getLPTokenId",
        "readonly": true,
        "args": [],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "bootstrap",
        "desc": "Anybody can deploy the clamm smart contract",
        "args": [
          {
            "name": "txSeed",
            "type": "pay",
            "desc": "Seed transaction so that smart contract can opt in to the assets"
          },
          {
            "name": "assetA",
            "type": "uint64",
            "desc": "Asset A ID must be lower then Asset B ID"
          },
          {
            "name": "assetB",
            "type": "uint64",
            "desc": "Asset B"
          },
          {
            "name": "feeB100000",
            "type": "uint32",
            "desc": "Fee in 100000 base level. value 10000 = 10000/100000 = 0,1 = 10% fee. 1000 = 1%. 100 = 0,1%. 10 = 0,01% = 1 base point"
          },
          {
            "name": "priceMaxA",
            "type": "uint64"
          },
          {
            "name": "priceMaxB",
            "type": "uint64"
          },
          {
            "name": "currentPrice",
            "type": "uint64"
          },
          {
            "name": "verificationClass",
            "type": "uint8",
            "desc": "Asset B"
          },
          {
            "name": "identityProvider",
            "type": "uint64"
          },
          {
            "name": "poolProvider",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "uint64",
          "desc": "LP token ID"
        }
      },
      {
        "name": "addLiquidity",
        "desc": "This method adds Asset A and Asset B to the Automated Market Maker Concentrated Liqudidity Pool and send to the liqudidty provider the liqudity token",
        "args": [
          {
            "name": "txAssetADeposit",
            "type": "txn",
            "desc": "Transfer of asset A to the LP pool"
          },
          {
            "name": "txAssetBDeposit",
            "type": "txn",
            "desc": "Transfer of asset B to the LP pool"
          },
          {
            "name": "poolAsset",
            "type": "uint64",
            "desc": "LP pool asset"
          },
          {
            "name": "assetA",
            "type": "uint64",
            "desc": "Asset A"
          },
          {
            "name": "assetB",
            "type": "uint64",
            "desc": "Asset B"
          }
        ],
        "returns": {
          "type": "uint64",
          "desc": "LP Token quantity distributed"
        }
      },
      {
        "name": "removeLiquidity",
        "desc": "This method retrieves from the liquidity provider LP token and returns Asset A and Asset B from the Automated Market Maker Concentrated Liqudidity Pool",
        "args": [
          {
            "name": "txLPXfer",
            "type": "axfer",
            "desc": "Transfer of the LP token"
          },
          {
            "name": "poolAsset",
            "type": "uint64",
            "desc": "LP pool asset"
          },
          {
            "name": "assetA",
            "type": "uint64",
            "desc": "Asset A"
          },
          {
            "name": "assetB",
            "type": "uint64",
            "desc": "Asset B"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "swap",
        "desc": "Swap Asset A to Asset B or Asset B to Asst A",
        "args": [
          {
            "name": "txSwap",
            "type": "axfer",
            "desc": "Transfer of the token to be deposited to the pool. To the owner the other asset will be sent."
          },
          {
            "name": "assetA",
            "type": "uint64",
            "desc": "Asset A"
          },
          {
            "name": "assetB",
            "type": "uint64",
            "desc": "Asset B"
          },
          {
            "name": "minimumToReceive",
            "type": "uint64",
            "desc": "If number greater then zero, the check is performed for the output of the other asset"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "calculateAssetBWithdrawOnAssetADeposit",
        "readonly": true,
        "args": [
          {
            "name": "inAmount",
            "type": "uint64"
          },
          {
            "name": "assetADecimals",
            "type": "uint64"
          },
          {
            "name": "assetBDecimals",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "uint64"
        }
      }
    ]
  }
}

/**
 * Defines an onCompletionAction of 'no_op'
 */
export type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }
/**
 * Defines an onCompletionAction of 'opt_in'
 */
export type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }
/**
 * Defines an onCompletionAction of 'close_out'
 */
export type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }
/**
 * Defines an onCompletionAction of 'delete_application'
 */
export type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }
/**
 * Defines an onCompletionAction of 'update_application'
 */
export type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }
/**
 * A state record containing a single unsigned integer
 */
export type IntegerState = {
  /**
   * Gets the state value as a BigInt 
   */
  asBigInt(): bigint
  /**
   * Gets the state value as a number.
   */
  asNumber(): number
}
/**
 * A state record containing binary data
 */
export type BinaryState = {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array
  /**
   * Gets the state value as a string
   */
  asString(): string
}

export type AppCreateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult> & AppReference
export type AppUpdateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult>

/**
 * Defines the types of available calls and state of the BiatecClamm smart contract.
 */
export type BiatecClamm = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'createApplication()void' | 'createApplication', {
      argsObj: {
      }
      argsTuple: []
      returns: void
    }>
    & Record<'getCurrentPrice()uint64' | 'getCurrentPrice', {
      argsObj: {
      }
      argsTuple: []
      returns: bigint
    }>
    & Record<'getHypotheticPrice(uint64,uint64)uint64' | 'getHypotheticPrice', {
      argsObj: {
        assetAQuantity: bigint | number
        assetBQuantity: bigint | number
      }
      argsTuple: [assetAQuantity: bigint | number, assetBQuantity: bigint | number]
      returns: bigint
    }>
    & Record<'getPriceDivider()uint64' | 'getPriceDivider', {
      argsObj: {
      }
      argsTuple: []
      returns: bigint
    }>
    & Record<'getLPTokenId()uint64' | 'getLPTokenId', {
      argsObj: {
      }
      argsTuple: []
      returns: bigint
    }>
    & Record<'bootstrap(pay,uint64,uint64,uint32,uint64,uint64,uint64,uint8,uint64,uint64)uint64' | 'bootstrap', {
      argsObj: {
        /**
         * Seed transaction so that smart contract can opt in to the assets
         */
        txSeed: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * Asset A ID must be lower then Asset B ID
         */
        assetA: bigint | number
        /**
         * Asset B
         */
        assetB: bigint | number
        /**
         * Fee in 100000 base level. value 10000 = 10000/100000 = 0,1 = 10% fee. 1000 = 1%. 100 = 0,1%. 10 = 0,01% = 1 base point
         */
        feeB100000: number
        priceMaxA: bigint | number
        priceMaxB: bigint | number
        currentPrice: bigint | number
        /**
         * Asset B
         */
        verificationClass: number
        identityProvider: bigint | number
        poolProvider: bigint | number
      }
      argsTuple: [txSeed: TransactionToSign | Transaction | Promise<SendTransactionResult>, assetA: bigint | number, assetB: bigint | number, feeB100000: number, priceMaxA: bigint | number, priceMaxB: bigint | number, currentPrice: bigint | number, verificationClass: number, identityProvider: bigint | number, poolProvider: bigint | number]
      /**
       * LP token ID
       */
      returns: bigint
    }>
    & Record<'addLiquidity(txn,txn,uint64,uint64,uint64)uint64' | 'addLiquidity', {
      argsObj: {
        /**
         * Transfer of asset A to the LP pool
         */
        txAssetADeposit: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * Transfer of asset B to the LP pool
         */
        txAssetBDeposit: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * LP pool asset
         */
        poolAsset: bigint | number
        /**
         * Asset A
         */
        assetA: bigint | number
        /**
         * Asset B
         */
        assetB: bigint | number
      }
      argsTuple: [txAssetADeposit: TransactionToSign | Transaction | Promise<SendTransactionResult>, txAssetBDeposit: TransactionToSign | Transaction | Promise<SendTransactionResult>, poolAsset: bigint | number, assetA: bigint | number, assetB: bigint | number]
      /**
       * LP Token quantity distributed
       */
      returns: bigint
    }>
    & Record<'removeLiquidity(axfer,uint64,uint64,uint64)void' | 'removeLiquidity', {
      argsObj: {
        /**
         * Transfer of the LP token
         */
        txLPXfer: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * LP pool asset
         */
        poolAsset: bigint | number
        /**
         * Asset A
         */
        assetA: bigint | number
        /**
         * Asset B
         */
        assetB: bigint | number
      }
      argsTuple: [txLPXfer: TransactionToSign | Transaction | Promise<SendTransactionResult>, poolAsset: bigint | number, assetA: bigint | number, assetB: bigint | number]
      returns: void
    }>
    & Record<'swap(axfer,uint64,uint64,uint64)void' | 'swap', {
      argsObj: {
        /**
         * Transfer of the token to be deposited to the pool. To the owner the other asset will be sent.
         */
        txSwap: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * Asset A
         */
        assetA: bigint | number
        /**
         * Asset B
         */
        assetB: bigint | number
        /**
         * If number greater then zero, the check is performed for the output of the other asset
         */
        minimumToReceive: bigint | number
      }
      argsTuple: [txSwap: TransactionToSign | Transaction | Promise<SendTransactionResult>, assetA: bigint | number, assetB: bigint | number, minimumToReceive: bigint | number]
      returns: void
    }>
    & Record<'calculateAssetBWithdrawOnAssetADeposit(uint64,uint64,uint64)uint64' | 'calculateAssetBWithdrawOnAssetADeposit', {
      argsObj: {
        inAmount: bigint | number
        assetADecimals: bigint | number
        assetBDecimals: bigint | number
      }
      argsTuple: [inAmount: bigint | number, assetADecimals: bigint | number, assetBDecimals: bigint | number]
      returns: bigint
    }>
  /**
   * Defines the shape of the global and local state of the application.
   */
  state: {
    global: {
      'a'?: IntegerState
      'b'?: IntegerState
      'ab'?: IntegerState
      'bb'?: IntegerState
      'pa'?: IntegerState
      'pb'?: IntegerState
      'pas'?: IntegerState
      'pbs'?: IntegerState
      'p'?: IntegerState
      'f'?: BinaryState
      'r'?: IntegerState
      'scale'?: IntegerState
      'i'?: IntegerState
      'pp'?: IntegerState
      'g'?: BinaryState
      'c'?: BinaryState
      'e'?: BinaryState
    }
  }
}
/**
 * Defines the possible abi call signatures
 */
export type BiatecClammSig = keyof BiatecClamm['methods']
/**
 * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made
 */
export type TypedCallParams<TSignature extends BiatecClammSig | undefined> = {
  method: TSignature
  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>
} & AppClientCallCoreParams & CoreAppCallArgs
/**
 * Defines the arguments required for a bare call
 */
export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>
/**
 * Maps a method signature from the BiatecClamm smart contract to the method's arguments in either tuple of struct form
 */
export type MethodArgs<TSignature extends BiatecClammSig> = BiatecClamm['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the BiatecClamm smart contract to the method's return type
 */
export type MethodReturn<TSignature extends BiatecClammSig> = BiatecClamm['methods'][TSignature]['returns']

/**
 * A factory for available 'create' calls
 */
export type BiatecClammCreateCalls = (typeof BiatecClammCallFactory)['create']
/**
 * Defines supported create methods for this smart contract
 */
export type BiatecClammCreateCallParams =
  | (TypedCallParams<'createApplication()void'> & (OnCompleteNoOp))
/**
 * Defines arguments required for the deploy method.
 */
export type BiatecClammDeployArgs = {
  deployTimeParams?: TealTemplateParams
  /**
   * A delegate which takes a create call factory and returns the create call params for this smart contract
   */
  createCall?: (callFactory: BiatecClammCreateCalls) => BiatecClammCreateCallParams
}


/**
 * Exposes methods for constructing all available smart contract calls
 */
export abstract class BiatecClammCallFactory {
  /**
   * Gets available create call factories
   */
  static get create() {
    return {
      /**
       * Constructs a create call for the BiatecCLAMM smart contract using the createApplication()void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      createApplication(args: MethodArgs<'createApplication()void'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return {
          method: 'createApplication()void' as const,
          methodArgs: Array.isArray(args) ? args : [],
          ...params,
        }
      },
    }
  }

  /**
   * Constructs a no op call for the getCurrentPrice()uint64 ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getCurrentPrice(args: MethodArgs<'getCurrentPrice()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getCurrentPrice()uint64' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the getHypotheticPrice(uint64,uint64)uint64 ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getHypotheticPrice(args: MethodArgs<'getHypotheticPrice(uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getHypotheticPrice(uint64,uint64)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.assetAQuantity, args.assetBQuantity],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the getPriceDivider()uint64 ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getPriceDivider(args: MethodArgs<'getPriceDivider()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getPriceDivider()uint64' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the getLPTokenId()uint64 ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getLpTokenId(args: MethodArgs<'getLPTokenId()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getLPTokenId()uint64' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the bootstrap(pay,uint64,uint64,uint32,uint64,uint64,uint64,uint8,uint64,uint64)uint64 ABI method
   *
   * Anybody can deploy the clamm smart contract
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static bootstrap(args: MethodArgs<'bootstrap(pay,uint64,uint64,uint32,uint64,uint64,uint64,uint8,uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'bootstrap(pay,uint64,uint64,uint32,uint64,uint64,uint64,uint8,uint64,uint64)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.txSeed, args.assetA, args.assetB, args.feeB100000, args.priceMaxA, args.priceMaxB, args.currentPrice, args.verificationClass, args.identityProvider, args.poolProvider],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the addLiquidity(txn,txn,uint64,uint64,uint64)uint64 ABI method
   *
   * This method adds Asset A and Asset B to the Automated Market Maker Concentrated Liqudidity Pool and send to the liqudidty provider the liqudity token
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static addLiquidity(args: MethodArgs<'addLiquidity(txn,txn,uint64,uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'addLiquidity(txn,txn,uint64,uint64,uint64)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.txAssetADeposit, args.txAssetBDeposit, args.poolAsset, args.assetA, args.assetB],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the removeLiquidity(axfer,uint64,uint64,uint64)void ABI method
   *
   * This method retrieves from the liquidity provider LP token and returns Asset A and Asset B from the Automated Market Maker Concentrated Liqudidity Pool
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static removeLiquidity(args: MethodArgs<'removeLiquidity(axfer,uint64,uint64,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'removeLiquidity(axfer,uint64,uint64,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.txLPXfer, args.poolAsset, args.assetA, args.assetB],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the swap(axfer,uint64,uint64,uint64)void ABI method
   *
   * Swap Asset A to Asset B or Asset B to Asst A
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static swap(args: MethodArgs<'swap(axfer,uint64,uint64,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'swap(axfer,uint64,uint64,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.txSwap, args.assetA, args.assetB, args.minimumToReceive],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the calculateAssetBWithdrawOnAssetADeposit(uint64,uint64,uint64)uint64 ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static calculateAssetBWithdrawOnAssetADeposit(args: MethodArgs<'calculateAssetBWithdrawOnAssetADeposit(uint64,uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'calculateAssetBWithdrawOnAssetADeposit(uint64,uint64,uint64)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.inAmount, args.assetADecimals, args.assetBDecimals],
      ...params,
    }
  }
}

/**
 * A client to make calls to the BiatecCLAMM smart contract
 */
export class BiatecClammClient {
  /**
   * The underlying `ApplicationClient` for when you want to have more flexibility
   */
  public readonly appClient: ApplicationClient

  private readonly sender: SendTransactionFrom | undefined

  /**
   * Creates a new instance of `BiatecClammClient`
   *
   * @param appDetails appDetails The details to identify the app to deploy
   * @param algod An algod client instance
   */
  constructor(appDetails: AppDetails, private algod: Algodv2) {
    this.sender = appDetails.sender
    this.appClient = algokit.getAppClient({
      ...appDetails,
      app: APP_SPEC
    }, algod)
  }

  /**
   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type
   *
   * @param result The AppCallTransactionResult to be mapped
   * @param returnValueFormatter An optional delegate to format the return value if required
   * @returns The smart contract response with an updated return value
   */
  protected mapReturnValue<TReturn, TResult extends AppCallTransactionResult = AppCallTransactionResult>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> & TResult {
    if(result.return?.decodeError) {
      throw result.return.decodeError
    }
    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined
      ? returnValueFormatter(result.return.returnValue)
      : result.return?.returnValue as TReturn | undefined
      return { ...result, return: returnValue } as AppCallTransactionResultOfType<TReturn> & TResult
  }

  /**
   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP
   *
   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters
   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type
   * @returns The result of the smart contract call
   */
  public async call<TSignature extends keyof BiatecClamm['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {
    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)
  }

  /**
   * Idempotently deploys the BiatecCLAMM smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public deploy(params: BiatecClammDeployArgs & AppClientDeployCoreParams = {}): ReturnType<ApplicationClient['deploy']> {
    const createArgs = params.createCall?.(BiatecClammCallFactory.create)
    return this.appClient.deploy({
      ...params,
      createArgs,
      createOnCompleteAction: createArgs?.onCompleteAction,
    })
  }

  /**
   * Gets available create methods
   */
  public get create() {
    const $this = this
    return {
      /**
       * Creates a new instance of the BiatecCLAMM smart contract using the createApplication()void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The create result
       */
      async createApplication(args: MethodArgs<'createApplication()void'>, params: AppClientCallCoreParams & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return $this.mapReturnValue<MethodReturn<'createApplication()void'>, AppCreateCallTransactionResult>(await $this.appClient.create(BiatecClammCallFactory.create.createApplication(args, params)))
      },
    }
  }

  /**
   * Makes a clear_state call to an existing instance of the BiatecCLAMM smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The clear_state result
   */
  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.appClient.clearState(args)
  }

  /**
   * Calls the getCurrentPrice()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getCurrentPrice(args: MethodArgs<'getCurrentPrice()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.getCurrentPrice(args, params))
  }

  /**
   * Calls the getHypotheticPrice(uint64,uint64)uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getHypotheticPrice(args: MethodArgs<'getHypotheticPrice(uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.getHypotheticPrice(args, params))
  }

  /**
   * Calls the getPriceDivider()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getPriceDivider(args: MethodArgs<'getPriceDivider()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.getPriceDivider(args, params))
  }

  /**
   * Calls the getLPTokenId()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getLpTokenId(args: MethodArgs<'getLPTokenId()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.getLpTokenId(args, params))
  }

  /**
   * Calls the bootstrap(pay,uint64,uint64,uint32,uint64,uint64,uint64,uint8,uint64,uint64)uint64 ABI method.
   *
   * Anybody can deploy the clamm smart contract
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: LP token ID
   */
  public bootstrap(args: MethodArgs<'bootstrap(pay,uint64,uint64,uint32,uint64,uint64,uint64,uint8,uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.bootstrap(args, params))
  }

  /**
   * Calls the addLiquidity(txn,txn,uint64,uint64,uint64)uint64 ABI method.
   *
   * This method adds Asset A and Asset B to the Automated Market Maker Concentrated Liqudidity Pool and send to the liqudidty provider the liqudity token
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: LP Token quantity distributed
   */
  public addLiquidity(args: MethodArgs<'addLiquidity(txn,txn,uint64,uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.addLiquidity(args, params))
  }

  /**
   * Calls the removeLiquidity(axfer,uint64,uint64,uint64)void ABI method.
   *
   * This method retrieves from the liquidity provider LP token and returns Asset A and Asset B from the Automated Market Maker Concentrated Liqudidity Pool
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public removeLiquidity(args: MethodArgs<'removeLiquidity(axfer,uint64,uint64,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.removeLiquidity(args, params))
  }

  /**
   * Calls the swap(axfer,uint64,uint64,uint64)void ABI method.
   *
   * Swap Asset A to Asset B or Asset B to Asst A
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public swap(args: MethodArgs<'swap(axfer,uint64,uint64,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.swap(args, params))
  }

  /**
   * Calls the calculateAssetBWithdrawOnAssetADeposit(uint64,uint64,uint64)uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public calculateAssetBWithdrawOnAssetADeposit(args: MethodArgs<'calculateAssetBWithdrawOnAssetADeposit(uint64,uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.calculateAssetBWithdrawOnAssetADeposit(args, params))
  }

  /**
   * Extracts a binary state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns A BinaryState instance containing the state value, or undefined if the key was not found
   */
  private static getBinaryState(state: AppState, key: string): BinaryState | undefined {
    const value = state[key]
    if (!value) return undefined
    if (!('valueRaw' in value))
      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`)
    return {
      asString(): string {
        return value.value
      },
      asByteArray(): Uint8Array {
        return value.valueRaw
      }
    }
  }

  /**
   * Extracts a integer state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns An IntegerState instance containing the state value, or undefined if the key was not found
   */
  private static getIntegerState(state: AppState, key: string): IntegerState | undefined {
    const value = state[key]
    if (!value) return undefined
    if ('valueRaw' in value)
      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`)
    return {
      asBigInt() {
        return typeof value.value === 'bigint' ? value.value : BigInt(value.value)
      },
      asNumber(): number {
        return typeof value.value === 'bigint' ? Number(value.value) : value.value
      },
    }
  }

  /**
   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value
   */
  public async getGlobalState(): Promise<BiatecClamm['state']['global']> {
    const state = await this.appClient.getGlobalState()
    return {
      get a() {
        return BiatecClammClient.getIntegerState(state, 'a')
      },
      get b() {
        return BiatecClammClient.getIntegerState(state, 'b')
      },
      get ab() {
        return BiatecClammClient.getIntegerState(state, 'ab')
      },
      get bb() {
        return BiatecClammClient.getIntegerState(state, 'bb')
      },
      get pa() {
        return BiatecClammClient.getIntegerState(state, 'pa')
      },
      get pb() {
        return BiatecClammClient.getIntegerState(state, 'pb')
      },
      get pas() {
        return BiatecClammClient.getIntegerState(state, 'pas')
      },
      get pbs() {
        return BiatecClammClient.getIntegerState(state, 'pbs')
      },
      get p() {
        return BiatecClammClient.getIntegerState(state, 'p')
      },
      get f() {
        return BiatecClammClient.getBinaryState(state, 'f')
      },
      get r() {
        return BiatecClammClient.getIntegerState(state, 'r')
      },
      get scale() {
        return BiatecClammClient.getIntegerState(state, 'scale')
      },
      get i() {
        return BiatecClammClient.getIntegerState(state, 'i')
      },
      get pp() {
        return BiatecClammClient.getIntegerState(state, 'pp')
      },
      get g() {
        return BiatecClammClient.getBinaryState(state, 'g')
      },
      get c() {
        return BiatecClammClient.getBinaryState(state, 'c')
      },
      get e() {
        return BiatecClammClient.getBinaryState(state, 'e')
      },
    }
  }

  public compose(): BiatecClammComposer {
    const client = this
    const atc = new AtomicTransactionComposer()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: any) => any)> = []
    return {
      getCurrentPrice(args: MethodArgs<'getCurrentPrice()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getCurrentPrice(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      getHypotheticPrice(args: MethodArgs<'getHypotheticPrice(uint64,uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getHypotheticPrice(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      getPriceDivider(args: MethodArgs<'getPriceDivider()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getPriceDivider(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      getLpTokenId(args: MethodArgs<'getLPTokenId()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getLpTokenId(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      bootstrap(args: MethodArgs<'bootstrap(pay,uint64,uint64,uint32,uint64,uint64,uint64,uint8,uint64,uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.bootstrap(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addLiquidity(args: MethodArgs<'addLiquidity(txn,txn,uint64,uint64,uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.addLiquidity(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      removeLiquidity(args: MethodArgs<'removeLiquidity(axfer,uint64,uint64,uint64)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.removeLiquidity(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      swap(args: MethodArgs<'swap(axfer,uint64,uint64,uint64)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.swap(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      calculateAssetBWithdrawOnAssetADeposit(args: MethodArgs<'calculateAssetBWithdrawOnAssetADeposit(uint64,uint64,uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.calculateAssetBWithdrawOnAssetADeposit(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {
        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))
        return this
      },
      async atc() {
        await promiseChain
        return atc
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await atc.simulate(client.algod, new modelsv2.SimulateRequest({ txnGroups: [], ...options }))
        return {
          ...result,
          returns: result.methodResults?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      },
      async execute() {
        await promiseChain
        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams: {} }, client.algod)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      }
    } as unknown as BiatecClammComposer
  }
}
export type BiatecClammComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the getCurrentPrice()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getCurrentPrice(args: MethodArgs<'getCurrentPrice()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'getCurrentPrice()uint64'>]>

  /**
   * Calls the getHypotheticPrice(uint64,uint64)uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getHypotheticPrice(args: MethodArgs<'getHypotheticPrice(uint64,uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'getHypotheticPrice(uint64,uint64)uint64'>]>

  /**
   * Calls the getPriceDivider()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getPriceDivider(args: MethodArgs<'getPriceDivider()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'getPriceDivider()uint64'>]>

  /**
   * Calls the getLPTokenId()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getLpTokenId(args: MethodArgs<'getLPTokenId()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'getLPTokenId()uint64'>]>

  /**
   * Calls the bootstrap(pay,uint64,uint64,uint32,uint64,uint64,uint64,uint8,uint64,uint64)uint64 ABI method.
   *
   * Anybody can deploy the clamm smart contract
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  bootstrap(args: MethodArgs<'bootstrap(pay,uint64,uint64,uint32,uint64,uint64,uint64,uint8,uint64,uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'bootstrap(pay,uint64,uint64,uint32,uint64,uint64,uint64,uint8,uint64,uint64)uint64'>]>

  /**
   * Calls the addLiquidity(txn,txn,uint64,uint64,uint64)uint64 ABI method.
   *
   * This method adds Asset A and Asset B to the Automated Market Maker Concentrated Liqudidity Pool and send to the liqudidty provider the liqudity token
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  addLiquidity(args: MethodArgs<'addLiquidity(txn,txn,uint64,uint64,uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'addLiquidity(txn,txn,uint64,uint64,uint64)uint64'>]>

  /**
   * Calls the removeLiquidity(axfer,uint64,uint64,uint64)void ABI method.
   *
   * This method retrieves from the liquidity provider LP token and returns Asset A and Asset B from the Automated Market Maker Concentrated Liqudidity Pool
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  removeLiquidity(args: MethodArgs<'removeLiquidity(axfer,uint64,uint64,uint64)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'removeLiquidity(axfer,uint64,uint64,uint64)void'>]>

  /**
   * Calls the swap(axfer,uint64,uint64,uint64)void ABI method.
   *
   * Swap Asset A to Asset B or Asset B to Asst A
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  swap(args: MethodArgs<'swap(axfer,uint64,uint64,uint64)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'swap(axfer,uint64,uint64,uint64)void'>]>

  /**
   * Calls the calculateAssetBWithdrawOnAssetADeposit(uint64,uint64,uint64)uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  calculateAssetBWithdrawOnAssetADeposit(args: MethodArgs<'calculateAssetBWithdrawOnAssetADeposit(uint64,uint64,uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'calculateAssetBWithdrawOnAssetADeposit(uint64,uint64,uint64)uint64'>]>

  /**
   * Makes a clear_state call to an existing instance of the BiatecCLAMM smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)
   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.
   */
  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): BiatecClammComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  atc(): Promise<AtomicTransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(options?: SimulateOptions): Promise<BiatecClammComposerSimulateResult<TReturns>>
  /**
   * Executes the transaction group and returns the results
   */
  execute(): Promise<BiatecClammComposerResults<TReturns>>
}
export type SimulateOptions = Omit<ConstructorParameters<typeof modelsv2.SimulateRequest>[0], 'txnGroups'>
export type BiatecClammComposerSimulateResult<TReturns extends [...any[]]> = {
  returns: TReturns
  methodResults: ABIResult[]
  simulateResponse: modelsv2.SimulateResponse
}
export type BiatecClammComposerResults<TReturns extends [...any[]]> = {
  returns: TReturns
  groupId: string
  txIds: string[]
  transactions: Transaction[]
}

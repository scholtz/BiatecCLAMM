/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^2
 */
import * as algokit from '@algorandfoundation/algokit-utils'
import type {
  ABIAppCallArg,
  AppCallTransactionResult,
  AppCallTransactionResultOfType,
  AppCompilationResult,
  AppReference,
  AppState,
  CoreAppCallArgs,
  RawAppCallArgs,
  TealTemplateParams,
} from '@algorandfoundation/algokit-utils/types/app'
import type {
  AppClientCallCoreParams,
  AppClientCompilationParams,
  AppClientDeployCoreParams,
  AppDetails,
  ApplicationClient,
} from '@algorandfoundation/algokit-utils/types/app-client'
import type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'
import type { SendTransactionResult, TransactionToSign, SendTransactionFrom } from '@algorandfoundation/algokit-utils/types/transaction'
import type { ABIResult, TransactionWithSigner } from 'algosdk'
import { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer, modelsv2 } from 'algosdk'
export const APP_SPEC: AppSpec = {
  "hints": {
    "createApplication()void": {
      "call_config": {
        "no_op": "CREATE"
      }
    },
    "getCurrentPrice()uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "getPriceDivider()uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "getLPTokenId()uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "bootstrap(pay,uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint64,uint64)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "addLiquidity(txn,txn,uint64,uint64,uint64)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "removeLiquidity(axfer,uint64,uint64,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "swap(axfer,uint64,uint64,uint64)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "calculateLiquidity(uint256,uint256,uint256,uint256,uint256,uint256)uint256": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256": {
      "call_config": {
        "no_op": "CALL"
      }
    }
  },
  "bare_call_config": {
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "close_out": "NEVER",
    "update_application": "NEVER",
    "delete_application": "NEVER"
  },
  "schema": {
    "local": {
      "declared": {},
      "reserved": {}
    },
    "global": {
      "declared": {
        "assetA": {
          "type": "uint64",
          "key": "a"
        },
        "assetB": {
          "type": "uint64",
          "key": "b"
        },
        "assetABalance": {
          "type": "bytes",
          "key": "ab"
        },
        "assetBBalance": {
          "type": "bytes",
          "key": "bb"
        },
        "priceMin": {
          "type": "uint64",
          "key": "pMin"
        },
        "priceMax": {
          "type": "uint64",
          "key": "pMax"
        },
        "priceMinSqrt": {
          "type": "bytes",
          "key": "pMinS"
        },
        "priceMaxSqrt": {
          "type": "bytes",
          "key": "pMaxS"
        },
        "Liqudity": {
          "type": "bytes",
          "key": "L"
        },
        "poolToken": {
          "type": "uint64",
          "key": "p"
        },
        "feeB100000": {
          "type": "uint64",
          "key": "f"
        },
        "ratio": {
          "type": "uint64",
          "key": "r"
        },
        "scale": {
          "type": "uint64",
          "key": "scale"
        },
        "identityProvider": {
          "type": "uint64",
          "key": "i"
        },
        "poolProvider": {
          "type": "uint64",
          "key": "pp"
        },
        "governor": {
          "type": "bytes",
          "key": "g"
        },
        "verificationClass": {
          "type": "bytes",
          "key": "c"
        },
        "engagementClass": {
          "type": "bytes",
          "key": "e"
        }
      },
      "reserved": {}
    }
  },
  "state": {
    "global": {
      "num_byte_slices": 8,
      "num_uints": 10
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0
    }
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCgovLyBUaGlzIFRFQUwgd2FzIGdlbmVyYXRlZCBieSBURUFMU2NyaXB0IHYwLjg2LjAKLy8gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29yYW5kZm91bmRhdGlvbi9URUFMU2NyaXB0CgovLyBUaGlzIGNvbnRyYWN0IGlzIGNvbXBsaWFudCB3aXRoIGFuZC9vciBpbXBsZW1lbnRzIHRoZSBmb2xsb3dpbmcgQVJDczogWyBBUkM0IF0KCi8vIFRoZSBmb2xsb3dpbmcgdGVuIGxpbmVzIG9mIFRFQUwgaGFuZGxlIGluaXRpYWwgcHJvZ3JhbSBmbG93Ci8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIHRvIG1ha2UgaXQgZWFzeSBmb3IgYW55b25lIHRvIHBhcnNlIHRoZSBzdGFydCBvZiB0aGUgcHJvZ3JhbSBhbmQgZGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgYWN0aW9uIGlzIGFsbG93ZWQKLy8gSGVyZSwgYWN0aW9uIHJlZmVycyB0byB0aGUgT25Db21wbGV0ZSBpbiBjb21iaW5hdGlvbiB3aXRoIHdoZXRoZXIgdGhlIGFwcCBpcyBiZWluZyBjcmVhdGVkIG9yIGNhbGxlZAovLyBFdmVyeSBwb3NzaWJsZSBhY3Rpb24gZm9yIHRoaXMgY29udHJhY3QgaXMgcmVwcmVzZW50ZWQgaW4gdGhlIHN3aXRjaCBzdGF0ZW1lbnQKLy8gSWYgdGhlIGFjdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIGNvbnRyYWN0LCBpdHMgcmVzcGVjdGl2ZSBicmFuY2ggd2lsbCBiZSAiKk5PVF9JTVBMRU1FTlRFRCIgd2hpY2gganVzdCBjb250YWlucyAiZXJyIgp0eG4gQXBwbGljYXRpb25JRAohCmludCA2CioKdHhuIE9uQ29tcGxldGlvbgorCnN3aXRjaCAqY2FsbF9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqY3JlYXRlX05vT3AgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVECgoqTk9UX0lNUExFTUVOVEVEOgoJZXJyCgovLyBjcmVhdGVBcHBsaWNhdGlvbigpdm9pZAoqYWJpX3JvdXRlX2NyZWF0ZUFwcGxpY2F0aW9uOgoJLy8gZXhlY3V0ZSBjcmVhdGVBcHBsaWNhdGlvbigpdm9pZAoJY2FsbHN1YiBjcmVhdGVBcHBsaWNhdGlvbgoJaW50IDEKCXJldHVybgoKLy8gY3JlYXRlQXBwbGljYXRpb24oKTogdm9pZAovLwovLyBJbml0aWFsIHNldHVwCmNyZWF0ZUFwcGxpY2F0aW9uOgoJcHJvdG8gMCAwCgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NzkKCS8vIGxvZyh2ZXJzaW9uKQoJYnl0ZSAiQ0xBTU0tMDEtMDEtMDEiCglsb2cKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo4MAoJLy8gdGhpcy5nb3Zlcm5vci52YWx1ZSA9IEFkZHJlc3MuZnJvbUJ5dGVzKGdvdmVybm9yKQoJYnl0ZSAweDY3IC8vICJnIgoJYnl0ZSAiQUxHT05BVVRTUElVSERDWDNTTEZYT0ZEVUtPRTRWWTM2WFY0SlgySkhRVFdKTktWQktQRUJRQUNSWSIKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6ODEKCS8vIHRoaXMuc2NhbGUudmFsdWUgPSBTQ0FMRQoJYnl0ZSAweDczNjM2MTZjNjUgLy8gInNjYWxlIgoJaW50IDEwMDAwMDAwMDAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6ODIKCS8vIHRoaXMuZmVlQjEwMDAwMC52YWx1ZSA9IDx1aW50NjQ+MAoJYnl0ZSAweDY2IC8vICJmIgoJaW50IDAKCWFwcF9nbG9iYWxfcHV0CglyZXRzdWIKCi8vIGdldEN1cnJlbnRQcmljZSgpdWludDY0CiphYmlfcm91dGVfZ2V0Q3VycmVudFByaWNlOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBleGVjdXRlIGdldEN1cnJlbnRQcmljZSgpdWludDY0CgljYWxsc3ViIGdldEN1cnJlbnRQcmljZQoJaXRvYgoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGdldEN1cnJlbnRQcmljZSgpOiB1aW50NjQKZ2V0Q3VycmVudFByaWNlOgoJcHJvdG8gMCAxCgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6ODcKCS8vIHJldHVybiB0aGlzLnJhdGlvLnZhbHVlOwoJYnl0ZSAweDcyIC8vICJyIgoJYXBwX2dsb2JhbF9nZXQKCXJldHN1YgoKLy8gZ2V0UHJpY2VEaXZpZGVyKCl1aW50NjQKKmFiaV9yb3V0ZV9nZXRQcmljZURpdmlkZXI6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIGV4ZWN1dGUgZ2V0UHJpY2VEaXZpZGVyKCl1aW50NjQKCWNhbGxzdWIgZ2V0UHJpY2VEaXZpZGVyCglpdG9iCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gZ2V0UHJpY2VEaXZpZGVyKCk6IHVpbnQ2NApnZXRQcmljZURpdmlkZXI6Cglwcm90byAwIDEKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo5MgoJLy8gcmV0dXJuIHRoaXMuc2NhbGUudmFsdWU7CglieXRlIDB4NzM2MzYxNmM2NSAvLyAic2NhbGUiCglhcHBfZ2xvYmFsX2dldAoJcmV0c3ViCgovLyBnZXRMUFRva2VuSWQoKXVpbnQ2NAoqYWJpX3JvdXRlX2dldExQVG9rZW5JZDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gZXhlY3V0ZSBnZXRMUFRva2VuSWQoKXVpbnQ2NAoJY2FsbHN1YiBnZXRMUFRva2VuSWQKCWl0b2IKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBnZXRMUFRva2VuSWQoKTogdWludDY0CmdldExQVG9rZW5JZDoKCXByb3RvIDAgMQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjk3CgkvLyByZXR1cm4gdGhpcy5wb29sVG9rZW4udmFsdWUuaWQ7CglieXRlIDB4NzAgLy8gInAiCglhcHBfZ2xvYmFsX2dldAoJcmV0c3ViCgovLyBib290c3RyYXAocGF5LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQpdWludDY0CiphYmlfcm91dGVfYm9vdHN0cmFwOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBwb29sUHJvdmlkZXI6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgOQoJYnRvaQoKCS8vIGlkZW50aXR5UHJvdmlkZXI6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgOAoJYnRvaQoKCS8vIHZlcmlmaWNhdGlvbkNsYXNzOiB1aW50OAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNwoJZHVwCglsZW4KCWludCAxCgk9PQoJYXNzZXJ0CglidG9pCgoJLy8gY3VycmVudFByaWNlOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDYKCWJ0b2kKCgkvLyBwcmljZU1heDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA1CglidG9pCgoJLy8gcHJpY2VNaW46IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAoJYnRvaQoKCS8vIGZlZUIxMDAwMDA6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJYnRvaQoKCS8vIGFzc2V0QjogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gYXNzZXRBOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyB0eFNlZWQ6IHBheQoJdHhuIEdyb3VwSW5kZXgKCWludCAxCgktCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnQgcGF5Cgk9PQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBib290c3RyYXAocGF5LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQpdWludDY0CgljYWxsc3ViIGJvb3RzdHJhcAoJaXRvYgoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGJvb3RzdHJhcCh0eFNlZWQ6IFBheVR4biwgYXNzZXRBOiBBc3NldElELCBhc3NldEI6IEFzc2V0SUQsIGZlZUIxMDAwMDA6IHVpbnQ2NCwgcHJpY2VNaW46IHVpbnQ2NCwgcHJpY2VNYXg6IHVpbnQ2NCwgY3VycmVudFByaWNlOiB1aW50NjQsIHZlcmlmaWNhdGlvbkNsYXNzOiB1aW50OCwgaWRlbnRpdHlQcm92aWRlcjogQXBwSUQsIHBvb2xQcm92aWRlcjogQXBwSUQpOiBBc3NldElECi8vCi8vIEFueWJvZHkgY2FuIGRlcGxveSB0aGUgY2xhbW0gc21hcnQgY29udHJhY3QKLy8gQHBhcmFtIHR4U2VlZCBTZWVkIHRyYW5zYWN0aW9uIHNvIHRoYXQgc21hcnQgY29udHJhY3QgY2FuIG9wdCBpbiB0byB0aGUgYXNzZXRzCi8vIEBwYXJhbSBhc3NldEEgQXNzZXQgQSBJRCBtdXN0IGJlIGxvd2VyIHRoZW4gQXNzZXQgQiBJRAovLyBAcGFyYW0gYXNzZXRCIEFzc2V0IEIKLy8gQHBhcmFtIGZlZUIxMDAwMDAgRmVlIGluIDEwMDAwMCBiYXNlIGxldmVsLiB2YWx1ZSAxMDAwMCA9IDEwMDAwLzEwMDAwMCA9IDAsMSA9IDEwJSBmZWUuIDEwMDAgPSAxJS4gMTAwID0gMCwxJS4gMTAgPSAwLDAxJSA9IDEgYmFzZSBwb2ludAovLyBAcGFyYW0gdmVyaWZpY2F0aW9uQ2xhc3MgQXNzZXQgQgovLyBAcmV0dXJucyBMUCB0b2tlbiBJRApib290c3RyYXA6Cglwcm90byAxMCAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxMjEKCS8vIHZlcmlmeVBheVR4bih0eFNlZWQsIHsgcmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MsIGFtb3VudDogeyBncmVhdGVyVGhhbkVxdWFsVG86IDMwMF8wMDAgfSB9KQoJLy8gdmVyaWZ5IHJlY2VpdmVyCglmcmFtZV9kaWcgLTEgLy8gdHhTZWVkOiBQYXlUeG4KCWd0eG5zIFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSBhbW91bnQKCWZyYW1lX2RpZyAtMSAvLyB0eFNlZWQ6IFBheVR4bgoJZ3R4bnMgQW1vdW50CglpbnQgMzAwXzAwMAoJPj0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjEyMgoJLy8gYXNzZXJ0KHRoaXMuZ292ZXJub3IudmFsdWUgPT09IEFkZHJlc3MuZnJvbUJ5dGVzKGdvdmVybm9yKSkKCWJ5dGUgMHg2NyAvLyAiZyIKCWFwcF9nbG9iYWxfZ2V0CglieXRlICJBTEdPTkFVVFNQSVVIRENYM1NMRlhPRkRVS09FNFZZMzZYVjRKWDJKSFFUV0pOS1ZCS1BFQlFBQ1JZIgoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjEyMwoJLy8gYXNzZXJ0KGFzc2V0QSA8IGFzc2V0QikKCWZyYW1lX2RpZyAtMiAvLyBhc3NldEE6IEFzc2V0SUQKCWZyYW1lX2RpZyAtMyAvLyBhc3NldEI6IEFzc2V0SUQKCTwKCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjEyNAoJLy8gYXNzZXJ0KGZlZUIxMDAwMDAgPCAxMDAwMDAwKQoJZnJhbWVfZGlnIC00IC8vIGZlZUIxMDAwMDA6IHVpbnQ2NAoJaW50IDEwMDAwMDAKCTwKCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjEyNQoJLy8gYXNzZXJ0KGZlZUIxMDAwMDAgPiAwKQoJZnJhbWVfZGlnIC00IC8vIGZlZUIxMDAwMDA6IHVpbnQ2NAoJaW50IDAKCT4KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjEyNgoJLy8gYXNzZXJ0KHZlcmlmaWNhdGlvbkNsYXNzIDwgNCkKCWZyYW1lX2RpZyAtOCAvLyB2ZXJpZmljYXRpb25DbGFzczogdWludDgKCWludCA0Cgk8Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxMjcKCS8vIGFzc2VydCghdGhpcy5yYXRpby5leGlzdHMpCgl0eG5hIEFwcGxpY2F0aW9ucyAwCglieXRlIDB4NzIgLy8gInIiCglhcHBfZ2xvYmFsX2dldF9leAoJc3dhcAoJcG9wCgkhCglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxMjgKCS8vIGFzc2VydChhc3NldEEuZGVjaW1hbHMgPD0gU0NBTEVfREVDSU1BTFMpCglmcmFtZV9kaWcgLTIgLy8gYXNzZXRBOiBBc3NldElECglhc3NldF9wYXJhbXNfZ2V0IEFzc2V0RGVjaW1hbHMKCXBvcAoJaW50IDkKCTw9Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxMjkKCS8vIGFzc2VydChhc3NldEIuZGVjaW1hbHMgPD0gU0NBTEVfREVDSU1BTFMpCglmcmFtZV9kaWcgLTMgLy8gYXNzZXRCOiBBc3NldElECglhc3NldF9wYXJhbXNfZ2V0IEFzc2V0RGVjaW1hbHMKCXBvcAoJaW50IDkKCTw9Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxMzAKCS8vIHMgPSBTQ0FMRSBhcyB1aW50MjU2CglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAzYjlhY2EwMAoJZnJhbWVfYnVyeSAwIC8vIHM6IHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxMzIKCS8vIGFzc2VydCh0aGlzLmZlZUIxMDAwMDAudmFsdWUgPD0gMCwgJ1lvdSBjYW4gYm9vdHN0cmFwIGNvbnRyYWN0IG9ubHkgb25jZScpCglieXRlIDB4NjYgLy8gImYiCglhcHBfZ2xvYmFsX2dldAoJaW50IDAKCTw9CgoJLy8gWW91IGNhbiBib290c3RyYXAgY29udHJhY3Qgb25seSBvbmNlCglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxMzQKCS8vIHRoaXMuaWRlbnRpdHlQcm92aWRlci52YWx1ZSA9IGlkZW50aXR5UHJvdmlkZXIKCWJ5dGUgMHg2OSAvLyAiaSIKCWZyYW1lX2RpZyAtOSAvLyBpZGVudGl0eVByb3ZpZGVyOiBBcHBJRAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxMzUKCS8vIHRoaXMucG9vbFByb3ZpZGVyLnZhbHVlID0gcG9vbFByb3ZpZGVyCglieXRlIDB4NzA3MCAvLyAicHAiCglmcmFtZV9kaWcgLTEwIC8vIHBvb2xQcm92aWRlcjogQXBwSUQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTM3CgkvLyB0aGlzLnByaWNlTWluLnZhbHVlID0gcHJpY2VNaW4KCWJ5dGUgMHg3MDRkNjk2ZSAvLyAicE1pbiIKCWZyYW1lX2RpZyAtNSAvLyBwcmljZU1pbjogdWludDY0CglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjEzOAoJLy8gdGhpcy5wcmljZU1heC52YWx1ZSA9IHByaWNlTWF4CglieXRlIDB4NzA0ZDYxNzggLy8gInBNYXgiCglmcmFtZV9kaWcgLTYgLy8gcHJpY2VNYXg6IHVpbnQ2NAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxMzkKCS8vIHRoaXMucHJpY2VNaW5TcXJ0LnZhbHVlID0gc3FydCgocHJpY2VNaW4gYXMgdWludDI1NikgKiBzKQoJYnl0ZSAweDcwNGQ2OTZlNTMgLy8gInBNaW5TIgoJZnJhbWVfZGlnIC01IC8vIHByaWNlTWluOiB1aW50NjQKCWl0b2IKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIqCglic3FydAoJZHVwCgliaXRsZW4KCWludCAyNTYKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDMyCgktCglzd2FwCglzdWJzdHJpbmczCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjE0MAoJLy8gdGhpcy5wcmljZU1heFNxcnQudmFsdWUgPSBzcXJ0KChwcmljZU1heCBhcyB1aW50MjU2KSAqIHMpCglieXRlIDB4NzA0ZDYxNzg1MyAvLyAicE1heFMiCglmcmFtZV9kaWcgLTYgLy8gcHJpY2VNYXg6IHVpbnQ2NAoJaXRvYgoJZnJhbWVfZGlnIDAgLy8gczogdWludDI1NgoJYioKCWJzcXJ0CglkdXAKCWJpdGxlbgoJaW50IDI1NgoJPD0KCWFzc2VydAoJYnl0ZSAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnQgMzIKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTQxCgkvLyB0aGlzLmFzc2V0QUJhbGFuY2UudmFsdWUgPSA8dWludDI1Nj4wCglieXRlIDB4NjE2MiAvLyAiYWIiCglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxNDIKCS8vIHRoaXMuYXNzZXRCQmFsYW5jZS52YWx1ZSA9IDx1aW50MjU2PjAKCWJ5dGUgMHg2MjYyIC8vICJiYiIKCWJ5dGUgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjE0MwoJLy8gdGhpcy5yYXRpby52YWx1ZSA9IGN1cnJlbnRQcmljZQoJYnl0ZSAweDcyIC8vICJyIgoJZnJhbWVfZGlnIC03IC8vIGN1cnJlbnRQcmljZTogdWludDY0CglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjE0NQoJLy8gdGhpcy5hc3NldEEudmFsdWUgPSBhc3NldEEKCWJ5dGUgMHg2MSAvLyAiYSIKCWZyYW1lX2RpZyAtMiAvLyBhc3NldEE6IEFzc2V0SUQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTQ2CgkvLyB0aGlzLmFzc2V0Qi52YWx1ZSA9IGFzc2V0QgoJYnl0ZSAweDYyIC8vICJiIgoJZnJhbWVfZGlnIC0zIC8vIGFzc2V0QjogQXNzZXRJRAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxNDcKCS8vIHRoaXMucG9vbFRva2VuLnZhbHVlID0gdGhpcy5kb0NyZWF0ZVBvb2xUb2tlbihhc3NldEEsIGFzc2V0QikKCWJ5dGUgMHg3MCAvLyAicCIKCWZyYW1lX2RpZyAtMyAvLyBhc3NldEI6IEFzc2V0SUQKCWZyYW1lX2RpZyAtMiAvLyBhc3NldEE6IEFzc2V0SUQKCWNhbGxzdWIgZG9DcmVhdGVQb29sVG9rZW4KCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTQ4CgkvLyB0aGlzLmZlZUIxMDAwMDAudmFsdWUgPSBmZWVCMTAwMDAwCglieXRlIDB4NjYgLy8gImYiCglmcmFtZV9kaWcgLTQgLy8gZmVlQjEwMDAwMDogdWludDY0CglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjE1MAoJLy8gdGhpcy5kb09wdEluKGFzc2V0QSkKCWZyYW1lX2RpZyAtMiAvLyBhc3NldEE6IEFzc2V0SUQKCWNhbGxzdWIgZG9PcHRJbgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjE1MQoJLy8gdGhpcy5kb09wdEluKGFzc2V0QikKCWZyYW1lX2RpZyAtMyAvLyBhc3NldEI6IEFzc2V0SUQKCWNhbGxzdWIgZG9PcHRJbgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjE1MwoJLy8gcmV0dXJuIHRoaXMucG9vbFRva2VuLnZhbHVlOwoJYnl0ZSAweDcwIC8vICJwIgoJYXBwX2dsb2JhbF9nZXQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCXJldHN1YgoKLy8gZG9BeGZlcihyZWNlaXZlcjogQWRkcmVzcywgYXNzZXQ6IEFzc2V0SUQsIGFtb3VudDogdWludDY0KTogdm9pZApkb0F4ZmVyOgoJcHJvdG8gMyAwCgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTU3CgkvLyBzZW5kQXNzZXRUcmFuc2Zlcih7CgkvLyAgICAgICBhc3NldFJlY2VpdmVyOiByZWNlaXZlciwKCS8vICAgICAgIHhmZXJBc3NldDogYXNzZXQsCgkvLyAgICAgICBhc3NldEFtb3VudDogYW1vdW50LAoJLy8gICAgICAgZmVlOiAwLAoJLy8gICAgIH0pCglpdHhuX2JlZ2luCglpbnQgYXhmZXIKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxNTgKCS8vIGFzc2V0UmVjZWl2ZXI6IHJlY2VpdmVyCglmcmFtZV9kaWcgLTEgLy8gcmVjZWl2ZXI6IEFkZHJlc3MKCWl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjE1OQoJLy8geGZlckFzc2V0OiBhc3NldAoJZnJhbWVfZGlnIC0yIC8vIGFzc2V0OiBBc3NldElECglpdHhuX2ZpZWxkIFhmZXJBc3NldAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjE2MAoJLy8gYXNzZXRBbW91bnQ6IGFtb3VudAoJZnJhbWVfZGlnIC0zIC8vIGFtb3VudDogdWludDY0CglpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTYxCgkvLyBmZWU6IDAKCWludCAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCXJldHN1YgoKLy8gZG9PcHRJbihhc3NldDogQXNzZXRJRCk6IHZvaWQKZG9PcHRJbjoKCXByb3RvIDEgMAoKCS8vICppZjBfY29uZGl0aW9uCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxNjYKCS8vIGFzc2V0LmlkID4gMAoJZnJhbWVfZGlnIC0xIC8vIGFzc2V0OiBBc3NldElECglpbnQgMAoJPgoJYnogKmlmMF9lbmQKCgkvLyAqaWYwX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjE2OAoJLy8gdGhpcy5kb0F4ZmVyKHRoaXMuYXBwLmFkZHJlc3MsIGFzc2V0LCAwKQoJaW50IDAKCWZyYW1lX2RpZyAtMSAvLyBhc3NldDogQXNzZXRJRAoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWNhbGxzdWIgZG9BeGZlcgoKKmlmMF9lbmQ6CglyZXRzdWIKCi8vIGRvQ3JlYXRlUG9vbFRva2VuKGFzc2V0QTogQXNzZXRJRCwgYXNzZXRCOiBBc3NldElEKTogQXNzZXRJRApkb0NyZWF0ZVBvb2xUb2tlbjoKCXByb3RvIDIgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTc2CgkvLyBuYW1lID0gJ0ItJyArIGFzc2V0QS51bml0TmFtZSArICctJyArIGFzc2V0Qi51bml0TmFtZQoJYnl0ZSAweDQyMmQgLy8gIkItIgoJZnJhbWVfZGlnIC0xIC8vIGFzc2V0QTogQXNzZXRJRAoJYXNzZXRfcGFyYW1zX2dldCBBc3NldFVuaXROYW1lCglwb3AKCWNvbmNhdAoJYnl0ZSAweDJkIC8vICItIgoJY29uY2F0CglmcmFtZV9kaWcgLTIgLy8gYXNzZXRCOiBBc3NldElECglhc3NldF9wYXJhbXNfZ2V0IEFzc2V0VW5pdE5hbWUKCXBvcAoJY29uY2F0CglmcmFtZV9idXJ5IDAgLy8gbmFtZTogYnl0ZVtdCgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTc4CgkvLyByZXR1cm4gc2VuZEFzc2V0Q3JlYXRpb24oewoJLy8gICAgICAgY29uZmlnQXNzZXROYW1lOiBuYW1lLAoJLy8gICAgICAgY29uZmlnQXNzZXRVbml0TmFtZTogJ0JMUCcsCgkvLyAgICAgICBjb25maWdBc3NldFRvdGFsOiBUT1RBTF9TVVBQTFksCgkvLyAgICAgICBjb25maWdBc3NldERlY2ltYWxzOiBMUF9UT0tFTl9ERUNJTUFMUywKCS8vICAgICAgIGNvbmZpZ0Fzc2V0TWFuYWdlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgIGNvbmZpZ0Fzc2V0UmVzZXJ2ZTogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICB9KTsKCWl0eG5fYmVnaW4KCWludCBhY2ZnCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTc5CgkvLyBjb25maWdBc3NldE5hbWU6IG5hbWUKCWZyYW1lX2RpZyAwIC8vIG5hbWU6IGJ5dGVbXQoJaXR4bl9maWVsZCBDb25maWdBc3NldE5hbWUKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxODAKCS8vIGNvbmZpZ0Fzc2V0VW5pdE5hbWU6ICdCTFAnCglieXRlIDB4NDI0YzUwIC8vICJCTFAiCglpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0VW5pdE5hbWUKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxODEKCS8vIGNvbmZpZ0Fzc2V0VG90YWw6IFRPVEFMX1NVUFBMWQoJaW50IDEwMDAwMDAwMDAwMDAwMDAwCglpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0VG90YWwKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxODIKCS8vIGNvbmZpZ0Fzc2V0RGVjaW1hbHM6IExQX1RPS0VOX0RFQ0lNQUxTCglpbnQgNgoJaXR4bl9maWVsZCBDb25maWdBc3NldERlY2ltYWxzCgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTgzCgkvLyBjb25maWdBc3NldE1hbmFnZXI6IHRoaXMuYXBwLmFkZHJlc3MKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0TWFuYWdlcgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjE4NAoJLy8gY29uZmlnQXNzZXRSZXNlcnZlOiB0aGlzLmFwcC5hZGRyZXNzCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJaXR4bl9maWVsZCBDb25maWdBc3NldFJlc2VydmUKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CglpdHhuIENyZWF0ZWRBc3NldElECgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCglyZXRzdWIKCi8vIGFkZExpcXVpZGl0eSh0eG4sdHhuLHVpbnQ2NCx1aW50NjQsdWludDY0KXVpbnQ2NAoqYWJpX3JvdXRlX2FkZExpcXVpZGl0eToKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gYXNzZXRCOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWJ0b2kKCgkvLyBhc3NldEE6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIGFzc2V0TFA6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIHR4QXNzZXRCRGVwb3NpdDogdHhuCgl0eG4gR3JvdXBJbmRleAoJaW50IDEKCS0KCgkvLyB0eEFzc2V0QURlcG9zaXQ6IHR4bgoJdHhuIEdyb3VwSW5kZXgKCWludCAyCgktCgoJLy8gZXhlY3V0ZSBhZGRMaXF1aWRpdHkodHhuLHR4bix1aW50NjQsdWludDY0LHVpbnQ2NCl1aW50NjQKCWNhbGxzdWIgYWRkTGlxdWlkaXR5CglpdG9iCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gYWRkTGlxdWlkaXR5KHR4QXNzZXRBRGVwb3NpdDogVHhuLCB0eEFzc2V0QkRlcG9zaXQ6IFR4biwgYXNzZXRMUDogQXNzZXRJRCwgYXNzZXRBOiBBc3NldElELCBhc3NldEI6IEFzc2V0SUQpOiB1aW50NjQKLy8KLy8gVGhpcyBtZXRob2QgYWRkcyBBc3NldCBBIGFuZCBBc3NldCBCIHRvIHRoZSBBdXRvbWF0ZWQgTWFya2V0IE1ha2VyIENvbmNlbnRyYXRlZCBMaXF1ZGlkaXR5IFBvb2wgYW5kIHNlbmQgdG8gdGhlIGxpcXVkaWR0eSBwcm92aWRlciB0aGUgbGlxdWRpdHkgdG9rZW4KLy8gQHBhcmFtIHR4QXNzZXRBRGVwb3NpdCBUcmFuc2ZlciBvZiBhc3NldCBBIHRvIHRoZSBMUCBwb29sCi8vIEBwYXJhbSB0eEFzc2V0QkRlcG9zaXQgVHJhbnNmZXIgb2YgYXNzZXQgQiB0byB0aGUgTFAgcG9vbAovLyBAcGFyYW0gYXNzZXRMUCBMaXF1aWRpdHkgcG9vbCBhc3NldAovLyBAcGFyYW0gYXNzZXRBIEFzc2V0IEEKLy8gQHBhcmFtIGFzc2V0QiBBc3NldCBCCi8vIEByZXR1cm5zIExQIFRva2VuIHF1YW50aXR5IGRpc3RyaWJ1dGVkCmFkZExpcXVpZGl0eToKCXByb3RvIDUgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CglkdXBuIDEyCgoJLy8gd2VsbCBmb3JtZWQgbWludAoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MjA3CgkvLyBhc3NlcnQoYXNzZXRBID09PSB0aGlzLmFzc2V0QS52YWx1ZSkKCWZyYW1lX2RpZyAtNCAvLyBhc3NldEE6IEFzc2V0SUQKCWJ5dGUgMHg2MSAvLyAiYSIKCWFwcF9nbG9iYWxfZ2V0Cgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MjA4CgkvLyBhc3NlcnQoYXNzZXRCID09PSB0aGlzLmFzc2V0Qi52YWx1ZSkKCWZyYW1lX2RpZyAtNSAvLyBhc3NldEI6IEFzc2V0SUQKCWJ5dGUgMHg2MiAvLyAiYiIKCWFwcF9nbG9iYWxfZ2V0Cgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MjA5CgkvLyBhc3NlcnQoYXNzZXRMUCA9PT0gdGhpcy5wb29sVG9rZW4udmFsdWUpCglmcmFtZV9kaWcgLTMgLy8gYXNzZXRMUDogQXNzZXRJRAoJYnl0ZSAweDcwIC8vICJwIgoJYXBwX2dsb2JhbF9nZXQKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoyMTEKCS8vIGFzc2V0QURlbGljbWFsU2NhbGUyU2NhbGUgPSAoMTAgKiogKFNDQUxFX0RFQ0lNQUxTIC0gYXNzZXRBLmRlY2ltYWxzKSkgYXMgdWludDI1NgoJaW50IDEwCglpbnQgOQoJZnJhbWVfZGlnIC00IC8vIGFzc2V0QTogQXNzZXRJRAoJYXNzZXRfcGFyYW1zX2dldCBBc3NldERlY2ltYWxzCglwb3AKCS0KCWV4cAoJaXRvYgoJZnJhbWVfYnVyeSAwIC8vIGFzc2V0QURlbGljbWFsU2NhbGUyU2NhbGU6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MjEzCgkvLyBhc3NldEJEZWxpY21hbFNjYWxlMlNjYWxlID0gKDEwICoqIChTQ0FMRV9ERUNJTUFMUyAtIGFzc2V0Qi5kZWNpbWFscykpIGFzIHVpbnQyNTYKCWludCAxMAoJaW50IDkKCWZyYW1lX2RpZyAtNSAvLyBhc3NldEI6IEFzc2V0SUQKCWFzc2V0X3BhcmFtc19nZXQgQXNzZXREZWNpbWFscwoJcG9wCgktCglleHAKCWl0b2IKCWZyYW1lX2J1cnkgMSAvLyBhc3NldEJEZWxpY21hbFNjYWxlMlNjYWxlOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjIxNQoJLy8gYXNzZXRMUERlbGljbWFsU2NhbGUyU2NhbGUgPSAoMTAgKiogKFNDQUxFX0RFQ0lNQUxTIC0gTFBfVE9LRU5fREVDSU1BTFMpKSBhcyB1aW50MjU2CglpbnQgMTAKCWludCAzCglleHAKCWl0b2IKCWZyYW1lX2J1cnkgMiAvLyBhc3NldExQRGVsaWNtYWxTY2FsZTJTY2FsZTogdW5zYWZlIHVpbnQyNTYKCgkvLyAqaWYxX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MjIzCgkvLyB0cnVlCglpbnQgMQoJYnogKmlmMV9lbmQKCgkvLyAqaWYxX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjIyNAoJLy8geGZlciA9IHR4QXNzZXRBRGVwb3NpdCBhcyBBc3NldFRyYW5zZmVyVHhuCglmcmFtZV9kaWcgLTEgLy8gdHhBc3NldEFEZXBvc2l0OiBUeG4KCWR1cAoJZ3R4bnMgVHlwZUVudW0KCWludCBheGZlcgoJPT0KCWFzc2VydAoJZnJhbWVfYnVyeSAzIC8vIHhmZXI6IGF4ZmVyCgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MjI1CgkvLyB2ZXJpZnlBc3NldFRyYW5zZmVyVHhuKHhmZXIsIHsKCS8vICAgICAgICAgYXNzZXRSZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgICAgeGZlckFzc2V0OiBhc3NldEEsCgkvLyAgICAgICAgIGFzc2V0QW1vdW50OiB7IGdyZWF0ZXJUaGFuRXF1YWxUbzogMCB9LAoJLy8gICAgICAgfSkKCS8vIHZlcmlmeSBheGZlcgoJZnJhbWVfZGlnIDMgLy8geGZlcjogYXhmZXIKCWd0eG5zIFR5cGVFbnVtCglpbnQgYXhmZXIKCT09Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYXNzZXRSZWNlaXZlcgoJZnJhbWVfZGlnIDMgLy8geGZlcjogYXhmZXIKCWd0eG5zIEFzc2V0UmVjZWl2ZXIKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IHhmZXJBc3NldAoJZnJhbWVfZGlnIDMgLy8geGZlcjogYXhmZXIKCWd0eG5zIFhmZXJBc3NldAoJZnJhbWVfZGlnIC00IC8vIGFzc2V0QTogQXNzZXRJRAoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSBhc3NldEFtb3VudAoJZnJhbWVfZGlnIDMgLy8geGZlcjogYXhmZXIKCWd0eG5zIEFzc2V0QW1vdW50CglpbnQgMAoJPj0KCWFzc2VydAoKKmlmMV9lbmQ6CgkvLyAqaWYyX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MjQwCgkvLyB0cnVlCglpbnQgMQoJYnogKmlmMl9lbmQKCgkvLyAqaWYyX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjI0MQoJLy8geGZlciA9IHR4QXNzZXRCRGVwb3NpdCBhcyBBc3NldFRyYW5zZmVyVHhuCglmcmFtZV9kaWcgLTIgLy8gdHhBc3NldEJEZXBvc2l0OiBUeG4KCWR1cAoJZ3R4bnMgVHlwZUVudW0KCWludCBheGZlcgoJPT0KCWFzc2VydAoJZnJhbWVfYnVyeSA0IC8vIHhmZXI6IGF4ZmVyCgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MjQyCgkvLyB2ZXJpZnlBc3NldFRyYW5zZmVyVHhuKHhmZXIsIHsKCS8vICAgICAgICAgYXNzZXRSZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgICAgeGZlckFzc2V0OiBhc3NldEIsCgkvLyAgICAgICAgIGFzc2V0QW1vdW50OiB7IGdyZWF0ZXJUaGFuRXF1YWxUbzogMCB9LAoJLy8gICAgICAgfSkKCS8vIHZlcmlmeSBheGZlcgoJZnJhbWVfZGlnIDQgLy8geGZlcjogYXhmZXIKCWd0eG5zIFR5cGVFbnVtCglpbnQgYXhmZXIKCT09Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYXNzZXRSZWNlaXZlcgoJZnJhbWVfZGlnIDQgLy8geGZlcjogYXhmZXIKCWd0eG5zIEFzc2V0UmVjZWl2ZXIKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IHhmZXJBc3NldAoJZnJhbWVfZGlnIDQgLy8geGZlcjogYXhmZXIKCWd0eG5zIFhmZXJBc3NldAoJZnJhbWVfZGlnIC01IC8vIGFzc2V0QjogQXNzZXRJRAoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSBhc3NldEFtb3VudAoJZnJhbWVfZGlnIDQgLy8geGZlcjogYXhmZXIKCWd0eG5zIEFzc2V0QW1vdW50CglpbnQgMAoJPj0KCWFzc2VydAoKKmlmMl9lbmQ6CgkvLyAqaWYzX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MjUxCgkvLyB0aGlzLmFwcC5hZGRyZXNzLmFzc2V0QmFsYW5jZShhc3NldEEpID09PSB0eEFzc2V0QURlcG9zaXQuYXNzZXRBbW91bnQgJiYKCS8vICAgICAgIHRoaXMuYXBwLmFkZHJlc3MuYXNzZXRCYWxhbmNlKGFzc2V0QikgPT09IHR4QXNzZXRCRGVwb3NpdC5hc3NldEFtb3VudAoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWZyYW1lX2RpZyAtNCAvLyBhc3NldEE6IEFzc2V0SUQKCWFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQoJcG9wCglmcmFtZV9kaWcgLTEgLy8gdHhBc3NldEFEZXBvc2l0OiBUeG4KCWd0eG5zIEFzc2V0QW1vdW50Cgk9PQoJZHVwCglieiAqc2tpcF9hbmQwCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJZnJhbWVfZGlnIC01IC8vIGFzc2V0QjogQXNzZXRJRAoJYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCglwb3AKCWZyYW1lX2RpZyAtMiAvLyB0eEFzc2V0QkRlcG9zaXQ6IFR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCT09CgkmJgoKKnNraXBfYW5kMDoKCWJ6ICppZjNfZW5kCgoJLy8gKmlmM19jb25zZXF1ZW50CgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoyNTgKCS8vIHRoaXMuYXNzZXRBQmFsYW5jZS52YWx1ZSA9ICh0eEFzc2V0QURlcG9zaXQuYXNzZXRBbW91bnQgYXMgdWludDI1NikgKiBhc3NldEFEZWxpY21hbFNjYWxlMlNjYWxlCglieXRlIDB4NjE2MiAvLyAiYWIiCglmcmFtZV9kaWcgLTEgLy8gdHhBc3NldEFEZXBvc2l0OiBUeG4KCWd0eG5zIEFzc2V0QW1vdW50CglpdG9iCglmcmFtZV9kaWcgMCAvLyBhc3NldEFEZWxpY21hbFNjYWxlMlNjYWxlOiB1bnNhZmUgdWludDI1NgoJYioKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoyNTkKCS8vIHRoaXMuYXNzZXRCQmFsYW5jZS52YWx1ZSA9ICh0eEFzc2V0QkRlcG9zaXQuYXNzZXRBbW91bnQgYXMgdWludDI1NikgKiBhc3NldEJEZWxpY21hbFNjYWxlMlNjYWxlCglieXRlIDB4NjI2MiAvLyAiYmIiCglmcmFtZV9kaWcgLTIgLy8gdHhBc3NldEJEZXBvc2l0OiBUeG4KCWd0eG5zIEFzc2V0QW1vdW50CglpdG9iCglmcmFtZV9kaWcgMSAvLyBhc3NldEJEZWxpY21hbFNjYWxlMlNjYWxlOiB1bnNhZmUgdWludDI1NgoJYioKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoyNjEKCS8vIHggPSB0aGlzLmFzc2V0QUJhbGFuY2UudmFsdWUKCWJ5dGUgMHg2MTYyIC8vICJhYiIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9idXJ5IDUgLy8geDogdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjI2MgoJLy8geSA9IHRoaXMuYXNzZXRCQmFsYW5jZS52YWx1ZQoJYnl0ZSAweDYyNjIgLy8gImJiIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2J1cnkgNiAvLyB5OiB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MjYzCgkvLyBwcmljZU1pbiA9IHRoaXMucHJpY2VNaW4udmFsdWUgYXMgdWludDI1NgoJYnl0ZSAweDcwNGQ2OTZlIC8vICJwTWluIgoJYXBwX2dsb2JhbF9nZXQKCWl0b2IKCWZyYW1lX2J1cnkgNyAvLyBwcmljZU1pbjogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoyNjQKCS8vIHByaWNlTWF4ID0gdGhpcy5wcmljZU1heC52YWx1ZSBhcyB1aW50MjU2CglieXRlIDB4NzA0ZDYxNzggLy8gInBNYXgiCglhcHBfZ2xvYmFsX2dldAoJaXRvYgoJZnJhbWVfYnVyeSA4IC8vIHByaWNlTWF4OiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjI2NQoJLy8gcHJpY2VNaW5TcXJ0ID0gdGhpcy5wcmljZU1pblNxcnQudmFsdWUKCWJ5dGUgMHg3MDRkNjk2ZTUzIC8vICJwTWluUyIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9idXJ5IDkgLy8gcHJpY2VNaW5TcXJ0OiB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MjY2CgkvLyBwcmljZU1heFNxcnQgPSB0aGlzLnByaWNlTWF4U3FydC52YWx1ZQoJYnl0ZSAweDcwNGQ2MTc4NTMgLy8gInBNYXhTIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2J1cnkgMTAgLy8gcHJpY2VNYXhTcXJ0OiB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MjY3CgkvLyBhc3NlcnQocHJpY2VNaW5TcXJ0ID4gPHVpbnQyNTY+MCkKCWZyYW1lX2RpZyA5IC8vIHByaWNlTWluU3FydDogdWludDI1NgoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKCWI+Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoyNjgKCS8vIHRvTWludCA9IHRoaXMuY2FsY3VsYXRlTGlxdWlkaXR5KHgsIHksIHByaWNlTWluLCBwcmljZU1heCwgcHJpY2VNaW5TcXJ0LCBwcmljZU1heFNxcnQpCglmcmFtZV9kaWcgMTAgLy8gcHJpY2VNYXhTcXJ0OiB1aW50MjU2CglmcmFtZV9kaWcgOSAvLyBwcmljZU1pblNxcnQ6IHVpbnQyNTYKCWZyYW1lX2RpZyA4IC8vIHByaWNlTWF4OiB1bnNhZmUgdWludDI1NgoJZHVwCgliaXRsZW4KCWludCAyNTYKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDMyCgktCglzd2FwCglzdWJzdHJpbmczCglmcmFtZV9kaWcgNyAvLyBwcmljZU1pbjogdW5zYWZlIHVpbnQyNTYKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJZnJhbWVfZGlnIDYgLy8geTogdWludDI1NgoJZnJhbWVfZGlnIDUgLy8geDogdWludDI1NgoJY2FsbHN1YiBjYWxjdWxhdGVMaXF1aWRpdHkKCWZyYW1lX2J1cnkgMTEgLy8gdG9NaW50OiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjI2OQoJLy8gYXNzZXJ0KGZhbHNlKQoJaW50IDAKCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjI3MAoJLy8gdGhpcy5MaXF1ZGl0eS52YWx1ZSA9IHRvTWludAoJYnl0ZSAweDRjIC8vICJMIgoJZnJhbWVfZGlnIDExIC8vIHRvTWludDogdW5zYWZlIHVpbnQyNTYKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoyNzEKCS8vIGxwVG9rZW5zVG9TZW5kID0gKHRvTWludCAvIGFzc2V0TFBEZWxpY21hbFNjYWxlMlNjYWxlKSBhcyB1aW50NjQKCWZyYW1lX2RpZyAxMSAvLyB0b01pbnQ6IHVuc2FmZSB1aW50MjU2CglmcmFtZV9kaWcgMiAvLyBhc3NldExQRGVsaWNtYWxTY2FsZTJTY2FsZTogdW5zYWZlIHVpbnQyNTYKCWIvCglkdXAKCWJpdGxlbgoJaW50IDY0Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCA4CgktCglzd2FwCglzdWJzdHJpbmczCglidG9pCglmcmFtZV9idXJ5IDEyIC8vIGxwVG9rZW5zVG9TZW5kOiB1aW50NjQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoyNzMKCS8vIHRoaXMuZG9BeGZlcih0aGlzLnR4bi5zZW5kZXIsIHRoaXMucG9vbFRva2VuLnZhbHVlLCBscFRva2Vuc1RvU2VuZCkKCWZyYW1lX2RpZyAxMiAvLyBscFRva2Vuc1RvU2VuZDogdWludDY0CglieXRlIDB4NzAgLy8gInAiCglhcHBfZ2xvYmFsX2dldAoJdHhuIFNlbmRlcgoJY2FsbHN1YiBkb0F4ZmVyCgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6Mjc0CgkvLyByZXR1cm4gbHBUb2tlbnNUb1NlbmQ7CglmcmFtZV9kaWcgMTIgLy8gbHBUb2tlbnNUb1NlbmQ6IHVpbnQ2NAoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDEyCglyZXRzdWIKCippZjNfZW5kOgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6Mjc2CgkvLyByZXR1cm4gMDsKCWludCAwCgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMTIKCXJldHN1YgoKLy8gcmVtb3ZlTGlxdWlkaXR5KGF4ZmVyLHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQKKmFiaV9yb3V0ZV9yZW1vdmVMaXF1aWRpdHk6CgkvLyBhc3NldEI6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJYnRvaQoKCS8vIGFzc2V0QTogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gYXNzZXRMUDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gdHhMUFhmZXI6IGF4ZmVyCgl0eG4gR3JvdXBJbmRleAoJaW50IDEKCS0KCWR1cAoJZ3R4bnMgVHlwZUVudW0KCWludCBheGZlcgoJPT0KCWFzc2VydAoKCS8vIGV4ZWN1dGUgcmVtb3ZlTGlxdWlkaXR5KGF4ZmVyLHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQKCWNhbGxzdWIgcmVtb3ZlTGlxdWlkaXR5CglpbnQgMQoJcmV0dXJuCgovLyByZW1vdmVMaXF1aWRpdHkodHhMUFhmZXI6IEFzc2V0VHJhbnNmZXJUeG4sIGFzc2V0TFA6IEFzc2V0SUQsIGFzc2V0QTogQXNzZXRJRCwgYXNzZXRCOiBBc3NldElEKTogdm9pZAovLwovLyBUaGlzIG1ldGhvZCByZXRyaWV2ZXMgZnJvbSB0aGUgbGlxdWlkaXR5IHByb3ZpZGVyIExQIHRva2VuIGFuZCByZXR1cm5zIEFzc2V0IEEgYW5kIEFzc2V0IEIgZnJvbSB0aGUgQXV0b21hdGVkIE1hcmtldCBNYWtlciBDb25jZW50cmF0ZWQgTGlxdWRpZGl0eSBQb29sCi8vIEBwYXJhbSB0eExQWGZlciBUcmFuc2ZlciBvZiB0aGUgTFAgdG9rZW4KLy8gQHBhcmFtIGFzc2V0TFAgTFAgcG9vbCBhc3NldAovLyBAcGFyYW0gYXNzZXRBIEFzc2V0IEEKLy8gQHBhcmFtIGFzc2V0QiBBc3NldCBCCnJlbW92ZUxpcXVpZGl0eToKCXByb3RvIDQgMAoKCS8vIHdlbGwgZm9ybWVkIG1pbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjI4OAoJLy8gYXNzZXJ0KGFzc2V0QSA9PT0gdGhpcy5hc3NldEEudmFsdWUpCglmcmFtZV9kaWcgLTMgLy8gYXNzZXRBOiBBc3NldElECglieXRlIDB4NjEgLy8gImEiCglhcHBfZ2xvYmFsX2dldAoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjI4OQoJLy8gYXNzZXJ0KGFzc2V0QiA9PT0gdGhpcy5hc3NldEIudmFsdWUpCglmcmFtZV9kaWcgLTQgLy8gYXNzZXRCOiBBc3NldElECglieXRlIDB4NjIgLy8gImIiCglhcHBfZ2xvYmFsX2dldAoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjI5MAoJLy8gYXNzZXJ0KGFzc2V0TFAgPT09IHRoaXMucG9vbFRva2VuLnZhbHVlKQoJZnJhbWVfZGlnIC0yIC8vIGFzc2V0TFA6IEFzc2V0SUQKCWJ5dGUgMHg3MCAvLyAicCIKCWFwcF9nbG9iYWxfZ2V0Cgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MjkyCgkvLyB2ZXJpZnlBc3NldFRyYW5zZmVyVHhuKHR4TFBYZmVyLCB7CgkvLyAgICAgICBhc3NldFJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gICAgICAgeGZlckFzc2V0OiBhc3NldExQLAoJLy8gICAgICAgYXNzZXRBbW91bnQ6IHsgZ3JlYXRlclRoYW5FcXVhbFRvOiAwIH0sCgkvLyAgICAgfSkKCS8vIHZlcmlmeSBhc3NldFJlY2VpdmVyCglmcmFtZV9kaWcgLTEgLy8gdHhMUFhmZXI6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIEFzc2V0UmVjZWl2ZXIKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IHhmZXJBc3NldAoJZnJhbWVfZGlnIC0xIC8vIHR4TFBYZmVyOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBYZmVyQXNzZXQKCWZyYW1lX2RpZyAtMiAvLyBhc3NldExQOiBBc3NldElECgk9PQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IGFzc2V0QW1vdW50CglmcmFtZV9kaWcgLTEgLy8gdHhMUFhmZXI6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIEFzc2V0QW1vdW50CglpbnQgMAoJPj0KCWFzc2VydAoJZXJyCgovLyBzd2FwKGF4ZmVyLHVpbnQ2NCx1aW50NjQsdWludDY0KXVpbnQ2NAoqYWJpX3JvdXRlX3N3YXA6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIG1pbmltdW1Ub1JlY2VpdmU6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJYnRvaQoKCS8vIGFzc2V0QjogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gYXNzZXRBOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyB0eFN3YXA6IGF4ZmVyCgl0eG4gR3JvdXBJbmRleAoJaW50IDEKCS0KCWR1cAoJZ3R4bnMgVHlwZUVudW0KCWludCBheGZlcgoJPT0KCWFzc2VydAoKCS8vIGV4ZWN1dGUgc3dhcChheGZlcix1aW50NjQsdWludDY0LHVpbnQ2NCl1aW50NjQKCWNhbGxzdWIgc3dhcAoJaXRvYgoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIHN3YXAodHhTd2FwOiBBc3NldFRyYW5zZmVyVHhuLCBhc3NldEE6IEFzc2V0SUQsIGFzc2V0QjogQXNzZXRJRCwgbWluaW11bVRvUmVjZWl2ZTogdWludDY0KTogdWludDY0Ci8vCi8vIFN3YXAgQXNzZXQgQSB0byBBc3NldCBCIG9yIEFzc2V0IEIgdG8gQXNzdCBBCi8vIEBwYXJhbSB0eFN3YXAgVHJhbnNmZXIgb2YgdGhlIHRva2VuIHRvIGJlIGRlcG9zaXRlZCB0byB0aGUgcG9vbC4gVG8gdGhlIG93bmVyIHRoZSBvdGhlciBhc3NldCB3aWxsIGJlIHNlbnQuCi8vIEBwYXJhbSBhc3NldEEgQXNzZXQgQQovLyBAcGFyYW0gYXNzZXRCIEFzc2V0IEIKLy8gQHBhcmFtIG1pbmltdW1Ub1JlY2VpdmUgSWYgbnVtYmVyIGdyZWF0ZXIgdGhlbiB6ZXJvLCB0aGUgY2hlY2sgaXMgcGVyZm9ybWVkIGZvciB0aGUgb3V0cHV0IG9mIHRoZSBvdGhlciBhc3NldApzd2FwOgoJcHJvdG8gNCAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gNgoKCS8vIHdlbGwgZm9ybWVkIHN3YXAKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjMxMAoJLy8gYXNzZXJ0KGFzc2V0QSA9PT0gdGhpcy5hc3NldEEudmFsdWUpCglmcmFtZV9kaWcgLTIgLy8gYXNzZXRBOiBBc3NldElECglieXRlIDB4NjEgLy8gImEiCglhcHBfZ2xvYmFsX2dldAoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjMxMQoJLy8gYXNzZXJ0KGFzc2V0QiA9PT0gdGhpcy5hc3NldEIudmFsdWUpCglmcmFtZV9kaWcgLTMgLy8gYXNzZXRCOiBBc3NldElECglieXRlIDB4NjIgLy8gImIiCglhcHBfZ2xvYmFsX2dldAoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjMxMwoJLy8gdmVyaWZ5QXNzZXRUcmFuc2ZlclR4bih0eFN3YXAsIHsKCS8vICAgICAgIGFzc2V0QW1vdW50OiB7IGdyZWF0ZXJUaGFuOiAwIH0sCgkvLyAgICAgICBhc3NldFJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gICAgICAgc2VuZGVyOiB0aGlzLnR4bi5zZW5kZXIsCgkvLyAgICAgICB4ZmVyQXNzZXQ6IHsgaW5jbHVkZWRJbjogW2Fzc2V0QSwgYXNzZXRCXSB9LAoJLy8gICAgIH0pCgkvLyB2ZXJpZnkgYXNzZXRBbW91bnQKCWZyYW1lX2RpZyAtMSAvLyB0eFN3YXA6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIEFzc2V0QW1vdW50CglpbnQgMAoJPgoJYXNzZXJ0CgoJLy8gdmVyaWZ5IGFzc2V0UmVjZWl2ZXIKCWZyYW1lX2RpZyAtMSAvLyB0eFN3YXA6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIEFzc2V0UmVjZWl2ZXIKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IHNlbmRlcgoJZnJhbWVfZGlnIC0xIC8vIHR4U3dhcDogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgU2VuZGVyCgl0eG4gU2VuZGVyCgk9PQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IHhmZXJBc3NldAoJZnJhbWVfZGlnIC0xIC8vIHR4U3dhcDogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgWGZlckFzc2V0CglmcmFtZV9kaWcgLTIgLy8gYXNzZXRBOiBBc3NldElECgk9PQoJZnJhbWVfZGlnIC0xIC8vIHR4U3dhcDogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgWGZlckFzc2V0CglmcmFtZV9kaWcgLTMgLy8gYXNzZXRCOiBBc3NldElECgk9PQoJfHwKCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjMyMAoJLy8gYXNzZXRBRGVsaWNtYWxTY2FsZTJTY2FsZSA9ICgxMCAqKiAoU0NBTEVfREVDSU1BTFMgLSBhc3NldEEuZGVjaW1hbHMpKSBhcyB1aW50MjU2CglpbnQgMTAKCWludCA5CglmcmFtZV9kaWcgLTIgLy8gYXNzZXRBOiBBc3NldElECglhc3NldF9wYXJhbXNfZ2V0IEFzc2V0RGVjaW1hbHMKCXBvcAoJLQoJZXhwCglpdG9iCglmcmFtZV9idXJ5IDAgLy8gYXNzZXRBRGVsaWNtYWxTY2FsZTJTY2FsZTogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozMjIKCS8vIGFzc2V0QkRlbGljbWFsU2NhbGUyU2NhbGUgPSAoMTAgKiogKFNDQUxFX0RFQ0lNQUxTIC0gYXNzZXRCLmRlY2ltYWxzKSkgYXMgdWludDI1NgoJaW50IDEwCglpbnQgOQoJZnJhbWVfZGlnIC0zIC8vIGFzc2V0QjogQXNzZXRJRAoJYXNzZXRfcGFyYW1zX2dldCBBc3NldERlY2ltYWxzCglwb3AKCS0KCWV4cAoJaXRvYgoJZnJhbWVfYnVyeSAxIC8vIGFzc2V0QkRlbGljbWFsU2NhbGUyU2NhbGU6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MzIzCgkvLyB0b1N3YXA6IHVpbnQyNTYgPSAwCglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAoJZnJhbWVfYnVyeSAyIC8vIHRvU3dhcDogdWludDI1NgoKCS8vICppZjRfY29uZGl0aW9uCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozMjQKCS8vIHR4U3dhcC54ZmVyQXNzZXQgPT09IGFzc2V0QQoJZnJhbWVfZGlnIC0xIC8vIHR4U3dhcDogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgWGZlckFzc2V0CglmcmFtZV9kaWcgLTIgLy8gYXNzZXRBOiBBc3NldElECgk9PQoJYnogKmlmNF9lbmQKCgkvLyAqaWY0X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjMyNQoJLy8gYXNzZXRJbkFzc2V0RGVjaW1hbHMgPSB0eFN3YXAuYXNzZXRBbW91bnQgYXMgdWludDI1NgoJZnJhbWVfZGlnIC0xIC8vIHR4U3dhcDogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCWl0b2IKCWZyYW1lX2J1cnkgMyAvLyBhc3NldEluQXNzZXREZWNpbWFsczogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozMjYKCS8vIHRvU3dhcCA9IHRoaXMuY2FsY3VsYXRlQXNzZXRCV2l0aGRyYXdPbkFzc2V0QURlcG9zaXQoCgkvLyAgICAgICAgIGFzc2V0SW5Bc3NldERlY2ltYWxzICogYXNzZXRBRGVsaWNtYWxTY2FsZTJTY2FsZSwKCS8vICAgICAgICAgdGhpcy5hc3NldEFCYWxhbmNlLnZhbHVlLAoJLy8gICAgICAgICB0aGlzLmFzc2V0QkJhbGFuY2UudmFsdWUsCgkvLyAgICAgICAgIHRoaXMucHJpY2VNaW5TcXJ0LnZhbHVlLAoJLy8gICAgICAgICB0aGlzLnByaWNlTWF4U3FydC52YWx1ZSwKCS8vICAgICAgICAgdGhpcy5MaXF1ZGl0eS52YWx1ZQoJLy8gICAgICAgKQoJYnl0ZSAweDRjIC8vICJMIgoJYXBwX2dsb2JhbF9nZXQKCWJ5dGUgMHg3MDRkNjE3ODUzIC8vICJwTWF4UyIKCWFwcF9nbG9iYWxfZ2V0CglieXRlIDB4NzA0ZDY5NmU1MyAvLyAicE1pblMiCglhcHBfZ2xvYmFsX2dldAoJYnl0ZSAweDYyNjIgLy8gImJiIgoJYXBwX2dsb2JhbF9nZXQKCWJ5dGUgMHg2MTYyIC8vICJhYiIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9kaWcgMyAvLyBhc3NldEluQXNzZXREZWNpbWFsczogdW5zYWZlIHVpbnQyNTYKCWZyYW1lX2RpZyAwIC8vIGFzc2V0QURlbGljbWFsU2NhbGUyU2NhbGU6IHVuc2FmZSB1aW50MjU2CgliKgoJZHVwCgliaXRsZW4KCWludCAyNTYKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDMyCgktCglzd2FwCglzdWJzdHJpbmczCgljYWxsc3ViIGNhbGN1bGF0ZUFzc2V0QldpdGhkcmF3T25Bc3NldEFEZXBvc2l0CglmcmFtZV9idXJ5IDIgLy8gdG9Td2FwOiB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MzM0CgkvLyB0b1N3YXAgPSB0b1N3YXAgLyBhc3NldEJEZWxpY21hbFNjYWxlMlNjYWxlCglmcmFtZV9kaWcgMiAvLyB0b1N3YXA6IHVpbnQyNTYKCWZyYW1lX2RpZyAxIC8vIGFzc2V0QkRlbGljbWFsU2NhbGUyU2NhbGU6IHVuc2FmZSB1aW50MjU2CgliLwoJZnJhbWVfYnVyeSAyIC8vIHRvU3dhcDogdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjMzNQoJLy8gdG9Td2FwQkRlY2ltYWxzID0gdG9Td2FwIGFzIHVpbnQ2NAoJZnJhbWVfZGlnIDIgLy8gdG9Td2FwOiB1aW50MjU2CglkdXAKCWJpdGxlbgoJaW50IDY0Cgk8PQoJYXNzZXJ0CglleHRyYWN0IDI0IDgKCWJ0b2kKCWZyYW1lX2J1cnkgNCAvLyB0b1N3YXBCRGVjaW1hbHM6IHVpbnQ2NAoKCS8vICppZjVfY29uZGl0aW9uCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozMzYKCS8vIG1pbmltdW1Ub1JlY2VpdmUgPiAwCglmcmFtZV9kaWcgLTQgLy8gbWluaW11bVRvUmVjZWl2ZTogdWludDY0CglpbnQgMAoJPgoJYnogKmlmNV9lbmQKCgkvLyAqaWY1X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjMzOAoJLy8gYXNzZXJ0KG1pbmltdW1Ub1JlY2VpdmUgPj0gdG9Td2FwQkRlY2ltYWxzKQoJZnJhbWVfZGlnIC00IC8vIG1pbmltdW1Ub1JlY2VpdmU6IHVpbnQ2NAoJZnJhbWVfZGlnIDQgLy8gdG9Td2FwQkRlY2ltYWxzOiB1aW50NjQKCT49Cglhc3NlcnQKCippZjVfZW5kOgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MzQxCgkvLyB0aGlzLmRvQXhmZXIodGhpcy50eG4uc2VuZGVyLCBhc3NldEIsIHRvU3dhcEJEZWNpbWFscykKCWZyYW1lX2RpZyA0IC8vIHRvU3dhcEJEZWNpbWFsczogdWludDY0CglmcmFtZV9kaWcgLTMgLy8gYXNzZXRCOiBBc3NldElECgl0eG4gU2VuZGVyCgljYWxsc3ViIGRvQXhmZXIKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozNDMKCS8vIHRoaXMuYXNzZXRBQmFsYW5jZS52YWx1ZSA9CgkvLyAgICAgICAgICh0aGlzLmFwcC5hZGRyZXNzLmFzc2V0QmFsYW5jZSh0aGlzLmFzc2V0QS52YWx1ZSkgYXMgdWludDI1NikgKiBhc3NldEFEZWxpY21hbFNjYWxlMlNjYWxlCglieXRlIDB4NjE2MiAvLyAiYWIiCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJYnl0ZSAweDYxIC8vICJhIgoJYXBwX2dsb2JhbF9nZXQKCWFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQoJcG9wCglpdG9iCglmcmFtZV9kaWcgMCAvLyBhc3NldEFEZWxpY21hbFNjYWxlMlNjYWxlOiB1bnNhZmUgdWludDI1NgoJYioKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozNDUKCS8vIHRoaXMuYXNzZXRCQmFsYW5jZS52YWx1ZSA9CgkvLyAgICAgICAgICh0aGlzLmFwcC5hZGRyZXNzLmFzc2V0QmFsYW5jZSh0aGlzLmFzc2V0Qi52YWx1ZSkgYXMgdWludDI1NikgKiBhc3NldEJEZWxpY21hbFNjYWxlMlNjYWxlCglieXRlIDB4NjI2MiAvLyAiYmIiCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJYnl0ZSAweDYyIC8vICJiIgoJYXBwX2dsb2JhbF9nZXQKCWFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQoJcG9wCglpdG9iCglmcmFtZV9kaWcgMSAvLyBhc3NldEJEZWxpY21hbFNjYWxlMlNjYWxlOiB1bnNhZmUgdWludDI1NgoJYioKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJYXBwX2dsb2JhbF9wdXQKCippZjRfZW5kOgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MzQ5CgkvLyBuZXdQcmljZSA9IHRoaXMuY2FsY3VsYXRlUHJpY2UoCgkvLyAgICAgICB0aGlzLmFzc2V0QUJhbGFuY2UudmFsdWUsIC8vIGFzc2V0QVF1YW50aXR5OiB1aW50MjU2LAoJLy8gICAgICAgdGhpcy5hc3NldEJCYWxhbmNlLnZhbHVlLCAvLyBhc3NldEJRdWFudGl0eTogdWludDI1NiwKCS8vICAgICAgIHRoaXMucHJpY2VNaW5TcXJ0LnZhbHVlLCAvLyBwcmljZU1pblNxcnQ6IHVpbnQyNTYsCgkvLyAgICAgICB0aGlzLnByaWNlTWF4U3FydC52YWx1ZSwgLy8gcHJpY2VNYXhTcXJ0OiB1aW50MjU2LAoJLy8gICAgICAgdGhpcy5MaXF1ZGl0eS52YWx1ZSAvLyBsaXF1aWRpdHk6IHVpbnQyNTYKCS8vICAgICApCglieXRlIDB4NGMgLy8gIkwiCglhcHBfZ2xvYmFsX2dldAoJYnl0ZSAweDcwNGQ2MTc4NTMgLy8gInBNYXhTIgoJYXBwX2dsb2JhbF9nZXQKCWJ5dGUgMHg3MDRkNjk2ZTUzIC8vICJwTWluUyIKCWFwcF9nbG9iYWxfZ2V0CglieXRlIDB4NjI2MiAvLyAiYmIiCglhcHBfZ2xvYmFsX2dldAoJYnl0ZSAweDYxNjIgLy8gImFiIgoJYXBwX2dsb2JhbF9nZXQKCWNhbGxzdWIgY2FsY3VsYXRlUHJpY2UKCWZyYW1lX2J1cnkgNSAvLyBuZXdQcmljZTogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozNTYKCS8vIHRoaXMucmF0aW8udmFsdWUgPSBuZXdQcmljZSBhcyB1aW50NjQKCWJ5dGUgMHg3MiAvLyAiciIKCWZyYW1lX2RpZyA1IC8vIG5ld1ByaWNlOiB1bnNhZmUgdWludDI1NgoJZHVwCgliaXRsZW4KCWludCA2NAoJPD0KCWFzc2VydAoJYnl0ZSAweEZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnQgOAoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJYnRvaQoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozNTkKCS8vIG5ld0wgPSB0aGlzLmNhbGN1bGF0ZUxpcXVpZGl0eSgKCS8vICAgICAgIHRoaXMuYXNzZXRBQmFsYW5jZS52YWx1ZSwKCS8vICAgICAgIHRoaXMuYXNzZXRCQmFsYW5jZS52YWx1ZSwKCS8vICAgICAgIHRoaXMucHJpY2VNaW4udmFsdWUgYXMgdWludDI1NiwgLy8gcHJpY2VNaW46IHVpbnQyNTYsCgkvLyAgICAgICB0aGlzLnByaWNlTWF4LnZhbHVlIGFzIHVpbnQyNTYsIC8vIHByaWNlTWF4OiB1aW50MjU2LAoJLy8gICAgICAgdGhpcy5wcmljZU1pblNxcnQudmFsdWUsIC8vIHByaWNlTWluU3FydDogdWludDI1NiwKCS8vICAgICAgIHRoaXMucHJpY2VNYXhTcXJ0LnZhbHVlIC8vIHByaWNlTWF4U3FydDogdWludDI1NiwKCS8vICAgICApCglieXRlIDB4NzA0ZDYxNzg1MyAvLyAicE1heFMiCglhcHBfZ2xvYmFsX2dldAoJYnl0ZSAweDcwNGQ2OTZlNTMgLy8gInBNaW5TIgoJYXBwX2dsb2JhbF9nZXQKCWJ5dGUgMHg3MDRkNjE3OCAvLyAicE1heCIKCWFwcF9nbG9iYWxfZ2V0CglpdG9iCglkdXAKCWJpdGxlbgoJaW50IDI1NgoJPD0KCWFzc2VydAoJYnl0ZSAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnQgMzIKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWJ5dGUgMHg3MDRkNjk2ZSAvLyAicE1pbiIKCWFwcF9nbG9iYWxfZ2V0CglpdG9iCglkdXAKCWJpdGxlbgoJaW50IDI1NgoJPD0KCWFzc2VydAoJYnl0ZSAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnQgMzIKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWJ5dGUgMHg2MjYyIC8vICJiYiIKCWFwcF9nbG9iYWxfZ2V0CglieXRlIDB4NjE2MiAvLyAiYWIiCglhcHBfZ2xvYmFsX2dldAoJY2FsbHN1YiBjYWxjdWxhdGVMaXF1aWRpdHkKCWZyYW1lX2J1cnkgNiAvLyBuZXdMOiB1bnNhZmUgdWludDI1NgoKCS8vICppZjZfY29uZGl0aW9uCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozNjcKCS8vIG5ld0wgIT09IHRoaXMuTGlxdWRpdHkudmFsdWUKCWZyYW1lX2RpZyA2IC8vIG5ld0w6IHVuc2FmZSB1aW50MjU2CglieXRlIDB4NGMgLy8gIkwiCglhcHBfZ2xvYmFsX2dldAoJYiE9CglieiAqaWY2X2VuZAoKCS8vICppZjZfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MzY4CgkvLyBsb2coJ05ldyBsaXF1aWRpdHkgZG9lcyBub3QgbWF0Y2gnKQoJYnl0ZSAweDRlNjU3NzIwNmM2OTcxNzU2OTY0Njk3NDc5MjA2NDZmNjU3MzIwNmU2Zjc0MjA2ZDYxNzQ2MzY4IC8vICJOZXcgbGlxdWlkaXR5IGRvZXMgbm90IG1hdGNoIgoJbG9nCgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MzY5CgkvLyBhc3NlcnQobmV3TCA9PT0gdGhpcy5MaXF1ZGl0eS52YWx1ZSwgJ05ldyBsaXF1aWRpdHkgZG9lcyBub3QgbWF0Y2gnKQoJZnJhbWVfZGlnIDYgLy8gbmV3TDogdW5zYWZlIHVpbnQyNTYKCWJ5dGUgMHg0YyAvLyAiTCIKCWFwcF9nbG9iYWxfZ2V0CgliPT0KCgkvLyBOZXcgbGlxdWlkaXR5IGRvZXMgbm90IG1hdGNoCglhc3NlcnQKCippZjZfZW5kOgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MzcxCgkvLyByZXR1cm4gdG9Td2FwIGFzIHVpbnQ2NDsKCWZyYW1lX2RpZyAyIC8vIHRvU3dhcDogdWludDI1NgoJZHVwCgliaXRsZW4KCWludCA2NAoJPD0KCWFzc2VydAoJZXh0cmFjdCAyNCA4CglidG9pCgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gNgoJcmV0c3ViCgovLyBjYWxjdWxhdGVMaXF1aWRpdHkodWludDI1Nix1aW50MjU2LHVpbnQyNTYsdWludDI1Nix1aW50MjU2LHVpbnQyNTYpdWludDI1NgoqYWJpX3JvdXRlX2NhbGN1bGF0ZUxpcXVpZGl0eToKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gcHJpY2VNYXhTcXJ0OiB1aW50MjU2Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA2CglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gcHJpY2VNaW5TcXJ0OiB1aW50MjU2Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA1CglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gcHJpY2VNYXg6IHVpbnQyNTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDQKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBwcmljZU1pbjogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIHk6IHVpbnQyNTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyB4OiB1aW50MjU2Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBjYWxjdWxhdGVMaXF1aWRpdHkodWludDI1Nix1aW50MjU2LHVpbnQyNTYsdWludDI1Nix1aW50MjU2LHVpbnQyNTYpdWludDI1NgoJY2FsbHN1YiBjYWxjdWxhdGVMaXF1aWRpdHkKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGNhbGN1bGF0ZUxpcXVpZGl0eSh4OiB1aW50MjU2LCB5OiB1aW50MjU2LCBwcmljZU1pbjogdWludDI1NiwgcHJpY2VNYXg6IHVpbnQyNTYsIHByaWNlTWluU3FydDogdWludDI1NiwgcHJpY2VNYXhTcXJ0OiB1aW50MjU2KTogdWludDI1NgovLwovLyBDYWxjdWxhdGVzIHRoZSBsaXF1aWRpdHkgIGZyb20gdGhlIHggLSBBc3NldCBBIHBvc2l0aW9uIGFuZCB5IC0gQXNzZXQgQiBwb3NpdGlvbgovLwovLyBAcGFyYW0geCBBc3NldCBBIHBvc2l0aW9uIGJhbGFuY2VkIG9uIHRoZSBjdXJ2ZQovLyBAcGFyYW0geSBBc3NldCBCIHBvc2l0aW9uIGJhbGFuY2VkIG9uIHRoZSBjdXJ2ZQovLyBAcGFyYW0gcHJpY2VNaW4gTWluaW11bSBwcmljZSB2YXJpYWJsZSBpbiBiYXNlIHNjYWxlIGRlY2ltYWxzIChwYSkKLy8gQHBhcmFtIHByaWNlTWF4IE1heGltdW0gcHJpY2UgdmFyaWFibGUgaW4gYmFzZSBzY2FsZSBkZWNpbWFscyAocGIpCi8vIEBwYXJhbSBwcmljZU1pblNxcnQgc3FydChwcmljZU1pbikgaW4gYmFzZSBzY2FsZSBkZWNpbWFscyBWYXJpYWJsZSBwYXMKLy8gQHBhcmFtIHByaWNlTWF4U3FydCBzcXJ0KHByaWNlTWF4KSBpbiBiYXNlIHNjYWxlIGRlY2ltYWxzIFZhcmlhYmxlIHBicwovLyBAcmV0dXJucyBMaXF1aWRpdHkgaXMgY29uc3RhbnQgaW4gc3dhcHBpbmcgZWFjaCBkaXJlY3Rpb24uIE9uIGRlcG9zaXQgdGhlIGRpZmYgYmV0d2VlbiB0aGUgbGlxdWlkaXR5IGlzIG51bWJlciBvZiBMUCB0b2tlbnMgcmVjZWl2ZWQgYnkgdXNlci4KY2FsY3VsYXRlTGlxdWlkaXR5OgoJcHJvdG8gNiAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gMTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo0MjEKCS8vIHMgPSBTQ0FMRSBhcyB1aW50MjU2CglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAzYjlhY2EwMAoJZnJhbWVfYnVyeSAwIC8vIHM6IHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo0MjMKCS8vIEQxID0gKCgoeCAqIHgpIC8gcykgKiBwcmljZU1pbikgLyBzCglmcmFtZV9kaWcgLTEgLy8geDogdWludDI1NgoJZnJhbWVfZGlnIC0xIC8vIHg6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMCAvLyBzOiB1aW50MjU2CgliLwoJZnJhbWVfZGlnIC0zIC8vIHByaWNlTWluOiB1aW50MjU2CgliKgoJZnJhbWVfZGlnIDAgLy8gczogdWludDI1NgoJYi8KCWZyYW1lX2J1cnkgMSAvLyBEMTogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo0MjUKCS8vIEQyID0gKHkgKiB5KSAvIHByaWNlTWF4CglmcmFtZV9kaWcgLTIgLy8geTogdWludDI1NgoJZnJhbWVfZGlnIC0yIC8vIHk6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgLTQgLy8gcHJpY2VNYXg6IHVpbnQyNTYKCWIvCglmcmFtZV9idXJ5IDIgLy8gRDI6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NDI3CgkvLyBEMyA9ICgoKDx1aW50MjU2PjIgKiB4ICogeSkgLyBzKSAqIHByaWNlTWluU3FydCkgLyBzIC8gcHJpY2VNYXhTcXJ0CglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMgoJZnJhbWVfZGlnIC0xIC8vIHg6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgLTIgLy8geTogdWludDI1NgoJYioKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIvCglmcmFtZV9kaWcgLTUgLy8gcHJpY2VNaW5TcXJ0OiB1aW50MjU2CgliKgoJZnJhbWVfZGlnIDAgLy8gczogdWludDI1NgoJYi8KCWZyYW1lX2RpZyAtNiAvLyBwcmljZU1heFNxcnQ6IHVpbnQyNTYKCWIvCglmcmFtZV9idXJ5IDMgLy8gRDM6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NDMwCgkvLyBENCA9ICg8dWludDI1Nj40ICogeCAqIHkpIC8gcwoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQKCWZyYW1lX2RpZyAtMSAvLyB4OiB1aW50MjU2CgliKgoJZnJhbWVfZGlnIC0yIC8vIHk6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMCAvLyBzOiB1aW50MjU2CgliLwoJZnJhbWVfYnVyeSA0IC8vIEQ0OiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQzMgoJLy8gRDUgPSAoKCg8dWludDI1Nj40ICogeCAqIHkpIC8gcykgKiBwcmljZU1pblNxcnQpIC8gcyAvIHByaWNlTWF4U3FydAoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQKCWZyYW1lX2RpZyAtMSAvLyB4OiB1aW50MjU2CgliKgoJZnJhbWVfZGlnIC0yIC8vIHk6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMCAvLyBzOiB1aW50MjU2CgliLwoJZnJhbWVfZGlnIC01IC8vIHByaWNlTWluU3FydDogdWludDI1NgoJYioKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIvCglmcmFtZV9kaWcgLTYgLy8gcHJpY2VNYXhTcXJ0OiB1aW50MjU2CgliLwoJZnJhbWVfYnVyeSA1IC8vIEQ1OiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQzMwoJLy8gRCA9IEQxICsgRDIgKyBEMyArIEQ0IC0gRDUKCWZyYW1lX2RpZyAxIC8vIEQxOiB1bnNhZmUgdWludDI1NgoJZnJhbWVfZGlnIDIgLy8gRDI6IHVuc2FmZSB1aW50MjU2CgliKwoJZnJhbWVfZGlnIDMgLy8gRDM6IHVuc2FmZSB1aW50MjU2CgliKwoJZnJhbWVfZGlnIDQgLy8gRDQ6IHVuc2FmZSB1aW50MjU2CgliKwoJZnJhbWVfZGlnIDUgLy8gRDU6IHVuc2FmZSB1aW50MjU2CgliLQoJZnJhbWVfYnVyeSA2IC8vIEQ6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NDM3CgkvLyBMMSA9ICh4ICogcHJpY2VNaW5TcXJ0KSAvIHMKCWZyYW1lX2RpZyAtMSAvLyB4OiB1aW50MjU2CglmcmFtZV9kaWcgLTUgLy8gcHJpY2VNaW5TcXJ0OiB1aW50MjU2CgliKgoJZnJhbWVfZGlnIDAgLy8gczogdWludDI1NgoJYi8KCWZyYW1lX2J1cnkgNyAvLyBMMTogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo0NDAKCS8vIEwyID0gKHkgKiBzKSAvIHByaWNlTWF4U3FydAoJZnJhbWVfZGlnIC0yIC8vIHk6IHVpbnQyNTYKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgLTYgLy8gcHJpY2VNYXhTcXJ0OiB1aW50MjU2CgliLwoJZnJhbWVfYnVyeSA4IC8vIEwyOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQ0MgoJLy8gTDMgPSAoPHVpbnQyNTY+MiAqIHByaWNlTWluU3FydCAqIHMpIC8gcHJpY2VNYXhTcXJ0CglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMgoJZnJhbWVfZGlnIC01IC8vIHByaWNlTWluU3FydDogdWludDI1NgoJYioKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgLTYgLy8gcHJpY2VNYXhTcXJ0OiB1aW50MjU2CgliLwoJZnJhbWVfYnVyeSA5IC8vIEwzOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQ0NQoJLy8gRF9TUVJUID0gc3FydChzICogRCkKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWZyYW1lX2RpZyA2IC8vIEQ6IHVuc2FmZSB1aW50MjU2CgliKgoJYnNxcnQKCWZyYW1lX2J1cnkgMTAgLy8gRF9TUVJUOiB1bnNhZmUgdWludDI1NgoKCS8vICppZjdfY29uZGl0aW9uCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo0NDcKCS8vIDx1aW50MjU2PjIgKiBzID4gTDMKCWJ5dGUgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyCglmcmFtZV9kaWcgMCAvLyBzOiB1aW50MjU2CgliKgoJZnJhbWVfZGlnIDkgLy8gTDM6IHVuc2FmZSB1aW50MjU2CgliPgoJYnogKmlmN19lbmQKCgkvLyAqaWY3X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQ0OAoJLy8gbm9tID0gTDEgKyBMMiArIERfU1FSVAoJZnJhbWVfZGlnIDcgLy8gTDE6IHVuc2FmZSB1aW50MjU2CglmcmFtZV9kaWcgOCAvLyBMMjogdW5zYWZlIHVpbnQyNTYKCWIrCglmcmFtZV9kaWcgMTAgLy8gRF9TUVJUOiB1bnNhZmUgdWludDI1NgoJYisKCWZyYW1lX2J1cnkgMTEgLy8gbm9tOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQ0OQoJLy8gZGVuID0gPHVpbnQyNTY+MiAqIHMgLSBMMwoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgOSAvLyBMMzogdW5zYWZlIHVpbnQyNTYKCWItCglmcmFtZV9idXJ5IDEyIC8vIGRlbjogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo0NTAKCS8vIHJldCA9IChzICogbm9tKSAvIGRlbgoJZnJhbWVfZGlnIDAgLy8gczogdWludDI1NgoJZnJhbWVfZGlnIDExIC8vIG5vbTogdW5zYWZlIHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMTIgLy8gZGVuOiB1bnNhZmUgdWludDI1NgoJYi8KCWZyYW1lX2J1cnkgMTMgLy8gcmV0OiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQ1MQoJLy8gcmV0dXJuIHJldDsKCWZyYW1lX2RpZyAxMyAvLyByZXQ6IHVuc2FmZSB1aW50MjU2CgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMTMKCXJldHN1YgoKKmlmN19lbmQ6CgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo0NTMKCS8vIG5vbSA9IEwxICsgTDIgLSBEX1NRUlQKCWZyYW1lX2RpZyA3IC8vIEwxOiB1bnNhZmUgdWludDI1NgoJZnJhbWVfZGlnIDggLy8gTDI6IHVuc2FmZSB1aW50MjU2CgliKwoJZnJhbWVfZGlnIDEwIC8vIERfU1FSVDogdW5zYWZlIHVpbnQyNTYKCWItCglmcmFtZV9idXJ5IDE0IC8vIG5vbTogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo0NTQKCS8vIGRlbiA9IEwzIC0gPHVpbnQyNTY+MiAqIHMKCWZyYW1lX2RpZyA5IC8vIEwzOiB1bnNhZmUgdWludDI1NgoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIqCgliLQoJZnJhbWVfYnVyeSAxNSAvLyBkZW46IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NDU1CgkvLyByZXQgPSAocyAqIG5vbSkgLyBkZW4KCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWZyYW1lX2RpZyAxNCAvLyBub206IHVuc2FmZSB1aW50MjU2CgliKgoJZnJhbWVfZGlnIDE1IC8vIGRlbjogdW5zYWZlIHVpbnQyNTYKCWIvCglmcmFtZV9idXJ5IDE2IC8vIHJldDogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo0NTYKCS8vIHJldHVybiByZXQ7CglmcmFtZV9kaWcgMTYgLy8gcmV0OiB1bnNhZmUgdWludDI1NgoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDE2CglyZXRzdWIKCi8vIGNhbGN1bGF0ZVByaWNlKHVpbnQyNTYsdWludDI1Nix1aW50MjU2LHVpbnQyNTYsdWludDI1Nil1aW50MjU2CiphYmlfcm91dGVfY2FsY3VsYXRlUHJpY2U6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIGxpcXVpZGl0eTogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIHByaWNlTWF4U3FydDogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIHByaWNlTWluU3FydDogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIGFzc2V0QlF1YW50aXR5OiB1aW50MjU2Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gYXNzZXRBUXVhbnRpdHk6IHVpbnQyNTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBleGVjdXRlIGNhbGN1bGF0ZVByaWNlKHVpbnQyNTYsdWludDI1Nix1aW50MjU2LHVpbnQyNTYsdWludDI1Nil1aW50MjU2CgljYWxsc3ViIGNhbGN1bGF0ZVByaWNlCglkdXAKCWJpdGxlbgoJaW50IDI1NgoJPD0KCWFzc2VydAoJYnl0ZSAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnQgMzIKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBjYWxjdWxhdGVQcmljZShhc3NldEFRdWFudGl0eTogdWludDI1NiwgYXNzZXRCUXVhbnRpdHk6IHVpbnQyNTYsIHByaWNlTWluU3FydDogdWludDI1NiwgcHJpY2VNYXhTcXJ0OiB1aW50MjU2LCBsaXF1aWRpdHk6IHVpbnQyNTYpOiB1aW50MjU2Ci8vCi8vIEdldCB0aGUgY3VycmVudCBwcmljZSB3aGVuIGFzc2V0IGEgaGFzIHgKLy8gQHBhcmFtIGFzc2V0QVF1YW50aXR5IHgKLy8gQHBhcmFtIGFzc2V0QlF1YW50aXR5IHkKLy8gQHBhcmFtIHByaWNlTWluU3FydCBzcXJ0KHByaWNlTWluKQovLyBAcGFyYW0gcHJpY2VNYXhTcXJ0IHNxcnQocHJpY2VNYXgpCi8vIEBwYXJhbSBsaXF1aWRpdHkgQ3VycmVudCBwb29sIGxpcXVpZGl0eSAtIEwgdmFyaWFibGUKLy8gQHJldHVybnMgdGhlIHByaWNlIHdpdGggc3BlY2lmaWVkIHF1YW50aXR5IHdpdGggdGhlIHByaWNlIHJhbmdlIHNldCBpbiB0aGUgY29udHJhY3QKY2FsY3VsYXRlUHJpY2U6Cglwcm90byA1IDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwbiA3CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NDgwCgkvLyBzID0gU0NBTEUgYXMgdWludDI1NgoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwM2I5YWNhMDAKCWZyYW1lX2J1cnkgMCAvLyBzOiB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NDgxCgkvLyBhID0gcHJpY2VNaW5TcXJ0CglmcmFtZV9kaWcgLTMgLy8gcHJpY2VNaW5TcXJ0OiB1aW50MjU2CglmcmFtZV9idXJ5IDEgLy8gYTogdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQ4MgoJLy8gYiA9IHByaWNlTWF4U3FydAoJZnJhbWVfZGlnIC00IC8vIHByaWNlTWF4U3FydDogdWludDI1NgoJZnJhbWVfYnVyeSAyIC8vIGI6IHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo0ODMKCS8vIFAxID0gKGxpcXVpZGl0eSAqIGEpIC8gcwoJZnJhbWVfZGlnIC01IC8vIGxpcXVpZGl0eTogdWludDI1NgoJZnJhbWVfZGlnIDEgLy8gYTogdWludDI1NgoJYioKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIvCglmcmFtZV9idXJ5IDMgLy8gUDE6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NDg0CgkvLyBQMiA9IChsaXF1aWRpdHkgKiBzKSAvIGIKCWZyYW1lX2RpZyAtNSAvLyBsaXF1aWRpdHk6IHVpbnQyNTYKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMiAvLyBiOiB1aW50MjU2CgliLwoJZnJhbWVfYnVyeSA0IC8vIFAyOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQ4NQoJLy8gTm9tID0gYXNzZXRCUXVhbnRpdHkgKyBQMQoJZnJhbWVfZGlnIC0yIC8vIGFzc2V0QlF1YW50aXR5OiB1aW50MjU2CglmcmFtZV9kaWcgMyAvLyBQMTogdW5zYWZlIHVpbnQyNTYKCWIrCglmcmFtZV9idXJ5IDUgLy8gTm9tOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQ4NgoJLy8gRGVub20gPSBhc3NldEFRdWFudGl0eSArIFAyCglmcmFtZV9kaWcgLTEgLy8gYXNzZXRBUXVhbnRpdHk6IHVpbnQyNTYKCWZyYW1lX2RpZyA0IC8vIFAyOiB1bnNhZmUgdWludDI1NgoJYisKCWZyYW1lX2J1cnkgNiAvLyBEZW5vbTogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo0ODcKCS8vIHJldCA9IChOb20gKiBzKSAvIERlbm9tCglmcmFtZV9kaWcgNSAvLyBOb206IHVuc2FmZSB1aW50MjU2CglmcmFtZV9kaWcgMCAvLyBzOiB1aW50MjU2CgliKgoJZnJhbWVfZGlnIDYgLy8gRGVub206IHVuc2FmZSB1aW50MjU2CgliLwoJZnJhbWVfYnVyeSA3IC8vIHJldDogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo0ODgKCS8vIHJldHVybiByZXQ7CglmcmFtZV9kaWcgNyAvLyByZXQ6IHVuc2FmZSB1aW50MjU2CgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gNwoJcmV0c3ViCgovLyBjYWxjdWxhdGVBc3NldEJXaXRoZHJhd09uQXNzZXRBRGVwb3NpdCh1aW50MjU2LHVpbnQyNTYsdWludDI1Nix1aW50MjU2LHVpbnQyNTYsdWludDI1Nil1aW50MjU2CiphYmlfcm91dGVfY2FsY3VsYXRlQXNzZXRCV2l0aGRyYXdPbkFzc2V0QURlcG9zaXQ6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIGxpcXVkaXR5OiB1aW50MjU2Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA2CglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gcHJpY2VNYXhTcXJ0OiB1aW50MjU2Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA1CglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gcHJpY2VNaW5TcXJ0OiB1aW50MjU2Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA0CglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gYXNzZXRCQmFsYW5jZTogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIGFzc2V0QUJhbGFuY2U6IHVpbnQyNTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBpbkFtb3VudDogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIGV4ZWN1dGUgY2FsY3VsYXRlQXNzZXRCV2l0aGRyYXdPbkFzc2V0QURlcG9zaXQodWludDI1Nix1aW50MjU2LHVpbnQyNTYsdWludDI1Nix1aW50MjU2LHVpbnQyNTYpdWludDI1NgoJY2FsbHN1YiBjYWxjdWxhdGVBc3NldEJXaXRoZHJhd09uQXNzZXRBRGVwb3NpdAoJZHVwCgliaXRsZW4KCWludCAyNTYKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDMyCgktCglzd2FwCglzdWJzdHJpbmczCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gY2FsY3VsYXRlQXNzZXRCV2l0aGRyYXdPbkFzc2V0QURlcG9zaXQoaW5BbW91bnQ6IHVpbnQyNTYsIGFzc2V0QUJhbGFuY2U6IHVpbnQyNTYsIGFzc2V0QkJhbGFuY2U6IHVpbnQyNTYsIHByaWNlTWluU3FydDogdWludDI1NiwgcHJpY2VNYXhTcXJ0OiB1aW50MjU2LCBsaXF1ZGl0eTogdWludDI1Nik6IHVpbnQyNTYKLy8KLy8gQ2FsY3VsYXRlcyBob3cgbXVjaCBhc3NldCBCIHdpbGwgYmUgdGFrZW4gZnJvbSB0aGUgc21hcnQgY29udHJhY3Qgb24gYXNzZXQgQSBkZXBvc2l0Ci8vIEBwYXJhbSBpbkFtb3VudCBBc3NldCBBIGFtb3VudCBpbiBCYXNlIGRlY2ltYWwgcmVwcmVzZW50YXRpb24uLiBJZiBhc3NldCBoYXMgNiBkZWNpbWFscywgMSBpcyByZXByZXNlbnRlZCBhcyAxMDAwMDAwMDAwCi8vIEBwYXJhbSBhc3NldEFCYWxhbmNlIEFzc2V0IEEgYmFsYW5jZS4gVmFyaWFibGUgYWIsIGluIGJhc2Ugc2NhbGUKLy8gQHBhcmFtIGFzc2V0QkJhbGFuY2UgQXNzZXQgQiBiYWxhbmNlLiBWYXJpYWJsZSBiYiwgaW4gYmFzZSBzY2FsZQovLyBAcGFyYW0gcHJpY2VNaW5TcXJ0IHNxcnQoTWluIHByaWNlKS4gVmFyaWFibGUgcE1pblMsIGluIGJhc2Ugc2NhbGUKLy8gQHBhcmFtIHByaWNlTWF4U3FydCBzcXJ0KE1heCBwcmljZSkuIFZhcmlhYmxlIHBNYXhTLCBpbiBiYXNlIHNjYWxlCi8vIEBwYXJhbSBsaXF1ZGl0eSBzcXJ0KE1heCBwcmljZSkuIFZhcmlhYmxlIEwsIGluIGJhc2Ugc2NhbGUKLy8gQHJldHVybnMgQW1vdW50IG9mIGFzc2V0IEIgdG8gYmUgZ2l2ZW4gdG8gdGhlIGNhbGxlciBiZWZvcmUgZmVlcy4gVGhlIHJlc3VsdCBpcyBpbiBCYXNlIGRlY2ltYWxzICg5KQpjYWxjdWxhdGVBc3NldEJXaXRoZHJhd09uQXNzZXRBRGVwb3NpdDoKCXByb3RvIDYgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CglkdXBuIDEyCgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NTI2CgkvLyBzID0gU0NBTEUgYXMgdWludDI1NgoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwM2I5YWNhMDAKCWZyYW1lX2J1cnkgMCAvLyBzOiB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NTI3CgkvLyB4ID0gYXNzZXRBQmFsYW5jZQoJZnJhbWVfZGlnIC0yIC8vIGFzc2V0QUJhbGFuY2U6IHVpbnQyNTYKCWZyYW1lX2J1cnkgMSAvLyB4OiB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NTI4CgkvLyB5ID0gYXNzZXRCQmFsYW5jZQoJZnJhbWVfZGlnIC0zIC8vIGFzc2V0QkJhbGFuY2U6IHVpbnQyNTYKCWZyYW1lX2J1cnkgMiAvLyB5OiB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NTI5CgkvLyBhID0gcHJpY2VNaW5TcXJ0CglmcmFtZV9kaWcgLTQgLy8gcHJpY2VNaW5TcXJ0OiB1aW50MjU2CglmcmFtZV9idXJ5IDMgLy8gYTogdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjUzMAoJLy8gYiA9IHByaWNlTWF4U3FydAoJZnJhbWVfZGlnIC01IC8vIHByaWNlTWF4U3FydDogdWludDI1NgoJZnJhbWVfYnVyeSA0IC8vIGI6IHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo1MzEKCS8vIEwgPSBsaXF1ZGl0eQoJZnJhbWVfZGlnIC02IC8vIGxpcXVkaXR5OiB1aW50MjU2CglmcmFtZV9idXJ5IDUgLy8gTDogdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjUzMwoJLy8gUDEgPSAoKCgoKGEgLyogMTBEICovICogYikgLyogMTBEICovIC8gcykgKiBpbkFtb3VudCkgLyogQUQgKi8gLyBzKSAqIEwpIC8qIDEwRCAqLyAvIHMKCWZyYW1lX2RpZyAzIC8vIGE6IHVpbnQyNTYKCWZyYW1lX2RpZyA0IC8vIGI6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMCAvLyBzOiB1aW50MjU2CgliLwoJZnJhbWVfZGlnIC0xIC8vIGluQW1vdW50OiB1aW50MjU2CgliKgoJZnJhbWVfZGlnIDAgLy8gczogdWludDI1NgoJYi8KCWZyYW1lX2RpZyA1IC8vIEw6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMCAvLyBzOiB1aW50MjU2CgliLwoJZnJhbWVfYnVyeSA2IC8vIFAxOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjUzNQoJLy8gUDIgPSAoKChiIC8qIDEwRCAqLyAqIGluQW1vdW50KSAvKiBBRCAqLyAvIHMpICogeSkgLyogQkQgKi8gLyBzCglmcmFtZV9kaWcgNCAvLyBiOiB1aW50MjU2CglmcmFtZV9kaWcgLTEgLy8gaW5BbW91bnQ6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMCAvLyBzOiB1aW50MjU2CgliLwoJZnJhbWVfZGlnIDIgLy8geTogdWludDI1NgoJYioKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIvCglmcmFtZV9idXJ5IDcgLy8gUDI6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NTM3CgkvLyBQMyA9IChiIC8qIDEwRCAqLyAqIGluQW1vdW50KSAvKiBBRCAqLyAvIHMKCWZyYW1lX2RpZyA0IC8vIGI6IHVpbnQyNTYKCWZyYW1lX2RpZyAtMSAvLyBpbkFtb3VudDogdWludDI1NgoJYioKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIvCglmcmFtZV9idXJ5IDggLy8gUDM6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NTM5CgkvLyBQNCA9IChiIC8qIDEwRCAqLyAqIHgpIC8qIDEwRCAqLyAvIHMKCWZyYW1lX2RpZyA0IC8vIGI6IHVpbnQyNTYKCWZyYW1lX2RpZyAxIC8vIHg6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMCAvLyBzOiB1aW50MjU2CgliLwoJZnJhbWVfYnVyeSA5IC8vIFA0OiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjU0MQoJLy8gUDEyID0gUDEgKyBQMgoJZnJhbWVfZGlnIDYgLy8gUDE6IHVuc2FmZSB1aW50MjU2CglmcmFtZV9kaWcgNyAvLyBQMjogdW5zYWZlIHVpbnQyNTYKCWIrCglmcmFtZV9idXJ5IDEwIC8vIFAxMjogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo1NDMKCS8vIFAzNDUgPSBQMyArIFA0ICsgTAoJZnJhbWVfZGlnIDggLy8gUDM6IHVuc2FmZSB1aW50MjU2CglmcmFtZV9kaWcgOSAvLyBQNDogdW5zYWZlIHVpbnQyNTYKCWIrCglmcmFtZV9kaWcgNSAvLyBMOiB1aW50MjU2CgliKwoJZnJhbWVfYnVyeSAxMSAvLyBQMzQ1OiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjU0NQoJLy8gcmV0ID0gKFAxMiAqIHMpIC8gUDM0NQoJZnJhbWVfZGlnIDEwIC8vIFAxMjogdW5zYWZlIHVpbnQyNTYKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMTEgLy8gUDM0NTogdW5zYWZlIHVpbnQyNTYKCWIvCglmcmFtZV9idXJ5IDEyIC8vIHJldDogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo1NDYKCS8vIHJldHVybiByZXQ7CglmcmFtZV9kaWcgMTIgLy8gcmV0OiB1bnNhZmUgdWludDI1NgoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDEyCglyZXRzdWIKCi8vIGNhbGN1bGF0ZUFzc2V0QVdpdGhkcmF3T25Bc3NldEJEZXBvc2l0KHVpbnQyNTYsdWludDI1Nix1aW50MjU2LHVpbnQyNTYsdWludDI1Nix1aW50MjU2KXVpbnQyNTYKKmFiaV9yb3V0ZV9jYWxjdWxhdGVBc3NldEFXaXRoZHJhd09uQXNzZXRCRGVwb3NpdDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gbGlxdWRpdHk6IHVpbnQyNTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDYKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBwcmljZU1heFNxcnQ6IHVpbnQyNTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDUKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBwcmljZU1pblNxcnQ6IHVpbnQyNTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDQKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBhc3NldEJCYWxhbmNlOiB1aW50MjU2Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gYXNzZXRBQmFsYW5jZTogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIGluQW1vdW50OiB1aW50MjU2Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBjYWxjdWxhdGVBc3NldEFXaXRoZHJhd09uQXNzZXRCRGVwb3NpdCh1aW50MjU2LHVpbnQyNTYsdWludDI1Nix1aW50MjU2LHVpbnQyNTYsdWludDI1Nil1aW50MjU2CgljYWxsc3ViIGNhbGN1bGF0ZUFzc2V0QVdpdGhkcmF3T25Bc3NldEJEZXBvc2l0CglkdXAKCWJpdGxlbgoJaW50IDI1NgoJPD0KCWFzc2VydAoJYnl0ZSAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnQgMzIKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBjYWxjdWxhdGVBc3NldEFXaXRoZHJhd09uQXNzZXRCRGVwb3NpdChpbkFtb3VudDogdWludDI1NiwgYXNzZXRBQmFsYW5jZTogdWludDI1NiwgYXNzZXRCQmFsYW5jZTogdWludDI1NiwgcHJpY2VNaW5TcXJ0OiB1aW50MjU2LCBwcmljZU1heFNxcnQ6IHVpbnQyNTYsIGxpcXVkaXR5OiB1aW50MjU2KTogdWludDI1NgovLwovLyBDYWxjdWxhdGVzIGhvdyBtdWNoIGFzc2V0IEEgd2lsbCBiZSB0YWtlbiBmcm9tIHRoZSBzbWFydCBjb250cmFjdCBvbiBhc3NldCBCIGRlcG9zaXQKLy8gQHBhcmFtIGluQW1vdW50IEFzc2V0IEIgYW1vdW50IGluIEJhc2UgZGVjaW1hbCByZXByZXNlbnRhdGlvbi4uIElmIGFzc2V0IGhhcyA2IGRlY2ltYWxzLCAxIGlzIHJlcHJlc2VudGVkIGFzIDEwMDAwMDAwMDAKLy8gQHBhcmFtIGFzc2V0QUJhbGFuY2UgQXNzZXQgQSBiYWxhbmNlLiBWYXJpYWJsZSBhYiwgaW4gYmFzZSBzY2FsZQovLyBAcGFyYW0gYXNzZXRCQmFsYW5jZSBBc3NldCBCIGJhbGFuY2UuIFZhcmlhYmxlIGJiLCBpbiBiYXNlIHNjYWxlCi8vIEBwYXJhbSBwcmljZU1pblNxcnQgc3FydChNaW4gcHJpY2UpLiBWYXJpYWJsZSBwTWluUywgaW4gYmFzZSBzY2FsZQovLyBAcGFyYW0gcHJpY2VNYXhTcXJ0IHNxcnQoTWF4IHByaWNlKS4gVmFyaWFibGUgcE1heFMsIGluIGJhc2Ugc2NhbGUKLy8gQHBhcmFtIGxpcXVkaXR5IHNxcnQoTWF4IHByaWNlKS4gVmFyaWFibGUgTCwgaW4gYmFzZSBzY2FsZQovLwovLyBAcmV0dXJucyBBbW91bnQgb2YgYXNzZXQgQSB0byBiZSBnaXZlbiB0byB0aGUgY2FsbGVyIGJlZm9yZSBmZWVzLiBUaGUgcmVzdWx0IGlzIGluIEJhc2UgZGVjaW1hbHMgKDkpCmNhbGN1bGF0ZUFzc2V0QVdpdGhkcmF3T25Bc3NldEJEZXBvc2l0OgoJcHJvdG8gNiAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gMTMKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo1ODEKCS8vIHMgPSBTQ0FMRSBhcyB1aW50MjU2CglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAzYjlhY2EwMAoJZnJhbWVfYnVyeSAwIC8vIHM6IHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo1ODIKCS8vIHggPSBhc3NldEFCYWxhbmNlCglmcmFtZV9kaWcgLTIgLy8gYXNzZXRBQmFsYW5jZTogdWludDI1NgoJZnJhbWVfYnVyeSAxIC8vIHg6IHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo1ODMKCS8vIHkgPSBhc3NldEJCYWxhbmNlCglmcmFtZV9kaWcgLTMgLy8gYXNzZXRCQmFsYW5jZTogdWludDI1NgoJZnJhbWVfYnVyeSAyIC8vIHk6IHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo1ODQKCS8vIGEgPSBwcmljZU1pblNxcnQKCWZyYW1lX2RpZyAtNCAvLyBwcmljZU1pblNxcnQ6IHVpbnQyNTYKCWZyYW1lX2J1cnkgMyAvLyBhOiB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NTg1CgkvLyBiID0gcHJpY2VNYXhTcXJ0CglmcmFtZV9kaWcgLTUgLy8gcHJpY2VNYXhTcXJ0OiB1aW50MjU2CglmcmFtZV9idXJ5IDQgLy8gYjogdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjU4NgoJLy8gTCA9IGxpcXVkaXR5CglmcmFtZV9kaWcgLTYgLy8gbGlxdWRpdHk6IHVpbnQyNTYKCWZyYW1lX2J1cnkgNSAvLyBMOiB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NTg5CgkvLyBQMSA9IChpbkFtb3VudCAqIEwpIC8gcwoJZnJhbWVfZGlnIC0xIC8vIGluQW1vdW50OiB1aW50MjU2CglmcmFtZV9kaWcgNSAvLyBMOiB1aW50MjU2CgliKgoJZnJhbWVfZGlnIDAgLy8gczogdWludDI1NgoJYi8KCWZyYW1lX2J1cnkgNiAvLyBQMTogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo1OTEKCS8vIFAyID0gKCgoYiAqIGluQW1vdW50KSAvIHMpICogeCkgLyBzCglmcmFtZV9kaWcgNCAvLyBiOiB1aW50MjU2CglmcmFtZV9kaWcgLTEgLy8gaW5BbW91bnQ6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMCAvLyBzOiB1aW50MjU2CgliLwoJZnJhbWVfZGlnIDEgLy8geDogdWludDI1NgoJYioKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIvCglmcmFtZV9idXJ5IDcgLy8gUDI6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NTkzCgkvLyBub20gPSBQMSArIFAyCglmcmFtZV9kaWcgNiAvLyBQMTogdW5zYWZlIHVpbnQyNTYKCWZyYW1lX2RpZyA3IC8vIFAyOiB1bnNhZmUgdWludDI1NgoJYisKCWZyYW1lX2J1cnkgOCAvLyBub206IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NTk1CgkvLyBQMyA9ICgoKGEgKiBiKSAvIHMpICogTCkgLyBzCglmcmFtZV9kaWcgMyAvLyBhOiB1aW50MjU2CglmcmFtZV9kaWcgNCAvLyBiOiB1aW50MjU2CgliKgoJZnJhbWVfZGlnIDAgLy8gczogdWludDI1NgoJYi8KCWZyYW1lX2RpZyA1IC8vIEw6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMCAvLyBzOiB1aW50MjU2CgliLwoJZnJhbWVfYnVyeSA5IC8vIFAzOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjU5NwoJLy8gUDQgPSAoYiAqIGluQW1vdW50KSAvIHMKCWZyYW1lX2RpZyA0IC8vIGI6IHVpbnQyNTYKCWZyYW1lX2RpZyAtMSAvLyBpbkFtb3VudDogdWludDI1NgoJYioKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIvCglmcmFtZV9idXJ5IDEwIC8vIFA0OiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjU5OQoJLy8gUDUgPSAoYiAqIHkpIC8gcwoJZnJhbWVfZGlnIDQgLy8gYjogdWludDI1NgoJZnJhbWVfZGlnIDIgLy8geTogdWludDI1NgoJYioKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIvCglmcmFtZV9idXJ5IDExIC8vIFA1OiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjYwMQoJLy8gZGVub20gPSBQMyArIFA0ICsgUDUKCWZyYW1lX2RpZyA5IC8vIFAzOiB1bnNhZmUgdWludDI1NgoJZnJhbWVfZGlnIDEwIC8vIFA0OiB1bnNhZmUgdWludDI1NgoJYisKCWZyYW1lX2RpZyAxMSAvLyBQNTogdW5zYWZlIHVpbnQyNTYKCWIrCglmcmFtZV9idXJ5IDEyIC8vIGRlbm9tOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjYwMwoJLy8gcmV0ID0gKG5vbSAqIHMpIC8gZGVub20KCWZyYW1lX2RpZyA4IC8vIG5vbTogdW5zYWZlIHVpbnQyNTYKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMTIgLy8gZGVub206IHVuc2FmZSB1aW50MjU2CgliLwoJZnJhbWVfYnVyeSAxMyAvLyByZXQ6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NjA0CgkvLyByZXR1cm4gcmV0OwoJZnJhbWVfZGlnIDEzIC8vIHJldDogdW5zYWZlIHVpbnQyNTYKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiAxMwoJcmV0c3ViCgoqY3JlYXRlX05vT3A6CgltZXRob2QgImNyZWF0ZUFwcGxpY2F0aW9uKCl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbgoJZXJyCgoqY2FsbF9Ob09wOgoJbWV0aG9kICJnZXRDdXJyZW50UHJpY2UoKXVpbnQ2NCIKCW1ldGhvZCAiZ2V0UHJpY2VEaXZpZGVyKCl1aW50NjQiCgltZXRob2QgImdldExQVG9rZW5JZCgpdWludDY0IgoJbWV0aG9kICJib290c3RyYXAocGF5LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQpdWludDY0IgoJbWV0aG9kICJhZGRMaXF1aWRpdHkodHhuLHR4bix1aW50NjQsdWludDY0LHVpbnQ2NCl1aW50NjQiCgltZXRob2QgInJlbW92ZUxpcXVpZGl0eShheGZlcix1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkIgoJbWV0aG9kICJzd2FwKGF4ZmVyLHVpbnQ2NCx1aW50NjQsdWludDY0KXVpbnQ2NCIKCW1ldGhvZCAiY2FsY3VsYXRlTGlxdWlkaXR5KHVpbnQyNTYsdWludDI1Nix1aW50MjU2LHVpbnQyNTYsdWludDI1Nix1aW50MjU2KXVpbnQyNTYiCgltZXRob2QgImNhbGN1bGF0ZVByaWNlKHVpbnQyNTYsdWludDI1Nix1aW50MjU2LHVpbnQyNTYsdWludDI1Nil1aW50MjU2IgoJbWV0aG9kICJjYWxjdWxhdGVBc3NldEJXaXRoZHJhd09uQXNzZXRBRGVwb3NpdCh1aW50MjU2LHVpbnQyNTYsdWludDI1Nix1aW50MjU2LHVpbnQyNTYsdWludDI1Nil1aW50MjU2IgoJbWV0aG9kICJjYWxjdWxhdGVBc3NldEFXaXRoZHJhd09uQXNzZXRCRGVwb3NpdCh1aW50MjU2LHVpbnQyNTYsdWludDI1Nix1aW50MjU2LHVpbnQyNTYsdWludDI1Nil1aW50MjU2IgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV9nZXRDdXJyZW50UHJpY2UgKmFiaV9yb3V0ZV9nZXRQcmljZURpdmlkZXIgKmFiaV9yb3V0ZV9nZXRMUFRva2VuSWQgKmFiaV9yb3V0ZV9ib290c3RyYXAgKmFiaV9yb3V0ZV9hZGRMaXF1aWRpdHkgKmFiaV9yb3V0ZV9yZW1vdmVMaXF1aWRpdHkgKmFiaV9yb3V0ZV9zd2FwICphYmlfcm91dGVfY2FsY3VsYXRlTGlxdWlkaXR5ICphYmlfcm91dGVfY2FsY3VsYXRlUHJpY2UgKmFiaV9yb3V0ZV9jYWxjdWxhdGVBc3NldEJXaXRoZHJhd09uQXNzZXRBRGVwb3NpdCAqYWJpX3JvdXRlX2NhbGN1bGF0ZUFzc2V0QVdpdGhkcmF3T25Bc3NldEJEZXBvc2l0CgllcnI=",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEw"
  },
  "contract": {
    "name": "BiatecCLAMM",
    "desc": "",
    "methods": [
      {
        "name": "createApplication",
        "desc": "Initial setup",
        "args": [],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "getCurrentPrice",
        "readonly": true,
        "args": [],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "getPriceDivider",
        "readonly": true,
        "args": [],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "getLPTokenId",
        "readonly": true,
        "args": [],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "bootstrap",
        "desc": "Anybody can deploy the clamm smart contract",
        "args": [
          {
            "name": "txSeed",
            "type": "pay",
            "desc": "Seed transaction so that smart contract can opt in to the assets"
          },
          {
            "name": "assetA",
            "type": "uint64",
            "desc": "Asset A ID must be lower then Asset B ID"
          },
          {
            "name": "assetB",
            "type": "uint64",
            "desc": "Asset B"
          },
          {
            "name": "feeB100000",
            "type": "uint64",
            "desc": "Fee in 100000 base level. value 10000 = 10000/100000 = 0,1 = 10% fee. 1000 = 1%. 100 = 0,1%. 10 = 0,01% = 1 base point"
          },
          {
            "name": "priceMin",
            "type": "uint64"
          },
          {
            "name": "priceMax",
            "type": "uint64"
          },
          {
            "name": "currentPrice",
            "type": "uint64"
          },
          {
            "name": "verificationClass",
            "type": "uint8",
            "desc": "Asset B"
          },
          {
            "name": "identityProvider",
            "type": "uint64"
          },
          {
            "name": "poolProvider",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "uint64",
          "desc": "LP token ID"
        }
      },
      {
        "name": "addLiquidity",
        "desc": "This method adds Asset A and Asset B to the Automated Market Maker Concentrated Liqudidity Pool and send to the liqudidty provider the liqudity token",
        "args": [
          {
            "name": "txAssetADeposit",
            "type": "txn",
            "desc": "Transfer of asset A to the LP pool"
          },
          {
            "name": "txAssetBDeposit",
            "type": "txn",
            "desc": "Transfer of asset B to the LP pool"
          },
          {
            "name": "assetLP",
            "type": "uint64",
            "desc": "Liquidity pool asset"
          },
          {
            "name": "assetA",
            "type": "uint64",
            "desc": "Asset A"
          },
          {
            "name": "assetB",
            "type": "uint64",
            "desc": "Asset B"
          }
        ],
        "returns": {
          "type": "uint64",
          "desc": "LP Token quantity distributed"
        }
      },
      {
        "name": "removeLiquidity",
        "desc": "This method retrieves from the liquidity provider LP token and returns Asset A and Asset B from the Automated Market Maker Concentrated Liqudidity Pool",
        "args": [
          {
            "name": "txLPXfer",
            "type": "axfer",
            "desc": "Transfer of the LP token"
          },
          {
            "name": "assetLP",
            "type": "uint64",
            "desc": "LP pool asset"
          },
          {
            "name": "assetA",
            "type": "uint64",
            "desc": "Asset A"
          },
          {
            "name": "assetB",
            "type": "uint64",
            "desc": "Asset B"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "swap",
        "desc": "Swap Asset A to Asset B or Asset B to Asst A",
        "args": [
          {
            "name": "txSwap",
            "type": "axfer",
            "desc": "Transfer of the token to be deposited to the pool. To the owner the other asset will be sent."
          },
          {
            "name": "assetA",
            "type": "uint64",
            "desc": "Asset A"
          },
          {
            "name": "assetB",
            "type": "uint64",
            "desc": "Asset B"
          },
          {
            "name": "minimumToReceive",
            "type": "uint64",
            "desc": "If number greater then zero, the check is performed for the output of the other asset"
          }
        ],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "calculateLiquidity",
        "desc": "Calculates the liquidity  from the x - Asset A position and y - Asset B position",
        "readonly": true,
        "args": [
          {
            "name": "x",
            "type": "uint256",
            "desc": "Asset A position balanced on the curve"
          },
          {
            "name": "y",
            "type": "uint256",
            "desc": "Asset B position balanced on the curve"
          },
          {
            "name": "priceMin",
            "type": "uint256",
            "desc": "Minimum price variable in base scale decimals (pa)"
          },
          {
            "name": "priceMax",
            "type": "uint256",
            "desc": "Maximum price variable in base scale decimals (pb)"
          },
          {
            "name": "priceMinSqrt",
            "type": "uint256",
            "desc": "sqrt(priceMin) in base scale decimals Variable pas"
          },
          {
            "name": "priceMaxSqrt",
            "type": "uint256",
            "desc": "sqrt(priceMax) in base scale decimals Variable pbs"
          }
        ],
        "returns": {
          "type": "uint256",
          "desc": "Liquidity is constant in swapping each direction. On deposit the diff between the liquidity is number of LP tokens received by user."
        }
      },
      {
        "name": "calculatePrice",
        "desc": "Get the current price when asset a has x",
        "readonly": true,
        "args": [
          {
            "name": "assetAQuantity",
            "type": "uint256",
            "desc": "x"
          },
          {
            "name": "assetBQuantity",
            "type": "uint256",
            "desc": "y"
          },
          {
            "name": "priceMinSqrt",
            "type": "uint256",
            "desc": "sqrt(priceMin)"
          },
          {
            "name": "priceMaxSqrt",
            "type": "uint256",
            "desc": "sqrt(priceMax)"
          },
          {
            "name": "liquidity",
            "type": "uint256",
            "desc": "Current pool liquidity - L variable"
          }
        ],
        "returns": {
          "type": "uint256",
          "desc": "the price with specified quantity with the price range set in the contract"
        }
      },
      {
        "name": "calculateAssetBWithdrawOnAssetADeposit",
        "desc": "Calculates how much asset B will be taken from the smart contract on asset A deposit",
        "readonly": true,
        "args": [
          {
            "name": "inAmount",
            "type": "uint256",
            "desc": "Asset A amount in Base decimal representation.. If asset has 6 decimals, 1 is represented as 1000000000"
          },
          {
            "name": "assetABalance",
            "type": "uint256",
            "desc": "Asset A balance. Variable ab, in base scale"
          },
          {
            "name": "assetBBalance",
            "type": "uint256",
            "desc": "Asset B balance. Variable bb, in base scale"
          },
          {
            "name": "priceMinSqrt",
            "type": "uint256",
            "desc": "sqrt(Min price). Variable pMinS, in base scale"
          },
          {
            "name": "priceMaxSqrt",
            "type": "uint256",
            "desc": "sqrt(Max price). Variable pMaxS, in base scale"
          },
          {
            "name": "liqudity",
            "type": "uint256",
            "desc": "sqrt(Max price). Variable L, in base scale"
          }
        ],
        "returns": {
          "type": "uint256",
          "desc": "Amount of asset B to be given to the caller before fees. The result is in Base decimals (9)"
        }
      },
      {
        "name": "calculateAssetAWithdrawOnAssetBDeposit",
        "desc": "Calculates how much asset A will be taken from the smart contract on asset B deposit",
        "readonly": true,
        "args": [
          {
            "name": "inAmount",
            "type": "uint256",
            "desc": "Asset B amount in Base decimal representation.. If asset has 6 decimals, 1 is represented as 1000000000"
          },
          {
            "name": "assetABalance",
            "type": "uint256",
            "desc": "Asset A balance. Variable ab, in base scale"
          },
          {
            "name": "assetBBalance",
            "type": "uint256",
            "desc": "Asset B balance. Variable bb, in base scale"
          },
          {
            "name": "priceMinSqrt",
            "type": "uint256",
            "desc": "sqrt(Min price). Variable pMinS, in base scale"
          },
          {
            "name": "priceMaxSqrt",
            "type": "uint256",
            "desc": "sqrt(Max price). Variable pMaxS, in base scale"
          },
          {
            "name": "liqudity",
            "type": "uint256",
            "desc": "sqrt(Max price). Variable L, in base scale"
          }
        ],
        "returns": {
          "type": "uint256",
          "desc": "Amount of asset A to be given to the caller before fees. The result is in Base decimals (9)"
        }
      }
    ]
  }
}

/**
 * Defines an onCompletionAction of 'no_op'
 */
export type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }
/**
 * Defines an onCompletionAction of 'opt_in'
 */
export type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }
/**
 * Defines an onCompletionAction of 'close_out'
 */
export type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }
/**
 * Defines an onCompletionAction of 'delete_application'
 */
export type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }
/**
 * Defines an onCompletionAction of 'update_application'
 */
export type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }
/**
 * A state record containing a single unsigned integer
 */
export type IntegerState = {
  /**
   * Gets the state value as a BigInt 
   */
  asBigInt(): bigint
  /**
   * Gets the state value as a number.
   */
  asNumber(): number
}
/**
 * A state record containing binary data
 */
export type BinaryState = {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array
  /**
   * Gets the state value as a string
   */
  asString(): string
}

export type AppCreateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult> & AppReference
export type AppUpdateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult>

/**
 * Defines the types of available calls and state of the BiatecClamm smart contract.
 */
export type BiatecClamm = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'createApplication()void' | 'createApplication', {
      argsObj: {
      }
      argsTuple: []
      returns: void
    }>
    & Record<'getCurrentPrice()uint64' | 'getCurrentPrice', {
      argsObj: {
      }
      argsTuple: []
      returns: bigint
    }>
    & Record<'getPriceDivider()uint64' | 'getPriceDivider', {
      argsObj: {
      }
      argsTuple: []
      returns: bigint
    }>
    & Record<'getLPTokenId()uint64' | 'getLPTokenId', {
      argsObj: {
      }
      argsTuple: []
      returns: bigint
    }>
    & Record<'bootstrap(pay,uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint64,uint64)uint64' | 'bootstrap', {
      argsObj: {
        /**
         * Seed transaction so that smart contract can opt in to the assets
         */
        txSeed: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * Asset A ID must be lower then Asset B ID
         */
        assetA: bigint | number
        /**
         * Asset B
         */
        assetB: bigint | number
        /**
         * Fee in 100000 base level. value 10000 = 10000/100000 = 0,1 = 10% fee. 1000 = 1%. 100 = 0,1%. 10 = 0,01% = 1 base point
         */
        feeB100000: bigint | number
        priceMin: bigint | number
        priceMax: bigint | number
        currentPrice: bigint | number
        /**
         * Asset B
         */
        verificationClass: number
        identityProvider: bigint | number
        poolProvider: bigint | number
      }
      argsTuple: [txSeed: TransactionToSign | Transaction | Promise<SendTransactionResult>, assetA: bigint | number, assetB: bigint | number, feeB100000: bigint | number, priceMin: bigint | number, priceMax: bigint | number, currentPrice: bigint | number, verificationClass: number, identityProvider: bigint | number, poolProvider: bigint | number]
      /**
       * LP token ID
       */
      returns: bigint
    }>
    & Record<'addLiquidity(txn,txn,uint64,uint64,uint64)uint64' | 'addLiquidity', {
      argsObj: {
        /**
         * Transfer of asset A to the LP pool
         */
        txAssetADeposit: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * Transfer of asset B to the LP pool
         */
        txAssetBDeposit: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * Liquidity pool asset
         */
        assetLP: bigint | number
        /**
         * Asset A
         */
        assetA: bigint | number
        /**
         * Asset B
         */
        assetB: bigint | number
      }
      argsTuple: [txAssetADeposit: TransactionToSign | Transaction | Promise<SendTransactionResult>, txAssetBDeposit: TransactionToSign | Transaction | Promise<SendTransactionResult>, assetLP: bigint | number, assetA: bigint | number, assetB: bigint | number]
      /**
       * LP Token quantity distributed
       */
      returns: bigint
    }>
    & Record<'removeLiquidity(axfer,uint64,uint64,uint64)void' | 'removeLiquidity', {
      argsObj: {
        /**
         * Transfer of the LP token
         */
        txLPXfer: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * LP pool asset
         */
        assetLP: bigint | number
        /**
         * Asset A
         */
        assetA: bigint | number
        /**
         * Asset B
         */
        assetB: bigint | number
      }
      argsTuple: [txLPXfer: TransactionToSign | Transaction | Promise<SendTransactionResult>, assetLP: bigint | number, assetA: bigint | number, assetB: bigint | number]
      returns: void
    }>
    & Record<'swap(axfer,uint64,uint64,uint64)uint64' | 'swap', {
      argsObj: {
        /**
         * Transfer of the token to be deposited to the pool. To the owner the other asset will be sent.
         */
        txSwap: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * Asset A
         */
        assetA: bigint | number
        /**
         * Asset B
         */
        assetB: bigint | number
        /**
         * If number greater then zero, the check is performed for the output of the other asset
         */
        minimumToReceive: bigint | number
      }
      argsTuple: [txSwap: TransactionToSign | Transaction | Promise<SendTransactionResult>, assetA: bigint | number, assetB: bigint | number, minimumToReceive: bigint | number]
      returns: bigint
    }>
    & Record<'calculateLiquidity(uint256,uint256,uint256,uint256,uint256,uint256)uint256' | 'calculateLiquidity', {
      argsObj: {
        /**
         * Asset A position balanced on the curve
         */
        x: bigint | number
        /**
         * Asset B position balanced on the curve
         */
        y: bigint | number
        /**
         * Minimum price variable in base scale decimals (pa)
         */
        priceMin: bigint | number
        /**
         * Maximum price variable in base scale decimals (pb)
         */
        priceMax: bigint | number
        /**
         * sqrt(priceMin) in base scale decimals Variable pas
         */
        priceMinSqrt: bigint | number
        /**
         * sqrt(priceMax) in base scale decimals Variable pbs
         */
        priceMaxSqrt: bigint | number
      }
      argsTuple: [x: bigint | number, y: bigint | number, priceMin: bigint | number, priceMax: bigint | number, priceMinSqrt: bigint | number, priceMaxSqrt: bigint | number]
      /**
       * Liquidity is constant in swapping each direction. On deposit the diff between the liquidity is number of LP tokens received by user.
       */
      returns: bigint
    }>
    & Record<'calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256' | 'calculatePrice', {
      argsObj: {
        /**
         * x
         */
        assetAQuantity: bigint | number
        /**
         * y
         */
        assetBQuantity: bigint | number
        /**
         * sqrt(priceMin)
         */
        priceMinSqrt: bigint | number
        /**
         * sqrt(priceMax)
         */
        priceMaxSqrt: bigint | number
        /**
         * Current pool liquidity - L variable
         */
        liquidity: bigint | number
      }
      argsTuple: [assetAQuantity: bigint | number, assetBQuantity: bigint | number, priceMinSqrt: bigint | number, priceMaxSqrt: bigint | number, liquidity: bigint | number]
      /**
       * the price with specified quantity with the price range set in the contract
       */
      returns: bigint
    }>
    & Record<'calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256' | 'calculateAssetBWithdrawOnAssetADeposit', {
      argsObj: {
        /**
         * Asset A amount in Base decimal representation.. If asset has 6 decimals, 1 is represented as 1000000000
         */
        inAmount: bigint | number
        /**
         * Asset A balance. Variable ab, in base scale
         */
        assetABalance: bigint | number
        /**
         * Asset B balance. Variable bb, in base scale
         */
        assetBBalance: bigint | number
        /**
         * sqrt(Min price). Variable pMinS, in base scale
         */
        priceMinSqrt: bigint | number
        /**
         * sqrt(Max price). Variable pMaxS, in base scale
         */
        priceMaxSqrt: bigint | number
        /**
         * sqrt(Max price). Variable L, in base scale
         */
        liqudity: bigint | number
      }
      argsTuple: [inAmount: bigint | number, assetABalance: bigint | number, assetBBalance: bigint | number, priceMinSqrt: bigint | number, priceMaxSqrt: bigint | number, liqudity: bigint | number]
      /**
       * Amount of asset B to be given to the caller before fees. The result is in Base decimals (9)
       */
      returns: bigint
    }>
    & Record<'calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256' | 'calculateAssetAWithdrawOnAssetBDeposit', {
      argsObj: {
        /**
         * Asset B amount in Base decimal representation.. If asset has 6 decimals, 1 is represented as 1000000000
         */
        inAmount: bigint | number
        /**
         * Asset A balance. Variable ab, in base scale
         */
        assetABalance: bigint | number
        /**
         * Asset B balance. Variable bb, in base scale
         */
        assetBBalance: bigint | number
        /**
         * sqrt(Min price). Variable pMinS, in base scale
         */
        priceMinSqrt: bigint | number
        /**
         * sqrt(Max price). Variable pMaxS, in base scale
         */
        priceMaxSqrt: bigint | number
        /**
         * sqrt(Max price). Variable L, in base scale
         */
        liqudity: bigint | number
      }
      argsTuple: [inAmount: bigint | number, assetABalance: bigint | number, assetBBalance: bigint | number, priceMinSqrt: bigint | number, priceMaxSqrt: bigint | number, liqudity: bigint | number]
      /**
       * Amount of asset A to be given to the caller before fees. The result is in Base decimals (9)
       */
      returns: bigint
    }>
  /**
   * Defines the shape of the global and local state of the application.
   */
  state: {
    global: {
      'a'?: IntegerState
      'b'?: IntegerState
      'ab'?: BinaryState
      'bb'?: BinaryState
      'pMin'?: IntegerState
      'pMax'?: IntegerState
      'pMinS'?: BinaryState
      'pMaxS'?: BinaryState
      'L'?: BinaryState
      'p'?: IntegerState
      'f'?: IntegerState
      'r'?: IntegerState
      'scale'?: IntegerState
      'i'?: IntegerState
      'pp'?: IntegerState
      'g'?: BinaryState
      'c'?: BinaryState
      'e'?: BinaryState
    }
  }
}
/**
 * Defines the possible abi call signatures
 */
export type BiatecClammSig = keyof BiatecClamm['methods']
/**
 * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made
 */
export type TypedCallParams<TSignature extends BiatecClammSig | undefined> = {
  method: TSignature
  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>
} & AppClientCallCoreParams & CoreAppCallArgs
/**
 * Defines the arguments required for a bare call
 */
export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>
/**
 * Maps a method signature from the BiatecClamm smart contract to the method's arguments in either tuple of struct form
 */
export type MethodArgs<TSignature extends BiatecClammSig> = BiatecClamm['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the BiatecClamm smart contract to the method's return type
 */
export type MethodReturn<TSignature extends BiatecClammSig> = BiatecClamm['methods'][TSignature]['returns']

/**
 * A factory for available 'create' calls
 */
export type BiatecClammCreateCalls = (typeof BiatecClammCallFactory)['create']
/**
 * Defines supported create methods for this smart contract
 */
export type BiatecClammCreateCallParams =
  | (TypedCallParams<'createApplication()void'> & (OnCompleteNoOp))
/**
 * Defines arguments required for the deploy method.
 */
export type BiatecClammDeployArgs = {
  deployTimeParams?: TealTemplateParams
  /**
   * A delegate which takes a create call factory and returns the create call params for this smart contract
   */
  createCall?: (callFactory: BiatecClammCreateCalls) => BiatecClammCreateCallParams
}


/**
 * Exposes methods for constructing all available smart contract calls
 */
export abstract class BiatecClammCallFactory {
  /**
   * Gets available create call factories
   */
  static get create() {
    return {
      /**
       * Constructs a create call for the BiatecCLAMM smart contract using the createApplication()void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      createApplication(args: MethodArgs<'createApplication()void'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return {
          method: 'createApplication()void' as const,
          methodArgs: Array.isArray(args) ? args : [],
          ...params,
        }
      },
    }
  }

  /**
   * Constructs a no op call for the getCurrentPrice()uint64 ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getCurrentPrice(args: MethodArgs<'getCurrentPrice()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getCurrentPrice()uint64' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the getPriceDivider()uint64 ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getPriceDivider(args: MethodArgs<'getPriceDivider()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getPriceDivider()uint64' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the getLPTokenId()uint64 ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getLpTokenId(args: MethodArgs<'getLPTokenId()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getLPTokenId()uint64' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the bootstrap(pay,uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint64,uint64)uint64 ABI method
   *
   * Anybody can deploy the clamm smart contract
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static bootstrap(args: MethodArgs<'bootstrap(pay,uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'bootstrap(pay,uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint64,uint64)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.txSeed, args.assetA, args.assetB, args.feeB100000, args.priceMin, args.priceMax, args.currentPrice, args.verificationClass, args.identityProvider, args.poolProvider],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the addLiquidity(txn,txn,uint64,uint64,uint64)uint64 ABI method
   *
   * This method adds Asset A and Asset B to the Automated Market Maker Concentrated Liqudidity Pool and send to the liqudidty provider the liqudity token
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static addLiquidity(args: MethodArgs<'addLiquidity(txn,txn,uint64,uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'addLiquidity(txn,txn,uint64,uint64,uint64)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.txAssetADeposit, args.txAssetBDeposit, args.assetLP, args.assetA, args.assetB],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the removeLiquidity(axfer,uint64,uint64,uint64)void ABI method
   *
   * This method retrieves from the liquidity provider LP token and returns Asset A and Asset B from the Automated Market Maker Concentrated Liqudidity Pool
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static removeLiquidity(args: MethodArgs<'removeLiquidity(axfer,uint64,uint64,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'removeLiquidity(axfer,uint64,uint64,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.txLPXfer, args.assetLP, args.assetA, args.assetB],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the swap(axfer,uint64,uint64,uint64)uint64 ABI method
   *
   * Swap Asset A to Asset B or Asset B to Asst A
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static swap(args: MethodArgs<'swap(axfer,uint64,uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'swap(axfer,uint64,uint64,uint64)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.txSwap, args.assetA, args.assetB, args.minimumToReceive],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the calculateLiquidity(uint256,uint256,uint256,uint256,uint256,uint256)uint256 ABI method
   *
   * Calculates the liquidity  from the x - Asset A position and y - Asset B position
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static calculateLiquidity(args: MethodArgs<'calculateLiquidity(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'calculateLiquidity(uint256,uint256,uint256,uint256,uint256,uint256)uint256' as const,
      methodArgs: Array.isArray(args) ? args : [args.x, args.y, args.priceMin, args.priceMax, args.priceMinSqrt, args.priceMaxSqrt],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256 ABI method
   *
   * Get the current price when asset a has x
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static calculatePrice(args: MethodArgs<'calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256' as const,
      methodArgs: Array.isArray(args) ? args : [args.assetAQuantity, args.assetBQuantity, args.priceMinSqrt, args.priceMaxSqrt, args.liquidity],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256 ABI method
   *
   * Calculates how much asset B will be taken from the smart contract on asset A deposit
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static calculateAssetBWithdrawOnAssetADeposit(args: MethodArgs<'calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256' as const,
      methodArgs: Array.isArray(args) ? args : [args.inAmount, args.assetABalance, args.assetBBalance, args.priceMinSqrt, args.priceMaxSqrt, args.liqudity],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256 ABI method
   *
   * Calculates how much asset A will be taken from the smart contract on asset B deposit
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static calculateAssetAWithdrawOnAssetBDeposit(args: MethodArgs<'calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256' as const,
      methodArgs: Array.isArray(args) ? args : [args.inAmount, args.assetABalance, args.assetBBalance, args.priceMinSqrt, args.priceMaxSqrt, args.liqudity],
      ...params,
    }
  }
}

/**
 * A client to make calls to the BiatecCLAMM smart contract
 */
export class BiatecClammClient {
  /**
   * The underlying `ApplicationClient` for when you want to have more flexibility
   */
  public readonly appClient: ApplicationClient

  private readonly sender: SendTransactionFrom | undefined

  /**
   * Creates a new instance of `BiatecClammClient`
   *
   * @param appDetails appDetails The details to identify the app to deploy
   * @param algod An algod client instance
   */
  constructor(appDetails: AppDetails, private algod: Algodv2) {
    this.sender = appDetails.sender
    this.appClient = algokit.getAppClient({
      ...appDetails,
      app: APP_SPEC
    }, algod)
  }

  /**
   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type
   *
   * @param result The AppCallTransactionResult to be mapped
   * @param returnValueFormatter An optional delegate to format the return value if required
   * @returns The smart contract response with an updated return value
   */
  protected mapReturnValue<TReturn, TResult extends AppCallTransactionResult = AppCallTransactionResult>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> & TResult {
    if(result.return?.decodeError) {
      throw result.return.decodeError
    }
    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined
      ? returnValueFormatter(result.return.returnValue)
      : result.return?.returnValue as TReturn | undefined
      return { ...result, return: returnValue } as AppCallTransactionResultOfType<TReturn> & TResult
  }

  /**
   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP
   *
   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters
   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type
   * @returns The result of the smart contract call
   */
  public async call<TSignature extends keyof BiatecClamm['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {
    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)
  }

  /**
   * Idempotently deploys the BiatecCLAMM smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public deploy(params: BiatecClammDeployArgs & AppClientDeployCoreParams = {}): ReturnType<ApplicationClient['deploy']> {
    const createArgs = params.createCall?.(BiatecClammCallFactory.create)
    return this.appClient.deploy({
      ...params,
      createArgs,
      createOnCompleteAction: createArgs?.onCompleteAction,
    })
  }

  /**
   * Gets available create methods
   */
  public get create() {
    const $this = this
    return {
      /**
       * Creates a new instance of the BiatecCLAMM smart contract using the createApplication()void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The create result
       */
      async createApplication(args: MethodArgs<'createApplication()void'>, params: AppClientCallCoreParams & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return $this.mapReturnValue<MethodReturn<'createApplication()void'>, AppCreateCallTransactionResult>(await $this.appClient.create(BiatecClammCallFactory.create.createApplication(args, params)))
      },
    }
  }

  /**
   * Makes a clear_state call to an existing instance of the BiatecCLAMM smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The clear_state result
   */
  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.appClient.clearState(args)
  }

  /**
   * Calls the getCurrentPrice()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getCurrentPrice(args: MethodArgs<'getCurrentPrice()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.getCurrentPrice(args, params))
  }

  /**
   * Calls the getPriceDivider()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getPriceDivider(args: MethodArgs<'getPriceDivider()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.getPriceDivider(args, params))
  }

  /**
   * Calls the getLPTokenId()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getLpTokenId(args: MethodArgs<'getLPTokenId()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.getLpTokenId(args, params))
  }

  /**
   * Calls the bootstrap(pay,uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint64,uint64)uint64 ABI method.
   *
   * Anybody can deploy the clamm smart contract
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: LP token ID
   */
  public bootstrap(args: MethodArgs<'bootstrap(pay,uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.bootstrap(args, params))
  }

  /**
   * Calls the addLiquidity(txn,txn,uint64,uint64,uint64)uint64 ABI method.
   *
   * This method adds Asset A and Asset B to the Automated Market Maker Concentrated Liqudidity Pool and send to the liqudidty provider the liqudity token
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: LP Token quantity distributed
   */
  public addLiquidity(args: MethodArgs<'addLiquidity(txn,txn,uint64,uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.addLiquidity(args, params))
  }

  /**
   * Calls the removeLiquidity(axfer,uint64,uint64,uint64)void ABI method.
   *
   * This method retrieves from the liquidity provider LP token and returns Asset A and Asset B from the Automated Market Maker Concentrated Liqudidity Pool
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public removeLiquidity(args: MethodArgs<'removeLiquidity(axfer,uint64,uint64,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.removeLiquidity(args, params))
  }

  /**
   * Calls the swap(axfer,uint64,uint64,uint64)uint64 ABI method.
   *
   * Swap Asset A to Asset B or Asset B to Asst A
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public swap(args: MethodArgs<'swap(axfer,uint64,uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.swap(args, params))
  }

  /**
   * Calls the calculateLiquidity(uint256,uint256,uint256,uint256,uint256,uint256)uint256 ABI method.
   *
   * Calculates the liquidity  from the x - Asset A position and y - Asset B position
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Liquidity is constant in swapping each direction. On deposit the diff between the liquidity is number of LP tokens received by user.
   */
  public calculateLiquidity(args: MethodArgs<'calculateLiquidity(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.calculateLiquidity(args, params))
  }

  /**
   * Calls the calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256 ABI method.
   *
   * Get the current price when asset a has x
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: the price with specified quantity with the price range set in the contract
   */
  public calculatePrice(args: MethodArgs<'calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.calculatePrice(args, params))
  }

  /**
   * Calls the calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256 ABI method.
   *
   * Calculates how much asset B will be taken from the smart contract on asset A deposit
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Amount of asset B to be given to the caller before fees. The result is in Base decimals (9)
   */
  public calculateAssetBWithdrawOnAssetADeposit(args: MethodArgs<'calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.calculateAssetBWithdrawOnAssetADeposit(args, params))
  }

  /**
   * Calls the calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256 ABI method.
   *
   * Calculates how much asset A will be taken from the smart contract on asset B deposit
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Amount of asset A to be given to the caller before fees. The result is in Base decimals (9)
   */
  public calculateAssetAWithdrawOnAssetBDeposit(args: MethodArgs<'calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.calculateAssetAWithdrawOnAssetBDeposit(args, params))
  }

  /**
   * Extracts a binary state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns A BinaryState instance containing the state value, or undefined if the key was not found
   */
  private static getBinaryState(state: AppState, key: string): BinaryState | undefined {
    const value = state[key]
    if (!value) return undefined
    if (!('valueRaw' in value))
      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`)
    return {
      asString(): string {
        return value.value
      },
      asByteArray(): Uint8Array {
        return value.valueRaw
      }
    }
  }

  /**
   * Extracts a integer state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns An IntegerState instance containing the state value, or undefined if the key was not found
   */
  private static getIntegerState(state: AppState, key: string): IntegerState | undefined {
    const value = state[key]
    if (!value) return undefined
    if ('valueRaw' in value)
      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`)
    return {
      asBigInt() {
        return typeof value.value === 'bigint' ? value.value : BigInt(value.value)
      },
      asNumber(): number {
        return typeof value.value === 'bigint' ? Number(value.value) : value.value
      },
    }
  }

  /**
   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value
   */
  public async getGlobalState(): Promise<BiatecClamm['state']['global']> {
    const state = await this.appClient.getGlobalState()
    return {
      get a() {
        return BiatecClammClient.getIntegerState(state, 'a')
      },
      get b() {
        return BiatecClammClient.getIntegerState(state, 'b')
      },
      get ab() {
        return BiatecClammClient.getBinaryState(state, 'ab')
      },
      get bb() {
        return BiatecClammClient.getBinaryState(state, 'bb')
      },
      get pMin() {
        return BiatecClammClient.getIntegerState(state, 'pMin')
      },
      get pMax() {
        return BiatecClammClient.getIntegerState(state, 'pMax')
      },
      get pMinS() {
        return BiatecClammClient.getBinaryState(state, 'pMinS')
      },
      get pMaxS() {
        return BiatecClammClient.getBinaryState(state, 'pMaxS')
      },
      get L() {
        return BiatecClammClient.getBinaryState(state, 'L')
      },
      get p() {
        return BiatecClammClient.getIntegerState(state, 'p')
      },
      get f() {
        return BiatecClammClient.getIntegerState(state, 'f')
      },
      get r() {
        return BiatecClammClient.getIntegerState(state, 'r')
      },
      get scale() {
        return BiatecClammClient.getIntegerState(state, 'scale')
      },
      get i() {
        return BiatecClammClient.getIntegerState(state, 'i')
      },
      get pp() {
        return BiatecClammClient.getIntegerState(state, 'pp')
      },
      get g() {
        return BiatecClammClient.getBinaryState(state, 'g')
      },
      get c() {
        return BiatecClammClient.getBinaryState(state, 'c')
      },
      get e() {
        return BiatecClammClient.getBinaryState(state, 'e')
      },
    }
  }

  public compose(): BiatecClammComposer {
    const client = this
    const atc = new AtomicTransactionComposer()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: any) => any)> = []
    return {
      getCurrentPrice(args: MethodArgs<'getCurrentPrice()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getCurrentPrice(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      getPriceDivider(args: MethodArgs<'getPriceDivider()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getPriceDivider(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      getLpTokenId(args: MethodArgs<'getLPTokenId()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getLpTokenId(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      bootstrap(args: MethodArgs<'bootstrap(pay,uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint64,uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.bootstrap(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addLiquidity(args: MethodArgs<'addLiquidity(txn,txn,uint64,uint64,uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.addLiquidity(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      removeLiquidity(args: MethodArgs<'removeLiquidity(axfer,uint64,uint64,uint64)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.removeLiquidity(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      swap(args: MethodArgs<'swap(axfer,uint64,uint64,uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.swap(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      calculateLiquidity(args: MethodArgs<'calculateLiquidity(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.calculateLiquidity(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      calculatePrice(args: MethodArgs<'calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.calculatePrice(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      calculateAssetBWithdrawOnAssetADeposit(args: MethodArgs<'calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.calculateAssetBWithdrawOnAssetADeposit(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      calculateAssetAWithdrawOnAssetBDeposit(args: MethodArgs<'calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.calculateAssetAWithdrawOnAssetBDeposit(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {
        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))
        return this
      },
      async atc() {
        await promiseChain
        return atc
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await atc.simulate(client.algod, new modelsv2.SimulateRequest({ txnGroups: [], ...options }))
        return {
          ...result,
          returns: result.methodResults?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      },
      async execute() {
        await promiseChain
        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams: {} }, client.algod)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      }
    } as unknown as BiatecClammComposer
  }
}
export type BiatecClammComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the getCurrentPrice()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getCurrentPrice(args: MethodArgs<'getCurrentPrice()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'getCurrentPrice()uint64'>]>

  /**
   * Calls the getPriceDivider()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getPriceDivider(args: MethodArgs<'getPriceDivider()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'getPriceDivider()uint64'>]>

  /**
   * Calls the getLPTokenId()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getLpTokenId(args: MethodArgs<'getLPTokenId()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'getLPTokenId()uint64'>]>

  /**
   * Calls the bootstrap(pay,uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint64,uint64)uint64 ABI method.
   *
   * Anybody can deploy the clamm smart contract
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  bootstrap(args: MethodArgs<'bootstrap(pay,uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint64,uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'bootstrap(pay,uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint64,uint64)uint64'>]>

  /**
   * Calls the addLiquidity(txn,txn,uint64,uint64,uint64)uint64 ABI method.
   *
   * This method adds Asset A and Asset B to the Automated Market Maker Concentrated Liqudidity Pool and send to the liqudidty provider the liqudity token
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  addLiquidity(args: MethodArgs<'addLiquidity(txn,txn,uint64,uint64,uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'addLiquidity(txn,txn,uint64,uint64,uint64)uint64'>]>

  /**
   * Calls the removeLiquidity(axfer,uint64,uint64,uint64)void ABI method.
   *
   * This method retrieves from the liquidity provider LP token and returns Asset A and Asset B from the Automated Market Maker Concentrated Liqudidity Pool
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  removeLiquidity(args: MethodArgs<'removeLiquidity(axfer,uint64,uint64,uint64)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'removeLiquidity(axfer,uint64,uint64,uint64)void'>]>

  /**
   * Calls the swap(axfer,uint64,uint64,uint64)uint64 ABI method.
   *
   * Swap Asset A to Asset B or Asset B to Asst A
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  swap(args: MethodArgs<'swap(axfer,uint64,uint64,uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'swap(axfer,uint64,uint64,uint64)uint64'>]>

  /**
   * Calls the calculateLiquidity(uint256,uint256,uint256,uint256,uint256,uint256)uint256 ABI method.
   *
   * Calculates the liquidity  from the x - Asset A position and y - Asset B position
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  calculateLiquidity(args: MethodArgs<'calculateLiquidity(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'calculateLiquidity(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>]>

  /**
   * Calls the calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256 ABI method.
   *
   * Get the current price when asset a has x
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  calculatePrice(args: MethodArgs<'calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256'>]>

  /**
   * Calls the calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256 ABI method.
   *
   * Calculates how much asset B will be taken from the smart contract on asset A deposit
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  calculateAssetBWithdrawOnAssetADeposit(args: MethodArgs<'calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>]>

  /**
   * Calls the calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256 ABI method.
   *
   * Calculates how much asset A will be taken from the smart contract on asset B deposit
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  calculateAssetAWithdrawOnAssetBDeposit(args: MethodArgs<'calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>]>

  /**
   * Makes a clear_state call to an existing instance of the BiatecCLAMM smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)
   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.
   */
  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): BiatecClammComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  atc(): Promise<AtomicTransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(options?: SimulateOptions): Promise<BiatecClammComposerSimulateResult<TReturns>>
  /**
   * Executes the transaction group and returns the results
   */
  execute(): Promise<BiatecClammComposerResults<TReturns>>
}
export type SimulateOptions = Omit<ConstructorParameters<typeof modelsv2.SimulateRequest>[0], 'txnGroups'>
export type BiatecClammComposerSimulateResult<TReturns extends [...any[]]> = {
  returns: TReturns
  methodResults: ABIResult[]
  simulateResponse: modelsv2.SimulateResponse
}
export type BiatecClammComposerResults<TReturns extends [...any[]]> = {
  returns: TReturns
  groupId: string
  txIds: string[]
  transactions: Transaction[]
}

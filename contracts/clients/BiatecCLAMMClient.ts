/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^2
 */
import * as algokit from '@algorandfoundation/algokit-utils'
import type {
  ABIAppCallArg,
  AppCallTransactionResult,
  AppCallTransactionResultOfType,
  AppCompilationResult,
  AppReference,
  AppState,
  CoreAppCallArgs,
  RawAppCallArgs,
  TealTemplateParams,
} from '@algorandfoundation/algokit-utils/types/app'
import type {
  AppClientCallCoreParams,
  AppClientCompilationParams,
  AppClientDeployCoreParams,
  AppDetails,
  ApplicationClient,
} from '@algorandfoundation/algokit-utils/types/app-client'
import type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'
import type { SendTransactionResult, TransactionToSign, SendTransactionFrom } from '@algorandfoundation/algokit-utils/types/transaction'
import type { ABIResult, TransactionWithSigner } from 'algosdk'
import { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer, modelsv2 } from 'algosdk'
export const APP_SPEC: AppSpec = {
  "hints": {
    "createApplication()void": {
      "call_config": {
        "no_op": "CREATE"
      }
    },
    "getCurrentPrice()uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "getPriceDivider()uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "getLPTokenId()uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "bootstrap(pay,uint64,uint64,uint32,uint64,uint64,uint64,uint8,uint64,uint64)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "addLiquidity(txn,txn,uint64,uint64,uint64)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "getHypotheticPrice(uint64,uint64,uint64,uint64,uint64,uint64,uint64)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "removeLiquidity(axfer,uint64,uint64,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "swap(axfer,uint64,uint64,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "calculateAssetBWithdrawOnAssetADeposit(uint64,uint64,uint64)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    }
  },
  "bare_call_config": {
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "close_out": "NEVER",
    "update_application": "NEVER",
    "delete_application": "NEVER"
  },
  "schema": {
    "local": {
      "declared": {},
      "reserved": {}
    },
    "global": {
      "declared": {
        "assetA": {
          "type": "uint64",
          "key": "a"
        },
        "assetB": {
          "type": "uint64",
          "key": "b"
        },
        "assetABalance": {
          "type": "uint64",
          "key": "ab"
        },
        "assetBBalance": {
          "type": "uint64",
          "key": "bb"
        },
        "priceMaxA": {
          "type": "uint64",
          "key": "pa"
        },
        "priceMaxB": {
          "type": "uint64",
          "key": "pb"
        },
        "priceMaxASqrt": {
          "type": "uint64",
          "key": "pas"
        },
        "priceMaxBSqrt": {
          "type": "uint64",
          "key": "pbs"
        },
        "Liqudity": {
          "type": "uint64",
          "key": "L"
        },
        "poolToken": {
          "type": "uint64",
          "key": "p"
        },
        "feeB100000": {
          "type": "bytes",
          "key": "f"
        },
        "ratio": {
          "type": "uint64",
          "key": "r"
        },
        "scale": {
          "type": "uint64",
          "key": "scale"
        },
        "identityProvider": {
          "type": "uint64",
          "key": "i"
        },
        "poolProvider": {
          "type": "uint64",
          "key": "pp"
        },
        "governor": {
          "type": "bytes",
          "key": "g"
        },
        "verificationClass": {
          "type": "bytes",
          "key": "c"
        },
        "engagementClass": {
          "type": "bytes",
          "key": "e"
        }
      },
      "reserved": {}
    }
  },
  "state": {
    "global": {
      "num_byte_slices": 4,
      "num_uints": 14
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0
    }
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCgovLyBUaGlzIFRFQUwgd2FzIGdlbmVyYXRlZCBieSBURUFMU2NyaXB0IHYwLjg2LjAKLy8gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29yYW5kZm91bmRhdGlvbi9URUFMU2NyaXB0CgovLyBUaGlzIGNvbnRyYWN0IGlzIGNvbXBsaWFudCB3aXRoIGFuZC9vciBpbXBsZW1lbnRzIHRoZSBmb2xsb3dpbmcgQVJDczogWyBBUkM0IF0KCi8vIFRoZSBmb2xsb3dpbmcgdGVuIGxpbmVzIG9mIFRFQUwgaGFuZGxlIGluaXRpYWwgcHJvZ3JhbSBmbG93Ci8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIHRvIG1ha2UgaXQgZWFzeSBmb3IgYW55b25lIHRvIHBhcnNlIHRoZSBzdGFydCBvZiB0aGUgcHJvZ3JhbSBhbmQgZGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgYWN0aW9uIGlzIGFsbG93ZWQKLy8gSGVyZSwgYWN0aW9uIHJlZmVycyB0byB0aGUgT25Db21wbGV0ZSBpbiBjb21iaW5hdGlvbiB3aXRoIHdoZXRoZXIgdGhlIGFwcCBpcyBiZWluZyBjcmVhdGVkIG9yIGNhbGxlZAovLyBFdmVyeSBwb3NzaWJsZSBhY3Rpb24gZm9yIHRoaXMgY29udHJhY3QgaXMgcmVwcmVzZW50ZWQgaW4gdGhlIHN3aXRjaCBzdGF0ZW1lbnQKLy8gSWYgdGhlIGFjdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIGNvbnRyYWN0LCBpdHMgcmVzcGVjdGl2ZSBicmFuY2ggd2lsbCBiZSAiKk5PVF9JTVBMRU1FTlRFRCIgd2hpY2gganVzdCBjb250YWlucyAiZXJyIgp0eG4gQXBwbGljYXRpb25JRAohCmludCA2CioKdHhuIE9uQ29tcGxldGlvbgorCnN3aXRjaCAqY2FsbF9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqY3JlYXRlX05vT3AgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVECgoqTk9UX0lNUExFTUVOVEVEOgoJZXJyCgovLyBjcmVhdGVBcHBsaWNhdGlvbigpdm9pZAoqYWJpX3JvdXRlX2NyZWF0ZUFwcGxpY2F0aW9uOgoJLy8gZXhlY3V0ZSBjcmVhdGVBcHBsaWNhdGlvbigpdm9pZAoJY2FsbHN1YiBjcmVhdGVBcHBsaWNhdGlvbgoJaW50IDEKCXJldHVybgoKLy8gY3JlYXRlQXBwbGljYXRpb24oKTogdm9pZAovLwovLyBJbml0aWFsIHNldHVwCmNyZWF0ZUFwcGxpY2F0aW9uOgoJcHJvdG8gMCAwCgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NzkKCS8vIGxvZyh2ZXJzaW9uKQoJYnl0ZSAiQ0xBTU0tMDEtMDEtMDEiCglsb2cKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo4MAoJLy8gdGhpcy5nb3Zlcm5vci52YWx1ZSA9IEFkZHJlc3MuZnJvbUJ5dGVzKGdvdmVybm9yKQoJYnl0ZSAweDY3IC8vICJnIgoJYnl0ZSAiQUxHT05BVVRTUElVSERDWDNTTEZYT0ZEVUtPRTRWWTM2WFY0SlgySkhRVFdKTktWQktQRUJRQUNSWSIKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6ODEKCS8vIHRoaXMuc2NhbGUudmFsdWUgPSBTQ0FMRQoJYnl0ZSAweDczNjM2MTZjNjUgLy8gInNjYWxlIgoJaW50IDEwMDAwMDAwMDAKCWFwcF9nbG9iYWxfcHV0CglyZXRzdWIKCi8vIGdldEN1cnJlbnRQcmljZSgpdWludDY0CiphYmlfcm91dGVfZ2V0Q3VycmVudFByaWNlOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBleGVjdXRlIGdldEN1cnJlbnRQcmljZSgpdWludDY0CgljYWxsc3ViIGdldEN1cnJlbnRQcmljZQoJaXRvYgoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGdldEN1cnJlbnRQcmljZSgpOiB1aW50NjQKZ2V0Q3VycmVudFByaWNlOgoJcHJvdG8gMCAxCgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6ODYKCS8vIHJldHVybiB0aGlzLnJhdGlvLnZhbHVlOwoJYnl0ZSAweDcyIC8vICJyIgoJYXBwX2dsb2JhbF9nZXQKCXJldHN1YgoKLy8gZ2V0UHJpY2VEaXZpZGVyKCl1aW50NjQKKmFiaV9yb3V0ZV9nZXRQcmljZURpdmlkZXI6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIGV4ZWN1dGUgZ2V0UHJpY2VEaXZpZGVyKCl1aW50NjQKCWNhbGxzdWIgZ2V0UHJpY2VEaXZpZGVyCglpdG9iCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gZ2V0UHJpY2VEaXZpZGVyKCk6IHVpbnQ2NApnZXRQcmljZURpdmlkZXI6Cglwcm90byAwIDEKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo5MQoJLy8gcmV0dXJuIHRoaXMuc2NhbGUudmFsdWU7CglieXRlIDB4NzM2MzYxNmM2NSAvLyAic2NhbGUiCglhcHBfZ2xvYmFsX2dldAoJcmV0c3ViCgovLyBnZXRMUFRva2VuSWQoKXVpbnQ2NAoqYWJpX3JvdXRlX2dldExQVG9rZW5JZDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gZXhlY3V0ZSBnZXRMUFRva2VuSWQoKXVpbnQ2NAoJY2FsbHN1YiBnZXRMUFRva2VuSWQKCWl0b2IKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBnZXRMUFRva2VuSWQoKTogdWludDY0CmdldExQVG9rZW5JZDoKCXByb3RvIDAgMQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjk2CgkvLyByZXR1cm4gdGhpcy5wb29sVG9rZW4udmFsdWUuaWQ7CglieXRlIDB4NzAgLy8gInAiCglhcHBfZ2xvYmFsX2dldAoJcmV0c3ViCgovLyBib290c3RyYXAocGF5LHVpbnQ2NCx1aW50NjQsdWludDMyLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQpdWludDY0CiphYmlfcm91dGVfYm9vdHN0cmFwOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBwb29sUHJvdmlkZXI6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgOQoJYnRvaQoKCS8vIGlkZW50aXR5UHJvdmlkZXI6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgOAoJYnRvaQoKCS8vIHZlcmlmaWNhdGlvbkNsYXNzOiB1aW50OAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNwoJZHVwCglsZW4KCWludCAxCgk9PQoJYXNzZXJ0CglidG9pCgoJLy8gY3VycmVudFByaWNlOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDYKCWJ0b2kKCgkvLyBwcmljZU1heEI6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQoJYnRvaQoKCS8vIHByaWNlTWF4QTogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA0CglidG9pCgoJLy8gZmVlQjEwMDAwMDogdWludDMyCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglkdXAKCWxlbgoJaW50IDQKCT09Cglhc3NlcnQKCWJ0b2kKCgkvLyBhc3NldEI6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIGFzc2V0QTogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gdHhTZWVkOiBwYXkKCXR4biBHcm91cEluZGV4CglpbnQgMQoJLQoJZHVwCglndHhucyBUeXBlRW51bQoJaW50IHBheQoJPT0KCWFzc2VydAoKCS8vIGV4ZWN1dGUgYm9vdHN0cmFwKHBheSx1aW50NjQsdWludDY0LHVpbnQzMix1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0KXVpbnQ2NAoJY2FsbHN1YiBib290c3RyYXAKCWl0b2IKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBib290c3RyYXAodHhTZWVkOiBQYXlUeG4sIGFzc2V0QTogQXNzZXRJRCwgYXNzZXRCOiBBc3NldElELCBmZWVCMTAwMDAwOiB1aW50MzIsIHByaWNlTWF4QTogdWludDY0LCBwcmljZU1heEI6IHVpbnQ2NCwgY3VycmVudFByaWNlOiB1aW50NjQsIHZlcmlmaWNhdGlvbkNsYXNzOiB1aW50OCwgaWRlbnRpdHlQcm92aWRlcjogQXBwSUQsIHBvb2xQcm92aWRlcjogQXBwSUQpOiBBc3NldElECi8vCi8vIEFueWJvZHkgY2FuIGRlcGxveSB0aGUgY2xhbW0gc21hcnQgY29udHJhY3QKLy8gQHBhcmFtIHR4U2VlZCBTZWVkIHRyYW5zYWN0aW9uIHNvIHRoYXQgc21hcnQgY29udHJhY3QgY2FuIG9wdCBpbiB0byB0aGUgYXNzZXRzCi8vIEBwYXJhbSBhc3NldEEgQXNzZXQgQSBJRCBtdXN0IGJlIGxvd2VyIHRoZW4gQXNzZXQgQiBJRAovLyBAcGFyYW0gYXNzZXRCIEFzc2V0IEIKLy8gQHBhcmFtIGZlZUIxMDAwMDAgRmVlIGluIDEwMDAwMCBiYXNlIGxldmVsLiB2YWx1ZSAxMDAwMCA9IDEwMDAwLzEwMDAwMCA9IDAsMSA9IDEwJSBmZWUuIDEwMDAgPSAxJS4gMTAwID0gMCwxJS4gMTAgPSAwLDAxJSA9IDEgYmFzZSBwb2ludAovLyBAcGFyYW0gdmVyaWZpY2F0aW9uQ2xhc3MgQXNzZXQgQgovLyBAcmV0dXJucyBMUCB0b2tlbiBJRApib290c3RyYXA6Cglwcm90byAxMCAxCgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTIwCgkvLyB2ZXJpZnlQYXlUeG4odHhTZWVkLCB7IHJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzLCBhbW91bnQ6IHsgZ3JlYXRlclRoYW5FcXVhbFRvOiAzMDBfMDAwIH0gfSkKCS8vIHZlcmlmeSByZWNlaXZlcgoJZnJhbWVfZGlnIC0xIC8vIHR4U2VlZDogUGF5VHhuCglndHhucyBSZWNlaXZlcgoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCT09Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYW1vdW50CglmcmFtZV9kaWcgLTEgLy8gdHhTZWVkOiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJaW50IDMwMF8wMDAKCT49Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxMjEKCS8vIGFzc2VydCh0aGlzLmdvdmVybm9yLnZhbHVlID09PSBBZGRyZXNzLmZyb21CeXRlcyhnb3Zlcm5vcikpCglieXRlIDB4NjcgLy8gImciCglhcHBfZ2xvYmFsX2dldAoJYnl0ZSAiQUxHT05BVVRTUElVSERDWDNTTEZYT0ZEVUtPRTRWWTM2WFY0SlgySkhRVFdKTktWQktQRUJRQUNSWSIKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxMjIKCS8vIGFzc2VydChhc3NldEEgPCBhc3NldEIpCglmcmFtZV9kaWcgLTIgLy8gYXNzZXRBOiBBc3NldElECglmcmFtZV9kaWcgLTMgLy8gYXNzZXRCOiBBc3NldElECgk8Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxMjMKCS8vIGFzc2VydChmZWVCMTAwMDAwIDwgMTAwMDAwMCkKCWZyYW1lX2RpZyAtNCAvLyBmZWVCMTAwMDAwOiB1aW50MzIKCWludCAxMDAwMDAwCgk8Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxMjQKCS8vIGFzc2VydCh2ZXJpZmljYXRpb25DbGFzcyA8IDQpCglmcmFtZV9kaWcgLTggLy8gdmVyaWZpY2F0aW9uQ2xhc3M6IHVpbnQ4CglpbnQgNAoJPAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTI1CgkvLyBhc3NlcnQoIXRoaXMucmF0aW8uZXhpc3RzKQoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJYnl0ZSAweDcyIC8vICJyIgoJYXBwX2dsb2JhbF9nZXRfZXgKCXN3YXAKCXBvcAoJIQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTI2CgkvLyBhc3NlcnQoYXNzZXRBLmRlY2ltYWxzIDw9IFNDQUxFX0RFQ0lNQUxTKQoJZnJhbWVfZGlnIC0yIC8vIGFzc2V0QTogQXNzZXRJRAoJYXNzZXRfcGFyYW1zX2dldCBBc3NldERlY2ltYWxzCglwb3AKCWludCA5Cgk8PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTI3CgkvLyBhc3NlcnQoYXNzZXRCLmRlY2ltYWxzIDw9IFNDQUxFX0RFQ0lNQUxTKQoJZnJhbWVfZGlnIC0zIC8vIGFzc2V0QjogQXNzZXRJRAoJYXNzZXRfcGFyYW1zX2dldCBBc3NldERlY2ltYWxzCglwb3AKCWludCA5Cgk8PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTI5CgkvLyB0aGlzLmlkZW50aXR5UHJvdmlkZXIudmFsdWUgPSBpZGVudGl0eVByb3ZpZGVyCglieXRlIDB4NjkgLy8gImkiCglmcmFtZV9kaWcgLTkgLy8gaWRlbnRpdHlQcm92aWRlcjogQXBwSUQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTMwCgkvLyB0aGlzLnBvb2xQcm92aWRlci52YWx1ZSA9IHBvb2xQcm92aWRlcgoJYnl0ZSAweDcwNzAgLy8gInBwIgoJZnJhbWVfZGlnIC0xMCAvLyBwb29sUHJvdmlkZXI6IEFwcElECglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjEzMgoJLy8gdGhpcy5wcmljZU1heEEudmFsdWUgPSBwcmljZU1heEEKCWJ5dGUgMHg3MDYxIC8vICJwYSIKCWZyYW1lX2RpZyAtNSAvLyBwcmljZU1heEE6IHVpbnQ2NAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxMzMKCS8vIHRoaXMucHJpY2VNYXhCLnZhbHVlID0gcHJpY2VNYXhCCglieXRlIDB4NzA2MiAvLyAicGIiCglmcmFtZV9kaWcgLTYgLy8gcHJpY2VNYXhCOiB1aW50NjQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTM0CgkvLyB0aGlzLnByaWNlTWF4QVNxcnQudmFsdWUgPSBzcXJ0KHByaWNlTWF4QSAqIFNDQUxFKQoJYnl0ZSAweDcwNjE3MyAvLyAicGFzIgoJZnJhbWVfZGlnIC01IC8vIHByaWNlTWF4QTogdWludDY0CglpbnQgMTAwMDAwMDAwMAoJKgoJc3FydAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxMzUKCS8vIHRoaXMucHJpY2VNYXhCU3FydC52YWx1ZSA9IHNxcnQocHJpY2VNYXhCICogU0NBTEUpCglieXRlIDB4NzA2MjczIC8vICJwYnMiCglmcmFtZV9kaWcgLTYgLy8gcHJpY2VNYXhCOiB1aW50NjQKCWludCAxMDAwMDAwMDAwCgkqCglzcXJ0CglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjEzNgoJLy8gdGhpcy5hc3NldEFCYWxhbmNlLnZhbHVlID0gMAoJYnl0ZSAweDYxNjIgLy8gImFiIgoJaW50IDAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTM3CgkvLyB0aGlzLmFzc2V0QkJhbGFuY2UudmFsdWUgPSAwCglieXRlIDB4NjI2MiAvLyAiYmIiCglpbnQgMAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxMzgKCS8vIHRoaXMucmF0aW8udmFsdWUgPSBjdXJyZW50UHJpY2UKCWJ5dGUgMHg3MiAvLyAiciIKCWZyYW1lX2RpZyAtNyAvLyBjdXJyZW50UHJpY2U6IHVpbnQ2NAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxNDAKCS8vIHRoaXMuYXNzZXRBLnZhbHVlID0gYXNzZXRBCglieXRlIDB4NjEgLy8gImEiCglmcmFtZV9kaWcgLTIgLy8gYXNzZXRBOiBBc3NldElECglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjE0MQoJLy8gdGhpcy5hc3NldEIudmFsdWUgPSBhc3NldEIKCWJ5dGUgMHg2MiAvLyAiYiIKCWZyYW1lX2RpZyAtMyAvLyBhc3NldEI6IEFzc2V0SUQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTQyCgkvLyB0aGlzLnBvb2xUb2tlbi52YWx1ZSA9IHRoaXMuZG9DcmVhdGVQb29sVG9rZW4oYXNzZXRBLCBhc3NldEIpCglieXRlIDB4NzAgLy8gInAiCglmcmFtZV9kaWcgLTMgLy8gYXNzZXRCOiBBc3NldElECglmcmFtZV9kaWcgLTIgLy8gYXNzZXRBOiBBc3NldElECgljYWxsc3ViIGRvQ3JlYXRlUG9vbFRva2VuCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjE0MwoJLy8gdGhpcy5mZWVCMTAwMDAwLnZhbHVlID0gZmVlQjEwMDAwMAoJYnl0ZSAweDY2IC8vICJmIgoJZnJhbWVfZGlnIC00IC8vIGZlZUIxMDAwMDA6IHVpbnQzMgoJaXRvYgoJZXh0cmFjdCA0IDQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTQ1CgkvLyB0aGlzLmRvT3B0SW4oYXNzZXRBKQoJZnJhbWVfZGlnIC0yIC8vIGFzc2V0QTogQXNzZXRJRAoJY2FsbHN1YiBkb09wdEluCgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTQ2CgkvLyB0aGlzLmRvT3B0SW4oYXNzZXRCKQoJZnJhbWVfZGlnIC0zIC8vIGFzc2V0QjogQXNzZXRJRAoJY2FsbHN1YiBkb09wdEluCgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTQ4CgkvLyByZXR1cm4gdGhpcy5wb29sVG9rZW4udmFsdWU7CglieXRlIDB4NzAgLy8gInAiCglhcHBfZ2xvYmFsX2dldAoJcmV0c3ViCgovLyBkb0F4ZmVyKHJlY2VpdmVyOiBBZGRyZXNzLCBhc3NldDogQXNzZXRJRCwgYW1vdW50OiB1aW50NjQpOiB2b2lkCmRvQXhmZXI6Cglwcm90byAzIDAKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxNTIKCS8vIHNlbmRBc3NldFRyYW5zZmVyKHsKCS8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IHJlY2VpdmVyLAoJLy8gICAgICAgeGZlckFzc2V0OiBhc3NldCwKCS8vICAgICAgIGFzc2V0QW1vdW50OiBhbW91bnQsCgkvLyAgICAgICBmZWU6IDAsCgkvLyAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBheGZlcgoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjE1MwoJLy8gYXNzZXRSZWNlaXZlcjogcmVjZWl2ZXIKCWZyYW1lX2RpZyAtMSAvLyByZWNlaXZlcjogQWRkcmVzcwoJaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTU0CgkvLyB4ZmVyQXNzZXQ6IGFzc2V0CglmcmFtZV9kaWcgLTIgLy8gYXNzZXQ6IEFzc2V0SUQKCWl0eG5fZmllbGQgWGZlckFzc2V0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTU1CgkvLyBhc3NldEFtb3VudDogYW1vdW50CglmcmFtZV9kaWcgLTMgLy8gYW1vdW50OiB1aW50NjQKCWl0eG5fZmllbGQgQXNzZXRBbW91bnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxNTYKCS8vIGZlZTogMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJcmV0c3ViCgovLyBkb09wdEluKGFzc2V0OiBBc3NldElEKTogdm9pZApkb09wdEluOgoJcHJvdG8gMSAwCgoJLy8gKmlmMF9jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjE2MQoJLy8gYXNzZXQuaWQgPiAwCglmcmFtZV9kaWcgLTEgLy8gYXNzZXQ6IEFzc2V0SUQKCWludCAwCgk+CglieiAqaWYwX2VuZAoKCS8vICppZjBfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTYzCgkvLyB0aGlzLmRvQXhmZXIodGhpcy5hcHAuYWRkcmVzcywgYXNzZXQsIDApCglpbnQgMAoJZnJhbWVfZGlnIC0xIC8vIGFzc2V0OiBBc3NldElECglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJY2FsbHN1YiBkb0F4ZmVyCgoqaWYwX2VuZDoKCXJldHN1YgoKLy8gZG9DcmVhdGVQb29sVG9rZW4oYXNzZXRBOiBBc3NldElELCBhc3NldEI6IEFzc2V0SUQpOiBBc3NldElECmRvQ3JlYXRlUG9vbFRva2VuOgoJcHJvdG8gMiAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxNzEKCS8vIG5hbWUgPSAnQi0nICsgYXNzZXRBLnVuaXROYW1lICsgJy0nICsgYXNzZXRCLnVuaXROYW1lCglieXRlIDB4NDIyZCAvLyAiQi0iCglmcmFtZV9kaWcgLTEgLy8gYXNzZXRBOiBBc3NldElECglhc3NldF9wYXJhbXNfZ2V0IEFzc2V0VW5pdE5hbWUKCXBvcAoJY29uY2F0CglieXRlIDB4MmQgLy8gIi0iCgljb25jYXQKCWZyYW1lX2RpZyAtMiAvLyBhc3NldEI6IEFzc2V0SUQKCWFzc2V0X3BhcmFtc19nZXQgQXNzZXRVbml0TmFtZQoJcG9wCgljb25jYXQKCWZyYW1lX2J1cnkgMCAvLyBuYW1lOiBieXRlW10KCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxNzMKCS8vIHJldHVybiBzZW5kQXNzZXRDcmVhdGlvbih7CgkvLyAgICAgICBjb25maWdBc3NldE5hbWU6IG5hbWUsCgkvLyAgICAgICBjb25maWdBc3NldFVuaXROYW1lOiAnQkxQJywKCS8vICAgICAgIGNvbmZpZ0Fzc2V0VG90YWw6IFRPVEFMX1NVUFBMWSwKCS8vICAgICAgIGNvbmZpZ0Fzc2V0RGVjaW1hbHM6IExQX1RPS0VOX0RFQ0lNQUxTLAoJLy8gICAgICAgY29uZmlnQXNzZXRNYW5hZ2VyOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gICAgICAgY29uZmlnQXNzZXRSZXNlcnZlOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gICAgIH0pOwoJaXR4bl9iZWdpbgoJaW50IGFjZmcKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxNzQKCS8vIGNvbmZpZ0Fzc2V0TmFtZTogbmFtZQoJZnJhbWVfZGlnIDAgLy8gbmFtZTogYnl0ZVtdCglpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0TmFtZQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjE3NQoJLy8gY29uZmlnQXNzZXRVbml0TmFtZTogJ0JMUCcKCWJ5dGUgMHg0MjRjNTAgLy8gIkJMUCIKCWl0eG5fZmllbGQgQ29uZmlnQXNzZXRVbml0TmFtZQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjE3NgoJLy8gY29uZmlnQXNzZXRUb3RhbDogVE9UQUxfU1VQUExZCglpbnQgMTAwMDAwMDAwMDAwMDAwMDAKCWl0eG5fZmllbGQgQ29uZmlnQXNzZXRUb3RhbAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjE3NwoJLy8gY29uZmlnQXNzZXREZWNpbWFsczogTFBfVE9LRU5fREVDSU1BTFMKCWludCA2CglpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0RGVjaW1hbHMKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoxNzgKCS8vIGNvbmZpZ0Fzc2V0TWFuYWdlcjogdGhpcy5hcHAuYWRkcmVzcwoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWl0eG5fZmllbGQgQ29uZmlnQXNzZXRNYW5hZ2VyCgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MTc5CgkvLyBjb25maWdBc3NldFJlc2VydmU6IHRoaXMuYXBwLmFkZHJlc3MKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0UmVzZXJ2ZQoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludCAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCWl0eG4gQ3JlYXRlZEFzc2V0SUQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCXJldHN1YgoKLy8gYWRkTGlxdWlkaXR5KHR4bix0eG4sdWludDY0LHVpbnQ2NCx1aW50NjQpdWludDY0CiphYmlfcm91dGVfYWRkTGlxdWlkaXR5OgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBhc3NldEI6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJYnRvaQoKCS8vIGFzc2V0QTogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gcG9vbEFzc2V0OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyB0eEFzc2V0QkRlcG9zaXQ6IHR4bgoJdHhuIEdyb3VwSW5kZXgKCWludCAxCgktCgoJLy8gdHhBc3NldEFEZXBvc2l0OiB0eG4KCXR4biBHcm91cEluZGV4CglpbnQgMgoJLQoKCS8vIGV4ZWN1dGUgYWRkTGlxdWlkaXR5KHR4bix0eG4sdWludDY0LHVpbnQ2NCx1aW50NjQpdWludDY0CgljYWxsc3ViIGFkZExpcXVpZGl0eQoJaXRvYgoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGFkZExpcXVpZGl0eSh0eEFzc2V0QURlcG9zaXQ6IFR4biwgdHhBc3NldEJEZXBvc2l0OiBUeG4sIHBvb2xBc3NldDogQXNzZXRJRCwgYXNzZXRBOiBBc3NldElELCBhc3NldEI6IEFzc2V0SUQpOiB1aW50NjQKLy8KLy8gVGhpcyBtZXRob2QgYWRkcyBBc3NldCBBIGFuZCBBc3NldCBCIHRvIHRoZSBBdXRvbWF0ZWQgTWFya2V0IE1ha2VyIENvbmNlbnRyYXRlZCBMaXF1ZGlkaXR5IFBvb2wgYW5kIHNlbmQgdG8gdGhlIGxpcXVkaWR0eSBwcm92aWRlciB0aGUgbGlxdWRpdHkgdG9rZW4KLy8gQHBhcmFtIHR4QXNzZXRBRGVwb3NpdCBUcmFuc2ZlciBvZiBhc3NldCBBIHRvIHRoZSBMUCBwb29sCi8vIEBwYXJhbSB0eEFzc2V0QkRlcG9zaXQgVHJhbnNmZXIgb2YgYXNzZXQgQiB0byB0aGUgTFAgcG9vbAovLyBAcGFyYW0gcG9vbEFzc2V0IExQIHBvb2wgYXNzZXQKLy8gQHBhcmFtIGFzc2V0QSBBc3NldCBBCi8vIEBwYXJhbSBhc3NldEIgQXNzZXQgQgovLyBAcmV0dXJucyBMUCBUb2tlbiBxdWFudGl0eSBkaXN0cmlidXRlZAphZGRMaXF1aWRpdHk6Cglwcm90byA1IDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwbiAyCgoJLy8gd2VsbCBmb3JtZWQgbWludAoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MjAyCgkvLyBhc3NlcnQoYXNzZXRBID09PSB0aGlzLmFzc2V0QS52YWx1ZSkKCWZyYW1lX2RpZyAtNCAvLyBhc3NldEE6IEFzc2V0SUQKCWJ5dGUgMHg2MSAvLyAiYSIKCWFwcF9nbG9iYWxfZ2V0Cgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MjAzCgkvLyBhc3NlcnQoYXNzZXRCID09PSB0aGlzLmFzc2V0Qi52YWx1ZSkKCWZyYW1lX2RpZyAtNSAvLyBhc3NldEI6IEFzc2V0SUQKCWJ5dGUgMHg2MiAvLyAiYiIKCWFwcF9nbG9iYWxfZ2V0Cgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MjA0CgkvLyBhc3NlcnQocG9vbEFzc2V0ID09PSB0aGlzLnBvb2xUb2tlbi52YWx1ZSkKCWZyYW1lX2RpZyAtMyAvLyBwb29sQXNzZXQ6IEFzc2V0SUQKCWJ5dGUgMHg3MCAvLyAicCIKCWFwcF9nbG9iYWxfZ2V0Cgk9PQoJYXNzZXJ0CgoJLy8gKmlmMV9jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjIxMgoJLy8gdHJ1ZQoJaW50IDEKCWJ6ICppZjFfZW5kCgoJLy8gKmlmMV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoyMTMKCS8vIHhmZXIgPSB0eEFzc2V0QURlcG9zaXQgYXMgQXNzZXRUcmFuc2ZlclR4bgoJZnJhbWVfZGlnIC0xIC8vIHR4QXNzZXRBRGVwb3NpdDogVHhuCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnQgYXhmZXIKCT09Cglhc3NlcnQKCWZyYW1lX2J1cnkgMCAvLyB4ZmVyOiBheGZlcgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjIxNAoJLy8gdmVyaWZ5QXNzZXRUcmFuc2ZlclR4bih4ZmVyLCB7CgkvLyAgICAgICAgIGFzc2V0UmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MsCgkvLyAgICAgICAgIHhmZXJBc3NldDogYXNzZXRBLAoJLy8gICAgICAgICBhc3NldEFtb3VudDogeyBncmVhdGVyVGhhbkVxdWFsVG86IDAgfSwKCS8vICAgICAgIH0pCgkvLyB2ZXJpZnkgYXhmZXIKCWZyYW1lX2RpZyAwIC8vIHhmZXI6IGF4ZmVyCglndHhucyBUeXBlRW51bQoJaW50IGF4ZmVyCgk9PQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IGFzc2V0UmVjZWl2ZXIKCWZyYW1lX2RpZyAwIC8vIHhmZXI6IGF4ZmVyCglndHhucyBBc3NldFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSB4ZmVyQXNzZXQKCWZyYW1lX2RpZyAwIC8vIHhmZXI6IGF4ZmVyCglndHhucyBYZmVyQXNzZXQKCWZyYW1lX2RpZyAtNCAvLyBhc3NldEE6IEFzc2V0SUQKCT09Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYXNzZXRBbW91bnQKCWZyYW1lX2RpZyAwIC8vIHhmZXI6IGF4ZmVyCglndHhucyBBc3NldEFtb3VudAoJaW50IDAKCT49Cglhc3NlcnQKCippZjFfZW5kOgoJLy8gKmlmMl9jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjIyOQoJLy8gdHJ1ZQoJaW50IDEKCWJ6ICppZjJfZW5kCgoJLy8gKmlmMl9jb25zZXF1ZW50CgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoyMzAKCS8vIHhmZXIgPSB0eEFzc2V0QkRlcG9zaXQgYXMgQXNzZXRUcmFuc2ZlclR4bgoJZnJhbWVfZGlnIC0yIC8vIHR4QXNzZXRCRGVwb3NpdDogVHhuCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnQgYXhmZXIKCT09Cglhc3NlcnQKCWZyYW1lX2J1cnkgMSAvLyB4ZmVyOiBheGZlcgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjIzMQoJLy8gdmVyaWZ5QXNzZXRUcmFuc2ZlclR4bih4ZmVyLCB7CgkvLyAgICAgICAgIGFzc2V0UmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MsCgkvLyAgICAgICAgIHhmZXJBc3NldDogYXNzZXRCLAoJLy8gICAgICAgICBhc3NldEFtb3VudDogeyBncmVhdGVyVGhhbkVxdWFsVG86IDAgfSwKCS8vICAgICAgIH0pCgkvLyB2ZXJpZnkgYXhmZXIKCWZyYW1lX2RpZyAxIC8vIHhmZXI6IGF4ZmVyCglndHhucyBUeXBlRW51bQoJaW50IGF4ZmVyCgk9PQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IGFzc2V0UmVjZWl2ZXIKCWZyYW1lX2RpZyAxIC8vIHhmZXI6IGF4ZmVyCglndHhucyBBc3NldFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSB4ZmVyQXNzZXQKCWZyYW1lX2RpZyAxIC8vIHhmZXI6IGF4ZmVyCglndHhucyBYZmVyQXNzZXQKCWZyYW1lX2RpZyAtNSAvLyBhc3NldEI6IEFzc2V0SUQKCT09Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYXNzZXRBbW91bnQKCWZyYW1lX2RpZyAxIC8vIHhmZXI6IGF4ZmVyCglndHhucyBBc3NldEFtb3VudAoJaW50IDAKCT49Cglhc3NlcnQKCippZjJfZW5kOgoJLy8gKmlmM19jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjI0MAoJLy8gdGhpcy5hcHAuYWRkcmVzcy5hc3NldEJhbGFuY2UoYXNzZXRBKSA9PT0gdHhBc3NldEFEZXBvc2l0LmFzc2V0QW1vdW50ICYmCgkvLyAgICAgICB0aGlzLmFwcC5hZGRyZXNzLmFzc2V0QmFsYW5jZShhc3NldEIpID09PSB0eEFzc2V0QkRlcG9zaXQuYXNzZXRBbW91bnQKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglmcmFtZV9kaWcgLTQgLy8gYXNzZXRBOiBBc3NldElECglhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKCXBvcAoJZnJhbWVfZGlnIC0xIC8vIHR4QXNzZXRBRGVwb3NpdDogVHhuCglndHhucyBBc3NldEFtb3VudAoJPT0KCWR1cAoJYnogKnNraXBfYW5kMAoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWZyYW1lX2RpZyAtNSAvLyBhc3NldEI6IEFzc2V0SUQKCWFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQoJcG9wCglmcmFtZV9kaWcgLTIgLy8gdHhBc3NldEJEZXBvc2l0OiBUeG4KCWd0eG5zIEFzc2V0QW1vdW50Cgk9PQoJJiYKCipza2lwX2FuZDA6CglieiAqaWYzX2VuZAoKCS8vICppZjNfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MjQ3CgkvLyB0aGlzLmFzc2V0QUJhbGFuY2UudmFsdWUgPSB0eEFzc2V0QURlcG9zaXQuYXNzZXRBbW91bnQKCWJ5dGUgMHg2MTYyIC8vICJhYiIKCWZyYW1lX2RpZyAtMSAvLyB0eEFzc2V0QURlcG9zaXQ6IFR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MjQ4CgkvLyB0aGlzLmFzc2V0QkJhbGFuY2UudmFsdWUgPSB0eEFzc2V0QkRlcG9zaXQuYXNzZXRBbW91bnQKCWJ5dGUgMHg2MjYyIC8vICJiYiIKCWZyYW1lX2RpZyAtMiAvLyB0eEFzc2V0QkRlcG9zaXQ6IFR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MjQ5CgkvLyB0b01pbnQgPSB0aGlzLmNhbGN1bGF0ZUwodGhpcy5hc3NldEFCYWxhbmNlLnZhbHVlLCB0aGlzLmFzc2V0QkJhbGFuY2UudmFsdWUpCglieXRlIDB4NjI2MiAvLyAiYmIiCglhcHBfZ2xvYmFsX2dldAoJYnl0ZSAweDYxNjIgLy8gImFiIgoJYXBwX2dsb2JhbF9nZXQKCWNhbGxzdWIgY2FsY3VsYXRlTAoJZnJhbWVfYnVyeSAyIC8vIHRvTWludDogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MjUwCgkvLyB0aGlzLkxpcXVkaXR5LnZhbHVlID0gdG9NaW50CglieXRlIDB4NGMgLy8gIkwiCglmcmFtZV9kaWcgMiAvLyB0b01pbnQ6IHVpbnQ2NAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoyNTMKCS8vIHJldHVybiB0b01pbnQ7CglmcmFtZV9kaWcgMiAvLyB0b01pbnQ6IHVpbnQ2NAoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDIKCXJldHN1YgoKKmlmM19lbmQ6CgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoyNTUKCS8vIHJldHVybiAwOwoJaW50IDAKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiAyCglyZXRzdWIKCi8vIGNhbGN1bGF0ZUwoeDogdWludDY0LCB5OiB1aW50NjQpOiB1aW50NjQKY2FsY3VsYXRlTDoKCXByb3RvIDIgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CglkdXBuIDE1CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6Mjg3CgkvLyBEMTogdWludDY0ID0gKCgoeCAqIHgpIC8gU0NBTEUpICogdGhpcy5wcmljZU1heEEudmFsdWUpIC8gU0NBTEUKCWZyYW1lX2RpZyAtMSAvLyB4OiB1aW50NjQKCWZyYW1lX2RpZyAtMSAvLyB4OiB1aW50NjQKCSoKCWludCAxMDAwMDAwMDAwCgkvCglieXRlIDB4NzA2MSAvLyAicGEiCglhcHBfZ2xvYmFsX2dldAoJKgoJaW50IDEwMDAwMDAwMDAKCS8KCWZyYW1lX2J1cnkgMCAvLyBEMTogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6Mjg5CgkvLyBEMjogdWludDY0ID0gKHkgKiB5KSAvIHRoaXMucHJpY2VNYXhCLnZhbHVlCglmcmFtZV9kaWcgLTIgLy8geTogdWludDY0CglmcmFtZV9kaWcgLTIgLy8geTogdWludDY0CgkqCglieXRlIDB4NzA2MiAvLyAicGIiCglhcHBfZ2xvYmFsX2dldAoJLwoJZnJhbWVfYnVyeSAxIC8vIEQyOiB1aW50NjQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoyOTEKCS8vIEQzOiB1aW50NjQgPSAoKCgyICogeCAqIHkpIC8gU0NBTEUpICogdGhpcy5wcmljZU1heEFTcXJ0LnZhbHVlKSAvIFNDQUxFIC8gdGhpcy5wcmljZU1heEJTcXJ0LnZhbHVlCglpbnQgMgoJZnJhbWVfZGlnIC0xIC8vIHg6IHVpbnQ2NAoJKgoJZnJhbWVfZGlnIC0yIC8vIHk6IHVpbnQ2NAoJKgoJaW50IDEwMDAwMDAwMDAKCS8KCWJ5dGUgMHg3MDYxNzMgLy8gInBhcyIKCWFwcF9nbG9iYWxfZ2V0CgkqCglpbnQgMTAwMDAwMDAwMAoJLwoJYnl0ZSAweDcwNjI3MyAvLyAicGJzIgoJYXBwX2dsb2JhbF9nZXQKCS8KCWZyYW1lX2J1cnkgMiAvLyBEMzogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6Mjk0CgkvLyBENDogdWludDY0ID0gKDQgKiB4ICogeSkgLyBTQ0FMRQoJaW50IDQKCWZyYW1lX2RpZyAtMSAvLyB4OiB1aW50NjQKCSoKCWZyYW1lX2RpZyAtMiAvLyB5OiB1aW50NjQKCSoKCWludCAxMDAwMDAwMDAwCgkvCglmcmFtZV9idXJ5IDMgLy8gRDQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjI5NgoJLy8gRDU6IHVpbnQ2NCA9ICgoKDQgKiB4ICogeSkgLyBTQ0FMRSkgKiB0aGlzLnByaWNlTWF4QVNxcnQudmFsdWUpIC8gU0NBTEUgLyB0aGlzLnByaWNlTWF4QlNxcnQudmFsdWUKCWludCA0CglmcmFtZV9kaWcgLTEgLy8geDogdWludDY0CgkqCglmcmFtZV9kaWcgLTIgLy8geTogdWludDY0CgkqCglpbnQgMTAwMDAwMDAwMAoJLwoJYnl0ZSAweDcwNjE3MyAvLyAicGFzIgoJYXBwX2dsb2JhbF9nZXQKCSoKCWludCAxMDAwMDAwMDAwCgkvCglieXRlIDB4NzA2MjczIC8vICJwYnMiCglhcHBfZ2xvYmFsX2dldAoJLwoJZnJhbWVfYnVyeSA0IC8vIEQ1OiB1aW50NjQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czoyOTcKCS8vIEQgPSBEMSArIEQyICsgRDMgKyBENCAtIEQ1CglmcmFtZV9kaWcgMCAvLyBEMTogdWludDY0CglmcmFtZV9kaWcgMSAvLyBEMjogdWludDY0CgkrCglmcmFtZV9kaWcgMiAvLyBEMzogdWludDY0CgkrCglmcmFtZV9kaWcgMyAvLyBENDogdWludDY0CgkrCglmcmFtZV9kaWcgNCAvLyBENTogdWludDY0CgktCglmcmFtZV9idXJ5IDUgLy8gRDogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MzAyCgkvLyBMMTogdWludDY0ID0gKHggKiB0aGlzLnByaWNlTWF4QVNxcnQudmFsdWUpIC8gU0NBTEUKCWZyYW1lX2RpZyAtMSAvLyB4OiB1aW50NjQKCWJ5dGUgMHg3MDYxNzMgLy8gInBhcyIKCWFwcF9nbG9iYWxfZ2V0CgkqCglpbnQgMTAwMDAwMDAwMAoJLwoJZnJhbWVfYnVyeSA2IC8vIEwxOiB1aW50NjQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozMDQKCS8vIEwyOiB1aW50NjQgPSAoeSAqIFNDQUxFKSAvIHRoaXMucHJpY2VNYXhCU3FydC52YWx1ZQoJZnJhbWVfZGlnIC0yIC8vIHk6IHVpbnQ2NAoJaW50IDEwMDAwMDAwMDAKCSoKCWJ5dGUgMHg3MDYyNzMgLy8gInBicyIKCWFwcF9nbG9iYWxfZ2V0CgkvCglmcmFtZV9idXJ5IDcgLy8gTDI6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjMwNgoJLy8gTDM6IHVpbnQ2NCA9ICgyICogdGhpcy5wcmljZU1heEFTcXJ0LnZhbHVlICogU0NBTEUpIC8gdGhpcy5wcmljZU1heEJTcXJ0LnZhbHVlCglpbnQgMgoJYnl0ZSAweDcwNjE3MyAvLyAicGFzIgoJYXBwX2dsb2JhbF9nZXQKCSoKCWludCAxMDAwMDAwMDAwCgkqCglieXRlIDB4NzA2MjczIC8vICJwYnMiCglhcHBfZ2xvYmFsX2dldAoJLwoJZnJhbWVfYnVyeSA4IC8vIEwzOiB1aW50NjQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozMDkKCS8vIERfU1FSVCA9IHNxcnQoU0NBTEUgKiBEKQoJaW50IDEwMDAwMDAwMDAKCWZyYW1lX2RpZyA1IC8vIEQ6IHVpbnQ2NAoJKgoJc3FydAoJZnJhbWVfYnVyeSA5IC8vIERfU1FSVDogdWludDY0CgoJLy8gKmlmNF9jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjMxMQoJLy8gMiAqIFNDQUxFID4gTDMKCWludCAyMDAwMDAwMDAwCglmcmFtZV9kaWcgOCAvLyBMMzogdWludDY0Cgk+CglieiAqaWY0X2VuZAoKCS8vICppZjRfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MzEyCgkvLyBub206IHVpbnQ2NCA9IEwxICsgTDIgKyBEX1NRUlQKCWZyYW1lX2RpZyA2IC8vIEwxOiB1aW50NjQKCWZyYW1lX2RpZyA3IC8vIEwyOiB1aW50NjQKCSsKCWZyYW1lX2RpZyA5IC8vIERfU1FSVDogdWludDY0CgkrCglmcmFtZV9idXJ5IDEwIC8vIG5vbTogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MzEzCgkvLyBkZW46IHVpbnQ2NCA9IDIgKiBTQ0FMRSAtIEwzCglpbnQgMjAwMDAwMDAwMAoJZnJhbWVfZGlnIDggLy8gTDM6IHVpbnQ2NAoJLQoJZnJhbWVfYnVyeSAxMSAvLyBkZW46IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjMxNAoJLy8gcmV0OiB1aW50NjQgPSAoU0NBTEUgKiBub20pIC8gZGVuCglpbnQgMTAwMDAwMDAwMAoJZnJhbWVfZGlnIDEwIC8vIG5vbTogdWludDY0CgkqCglmcmFtZV9kaWcgMTEgLy8gZGVuOiB1aW50NjQKCS8KCWZyYW1lX2J1cnkgMTIgLy8gcmV0OiB1aW50NjQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozMTUKCS8vIHJldHVybiByZXQ7CglmcmFtZV9kaWcgMTIgLy8gcmV0OiB1aW50NjQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiAxMgoJcmV0c3ViCgoqaWY0X2VuZDoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjMxNwoJLy8gbm9tOiB1aW50NjQgPSBMMSArIEwyIC0gRF9TUVJUCglmcmFtZV9kaWcgNiAvLyBMMTogdWludDY0CglmcmFtZV9kaWcgNyAvLyBMMjogdWludDY0CgkrCglmcmFtZV9kaWcgOSAvLyBEX1NRUlQ6IHVpbnQ2NAoJLQoJZnJhbWVfYnVyeSAxMyAvLyBub206IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjMxOAoJLy8gZGVuOiB1aW50NjQgPSBMMyAtIDIgKiBTQ0FMRQoJZnJhbWVfZGlnIDggLy8gTDM6IHVpbnQ2NAoJaW50IDIwMDAwMDAwMDAKCS0KCWZyYW1lX2J1cnkgMTQgLy8gZGVuOiB1aW50NjQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozMTkKCS8vIHJldDogdWludDY0ID0gKFNDQUxFICogbm9tKSAvIGRlbgoJaW50IDEwMDAwMDAwMDAKCWZyYW1lX2RpZyAxMyAvLyBub206IHVpbnQ2NAoJKgoJZnJhbWVfZGlnIDE0IC8vIGRlbjogdWludDY0CgkvCglmcmFtZV9idXJ5IDE1IC8vIHJldDogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MzIwCgkvLyByZXR1cm4gcmV0OwoJZnJhbWVfZGlnIDE1IC8vIHJldDogdWludDY0CgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMTUKCXJldHN1YgoKLy8gZ2V0SHlwb3RoZXRpY1ByaWNlKHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCl1aW50NjQKKmFiaV9yb3V0ZV9nZXRIeXBvdGhldGljUHJpY2U6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIGFzc2V0QkRlY2ltYWxzOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDcKCWJ0b2kKCgkvLyBhc3NldEFEZWNpbWFsczogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA2CglidG9pCgoJLy8gbGlxdWlkaXR5OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDUKCWJ0b2kKCgkvLyBwcmljZU1heEJTcXJ0OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDQKCWJ0b2kKCgkvLyBwcmljZU1heEFTcXJ0OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWJ0b2kKCgkvLyBhc3NldEJRdWFudGl0eTogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gYXNzZXRBUXVhbnRpdHk6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgZ2V0SHlwb3RoZXRpY1ByaWNlKHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCl1aW50NjQKCWNhbGxzdWIgZ2V0SHlwb3RoZXRpY1ByaWNlCglpdG9iCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gZ2V0SHlwb3RoZXRpY1ByaWNlKGFzc2V0QVF1YW50aXR5OiB1aW50NjQsIGFzc2V0QlF1YW50aXR5OiB1aW50NjQsIHByaWNlTWF4QVNxcnQ6IHVpbnQ2NCwgcHJpY2VNYXhCU3FydDogdWludDY0LCBsaXF1aWRpdHk6IHVpbnQ2NCwgYXNzZXRBRGVjaW1hbHM6IHVpbnQ2NCwgYXNzZXRCRGVjaW1hbHM6IHVpbnQ2NCk6IHVpbnQ2NAovLwovLyBHZXQgdGhlIGN1cnJlbnQgcHJpY2Ugd2hlbiBhc3NldCBhIGhhcyB4Ci8vIEBwYXJhbSBhc3NldEFRdWFudGl0eSB4Ci8vIEBwYXJhbSBhc3NldEJRdWFudGl0eSB5Ci8vIEByZXR1cm5zIHRoZSBwcmljZSB3aXRoIHNwZWNpZmllZCBxdWFudGl0eSB3aXRoIHRoZSBwcmljZSByYW5nZSBzZXQgaW4gdGhlIGNvbnRyYWN0CmdldEh5cG90aGV0aWNQcmljZToKCXByb3RvIDcgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CglkdXBuIDgKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozNDMKCS8vIGFzc2V0QURlbGljbWFsU2NhbGUyU2NhbGU6IHVpbnQ2NCA9IDEwICoqIChTQ0FMRV9ERUNJTUFMUyAtIGFzc2V0QURlY2ltYWxzKQoJaW50IDEwCglpbnQgOQoJZnJhbWVfZGlnIC02IC8vIGFzc2V0QURlY2ltYWxzOiB1aW50NjQKCS0KCWV4cAoJZnJhbWVfYnVyeSAwIC8vIGFzc2V0QURlbGljbWFsU2NhbGUyU2NhbGU6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjM0NAoJLy8gYXNzZXRCRGVsaWNtYWxTY2FsZTJTY2FsZTogdWludDY0ID0gMTAgKiogKFNDQUxFX0RFQ0lNQUxTIC0gYXNzZXRCRGVjaW1hbHMpCglpbnQgMTAKCWludCA5CglmcmFtZV9kaWcgLTcgLy8gYXNzZXRCRGVjaW1hbHM6IHVpbnQ2NAoJLQoJZXhwCglmcmFtZV9idXJ5IDEgLy8gYXNzZXRCRGVsaWNtYWxTY2FsZTJTY2FsZTogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MzQ1CgkvLyBhOiB1aW50NjQgPSBwcmljZU1heEFTcXJ0CglmcmFtZV9kaWcgLTMgLy8gcHJpY2VNYXhBU3FydDogdWludDY0CglmcmFtZV9idXJ5IDIgLy8gYTogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MzQ2CgkvLyBiOiB1aW50NjQgPSBwcmljZU1heEJTcXJ0CglmcmFtZV9kaWcgLTQgLy8gcHJpY2VNYXhCU3FydDogdWludDY0CglmcmFtZV9idXJ5IDMgLy8gYjogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MzQ3CgkvLyBQMTogdWludDY0ID0gKGxpcXVpZGl0eSAqIGEpIC8gU0NBTEUKCWZyYW1lX2RpZyAtNSAvLyBsaXF1aWRpdHk6IHVpbnQ2NAoJZnJhbWVfZGlnIDIgLy8gYTogdWludDY0CgkqCglpbnQgMTAwMDAwMDAwMAoJLwoJZnJhbWVfYnVyeSA0IC8vIFAxOiB1aW50NjQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozNDgKCS8vIFAyOiB1aW50NjQgPSAobGlxdWlkaXR5ICogU0NBTEUpIC8gYgoJZnJhbWVfZGlnIC01IC8vIGxpcXVpZGl0eTogdWludDY0CglpbnQgMTAwMDAwMDAwMAoJKgoJZnJhbWVfZGlnIDMgLy8gYjogdWludDY0CgkvCglmcmFtZV9idXJ5IDUgLy8gUDI6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjM0OQoJLy8gTm9tOiB1aW50NjQgPSBhc3NldEJRdWFudGl0eSAqIGFzc2V0QkRlbGljbWFsU2NhbGUyU2NhbGUgKyBQMQoJZnJhbWVfZGlnIC0yIC8vIGFzc2V0QlF1YW50aXR5OiB1aW50NjQKCWZyYW1lX2RpZyAxIC8vIGFzc2V0QkRlbGljbWFsU2NhbGUyU2NhbGU6IHVpbnQ2NAoJKgoJZnJhbWVfZGlnIDQgLy8gUDE6IHVpbnQ2NAoJKwoJZnJhbWVfYnVyeSA2IC8vIE5vbTogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MzUwCgkvLyBEZW5vbTogdWludDY0ID0gYXNzZXRBUXVhbnRpdHkgKiBhc3NldEFEZWxpY21hbFNjYWxlMlNjYWxlICsgUDIKCWZyYW1lX2RpZyAtMSAvLyBhc3NldEFRdWFudGl0eTogdWludDY0CglmcmFtZV9kaWcgMCAvLyBhc3NldEFEZWxpY21hbFNjYWxlMlNjYWxlOiB1aW50NjQKCSoKCWZyYW1lX2RpZyA1IC8vIFAyOiB1aW50NjQKCSsKCWZyYW1lX2J1cnkgNyAvLyBEZW5vbTogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MzUxCgkvLyByZXQgPSAoTm9tICogU0NBTEUpIC8gRGVub20KCWZyYW1lX2RpZyA2IC8vIE5vbTogdWludDY0CglpbnQgMTAwMDAwMDAwMAoJKgoJZnJhbWVfZGlnIDcgLy8gRGVub206IHVpbnQ2NAoJLwoJZnJhbWVfYnVyeSA4IC8vIHJldDogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6MzUyCgkvLyByZXR1cm4gcmV0OwoJZnJhbWVfZGlnIDggLy8gcmV0OiB1aW50NjQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiA4CglyZXRzdWIKCi8vIHJlbW92ZUxpcXVpZGl0eShheGZlcix1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkCiphYmlfcm91dGVfcmVtb3ZlTGlxdWlkaXR5OgoJLy8gYXNzZXRCOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWJ0b2kKCgkvLyBhc3NldEE6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIHBvb2xBc3NldDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gdHhMUFhmZXI6IGF4ZmVyCgl0eG4gR3JvdXBJbmRleAoJaW50IDEKCS0KCWR1cAoJZ3R4bnMgVHlwZUVudW0KCWludCBheGZlcgoJPT0KCWFzc2VydAoKCS8vIGV4ZWN1dGUgcmVtb3ZlTGlxdWlkaXR5KGF4ZmVyLHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQKCWNhbGxzdWIgcmVtb3ZlTGlxdWlkaXR5CglpbnQgMQoJcmV0dXJuCgovLyByZW1vdmVMaXF1aWRpdHkodHhMUFhmZXI6IEFzc2V0VHJhbnNmZXJUeG4sIHBvb2xBc3NldDogQXNzZXRJRCwgYXNzZXRBOiBBc3NldElELCBhc3NldEI6IEFzc2V0SUQpOiB2b2lkCi8vCi8vIFRoaXMgbWV0aG9kIHJldHJpZXZlcyBmcm9tIHRoZSBsaXF1aWRpdHkgcHJvdmlkZXIgTFAgdG9rZW4gYW5kIHJldHVybnMgQXNzZXQgQSBhbmQgQXNzZXQgQiBmcm9tIHRoZSBBdXRvbWF0ZWQgTWFya2V0IE1ha2VyIENvbmNlbnRyYXRlZCBMaXF1ZGlkaXR5IFBvb2wKLy8gQHBhcmFtIHR4TFBYZmVyIFRyYW5zZmVyIG9mIHRoZSBMUCB0b2tlbgovLyBAcGFyYW0gcG9vbEFzc2V0IExQIHBvb2wgYXNzZXQKLy8gQHBhcmFtIGFzc2V0QSBBc3NldCBBCi8vIEBwYXJhbSBhc3NldEIgQXNzZXQgQgpyZW1vdmVMaXF1aWRpdHk6Cglwcm90byA0IDAKCgkvLyB3ZWxsIGZvcm1lZCBtaW50CgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozNjQKCS8vIGFzc2VydChhc3NldEEgPT09IHRoaXMuYXNzZXRBLnZhbHVlKQoJZnJhbWVfZGlnIC0zIC8vIGFzc2V0QTogQXNzZXRJRAoJYnl0ZSAweDYxIC8vICJhIgoJYXBwX2dsb2JhbF9nZXQKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozNjUKCS8vIGFzc2VydChhc3NldEIgPT09IHRoaXMuYXNzZXRCLnZhbHVlKQoJZnJhbWVfZGlnIC00IC8vIGFzc2V0QjogQXNzZXRJRAoJYnl0ZSAweDYyIC8vICJiIgoJYXBwX2dsb2JhbF9nZXQKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozNjYKCS8vIGFzc2VydChwb29sQXNzZXQgPT09IHRoaXMucG9vbFRva2VuLnZhbHVlKQoJZnJhbWVfZGlnIC0yIC8vIHBvb2xBc3NldDogQXNzZXRJRAoJYnl0ZSAweDcwIC8vICJwIgoJYXBwX2dsb2JhbF9nZXQKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozNjgKCS8vIHZlcmlmeUFzc2V0VHJhbnNmZXJUeG4odHhMUFhmZXIsIHsKCS8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MsCgkvLyAgICAgICB4ZmVyQXNzZXQ6IHBvb2xBc3NldCwKCS8vICAgICAgIGFzc2V0QW1vdW50OiB7IGdyZWF0ZXJUaGFuRXF1YWxUbzogMCB9LAoJLy8gICAgIH0pCgkvLyB2ZXJpZnkgYXNzZXRSZWNlaXZlcgoJZnJhbWVfZGlnIC0xIC8vIHR4TFBYZmVyOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBBc3NldFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSB4ZmVyQXNzZXQKCWZyYW1lX2RpZyAtMSAvLyB0eExQWGZlcjogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgWGZlckFzc2V0CglmcmFtZV9kaWcgLTIgLy8gcG9vbEFzc2V0OiBBc3NldElECgk9PQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IGFzc2V0QW1vdW50CglmcmFtZV9kaWcgLTEgLy8gdHhMUFhmZXI6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIEFzc2V0QW1vdW50CglpbnQgMAoJPj0KCWFzc2VydAoJZXJyCgovLyBzd2FwKGF4ZmVyLHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQKKmFiaV9yb3V0ZV9zd2FwOgoJLy8gbWluaW11bVRvUmVjZWl2ZTogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglidG9pCgoJLy8gYXNzZXRCOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyBhc3NldEE6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIHR4U3dhcDogYXhmZXIKCXR4biBHcm91cEluZGV4CglpbnQgMQoJLQoJZHVwCglndHhucyBUeXBlRW51bQoJaW50IGF4ZmVyCgk9PQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBzd2FwKGF4ZmVyLHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQKCWNhbGxzdWIgc3dhcAoJaW50IDEKCXJldHVybgoKLy8gc3dhcCh0eFN3YXA6IEFzc2V0VHJhbnNmZXJUeG4sIGFzc2V0QTogQXNzZXRJRCwgYXNzZXRCOiBBc3NldElELCBtaW5pbXVtVG9SZWNlaXZlOiB1aW50NjQpOiB2b2lkCi8vCi8vIFN3YXAgQXNzZXQgQSB0byBBc3NldCBCIG9yIEFzc2V0IEIgdG8gQXNzdCBBCi8vIEBwYXJhbSB0eFN3YXAgVHJhbnNmZXIgb2YgdGhlIHRva2VuIHRvIGJlIGRlcG9zaXRlZCB0byB0aGUgcG9vbC4gVG8gdGhlIG93bmVyIHRoZSBvdGhlciBhc3NldCB3aWxsIGJlIHNlbnQuCi8vIEBwYXJhbSBhc3NldEEgQXNzZXQgQQovLyBAcGFyYW0gYXNzZXRCIEFzc2V0IEIKLy8gQHBhcmFtIG1pbmltdW1Ub1JlY2VpdmUgSWYgbnVtYmVyIGdyZWF0ZXIgdGhlbiB6ZXJvLCB0aGUgY2hlY2sgaXMgcGVyZm9ybWVkIGZvciB0aGUgb3V0cHV0IG9mIHRoZSBvdGhlciBhc3NldApzd2FwOgoJcHJvdG8gNCAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCgkvLyB3ZWxsIGZvcm1lZCBzd2FwCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozODYKCS8vIGFzc2VydChhc3NldEEgPT09IHRoaXMuYXNzZXRBLnZhbHVlKQoJZnJhbWVfZGlnIC0yIC8vIGFzc2V0QTogQXNzZXRJRAoJYnl0ZSAweDYxIC8vICJhIgoJYXBwX2dsb2JhbF9nZXQKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozODcKCS8vIGFzc2VydChhc3NldEIgPT09IHRoaXMuYXNzZXRCLnZhbHVlKQoJZnJhbWVfZGlnIC0zIC8vIGFzc2V0QjogQXNzZXRJRAoJYnl0ZSAweDYyIC8vICJiIgoJYXBwX2dsb2JhbF9nZXQKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozODkKCS8vIHZlcmlmeUFzc2V0VHJhbnNmZXJUeG4odHhTd2FwLCB7CgkvLyAgICAgICBhc3NldEFtb3VudDogeyBncmVhdGVyVGhhbjogMCB9LAoJLy8gICAgICAgYXNzZXRSZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgIHNlbmRlcjogdGhpcy50eG4uc2VuZGVyLAoJLy8gICAgICAgeGZlckFzc2V0OiB7IGluY2x1ZGVkSW46IFthc3NldEEsIGFzc2V0Ql0gfSwKCS8vICAgICB9KQoJLy8gdmVyaWZ5IGFzc2V0QW1vdW50CglmcmFtZV9kaWcgLTEgLy8gdHhTd2FwOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBBc3NldEFtb3VudAoJaW50IDAKCT4KCWFzc2VydAoKCS8vIHZlcmlmeSBhc3NldFJlY2VpdmVyCglmcmFtZV9kaWcgLTEgLy8gdHhTd2FwOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBBc3NldFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSBzZW5kZXIKCWZyYW1lX2RpZyAtMSAvLyB0eFN3YXA6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIFNlbmRlcgoJdHhuIFNlbmRlcgoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSB4ZmVyQXNzZXQKCWZyYW1lX2RpZyAtMSAvLyB0eFN3YXA6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIFhmZXJBc3NldAoJZnJhbWVfZGlnIC0yIC8vIGFzc2V0QTogQXNzZXRJRAoJPT0KCWZyYW1lX2RpZyAtMSAvLyB0eFN3YXA6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIFhmZXJBc3NldAoJZnJhbWVfZGlnIC0zIC8vIGFzc2V0QjogQXNzZXRJRAoJPT0KCXx8Cglhc3NlcnQKCgkvLyAqaWY1X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6Mzk2CgkvLyB0eFN3YXAueGZlckFzc2V0ID09PSBhc3NldEEKCWZyYW1lX2RpZyAtMSAvLyB0eFN3YXA6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIFhmZXJBc3NldAoJZnJhbWVfZGlnIC0yIC8vIGFzc2V0QTogQXNzZXRJRAoJPT0KCWJ6ICppZjVfZW5kCgoJLy8gKmlmNV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozOTcKCS8vIHRvU3dhcCA9IHRoaXMuY2FsY3VsYXRlQXNzZXRCV2l0aGRyYXdPbkFzc2V0QURlcG9zaXQodHhTd2FwLmFzc2V0QW1vdW50LCBhc3NldEEuZGVjaW1hbHMsIGFzc2V0Qi5kZWNpbWFscykKCWZyYW1lX2RpZyAtMyAvLyBhc3NldEI6IEFzc2V0SUQKCWFzc2V0X3BhcmFtc19nZXQgQXNzZXREZWNpbWFscwoJcG9wCglmcmFtZV9kaWcgLTIgLy8gYXNzZXRBOiBBc3NldElECglhc3NldF9wYXJhbXNfZ2V0IEFzc2V0RGVjaW1hbHMKCXBvcAoJZnJhbWVfZGlnIC0xIC8vIHR4U3dhcDogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCWNhbGxzdWIgY2FsY3VsYXRlQXNzZXRCV2l0aGRyYXdPbkFzc2V0QURlcG9zaXQKCWZyYW1lX2J1cnkgMCAvLyB0b1N3YXA6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjM5OAoJLy8gYXNzZXJ0KG1pbmltdW1Ub1JlY2VpdmUgPj0gdG9Td2FwKQoJZnJhbWVfZGlnIC00IC8vIG1pbmltdW1Ub1JlY2VpdmU6IHVpbnQ2NAoJZnJhbWVfZGlnIDAgLy8gdG9Td2FwOiB1aW50NjQKCT49Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czozOTkKCS8vIHRoaXMuZG9BeGZlcih0aGlzLnR4bi5zZW5kZXIsIGFzc2V0QiwgdG9Td2FwKQoJZnJhbWVfZGlnIDAgLy8gdG9Td2FwOiB1aW50NjQKCWZyYW1lX2RpZyAtMyAvLyBhc3NldEI6IEFzc2V0SUQKCXR4biBTZW5kZXIKCWNhbGxzdWIgZG9BeGZlcgoKKmlmNV9lbmQ6CglyZXRzdWIKCi8vIGNhbGN1bGF0ZUFzc2V0QldpdGhkcmF3T25Bc3NldEFEZXBvc2l0KHVpbnQ2NCx1aW50NjQsdWludDY0KXVpbnQ2NAoqYWJpX3JvdXRlX2NhbGN1bGF0ZUFzc2V0QldpdGhkcmF3T25Bc3NldEFEZXBvc2l0OgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBhc3NldEJEZWNpbWFsczogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglidG9pCgoJLy8gYXNzZXRBRGVjaW1hbHM6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIGluQW1vdW50OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGNhbGN1bGF0ZUFzc2V0QldpdGhkcmF3T25Bc3NldEFEZXBvc2l0KHVpbnQ2NCx1aW50NjQsdWludDY0KXVpbnQ2NAoJY2FsbHN1YiBjYWxjdWxhdGVBc3NldEJXaXRoZHJhd09uQXNzZXRBRGVwb3NpdAoJaXRvYgoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGNhbGN1bGF0ZUFzc2V0QldpdGhkcmF3T25Bc3NldEFEZXBvc2l0KGluQW1vdW50OiB1aW50NjQsIGFzc2V0QURlY2ltYWxzOiB1aW50NjQsIGFzc2V0QkRlY2ltYWxzOiB1aW50NjQpOiB1aW50NjQKY2FsY3VsYXRlQXNzZXRCV2l0aGRyYXdPbkFzc2V0QURlcG9zaXQ6Cglwcm90byAzIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwbiAxMwoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQyNAoJLy8gYXNzZXRBRGVsaWNtYWxTY2FsZTogdWludDY0ID0gMTAgKiogYXNzZXRBRGVjaW1hbHMKCWludCAxMAoJZnJhbWVfZGlnIC0yIC8vIGFzc2V0QURlY2ltYWxzOiB1aW50NjQKCWV4cAoJZnJhbWVfYnVyeSAwIC8vIGFzc2V0QURlbGljbWFsU2NhbGU6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQyNQoJLy8gYXNzZXRCRGVsaWNtYWxTY2FsZTogdWludDY0ID0gMTAgKiogYXNzZXRCRGVjaW1hbHMKCWludCAxMAoJZnJhbWVfZGlnIC0zIC8vIGFzc2V0QkRlY2ltYWxzOiB1aW50NjQKCWV4cAoJZnJhbWVfYnVyeSAxIC8vIGFzc2V0QkRlbGljbWFsU2NhbGU6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQyNwoJLy8geDogdWludDY0ID0gdGhpcy5hc3NldEFCYWxhbmNlLnZhbHVlCglieXRlIDB4NjE2MiAvLyAiYWIiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfYnVyeSAyIC8vIHg6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQyOAoJLy8geTogdWludDY0ID0gdGhpcy5hc3NldEJCYWxhbmNlLnZhbHVlCglieXRlIDB4NjI2MiAvLyAiYmIiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfYnVyeSAzIC8vIHk6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQyOQoJLy8gYTogdWludDY0ID0gdGhpcy5wcmljZU1heEFTcXJ0LnZhbHVlCglieXRlIDB4NzA2MTczIC8vICJwYXMiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfYnVyeSA0IC8vIGE6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQzMAoJLy8gYjogdWludDY0ID0gdGhpcy5wcmljZU1heEJTcXJ0LnZhbHVlCglieXRlIDB4NzA2MjczIC8vICJwYnMiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfYnVyeSA1IC8vIGI6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQzMQoJLy8gTDogdWludDY0ID0gdGhpcy5MaXF1ZGl0eS52YWx1ZQoJYnl0ZSAweDRjIC8vICJMIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2J1cnkgNiAvLyBMOiB1aW50NjQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo0MzMKCS8vIFAxOiB1aW50NjQgPQoJLy8gICAgICAgKCgoKChhIC8qIDEwRCAqLyAqIGIpIC8qIDEwRCAqLyAvIFNDQUxFKSAqIGluQW1vdW50KSAvKiBBRCAqLyAvIFNDQUxFKSAqIEwpIC8qIDEwRCAqLyAvIGFzc2V0QURlbGljbWFsU2NhbGUKCWZyYW1lX2RpZyA0IC8vIGE6IHVpbnQ2NAoJZnJhbWVfZGlnIDUgLy8gYjogdWludDY0CgkqCglpbnQgMTAwMDAwMDAwMAoJLwoJZnJhbWVfZGlnIC0xIC8vIGluQW1vdW50OiB1aW50NjQKCSoKCWludCAxMDAwMDAwMDAwCgkvCglmcmFtZV9kaWcgNiAvLyBMOiB1aW50NjQKCSoKCWZyYW1lX2RpZyAwIC8vIGFzc2V0QURlbGljbWFsU2NhbGU6IHVpbnQ2NAoJLwoJZnJhbWVfYnVyeSA3IC8vIFAxOiB1aW50NjQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo0MzYKCS8vIFAyOiB1aW50NjQgPSAoKChiIC8qIDEwRCAqLyAqIGluQW1vdW50KSAvKiBBRCAqLyAvIGFzc2V0QURlbGljbWFsU2NhbGUpICogeSkgLyogQkQgKi8gLyBTQ0FMRQoJZnJhbWVfZGlnIDUgLy8gYjogdWludDY0CglmcmFtZV9kaWcgLTEgLy8gaW5BbW91bnQ6IHVpbnQ2NAoJKgoJZnJhbWVfZGlnIDAgLy8gYXNzZXRBRGVsaWNtYWxTY2FsZTogdWludDY0CgkvCglmcmFtZV9kaWcgMyAvLyB5OiB1aW50NjQKCSoKCWludCAxMDAwMDAwMDAwCgkvCglmcmFtZV9idXJ5IDggLy8gUDI6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQzOAoJLy8gUDM6IHVpbnQ2NCA9IChiIC8qIDEwRCAqLyAqIGluQW1vdW50KSAvKiBBRCAqLyAvIGFzc2V0QURlbGljbWFsU2NhbGUKCWZyYW1lX2RpZyA1IC8vIGI6IHVpbnQ2NAoJZnJhbWVfZGlnIC0xIC8vIGluQW1vdW50OiB1aW50NjQKCSoKCWZyYW1lX2RpZyAwIC8vIGFzc2V0QURlbGljbWFsU2NhbGU6IHVpbnQ2NAoJLwoJZnJhbWVfYnVyeSA5IC8vIFAzOiB1aW50NjQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo0NDAKCS8vIFA0OiB1aW50NjQgPSAoYiAvKiAxMEQgKi8gKiB4KSAvKiAxMEQgKi8gLyBTQ0FMRQoJZnJhbWVfZGlnIDUgLy8gYjogdWludDY0CglmcmFtZV9kaWcgMiAvLyB4OiB1aW50NjQKCSoKCWludCAxMDAwMDAwMDAwCgkvCglmcmFtZV9idXJ5IDEwIC8vIFA0OiB1aW50NjQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ0xBTU0uYWxnby50czo0NDIKCS8vIFAxMjogdWludDY0ID0gUDEgKyBQMgoJZnJhbWVfZGlnIDcgLy8gUDE6IHVpbnQ2NAoJZnJhbWVfZGlnIDggLy8gUDI6IHVpbnQ2NAoJKwoJZnJhbWVfYnVyeSAxMSAvLyBQMTI6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDTEFNTS5hbGdvLnRzOjQ0NAoJLy8gUDM0NTogdWludDY0ID0gUDMgKyBQNCArIEwKCWZyYW1lX2RpZyA5IC8vIFAzOiB1aW50NjQKCWZyYW1lX2RpZyAxMCAvLyBQNDogdWludDY0CgkrCglmcmFtZV9kaWcgNiAvLyBMOiB1aW50NjQKCSsKCWZyYW1lX2J1cnkgMTIgLy8gUDM0NTogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NDQ2CgkvLyByZXQ6IHVpbnQ2NCA9IChQMTIgKiBhc3NldEJEZWxpY21hbFNjYWxlKSAvIFAzNDUKCWZyYW1lX2RpZyAxMSAvLyBQMTI6IHVpbnQ2NAoJZnJhbWVfZGlnIDEgLy8gYXNzZXRCRGVsaWNtYWxTY2FsZTogdWludDY0CgkqCglmcmFtZV9kaWcgMTIgLy8gUDM0NTogdWludDY0CgkvCglmcmFtZV9idXJ5IDEzIC8vIHJldDogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NMQU1NLmFsZ28udHM6NDQ3CgkvLyByZXR1cm4gcmV0OwoJZnJhbWVfZGlnIDEzIC8vIHJldDogdWludDY0CgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMTMKCXJldHN1YgoKKmNyZWF0ZV9Ob09wOgoJbWV0aG9kICJjcmVhdGVBcHBsaWNhdGlvbigpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb24KCWVycgoKKmNhbGxfTm9PcDoKCW1ldGhvZCAiZ2V0Q3VycmVudFByaWNlKCl1aW50NjQiCgltZXRob2QgImdldFByaWNlRGl2aWRlcigpdWludDY0IgoJbWV0aG9kICJnZXRMUFRva2VuSWQoKXVpbnQ2NCIKCW1ldGhvZCAiYm9vdHN0cmFwKHBheSx1aW50NjQsdWludDY0LHVpbnQzMix1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0KXVpbnQ2NCIKCW1ldGhvZCAiYWRkTGlxdWlkaXR5KHR4bix0eG4sdWludDY0LHVpbnQ2NCx1aW50NjQpdWludDY0IgoJbWV0aG9kICJnZXRIeXBvdGhldGljUHJpY2UodWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KXVpbnQ2NCIKCW1ldGhvZCAicmVtb3ZlTGlxdWlkaXR5KGF4ZmVyLHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQiCgltZXRob2QgInN3YXAoYXhmZXIsdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZCIKCW1ldGhvZCAiY2FsY3VsYXRlQXNzZXRCV2l0aGRyYXdPbkFzc2V0QURlcG9zaXQodWludDY0LHVpbnQ2NCx1aW50NjQpdWludDY0IgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV9nZXRDdXJyZW50UHJpY2UgKmFiaV9yb3V0ZV9nZXRQcmljZURpdmlkZXIgKmFiaV9yb3V0ZV9nZXRMUFRva2VuSWQgKmFiaV9yb3V0ZV9ib290c3RyYXAgKmFiaV9yb3V0ZV9hZGRMaXF1aWRpdHkgKmFiaV9yb3V0ZV9nZXRIeXBvdGhldGljUHJpY2UgKmFiaV9yb3V0ZV9yZW1vdmVMaXF1aWRpdHkgKmFiaV9yb3V0ZV9zd2FwICphYmlfcm91dGVfY2FsY3VsYXRlQXNzZXRCV2l0aGRyYXdPbkFzc2V0QURlcG9zaXQKCWVycg==",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEw"
  },
  "contract": {
    "name": "BiatecCLAMM",
    "desc": "",
    "methods": [
      {
        "name": "createApplication",
        "desc": "Initial setup",
        "args": [],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "getCurrentPrice",
        "readonly": true,
        "args": [],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "getPriceDivider",
        "readonly": true,
        "args": [],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "getLPTokenId",
        "readonly": true,
        "args": [],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "bootstrap",
        "desc": "Anybody can deploy the clamm smart contract",
        "args": [
          {
            "name": "txSeed",
            "type": "pay",
            "desc": "Seed transaction so that smart contract can opt in to the assets"
          },
          {
            "name": "assetA",
            "type": "uint64",
            "desc": "Asset A ID must be lower then Asset B ID"
          },
          {
            "name": "assetB",
            "type": "uint64",
            "desc": "Asset B"
          },
          {
            "name": "feeB100000",
            "type": "uint32",
            "desc": "Fee in 100000 base level. value 10000 = 10000/100000 = 0,1 = 10% fee. 1000 = 1%. 100 = 0,1%. 10 = 0,01% = 1 base point"
          },
          {
            "name": "priceMaxA",
            "type": "uint64"
          },
          {
            "name": "priceMaxB",
            "type": "uint64"
          },
          {
            "name": "currentPrice",
            "type": "uint64"
          },
          {
            "name": "verificationClass",
            "type": "uint8",
            "desc": "Asset B"
          },
          {
            "name": "identityProvider",
            "type": "uint64"
          },
          {
            "name": "poolProvider",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "uint64",
          "desc": "LP token ID"
        }
      },
      {
        "name": "addLiquidity",
        "desc": "This method adds Asset A and Asset B to the Automated Market Maker Concentrated Liqudidity Pool and send to the liqudidty provider the liqudity token",
        "args": [
          {
            "name": "txAssetADeposit",
            "type": "txn",
            "desc": "Transfer of asset A to the LP pool"
          },
          {
            "name": "txAssetBDeposit",
            "type": "txn",
            "desc": "Transfer of asset B to the LP pool"
          },
          {
            "name": "poolAsset",
            "type": "uint64",
            "desc": "LP pool asset"
          },
          {
            "name": "assetA",
            "type": "uint64",
            "desc": "Asset A"
          },
          {
            "name": "assetB",
            "type": "uint64",
            "desc": "Asset B"
          }
        ],
        "returns": {
          "type": "uint64",
          "desc": "LP Token quantity distributed"
        }
      },
      {
        "name": "getHypotheticPrice",
        "desc": "Get the current price when asset a has x",
        "readonly": true,
        "args": [
          {
            "name": "assetAQuantity",
            "type": "uint64",
            "desc": "x"
          },
          {
            "name": "assetBQuantity",
            "type": "uint64",
            "desc": "y"
          },
          {
            "name": "priceMaxASqrt",
            "type": "uint64"
          },
          {
            "name": "priceMaxBSqrt",
            "type": "uint64"
          },
          {
            "name": "liquidity",
            "type": "uint64"
          },
          {
            "name": "assetADecimals",
            "type": "uint64"
          },
          {
            "name": "assetBDecimals",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "uint64",
          "desc": "the price with specified quantity with the price range set in the contract"
        }
      },
      {
        "name": "removeLiquidity",
        "desc": "This method retrieves from the liquidity provider LP token and returns Asset A and Asset B from the Automated Market Maker Concentrated Liqudidity Pool",
        "args": [
          {
            "name": "txLPXfer",
            "type": "axfer",
            "desc": "Transfer of the LP token"
          },
          {
            "name": "poolAsset",
            "type": "uint64",
            "desc": "LP pool asset"
          },
          {
            "name": "assetA",
            "type": "uint64",
            "desc": "Asset A"
          },
          {
            "name": "assetB",
            "type": "uint64",
            "desc": "Asset B"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "swap",
        "desc": "Swap Asset A to Asset B or Asset B to Asst A",
        "args": [
          {
            "name": "txSwap",
            "type": "axfer",
            "desc": "Transfer of the token to be deposited to the pool. To the owner the other asset will be sent."
          },
          {
            "name": "assetA",
            "type": "uint64",
            "desc": "Asset A"
          },
          {
            "name": "assetB",
            "type": "uint64",
            "desc": "Asset B"
          },
          {
            "name": "minimumToReceive",
            "type": "uint64",
            "desc": "If number greater then zero, the check is performed for the output of the other asset"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "calculateAssetBWithdrawOnAssetADeposit",
        "readonly": true,
        "args": [
          {
            "name": "inAmount",
            "type": "uint64"
          },
          {
            "name": "assetADecimals",
            "type": "uint64"
          },
          {
            "name": "assetBDecimals",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "uint64"
        }
      }
    ]
  }
}

/**
 * Defines an onCompletionAction of 'no_op'
 */
export type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }
/**
 * Defines an onCompletionAction of 'opt_in'
 */
export type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }
/**
 * Defines an onCompletionAction of 'close_out'
 */
export type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }
/**
 * Defines an onCompletionAction of 'delete_application'
 */
export type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }
/**
 * Defines an onCompletionAction of 'update_application'
 */
export type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }
/**
 * A state record containing a single unsigned integer
 */
export type IntegerState = {
  /**
   * Gets the state value as a BigInt 
   */
  asBigInt(): bigint
  /**
   * Gets the state value as a number.
   */
  asNumber(): number
}
/**
 * A state record containing binary data
 */
export type BinaryState = {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array
  /**
   * Gets the state value as a string
   */
  asString(): string
}

export type AppCreateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult> & AppReference
export type AppUpdateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult>

/**
 * Defines the types of available calls and state of the BiatecClamm smart contract.
 */
export type BiatecClamm = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'createApplication()void' | 'createApplication', {
      argsObj: {
      }
      argsTuple: []
      returns: void
    }>
    & Record<'getCurrentPrice()uint64' | 'getCurrentPrice', {
      argsObj: {
      }
      argsTuple: []
      returns: bigint
    }>
    & Record<'getPriceDivider()uint64' | 'getPriceDivider', {
      argsObj: {
      }
      argsTuple: []
      returns: bigint
    }>
    & Record<'getLPTokenId()uint64' | 'getLPTokenId', {
      argsObj: {
      }
      argsTuple: []
      returns: bigint
    }>
    & Record<'bootstrap(pay,uint64,uint64,uint32,uint64,uint64,uint64,uint8,uint64,uint64)uint64' | 'bootstrap', {
      argsObj: {
        /**
         * Seed transaction so that smart contract can opt in to the assets
         */
        txSeed: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * Asset A ID must be lower then Asset B ID
         */
        assetA: bigint | number
        /**
         * Asset B
         */
        assetB: bigint | number
        /**
         * Fee in 100000 base level. value 10000 = 10000/100000 = 0,1 = 10% fee. 1000 = 1%. 100 = 0,1%. 10 = 0,01% = 1 base point
         */
        feeB100000: number
        priceMaxA: bigint | number
        priceMaxB: bigint | number
        currentPrice: bigint | number
        /**
         * Asset B
         */
        verificationClass: number
        identityProvider: bigint | number
        poolProvider: bigint | number
      }
      argsTuple: [txSeed: TransactionToSign | Transaction | Promise<SendTransactionResult>, assetA: bigint | number, assetB: bigint | number, feeB100000: number, priceMaxA: bigint | number, priceMaxB: bigint | number, currentPrice: bigint | number, verificationClass: number, identityProvider: bigint | number, poolProvider: bigint | number]
      /**
       * LP token ID
       */
      returns: bigint
    }>
    & Record<'addLiquidity(txn,txn,uint64,uint64,uint64)uint64' | 'addLiquidity', {
      argsObj: {
        /**
         * Transfer of asset A to the LP pool
         */
        txAssetADeposit: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * Transfer of asset B to the LP pool
         */
        txAssetBDeposit: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * LP pool asset
         */
        poolAsset: bigint | number
        /**
         * Asset A
         */
        assetA: bigint | number
        /**
         * Asset B
         */
        assetB: bigint | number
      }
      argsTuple: [txAssetADeposit: TransactionToSign | Transaction | Promise<SendTransactionResult>, txAssetBDeposit: TransactionToSign | Transaction | Promise<SendTransactionResult>, poolAsset: bigint | number, assetA: bigint | number, assetB: bigint | number]
      /**
       * LP Token quantity distributed
       */
      returns: bigint
    }>
    & Record<'getHypotheticPrice(uint64,uint64,uint64,uint64,uint64,uint64,uint64)uint64' | 'getHypotheticPrice', {
      argsObj: {
        /**
         * x
         */
        assetAQuantity: bigint | number
        /**
         * y
         */
        assetBQuantity: bigint | number
        priceMaxASqrt: bigint | number
        priceMaxBSqrt: bigint | number
        liquidity: bigint | number
        assetADecimals: bigint | number
        assetBDecimals: bigint | number
      }
      argsTuple: [assetAQuantity: bigint | number, assetBQuantity: bigint | number, priceMaxASqrt: bigint | number, priceMaxBSqrt: bigint | number, liquidity: bigint | number, assetADecimals: bigint | number, assetBDecimals: bigint | number]
      /**
       * the price with specified quantity with the price range set in the contract
       */
      returns: bigint
    }>
    & Record<'removeLiquidity(axfer,uint64,uint64,uint64)void' | 'removeLiquidity', {
      argsObj: {
        /**
         * Transfer of the LP token
         */
        txLPXfer: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * LP pool asset
         */
        poolAsset: bigint | number
        /**
         * Asset A
         */
        assetA: bigint | number
        /**
         * Asset B
         */
        assetB: bigint | number
      }
      argsTuple: [txLPXfer: TransactionToSign | Transaction | Promise<SendTransactionResult>, poolAsset: bigint | number, assetA: bigint | number, assetB: bigint | number]
      returns: void
    }>
    & Record<'swap(axfer,uint64,uint64,uint64)void' | 'swap', {
      argsObj: {
        /**
         * Transfer of the token to be deposited to the pool. To the owner the other asset will be sent.
         */
        txSwap: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * Asset A
         */
        assetA: bigint | number
        /**
         * Asset B
         */
        assetB: bigint | number
        /**
         * If number greater then zero, the check is performed for the output of the other asset
         */
        minimumToReceive: bigint | number
      }
      argsTuple: [txSwap: TransactionToSign | Transaction | Promise<SendTransactionResult>, assetA: bigint | number, assetB: bigint | number, minimumToReceive: bigint | number]
      returns: void
    }>
    & Record<'calculateAssetBWithdrawOnAssetADeposit(uint64,uint64,uint64)uint64' | 'calculateAssetBWithdrawOnAssetADeposit', {
      argsObj: {
        inAmount: bigint | number
        assetADecimals: bigint | number
        assetBDecimals: bigint | number
      }
      argsTuple: [inAmount: bigint | number, assetADecimals: bigint | number, assetBDecimals: bigint | number]
      returns: bigint
    }>
  /**
   * Defines the shape of the global and local state of the application.
   */
  state: {
    global: {
      'a'?: IntegerState
      'b'?: IntegerState
      'ab'?: IntegerState
      'bb'?: IntegerState
      'pa'?: IntegerState
      'pb'?: IntegerState
      'pas'?: IntegerState
      'pbs'?: IntegerState
      'L'?: IntegerState
      'p'?: IntegerState
      'f'?: BinaryState
      'r'?: IntegerState
      'scale'?: IntegerState
      'i'?: IntegerState
      'pp'?: IntegerState
      'g'?: BinaryState
      'c'?: BinaryState
      'e'?: BinaryState
    }
  }
}
/**
 * Defines the possible abi call signatures
 */
export type BiatecClammSig = keyof BiatecClamm['methods']
/**
 * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made
 */
export type TypedCallParams<TSignature extends BiatecClammSig | undefined> = {
  method: TSignature
  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>
} & AppClientCallCoreParams & CoreAppCallArgs
/**
 * Defines the arguments required for a bare call
 */
export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>
/**
 * Maps a method signature from the BiatecClamm smart contract to the method's arguments in either tuple of struct form
 */
export type MethodArgs<TSignature extends BiatecClammSig> = BiatecClamm['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the BiatecClamm smart contract to the method's return type
 */
export type MethodReturn<TSignature extends BiatecClammSig> = BiatecClamm['methods'][TSignature]['returns']

/**
 * A factory for available 'create' calls
 */
export type BiatecClammCreateCalls = (typeof BiatecClammCallFactory)['create']
/**
 * Defines supported create methods for this smart contract
 */
export type BiatecClammCreateCallParams =
  | (TypedCallParams<'createApplication()void'> & (OnCompleteNoOp))
/**
 * Defines arguments required for the deploy method.
 */
export type BiatecClammDeployArgs = {
  deployTimeParams?: TealTemplateParams
  /**
   * A delegate which takes a create call factory and returns the create call params for this smart contract
   */
  createCall?: (callFactory: BiatecClammCreateCalls) => BiatecClammCreateCallParams
}


/**
 * Exposes methods for constructing all available smart contract calls
 */
export abstract class BiatecClammCallFactory {
  /**
   * Gets available create call factories
   */
  static get create() {
    return {
      /**
       * Constructs a create call for the BiatecCLAMM smart contract using the createApplication()void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      createApplication(args: MethodArgs<'createApplication()void'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return {
          method: 'createApplication()void' as const,
          methodArgs: Array.isArray(args) ? args : [],
          ...params,
        }
      },
    }
  }

  /**
   * Constructs a no op call for the getCurrentPrice()uint64 ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getCurrentPrice(args: MethodArgs<'getCurrentPrice()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getCurrentPrice()uint64' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the getPriceDivider()uint64 ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getPriceDivider(args: MethodArgs<'getPriceDivider()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getPriceDivider()uint64' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the getLPTokenId()uint64 ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getLpTokenId(args: MethodArgs<'getLPTokenId()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getLPTokenId()uint64' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the bootstrap(pay,uint64,uint64,uint32,uint64,uint64,uint64,uint8,uint64,uint64)uint64 ABI method
   *
   * Anybody can deploy the clamm smart contract
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static bootstrap(args: MethodArgs<'bootstrap(pay,uint64,uint64,uint32,uint64,uint64,uint64,uint8,uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'bootstrap(pay,uint64,uint64,uint32,uint64,uint64,uint64,uint8,uint64,uint64)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.txSeed, args.assetA, args.assetB, args.feeB100000, args.priceMaxA, args.priceMaxB, args.currentPrice, args.verificationClass, args.identityProvider, args.poolProvider],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the addLiquidity(txn,txn,uint64,uint64,uint64)uint64 ABI method
   *
   * This method adds Asset A and Asset B to the Automated Market Maker Concentrated Liqudidity Pool and send to the liqudidty provider the liqudity token
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static addLiquidity(args: MethodArgs<'addLiquidity(txn,txn,uint64,uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'addLiquidity(txn,txn,uint64,uint64,uint64)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.txAssetADeposit, args.txAssetBDeposit, args.poolAsset, args.assetA, args.assetB],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the getHypotheticPrice(uint64,uint64,uint64,uint64,uint64,uint64,uint64)uint64 ABI method
   *
   * Get the current price when asset a has x
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getHypotheticPrice(args: MethodArgs<'getHypotheticPrice(uint64,uint64,uint64,uint64,uint64,uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getHypotheticPrice(uint64,uint64,uint64,uint64,uint64,uint64,uint64)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.assetAQuantity, args.assetBQuantity, args.priceMaxASqrt, args.priceMaxBSqrt, args.liquidity, args.assetADecimals, args.assetBDecimals],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the removeLiquidity(axfer,uint64,uint64,uint64)void ABI method
   *
   * This method retrieves from the liquidity provider LP token and returns Asset A and Asset B from the Automated Market Maker Concentrated Liqudidity Pool
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static removeLiquidity(args: MethodArgs<'removeLiquidity(axfer,uint64,uint64,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'removeLiquidity(axfer,uint64,uint64,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.txLPXfer, args.poolAsset, args.assetA, args.assetB],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the swap(axfer,uint64,uint64,uint64)void ABI method
   *
   * Swap Asset A to Asset B or Asset B to Asst A
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static swap(args: MethodArgs<'swap(axfer,uint64,uint64,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'swap(axfer,uint64,uint64,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.txSwap, args.assetA, args.assetB, args.minimumToReceive],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the calculateAssetBWithdrawOnAssetADeposit(uint64,uint64,uint64)uint64 ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static calculateAssetBWithdrawOnAssetADeposit(args: MethodArgs<'calculateAssetBWithdrawOnAssetADeposit(uint64,uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'calculateAssetBWithdrawOnAssetADeposit(uint64,uint64,uint64)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.inAmount, args.assetADecimals, args.assetBDecimals],
      ...params,
    }
  }
}

/**
 * A client to make calls to the BiatecCLAMM smart contract
 */
export class BiatecClammClient {
  /**
   * The underlying `ApplicationClient` for when you want to have more flexibility
   */
  public readonly appClient: ApplicationClient

  private readonly sender: SendTransactionFrom | undefined

  /**
   * Creates a new instance of `BiatecClammClient`
   *
   * @param appDetails appDetails The details to identify the app to deploy
   * @param algod An algod client instance
   */
  constructor(appDetails: AppDetails, private algod: Algodv2) {
    this.sender = appDetails.sender
    this.appClient = algokit.getAppClient({
      ...appDetails,
      app: APP_SPEC
    }, algod)
  }

  /**
   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type
   *
   * @param result The AppCallTransactionResult to be mapped
   * @param returnValueFormatter An optional delegate to format the return value if required
   * @returns The smart contract response with an updated return value
   */
  protected mapReturnValue<TReturn, TResult extends AppCallTransactionResult = AppCallTransactionResult>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> & TResult {
    if(result.return?.decodeError) {
      throw result.return.decodeError
    }
    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined
      ? returnValueFormatter(result.return.returnValue)
      : result.return?.returnValue as TReturn | undefined
      return { ...result, return: returnValue } as AppCallTransactionResultOfType<TReturn> & TResult
  }

  /**
   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP
   *
   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters
   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type
   * @returns The result of the smart contract call
   */
  public async call<TSignature extends keyof BiatecClamm['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {
    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)
  }

  /**
   * Idempotently deploys the BiatecCLAMM smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public deploy(params: BiatecClammDeployArgs & AppClientDeployCoreParams = {}): ReturnType<ApplicationClient['deploy']> {
    const createArgs = params.createCall?.(BiatecClammCallFactory.create)
    return this.appClient.deploy({
      ...params,
      createArgs,
      createOnCompleteAction: createArgs?.onCompleteAction,
    })
  }

  /**
   * Gets available create methods
   */
  public get create() {
    const $this = this
    return {
      /**
       * Creates a new instance of the BiatecCLAMM smart contract using the createApplication()void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The create result
       */
      async createApplication(args: MethodArgs<'createApplication()void'>, params: AppClientCallCoreParams & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return $this.mapReturnValue<MethodReturn<'createApplication()void'>, AppCreateCallTransactionResult>(await $this.appClient.create(BiatecClammCallFactory.create.createApplication(args, params)))
      },
    }
  }

  /**
   * Makes a clear_state call to an existing instance of the BiatecCLAMM smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The clear_state result
   */
  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.appClient.clearState(args)
  }

  /**
   * Calls the getCurrentPrice()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getCurrentPrice(args: MethodArgs<'getCurrentPrice()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.getCurrentPrice(args, params))
  }

  /**
   * Calls the getPriceDivider()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getPriceDivider(args: MethodArgs<'getPriceDivider()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.getPriceDivider(args, params))
  }

  /**
   * Calls the getLPTokenId()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getLpTokenId(args: MethodArgs<'getLPTokenId()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.getLpTokenId(args, params))
  }

  /**
   * Calls the bootstrap(pay,uint64,uint64,uint32,uint64,uint64,uint64,uint8,uint64,uint64)uint64 ABI method.
   *
   * Anybody can deploy the clamm smart contract
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: LP token ID
   */
  public bootstrap(args: MethodArgs<'bootstrap(pay,uint64,uint64,uint32,uint64,uint64,uint64,uint8,uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.bootstrap(args, params))
  }

  /**
   * Calls the addLiquidity(txn,txn,uint64,uint64,uint64)uint64 ABI method.
   *
   * This method adds Asset A and Asset B to the Automated Market Maker Concentrated Liqudidity Pool and send to the liqudidty provider the liqudity token
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: LP Token quantity distributed
   */
  public addLiquidity(args: MethodArgs<'addLiquidity(txn,txn,uint64,uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.addLiquidity(args, params))
  }

  /**
   * Calls the getHypotheticPrice(uint64,uint64,uint64,uint64,uint64,uint64,uint64)uint64 ABI method.
   *
   * Get the current price when asset a has x
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: the price with specified quantity with the price range set in the contract
   */
  public getHypotheticPrice(args: MethodArgs<'getHypotheticPrice(uint64,uint64,uint64,uint64,uint64,uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.getHypotheticPrice(args, params))
  }

  /**
   * Calls the removeLiquidity(axfer,uint64,uint64,uint64)void ABI method.
   *
   * This method retrieves from the liquidity provider LP token and returns Asset A and Asset B from the Automated Market Maker Concentrated Liqudidity Pool
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public removeLiquidity(args: MethodArgs<'removeLiquidity(axfer,uint64,uint64,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.removeLiquidity(args, params))
  }

  /**
   * Calls the swap(axfer,uint64,uint64,uint64)void ABI method.
   *
   * Swap Asset A to Asset B or Asset B to Asst A
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public swap(args: MethodArgs<'swap(axfer,uint64,uint64,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.swap(args, params))
  }

  /**
   * Calls the calculateAssetBWithdrawOnAssetADeposit(uint64,uint64,uint64)uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public calculateAssetBWithdrawOnAssetADeposit(args: MethodArgs<'calculateAssetBWithdrawOnAssetADeposit(uint64,uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammCallFactory.calculateAssetBWithdrawOnAssetADeposit(args, params))
  }

  /**
   * Extracts a binary state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns A BinaryState instance containing the state value, or undefined if the key was not found
   */
  private static getBinaryState(state: AppState, key: string): BinaryState | undefined {
    const value = state[key]
    if (!value) return undefined
    if (!('valueRaw' in value))
      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`)
    return {
      asString(): string {
        return value.value
      },
      asByteArray(): Uint8Array {
        return value.valueRaw
      }
    }
  }

  /**
   * Extracts a integer state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns An IntegerState instance containing the state value, or undefined if the key was not found
   */
  private static getIntegerState(state: AppState, key: string): IntegerState | undefined {
    const value = state[key]
    if (!value) return undefined
    if ('valueRaw' in value)
      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`)
    return {
      asBigInt() {
        return typeof value.value === 'bigint' ? value.value : BigInt(value.value)
      },
      asNumber(): number {
        return typeof value.value === 'bigint' ? Number(value.value) : value.value
      },
    }
  }

  /**
   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value
   */
  public async getGlobalState(): Promise<BiatecClamm['state']['global']> {
    const state = await this.appClient.getGlobalState()
    return {
      get a() {
        return BiatecClammClient.getIntegerState(state, 'a')
      },
      get b() {
        return BiatecClammClient.getIntegerState(state, 'b')
      },
      get ab() {
        return BiatecClammClient.getIntegerState(state, 'ab')
      },
      get bb() {
        return BiatecClammClient.getIntegerState(state, 'bb')
      },
      get pa() {
        return BiatecClammClient.getIntegerState(state, 'pa')
      },
      get pb() {
        return BiatecClammClient.getIntegerState(state, 'pb')
      },
      get pas() {
        return BiatecClammClient.getIntegerState(state, 'pas')
      },
      get pbs() {
        return BiatecClammClient.getIntegerState(state, 'pbs')
      },
      get L() {
        return BiatecClammClient.getIntegerState(state, 'L')
      },
      get p() {
        return BiatecClammClient.getIntegerState(state, 'p')
      },
      get f() {
        return BiatecClammClient.getBinaryState(state, 'f')
      },
      get r() {
        return BiatecClammClient.getIntegerState(state, 'r')
      },
      get scale() {
        return BiatecClammClient.getIntegerState(state, 'scale')
      },
      get i() {
        return BiatecClammClient.getIntegerState(state, 'i')
      },
      get pp() {
        return BiatecClammClient.getIntegerState(state, 'pp')
      },
      get g() {
        return BiatecClammClient.getBinaryState(state, 'g')
      },
      get c() {
        return BiatecClammClient.getBinaryState(state, 'c')
      },
      get e() {
        return BiatecClammClient.getBinaryState(state, 'e')
      },
    }
  }

  public compose(): BiatecClammComposer {
    const client = this
    const atc = new AtomicTransactionComposer()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: any) => any)> = []
    return {
      getCurrentPrice(args: MethodArgs<'getCurrentPrice()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getCurrentPrice(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      getPriceDivider(args: MethodArgs<'getPriceDivider()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getPriceDivider(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      getLpTokenId(args: MethodArgs<'getLPTokenId()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getLpTokenId(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      bootstrap(args: MethodArgs<'bootstrap(pay,uint64,uint64,uint32,uint64,uint64,uint64,uint8,uint64,uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.bootstrap(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addLiquidity(args: MethodArgs<'addLiquidity(txn,txn,uint64,uint64,uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.addLiquidity(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      getHypotheticPrice(args: MethodArgs<'getHypotheticPrice(uint64,uint64,uint64,uint64,uint64,uint64,uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getHypotheticPrice(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      removeLiquidity(args: MethodArgs<'removeLiquidity(axfer,uint64,uint64,uint64)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.removeLiquidity(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      swap(args: MethodArgs<'swap(axfer,uint64,uint64,uint64)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.swap(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      calculateAssetBWithdrawOnAssetADeposit(args: MethodArgs<'calculateAssetBWithdrawOnAssetADeposit(uint64,uint64,uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.calculateAssetBWithdrawOnAssetADeposit(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {
        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))
        return this
      },
      async atc() {
        await promiseChain
        return atc
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await atc.simulate(client.algod, new modelsv2.SimulateRequest({ txnGroups: [], ...options }))
        return {
          ...result,
          returns: result.methodResults?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      },
      async execute() {
        await promiseChain
        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams: {} }, client.algod)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      }
    } as unknown as BiatecClammComposer
  }
}
export type BiatecClammComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the getCurrentPrice()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getCurrentPrice(args: MethodArgs<'getCurrentPrice()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'getCurrentPrice()uint64'>]>

  /**
   * Calls the getPriceDivider()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getPriceDivider(args: MethodArgs<'getPriceDivider()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'getPriceDivider()uint64'>]>

  /**
   * Calls the getLPTokenId()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getLpTokenId(args: MethodArgs<'getLPTokenId()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'getLPTokenId()uint64'>]>

  /**
   * Calls the bootstrap(pay,uint64,uint64,uint32,uint64,uint64,uint64,uint8,uint64,uint64)uint64 ABI method.
   *
   * Anybody can deploy the clamm smart contract
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  bootstrap(args: MethodArgs<'bootstrap(pay,uint64,uint64,uint32,uint64,uint64,uint64,uint8,uint64,uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'bootstrap(pay,uint64,uint64,uint32,uint64,uint64,uint64,uint8,uint64,uint64)uint64'>]>

  /**
   * Calls the addLiquidity(txn,txn,uint64,uint64,uint64)uint64 ABI method.
   *
   * This method adds Asset A and Asset B to the Automated Market Maker Concentrated Liqudidity Pool and send to the liqudidty provider the liqudity token
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  addLiquidity(args: MethodArgs<'addLiquidity(txn,txn,uint64,uint64,uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'addLiquidity(txn,txn,uint64,uint64,uint64)uint64'>]>

  /**
   * Calls the getHypotheticPrice(uint64,uint64,uint64,uint64,uint64,uint64,uint64)uint64 ABI method.
   *
   * Get the current price when asset a has x
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getHypotheticPrice(args: MethodArgs<'getHypotheticPrice(uint64,uint64,uint64,uint64,uint64,uint64,uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'getHypotheticPrice(uint64,uint64,uint64,uint64,uint64,uint64,uint64)uint64'>]>

  /**
   * Calls the removeLiquidity(axfer,uint64,uint64,uint64)void ABI method.
   *
   * This method retrieves from the liquidity provider LP token and returns Asset A and Asset B from the Automated Market Maker Concentrated Liqudidity Pool
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  removeLiquidity(args: MethodArgs<'removeLiquidity(axfer,uint64,uint64,uint64)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'removeLiquidity(axfer,uint64,uint64,uint64)void'>]>

  /**
   * Calls the swap(axfer,uint64,uint64,uint64)void ABI method.
   *
   * Swap Asset A to Asset B or Asset B to Asst A
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  swap(args: MethodArgs<'swap(axfer,uint64,uint64,uint64)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'swap(axfer,uint64,uint64,uint64)void'>]>

  /**
   * Calls the calculateAssetBWithdrawOnAssetADeposit(uint64,uint64,uint64)uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  calculateAssetBWithdrawOnAssetADeposit(args: MethodArgs<'calculateAssetBWithdrawOnAssetADeposit(uint64,uint64,uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, MethodReturn<'calculateAssetBWithdrawOnAssetADeposit(uint64,uint64,uint64)uint64'>]>

  /**
   * Makes a clear_state call to an existing instance of the BiatecCLAMM smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs): BiatecClammComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)
   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.
   */
  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): BiatecClammComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  atc(): Promise<AtomicTransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(options?: SimulateOptions): Promise<BiatecClammComposerSimulateResult<TReturns>>
  /**
   * Executes the transaction group and returns the results
   */
  execute(): Promise<BiatecClammComposerResults<TReturns>>
}
export type SimulateOptions = Omit<ConstructorParameters<typeof modelsv2.SimulateRequest>[0], 'txnGroups'>
export type BiatecClammComposerSimulateResult<TReturns extends [...any[]]> = {
  returns: TReturns
  methodResults: ABIResult[]
  simulateResponse: modelsv2.SimulateResponse
}
export type BiatecClammComposerResults<TReturns extends [...any[]]> = {
  returns: TReturns
  groupId: string
  txIds: string[]
  transactions: Transaction[]
}

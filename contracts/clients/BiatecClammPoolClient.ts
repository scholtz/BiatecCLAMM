/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^2
 */
import * as algokit from '@algorandfoundation/algokit-utils'
import type {
  ABIAppCallArg,
  AppCallTransactionResult,
  AppCallTransactionResultOfType,
  AppCompilationResult,
  AppReference,
  AppState,
  CoreAppCallArgs,
  RawAppCallArgs,
  TealTemplateParams,
} from '@algorandfoundation/algokit-utils/types/app'
import type {
  AppClientCallCoreParams,
  AppClientCompilationParams,
  AppClientDeployCoreParams,
  AppDetails,
  ApplicationClient,
} from '@algorandfoundation/algokit-utils/types/app-client'
import type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'
import type { SendTransactionResult, TransactionToSign, SendTransactionFrom } from '@algorandfoundation/algokit-utils/types/transaction'
import type { ABIResult, TransactionWithSigner } from 'algosdk'
import { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer, modelsv2 } from 'algosdk'
export const APP_SPEC: AppSpec = {
  "hints": {
    "createApplication()void": {
      "call_config": {
        "no_op": "CREATE"
      }
    },
    "getCurrentPrice()uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "getPriceDivider()uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "getLPTokenId()uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "bootstrap(uint64,uint64,uint64,uint64,pay,uint64,uint64,uint64,uint64,uint8)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "addLiquidity(uint64,uint64,txn,txn,uint64,uint64,uint64)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "removeLiquidity(axfer,uint64,uint64,uint64)uint256": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "swap(uint64,uint64,txn,uint64,uint64,uint64)uint256": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "calculateDistributedLiquidity(uint64,uint256)uint256": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "calculateLiquidity(uint256,uint256,uint256,uint256,uint256,uint256)uint256": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "calculateAssetAWithdrawOnLpDeposit(uint256,uint256,uint256)uint256": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "calculateAssetBWithdrawOnLpDeposit(uint256,uint256,uint256)uint256": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "calculateAssetBDepositOnAssetADeposit(uint256,uint256,uint256,uint256)uint256": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "calculateAssetADepositOnAssetBDeposit(uint256,uint256,uint256,uint256)uint256": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "status(uint64,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)": {
      "call_config": {
        "no_op": "CALL"
      }
    }
  },
  "bare_call_config": {
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "close_out": "NEVER",
    "update_application": "NEVER",
    "delete_application": "NEVER"
  },
  "schema": {
    "local": {
      "declared": {},
      "reserved": {}
    },
    "global": {
      "declared": {
        "assetA": {
          "type": "uint64",
          "key": "a"
        },
        "assetB": {
          "type": "uint64",
          "key": "b"
        },
        "assetLP": {
          "type": "uint64",
          "key": "lp"
        },
        "assetABalance": {
          "type": "bytes",
          "key": "ab"
        },
        "assetBBalance": {
          "type": "bytes",
          "key": "bb"
        },
        "priceMin": {
          "type": "uint64",
          "key": "pMin"
        },
        "priceMax": {
          "type": "uint64",
          "key": "pMax"
        },
        "priceMinSqrt": {
          "type": "bytes",
          "key": "pMinS"
        },
        "priceMaxSqrt": {
          "type": "bytes",
          "key": "pMaxS"
        },
        "Liqudity": {
          "type": "bytes",
          "key": "L"
        },
        "LiqudityUsersFromFees": {
          "type": "bytes",
          "key": "Lu"
        },
        "LiqudityBiatecFromFees": {
          "type": "bytes",
          "key": "Lb"
        },
        "fee": {
          "type": "uint64",
          "key": "f"
        },
        "ratio": {
          "type": "uint64",
          "key": "r"
        },
        "scale": {
          "type": "uint64",
          "key": "scale"
        },
        "appBiatecConfigProvider": {
          "type": "uint64",
          "key": "B"
        },
        "appBiatecPoolProvider": {
          "type": "uint64",
          "key": "pp"
        },
        "verificationClass": {
          "type": "uint64",
          "key": "c"
        }
      },
      "reserved": {}
    }
  },
  "state": {
    "global": {
      "num_byte_slices": 7,
      "num_uints": 11
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0
    }
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCgovLyBUaGlzIFRFQUwgd2FzIGdlbmVyYXRlZCBieSBURUFMU2NyaXB0IHYwLjg4LjAKLy8gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29yYW5kZm91bmRhdGlvbi9URUFMU2NyaXB0CgovLyBUaGlzIGNvbnRyYWN0IGlzIGNvbXBsaWFudCB3aXRoIGFuZC9vciBpbXBsZW1lbnRzIHRoZSBmb2xsb3dpbmcgQVJDczogWyBBUkM0IF0KCi8vIFRoZSBmb2xsb3dpbmcgdGVuIGxpbmVzIG9mIFRFQUwgaGFuZGxlIGluaXRpYWwgcHJvZ3JhbSBmbG93Ci8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIHRvIG1ha2UgaXQgZWFzeSBmb3IgYW55b25lIHRvIHBhcnNlIHRoZSBzdGFydCBvZiB0aGUgcHJvZ3JhbSBhbmQgZGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgYWN0aW9uIGlzIGFsbG93ZWQKLy8gSGVyZSwgYWN0aW9uIHJlZmVycyB0byB0aGUgT25Db21wbGV0ZSBpbiBjb21iaW5hdGlvbiB3aXRoIHdoZXRoZXIgdGhlIGFwcCBpcyBiZWluZyBjcmVhdGVkIG9yIGNhbGxlZAovLyBFdmVyeSBwb3NzaWJsZSBhY3Rpb24gZm9yIHRoaXMgY29udHJhY3QgaXMgcmVwcmVzZW50ZWQgaW4gdGhlIHN3aXRjaCBzdGF0ZW1lbnQKLy8gSWYgdGhlIGFjdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIGNvbnRyYWN0LCBpdHMgcmVzcGVjdGl2ZSBicmFuY2ggd2lsbCBiZSAiKk5PVF9JTVBMRU1FTlRFRCIgd2hpY2gganVzdCBjb250YWlucyAiZXJyIgp0eG4gQXBwbGljYXRpb25JRAohCmludCA2CioKdHhuIE9uQ29tcGxldGlvbgorCnN3aXRjaCAqY2FsbF9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqY3JlYXRlX05vT3AgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVECgoqTk9UX0lNUExFTUVOVEVEOgoJZXJyCgovLyBjcmVhdGVBcHBsaWNhdGlvbigpdm9pZAoqYWJpX3JvdXRlX2NyZWF0ZUFwcGxpY2F0aW9uOgoJLy8gZXhlY3V0ZSBjcmVhdGVBcHBsaWNhdGlvbigpdm9pZAoJY2FsbHN1YiBjcmVhdGVBcHBsaWNhdGlvbgoJaW50IDEKCXJldHVybgoKLy8gY3JlYXRlQXBwbGljYXRpb24oKTogdm9pZAovLwovLyBJbml0aWFsIHNldHVwCmNyZWF0ZUFwcGxpY2F0aW9uOgoJcHJvdG8gMCAwCgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjIwOAoJLy8gbG9nKHZlcnNpb24pCglieXRlICJCSUFURUMtQ0xBTU0tMDEtMDEtMDEiCglsb2cKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MjA5CgkvLyB0aGlzLnNjYWxlLnZhbHVlID0gU0NBTEUKCWJ5dGUgMHg3MzYzNjE2YzY1IC8vICJzY2FsZSIKCWludCAxMDAwMDAwMDAwCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czoyMTAKCS8vIHRoaXMuZmVlLnZhbHVlID0gPHVpbnQ2ND4wCglieXRlIDB4NjYgLy8gImYiCglpbnQgMAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MjExCgkvLyB0aGlzLkxpcXVkaXR5LnZhbHVlID0gPHVpbnQyNTY+MAoJYnl0ZSAweDRjIC8vICJMIgoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjIxMgoJLy8gdGhpcy5MaXF1ZGl0eUJpYXRlY0Zyb21GZWVzLnZhbHVlID0gPHVpbnQyNTY+MAoJYnl0ZSAweDRjNjIgLy8gIkxiIgoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjIxMwoJLy8gdGhpcy5MaXF1ZGl0eVVzZXJzRnJvbUZlZXMudmFsdWUgPSA8dWludDI1Nj4wCglieXRlIDB4NGM3NSAvLyAiTHUiCglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MjE0CgkvLyB0aGlzLnByaWNlTWF4LnZhbHVlID0gMAoJYnl0ZSAweDcwNGQ2MTc4IC8vICJwTWF4IgoJaW50IDAKCWFwcF9nbG9iYWxfcHV0CglyZXRzdWIKCi8vIGdldEN1cnJlbnRQcmljZSgpdWludDY0CiphYmlfcm91dGVfZ2V0Q3VycmVudFByaWNlOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBleGVjdXRlIGdldEN1cnJlbnRQcmljZSgpdWludDY0CgljYWxsc3ViIGdldEN1cnJlbnRQcmljZQoJaXRvYgoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGdldEN1cnJlbnRQcmljZSgpOiB1aW50NjQKZ2V0Q3VycmVudFByaWNlOgoJcHJvdG8gMCAxCgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjIxOQoJLy8gcmV0dXJuIHRoaXMucmF0aW8udmFsdWU7CglieXRlIDB4NzIgLy8gInIiCglhcHBfZ2xvYmFsX2dldAoJcmV0c3ViCgovLyBnZXRQcmljZURpdmlkZXIoKXVpbnQ2NAoqYWJpX3JvdXRlX2dldFByaWNlRGl2aWRlcjoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gZXhlY3V0ZSBnZXRQcmljZURpdmlkZXIoKXVpbnQ2NAoJY2FsbHN1YiBnZXRQcmljZURpdmlkZXIKCWl0b2IKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBnZXRQcmljZURpdmlkZXIoKTogdWludDY0CmdldFByaWNlRGl2aWRlcjoKCXByb3RvIDAgMQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czoyMjQKCS8vIHJldHVybiB0aGlzLnNjYWxlLnZhbHVlOwoJYnl0ZSAweDczNjM2MTZjNjUgLy8gInNjYWxlIgoJYXBwX2dsb2JhbF9nZXQKCXJldHN1YgoKLy8gZ2V0TFBUb2tlbklkKCl1aW50NjQKKmFiaV9yb3V0ZV9nZXRMUFRva2VuSWQ6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIGV4ZWN1dGUgZ2V0TFBUb2tlbklkKCl1aW50NjQKCWNhbGxzdWIgZ2V0TFBUb2tlbklkCglpdG9iCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gZ2V0TFBUb2tlbklkKCk6IHVpbnQ2NApnZXRMUFRva2VuSWQ6Cglwcm90byAwIDEKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MjI5CgkvLyByZXR1cm4gdGhpcy5hc3NldExQLnZhbHVlOwoJYnl0ZSAweDZjNzAgLy8gImxwIgoJYXBwX2dsb2JhbF9nZXQKCXJldHN1YgoKLy8gYm9vdHN0cmFwKHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCxwYXksdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ4KXVpbnQ2NAoqYWJpX3JvdXRlX2Jvb3RzdHJhcDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gdmVyaWZpY2F0aW9uQ2xhc3M6IHVpbnQ4Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA5CglkdXAKCWxlbgoJaW50IDEKCT09Cglhc3NlcnQKCWJ0b2kKCgkvLyBjdXJyZW50UHJpY2U6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgOAoJYnRvaQoKCS8vIHByaWNlTWF4OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDcKCWJ0b2kKCgkvLyBwcmljZU1pbjogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA2CglidG9pCgoJLy8gZmVlOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDUKCWJ0b2kKCgkvLyB0eFNlZWQ6IHBheQoJdHhuIEdyb3VwSW5kZXgKCWludCAxCgktCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnQgcGF5Cgk9PQoJYXNzZXJ0CgoJLy8gYXBwQmlhdGVjUG9vbFByb3ZpZGVyOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDQKCWJ0b2kKCgkvLyBhcHBCaWF0ZWNDb25maWdQcm92aWRlcjogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglidG9pCgoJLy8gYXNzZXRCOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyBhc3NldEE6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgYm9vdHN0cmFwKHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCxwYXksdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ4KXVpbnQ2NAoJY2FsbHN1YiBib290c3RyYXAKCWl0b2IKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBib290c3RyYXAoYXNzZXRBOiBBc3NldElELCBhc3NldEI6IEFzc2V0SUQsIGFwcEJpYXRlY0NvbmZpZ1Byb3ZpZGVyOiBBcHBJRCwgYXBwQmlhdGVjUG9vbFByb3ZpZGVyOiBBcHBJRCwgdHhTZWVkOiBQYXlUeG4sIGZlZTogdWludDY0LCBwcmljZU1pbjogdWludDY0LCBwcmljZU1heDogdWludDY0LCBjdXJyZW50UHJpY2U6IHVpbnQ2NCwgdmVyaWZpY2F0aW9uQ2xhc3M6IHVpbnQ4KTogdWludDY0Ci8vCi8vIEFueWJvZHkgY2FuIGRlcGxveSB0aGUgY2xhbW0gc21hcnQgY29udHJhY3QKLy8gQHBhcmFtIGFzc2V0QSBBc3NldCBBIElEIG11c3QgYmUgbG93ZXIgdGhlbiBBc3NldCBCIElECi8vIEBwYXJhbSBhc3NldEIgQXNzZXQgQgovLyBAcGFyYW0gYXBwQmlhdGVjQ29uZmlnUHJvdmlkZXIgQmlhdGVjIGFtbSBwcm92aWRlcgovLyBAcGFyYW0gYXBwQmlhdGVjUG9vbFByb3ZpZGVyIFBvb2wgcHJvdmlkZXIKLy8gQHBhcmFtIHR4U2VlZCBTZWVkIHRyYW5zYWN0aW9uIHNvIHRoYXQgc21hcnQgY29udHJhY3QgY2FuIG9wdCBpbiB0byB0aGUgYXNzZXRzCi8vIEBwYXJhbSBmZWUgRmVlIGluIGJhc2UgbGV2ZWwgKDkgZGVjaW1hbHMpLiB2YWx1ZSAxXzAwMF8wMDBfMDAwID0gMSA9IDEwMCUuIDEwXzAwMF8wMDAgPSAxJS4gMV8wMDBfMDAwID0gMC4xJQovLyBAcGFyYW0gcHJpY2VNaW4gTWluIHByaWNlIHJhbmdlLiBBdCB0aGlzIHBvaW50IGFsbCBhc3NldHMgYXJlIGluIGFzc2V0IEEuCi8vIEBwYXJhbSBwcmljZU1heCBNYXggcHJpY2UgcmFuZ2UuIEF0IHRoaXMgcG9pbnQgYWxsIGFzc2V0cyBhcmUgaW4gYXNzZXQgQi4KLy8gQHBhcmFtIGN1cnJlbnRQcmljZSBEZXBsb3llciBjYW4gc3BlY2lmeSB0aGUgY3VycmVudCBwcmljZSBmb3IgZWFzaWVyIGRlcGxveWVtbnQuCi8vIEBwYXJhbSB2ZXJpZmljYXRpb25DbGFzcyBNaW5pbXVtIHZlcmlmaWNhdGlvbiBsZXZlbCBmcm9tIHRoZSBiaWF0ZWMgaWRlbnRpdHkuIExldmVsIDAgbWVhbnMgbm8ga3ljLgovLyBAcmV0dXJucyBMUCB0b2tlbiBJRApib290c3RyYXA6Cglwcm90byAxMCAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MjU4CgkvLyB2ZXJpZnlQYXlUeG4odHhTZWVkLCB7IHJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzLCBhbW91bnQ6IHsgZ3JlYXRlclRoYW5FcXVhbFRvOiAzMDBfMDAwIH0gfSkKCS8vIHZlcmlmeSByZWNlaXZlcgoJZnJhbWVfZGlnIC01IC8vIHR4U2VlZDogUGF5VHhuCglndHhucyBSZWNlaXZlcgoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCT09Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYW1vdW50CglmcmFtZV9kaWcgLTUgLy8gdHhTZWVkOiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJaW50IDMwMF8wMDAKCT49Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MjU5CgkvLyBhc3NlcnQodGhpcy5wcmljZU1heC52YWx1ZSA9PT0gMCwgJ0l0IGlzIG5vdCBwb3NzaWJsZSB0byBjYWxsIGJvb3RyYXAgdHdpY2UnKQoJYnl0ZSAweDcwNGQ2MTc4IC8vICJwTWF4IgoJYXBwX2dsb2JhbF9nZXQKCWludCAwCgk9PQoKCS8vIEl0IGlzIG5vdCBwb3NzaWJsZSB0byBjYWxsIGJvb3RyYXAgdHdpY2UKCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czoyNjAKCS8vIGFzc2VydCh0aGlzLnR4bi5zZW5kZXIgPT09IHRoaXMuYXBwLmNyZWF0b3IsICdPbmx5IGNyZWF0b3Igb2YgdGhlIGFwcCBjYW4gc2V0IGl0IHVwJykKCXR4biBTZW5kZXIKCXR4bmEgQXBwbGljYXRpb25zIDAKCWFwcF9wYXJhbXNfZ2V0IEFwcENyZWF0b3IKCXBvcAoJPT0KCgkvLyBPbmx5IGNyZWF0b3Igb2YgdGhlIGFwcCBjYW4gc2V0IGl0IHVwCglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MjYxCgkvLyBhc3NlcnQocHJpY2VNYXggPiAwLCAnWW91IG11c3Qgc2V0IHByaWNlJykKCWZyYW1lX2RpZyAtOCAvLyBwcmljZU1heDogdWludDY0CglpbnQgMAoJPgoKCS8vIFlvdSBtdXN0IHNldCBwcmljZQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjI2MgoJLy8gYXNzZXJ0KGFzc2V0QSA8IGFzc2V0QikKCWZyYW1lX2RpZyAtMSAvLyBhc3NldEE6IEFzc2V0SUQKCWZyYW1lX2RpZyAtMiAvLyBhc3NldEI6IEFzc2V0SUQKCTwKCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czoyNjMKCS8vIGFzc2VydChmZWUgPD0gU0NBTEUgLyAxMCkKCWZyYW1lX2RpZyAtNiAvLyBmZWU6IHVpbnQ2NAoJaW50IDEwMDAwMDAwMAoJPD0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czoyNjQKCS8vIGFzc2VydCh2ZXJpZmljYXRpb25DbGFzcyA8PSA0KQoJZnJhbWVfZGlnIC0xMCAvLyB2ZXJpZmljYXRpb25DbGFzczogdWludDgKCWludCA0Cgk8PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjI2NQoJLy8gYXNzZXJ0KCF0aGlzLnJhdGlvLmV4aXN0cykKCXR4bmEgQXBwbGljYXRpb25zIDAKCWJ5dGUgMHg3MiAvLyAiciIKCWFwcF9nbG9iYWxfZ2V0X2V4Cglzd2FwCglwb3AKCSEKCWFzc2VydAoKCS8vICppZjBfY29uZGl0aW9uCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MjY2CgkvLyBhc3NldEEuaWQgPiAwCglmcmFtZV9kaWcgLTEgLy8gYXNzZXRBOiBBc3NldElECglpbnQgMAoJPgoJYnogKmlmMF9lbmQKCgkvLyAqaWYwX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czoyNjcKCS8vIGFzc2VydChhc3NldEEuZGVjaW1hbHMgPD0gU0NBTEVfREVDSU1BTFMpCglmcmFtZV9kaWcgLTEgLy8gYXNzZXRBOiBBc3NldElECglhc3NldF9wYXJhbXNfZ2V0IEFzc2V0RGVjaW1hbHMKCXBvcAoJaW50IDkKCTw9Cglhc3NlcnQKCippZjBfZW5kOgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjI2OQoJLy8gYXNzZXJ0KGFzc2V0Qi5kZWNpbWFscyA8PSBTQ0FMRV9ERUNJTUFMUykKCWZyYW1lX2RpZyAtMiAvLyBhc3NldEI6IEFzc2V0SUQKCWFzc2V0X3BhcmFtc19nZXQgQXNzZXREZWNpbWFscwoJcG9wCglpbnQgOQoJPD0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czoyNzAKCS8vIHMgPSBTQ0FMRSBhcyB1aW50MjU2CglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAzYjlhY2EwMAoJZnJhbWVfYnVyeSAwIC8vIHM6IHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MjcyCgkvLyBhc3NlcnQodGhpcy5mZWUudmFsdWUgPD0gMCwgJ1lvdSBjYW4gYm9vdHN0cmFwIGNvbnRyYWN0IG9ubHkgb25jZScpCglieXRlIDB4NjYgLy8gImYiCglhcHBfZ2xvYmFsX2dldAoJaW50IDAKCTw9CgoJLy8gWW91IGNhbiBib290c3RyYXAgY29udHJhY3Qgb25seSBvbmNlCglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6Mjc0CgkvLyB0aGlzLmFwcEJpYXRlY0NvbmZpZ1Byb3ZpZGVyLnZhbHVlID0gYXBwQmlhdGVjQ29uZmlnUHJvdmlkZXIKCWJ5dGUgMHg0MiAvLyAiQiIKCWZyYW1lX2RpZyAtMyAvLyBhcHBCaWF0ZWNDb25maWdQcm92aWRlcjogQXBwSUQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjI3NQoJLy8gdGhpcy5hcHBCaWF0ZWNQb29sUHJvdmlkZXIudmFsdWUgPSBhcHBCaWF0ZWNQb29sUHJvdmlkZXIKCWJ5dGUgMHg3MDcwIC8vICJwcCIKCWZyYW1lX2RpZyAtNCAvLyBhcHBCaWF0ZWNQb29sUHJvdmlkZXI6IEFwcElECglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czoyNzcKCS8vIHRoaXMucHJpY2VNaW4udmFsdWUgPSBwcmljZU1pbgoJYnl0ZSAweDcwNGQ2OTZlIC8vICJwTWluIgoJZnJhbWVfZGlnIC03IC8vIHByaWNlTWluOiB1aW50NjQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjI3OAoJLy8gdGhpcy5wcmljZU1heC52YWx1ZSA9IHByaWNlTWF4CglieXRlIDB4NzA0ZDYxNzggLy8gInBNYXgiCglmcmFtZV9kaWcgLTggLy8gcHJpY2VNYXg6IHVpbnQ2NAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6Mjc5CgkvLyB0aGlzLnByaWNlTWluU3FydC52YWx1ZSA9IHNxcnQoKHByaWNlTWluIGFzIHVpbnQyNTYpICogcykKCWJ5dGUgMHg3MDRkNjk2ZTUzIC8vICJwTWluUyIKCWZyYW1lX2RpZyAtNyAvLyBwcmljZU1pbjogdWludDY0CglpdG9iCglmcmFtZV9kaWcgMCAvLyBzOiB1aW50MjU2CgliKgoJYnNxcnQKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MjgwCgkvLyB0aGlzLnByaWNlTWF4U3FydC52YWx1ZSA9IHNxcnQoKHByaWNlTWF4IGFzIHVpbnQyNTYpICogcykKCWJ5dGUgMHg3MDRkNjE3ODUzIC8vICJwTWF4UyIKCWZyYW1lX2RpZyAtOCAvLyBwcmljZU1heDogdWludDY0CglpdG9iCglmcmFtZV9kaWcgMCAvLyBzOiB1aW50MjU2CgliKgoJYnNxcnQKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MjgxCgkvLyB0aGlzLmFzc2V0QUJhbGFuY2UudmFsdWUgPSA8dWludDI1Nj4wCglieXRlIDB4NjE2MiAvLyAiYWIiCglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MjgyCgkvLyB0aGlzLmFzc2V0QkJhbGFuY2UudmFsdWUgPSA8dWludDI1Nj4wCglieXRlIDB4NjI2MiAvLyAiYmIiCglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MjgzCgkvLyB0aGlzLnJhdGlvLnZhbHVlID0gY3VycmVudFByaWNlCglieXRlIDB4NzIgLy8gInIiCglmcmFtZV9kaWcgLTkgLy8gY3VycmVudFByaWNlOiB1aW50NjQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjI4NQoJLy8gdGhpcy5hc3NldEEudmFsdWUgPSBhc3NldEEuaWQKCWJ5dGUgMHg2MSAvLyAiYSIKCWZyYW1lX2RpZyAtMSAvLyBhc3NldEE6IEFzc2V0SUQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjI4NgoJLy8gdGhpcy5hc3NldEIudmFsdWUgPSBhc3NldEIuaWQKCWJ5dGUgMHg2MiAvLyAiYiIKCWZyYW1lX2RpZyAtMiAvLyBhc3NldEI6IEFzc2V0SUQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjI4NwoJLy8gdGhpcy5hc3NldExQLnZhbHVlID0gdGhpcy5kb0NyZWF0ZVBvb2xUb2tlbihhc3NldEEsIGFzc2V0QikuaWQKCWJ5dGUgMHg2YzcwIC8vICJscCIKCWZyYW1lX2RpZyAtMiAvLyBhc3NldEI6IEFzc2V0SUQKCWZyYW1lX2RpZyAtMSAvLyBhc3NldEE6IEFzc2V0SUQKCWNhbGxzdWIgZG9DcmVhdGVQb29sVG9rZW4KCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjI4OAoJLy8gdGhpcy5mZWUudmFsdWUgPSBmZWUKCWJ5dGUgMHg2NiAvLyAiZiIKCWZyYW1lX2RpZyAtNiAvLyBmZWU6IHVpbnQ2NAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6Mjg5CgkvLyB0aGlzLmRvT3B0SW4oYXNzZXRBKQoJZnJhbWVfZGlnIC0xIC8vIGFzc2V0QTogQXNzZXRJRAoJY2FsbHN1YiBkb09wdEluCgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjI5MAoJLy8gdGhpcy5kb09wdEluKGFzc2V0QikKCWZyYW1lX2RpZyAtMiAvLyBhc3NldEI6IEFzc2V0SUQKCWNhbGxzdWIgZG9PcHRJbgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czoyOTIKCS8vIHJldHVybiB0aGlzLmFzc2V0TFAudmFsdWU7CglieXRlIDB4NmM3MCAvLyAibHAiCglhcHBfZ2xvYmFsX2dldAoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoJcmV0c3ViCgovLyBkb0F4ZmVyKHJlY2VpdmVyOiBBZGRyZXNzLCBhc3NldDogQXNzZXRJRCwgYW1vdW50OiB1aW50NjQpOiB2b2lkCmRvQXhmZXI6Cglwcm90byAzIDAKCgkvLyAqaWYxX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjI5NgoJLy8gYXNzZXQuaWQgPT09IDAKCWZyYW1lX2RpZyAtMiAvLyBhc3NldDogQXNzZXRJRAoJaW50IDAKCT09CglieiAqaWYxX2Vsc2UKCgkvLyAqaWYxX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czoyOTcKCS8vIHNlbmRQYXltZW50KHsKCS8vICAgICAgICAgcmVjZWl2ZXI6IHJlY2VpdmVyLAoJLy8gICAgICAgICBhbW91bnQ6IGFtb3VudCwKCS8vICAgICAgICAgZmVlOiAwLAoJLy8gICAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBwYXkKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6Mjk4CgkvLyByZWNlaXZlcjogcmVjZWl2ZXIKCWZyYW1lX2RpZyAtMSAvLyByZWNlaXZlcjogQWRkcmVzcwoJaXR4bl9maWVsZCBSZWNlaXZlcgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czoyOTkKCS8vIGFtb3VudDogYW1vdW50CglmcmFtZV9kaWcgLTMgLy8gYW1vdW50OiB1aW50NjQKCWl0eG5fZmllbGQgQW1vdW50CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjMwMAoJLy8gZmVlOiAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgliICppZjFfZW5kCgoqaWYxX2Vsc2U6CgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MzAzCgkvLyBzZW5kQXNzZXRUcmFuc2Zlcih7CgkvLyAgICAgICAgIGFzc2V0UmVjZWl2ZXI6IHJlY2VpdmVyLAoJLy8gICAgICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAoJLy8gICAgICAgICBhc3NldEFtb3VudDogYW1vdW50LAoJLy8gICAgICAgICBmZWU6IDAsCgkvLyAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IGF4ZmVyCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjMwNAoJLy8gYXNzZXRSZWNlaXZlcjogcmVjZWl2ZXIKCWZyYW1lX2RpZyAtMSAvLyByZWNlaXZlcjogQWRkcmVzcwoJaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjMwNQoJLy8geGZlckFzc2V0OiBhc3NldAoJZnJhbWVfZGlnIC0yIC8vIGFzc2V0OiBBc3NldElECglpdHhuX2ZpZWxkIFhmZXJBc3NldAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czozMDYKCS8vIGFzc2V0QW1vdW50OiBhbW91bnQKCWZyYW1lX2RpZyAtMyAvLyBhbW91bnQ6IHVpbnQ2NAoJaXR4bl9maWVsZCBBc3NldEFtb3VudAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czozMDcKCS8vIGZlZTogMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKKmlmMV9lbmQ6CglyZXRzdWIKCi8vIGRvT3B0SW4oYXNzZXQ6IEFzc2V0SUQpOiB2b2lkCmRvT3B0SW46Cglwcm90byAxIDAKCgkvLyAqaWYyX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjMxMwoJLy8gYXNzZXQuaWQgPiAwCglmcmFtZV9kaWcgLTEgLy8gYXNzZXQ6IEFzc2V0SUQKCWludCAwCgk+CglieiAqaWYyX2VuZAoKCS8vICppZjJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjMxNQoJLy8gdGhpcy5kb0F4ZmVyKHRoaXMuYXBwLmFkZHJlc3MsIGFzc2V0LCAwKQoJaW50IDAKCWZyYW1lX2RpZyAtMSAvLyBhc3NldDogQXNzZXRJRAoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWNhbGxzdWIgZG9BeGZlcgoKKmlmMl9lbmQ6CglyZXRzdWIKCi8vIGRvQ3JlYXRlUG9vbFRva2VuKGFzc2V0QTogQXNzZXRJRCwgYXNzZXRCOiBBc3NldElEKTogQXNzZXRJRApkb0NyZWF0ZVBvb2xUb2tlbjoKCXByb3RvIDIgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CglkdXAKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MzIzCgkvLyBuYW1lQXNzZXRBID0gJ0FMR08nCglieXRlIDB4NDE0YzQ3NGYgLy8gIkFMR08iCglmcmFtZV9idXJ5IDAgLy8gbmFtZUFzc2V0QTogYnl0ZVtdCgoJLy8gKmlmM19jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czozMjQKCS8vIGFzc2V0QS5pZCA+IDAKCWZyYW1lX2RpZyAtMSAvLyBhc3NldEE6IEFzc2V0SUQKCWludCAwCgk+CglieiAqaWYzX2VuZAoKCS8vICppZjNfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjMyNQoJLy8gbmFtZUFzc2V0QSA9IGFzc2V0QS51bml0TmFtZQoJZnJhbWVfZGlnIC0xIC8vIGFzc2V0QTogQXNzZXRJRAoJYXNzZXRfcGFyYW1zX2dldCBBc3NldFVuaXROYW1lCglwb3AKCWZyYW1lX2J1cnkgMCAvLyBuYW1lQXNzZXRBOiBieXRlW10KCippZjNfZW5kOgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjMyOAoJLy8gbmFtZSA9ICdCLScgKyBuYW1lQXNzZXRBICsgJy0nICsgYXNzZXRCLnVuaXROYW1lCglieXRlIDB4NDIyZCAvLyAiQi0iCglmcmFtZV9kaWcgMCAvLyBuYW1lQXNzZXRBOiBieXRlW10KCWNvbmNhdAoJYnl0ZSAweDJkIC8vICItIgoJY29uY2F0CglmcmFtZV9kaWcgLTIgLy8gYXNzZXRCOiBBc3NldElECglhc3NldF9wYXJhbXNfZ2V0IEFzc2V0VW5pdE5hbWUKCXBvcAoJY29uY2F0CglmcmFtZV9idXJ5IDEgLy8gbmFtZTogYnl0ZVtdCgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjMzMAoJLy8gcmV0dXJuIHNlbmRBc3NldENyZWF0aW9uKHsKCS8vICAgICAgIGNvbmZpZ0Fzc2V0TmFtZTogbmFtZSwKCS8vICAgICAgIGNvbmZpZ0Fzc2V0VW5pdE5hbWU6ICdCTFAnLAoJLy8gICAgICAgY29uZmlnQXNzZXRUb3RhbDogVE9UQUxfU1VQUExZLAoJLy8gICAgICAgY29uZmlnQXNzZXREZWNpbWFsczogTFBfVE9LRU5fREVDSU1BTFMsCgkvLyAgICAgICBjb25maWdBc3NldE1hbmFnZXI6IHRoaXMuYXBwLmFkZHJlc3MsCgkvLyAgICAgICBjb25maWdBc3NldFJlc2VydmU6IHRoaXMuYXBwLmFkZHJlc3MsCgkvLyAgICAgfSk7CglpdHhuX2JlZ2luCglpbnQgYWNmZwoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czozMzEKCS8vIGNvbmZpZ0Fzc2V0TmFtZTogbmFtZQoJZnJhbWVfZGlnIDEgLy8gbmFtZTogYnl0ZVtdCglpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0TmFtZQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czozMzIKCS8vIGNvbmZpZ0Fzc2V0VW5pdE5hbWU6ICdCTFAnCglieXRlIDB4NDI0YzUwIC8vICJCTFAiCglpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0VW5pdE5hbWUKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MzMzCgkvLyBjb25maWdBc3NldFRvdGFsOiBUT1RBTF9TVVBQTFkKCWludCAxMDAwMDAwMDAwMDAwMDAwMAoJaXR4bl9maWVsZCBDb25maWdBc3NldFRvdGFsCgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjMzNAoJLy8gY29uZmlnQXNzZXREZWNpbWFsczogTFBfVE9LRU5fREVDSU1BTFMKCWludCA2CglpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0RGVjaW1hbHMKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MzM1CgkvLyBjb25maWdBc3NldE1hbmFnZXI6IHRoaXMuYXBwLmFkZHJlc3MKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0TWFuYWdlcgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czozMzYKCS8vIGNvbmZpZ0Fzc2V0UmVzZXJ2ZTogdGhpcy5hcHAuYWRkcmVzcwoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWl0eG5fZmllbGQgQ29uZmlnQXNzZXRSZXNlcnZlCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJaXR4biBDcmVhdGVkQXNzZXRJRAoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDEKCXJldHN1YgoKLy8gYWRkTGlxdWlkaXR5KHVpbnQ2NCx1aW50NjQsdHhuLHR4bix1aW50NjQsdWludDY0LHVpbnQ2NCl1aW50NjQKKmFiaV9yb3V0ZV9hZGRMaXF1aWRpdHk6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIGFzc2V0QjogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA1CglidG9pCgoJLy8gYXNzZXRBOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDQKCWJ0b2kKCgkvLyBhc3NldExQOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWJ0b2kKCgkvLyB0eEFzc2V0QkRlcG9zaXQ6IHR4bgoJdHhuIEdyb3VwSW5kZXgKCWludCAxCgktCgoJLy8gdHhBc3NldEFEZXBvc2l0OiB0eG4KCXR4biBHcm91cEluZGV4CglpbnQgMgoJLQoKCS8vIGFwcEJpYXRlY0lkZW50aXR5UHJvdmlkZXI6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIGFwcEJpYXRlY0NvbmZpZ1Byb3ZpZGVyOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGFkZExpcXVpZGl0eSh1aW50NjQsdWludDY0LHR4bix0eG4sdWludDY0LHVpbnQ2NCx1aW50NjQpdWludDY0CgljYWxsc3ViIGFkZExpcXVpZGl0eQoJaXRvYgoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGFkZExpcXVpZGl0eShhcHBCaWF0ZWNDb25maWdQcm92aWRlcjogQXBwSUQsIGFwcEJpYXRlY0lkZW50aXR5UHJvdmlkZXI6IEFwcElELCB0eEFzc2V0QURlcG9zaXQ6IFR4biwgdHhBc3NldEJEZXBvc2l0OiBUeG4sIGFzc2V0TFA6IEFzc2V0SUQsIGFzc2V0QTogQXNzZXRJRCwgYXNzZXRCOiBBc3NldElEKTogdWludDY0Ci8vCi8vIFRoaXMgbWV0aG9kIGFkZHMgQXNzZXQgQSBhbmQgQXNzZXQgQiB0byB0aGUgQXV0b21hdGVkIE1hcmtldCBNYWtlciBDb25jZW50cmF0ZWQgTGlxdWRpZGl0eSBQb29sIGFuZCBzZW5kIHRvIHRoZSBsaXF1ZGlkdHkgcHJvdmlkZXIgdGhlIGxpcXVkaXR5IHRva2VuCi8vIEBwYXJhbSB0eEFzc2V0QURlcG9zaXQgVHJhbnNmZXIgb2YgYXNzZXQgQSB0byB0aGUgTFAgcG9vbAovLyBAcGFyYW0gdHhBc3NldEJEZXBvc2l0IFRyYW5zZmVyIG9mIGFzc2V0IEIgdG8gdGhlIExQIHBvb2wKLy8gQHBhcmFtIGFzc2V0TFAgTGlxdWlkaXR5IHBvb2wgYXNzZXQKLy8gQHBhcmFtIGFzc2V0QSBBc3NldCBBCi8vIEBwYXJhbSBhc3NldEIgQXNzZXQgQgovLyBAcmV0dXJucyBMUCBUb2tlbiBxdWFudGl0eSBkaXN0cmlidXRlZAphZGRMaXF1aWRpdHk6Cglwcm90byA3IDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwbiAyMwoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czozNjAKCS8vIGluY3JlYXNlT3Bjb2RlQnVkZ2V0KCkKCWl0eG5fYmVnaW4KCWludCBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCWJ5dGUgYjY0IENvRUIgLy8gI3ByYWdtYSB2ZXJzaW9uIDEwOyBpbnQgMQoJZHVwCglpdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQoJaXR4bl9maWVsZCBDbGVhclN0YXRlUHJvZ3JhbQoJaW50IERlbGV0ZUFwcGxpY2F0aW9uCglpdHhuX2ZpZWxkIE9uQ29tcGxldGlvbgoJaXR4bl9zdWJtaXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MzYxCgkvLyBpbmNyZWFzZU9wY29kZUJ1ZGdldCgpCglpdHhuX2JlZ2luCglpbnQgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJaW50IDAKCWl0eG5fZmllbGQgRmVlCglieXRlIGI2NCBDb0VCIC8vICNwcmFnbWEgdmVyc2lvbiAxMDsgaW50IDEKCWR1cAoJaXR4bl9maWVsZCBBcHByb3ZhbFByb2dyYW0KCWl0eG5fZmllbGQgQ2xlYXJTdGF0ZVByb2dyYW0KCWludCBEZWxldGVBcHBsaWNhdGlvbgoJaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KCWl0eG5fc3VibWl0CgoJLy8gd2VsbCBmb3JtZWQgbWludAoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjM2MwoJLy8gYXNzZXJ0KAoJLy8gICAgICAgYXBwQmlhdGVjQ29uZmlnUHJvdmlkZXIgPT09IHRoaXMuYXBwQmlhdGVjQ29uZmlnUHJvdmlkZXIudmFsdWUsCgkvLyAgICAgICAnYXBwQmlhdGVjQ29uZmlnUHJvdmlkZXIgbXVzdCBtYXRjaCB0byB0aGUgZ2xvYmFsIHZhcmlhYmxlIGFwcCBpZCcKCS8vICAgICApCglmcmFtZV9kaWcgLTEgLy8gYXBwQmlhdGVjQ29uZmlnUHJvdmlkZXI6IEFwcElECglieXRlIDB4NDIgLy8gIkIiCglhcHBfZ2xvYmFsX2dldAoJPT0KCgkvLyBhcHBCaWF0ZWNDb25maWdQcm92aWRlciBtdXN0IG1hdGNoIHRvIHRoZSBnbG9iYWwgdmFyaWFibGUgYXBwIGlkCglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MzY4CgkvLyBhc3NlcnQoYXNzZXRBLmlkID09PSB0aGlzLmFzc2V0QS52YWx1ZSwgJ2Fzc2V0QSBtdXN0IG1hdGNoIHRvIHRoZSBnbG9iYWwgdmFyaWFibGUgdmFsdWUnKQoJZnJhbWVfZGlnIC02IC8vIGFzc2V0QTogQXNzZXRJRAoJYnl0ZSAweDYxIC8vICJhIgoJYXBwX2dsb2JhbF9nZXQKCT09CgoJLy8gYXNzZXRBIG11c3QgbWF0Y2ggdG8gdGhlIGdsb2JhbCB2YXJpYWJsZSB2YWx1ZQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjM2OQoJLy8gYXNzZXJ0KGFzc2V0Qi5pZCA9PT0gdGhpcy5hc3NldEIudmFsdWUsICdhc3NldEIgbXVzdCBtYXRjaCB0byB0aGUgZ2xvYmFsIHZhcmlhYmxlIHZhbHVlJykKCWZyYW1lX2RpZyAtNyAvLyBhc3NldEI6IEFzc2V0SUQKCWJ5dGUgMHg2MiAvLyAiYiIKCWFwcF9nbG9iYWxfZ2V0Cgk9PQoKCS8vIGFzc2V0QiBtdXN0IG1hdGNoIHRvIHRoZSBnbG9iYWwgdmFyaWFibGUgdmFsdWUKCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czozNzAKCS8vIGFzc2VydChhc3NldExQLmlkID09PSB0aGlzLmFzc2V0TFAudmFsdWUsICdhc3NldExQIG11c3QgbWF0Y2ggdG8gdGhlIGdsb2JhbCB2YXJpYWJsZSB2YWx1ZScpCglmcmFtZV9kaWcgLTUgLy8gYXNzZXRMUDogQXNzZXRJRAoJYnl0ZSAweDZjNzAgLy8gImxwIgoJYXBwX2dsb2JhbF9nZXQKCT09CgoJLy8gYXNzZXRMUCBtdXN0IG1hdGNoIHRvIHRoZSBnbG9iYWwgdmFyaWFibGUgdmFsdWUKCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czozNzEKCS8vIGlkZW50aXR5RnJvbUNvbmZpZyA9IGFwcEJpYXRlY0NvbmZpZ1Byb3ZpZGVyLmdsb2JhbFN0YXRlKCdpJykKCWZyYW1lX2RpZyAtMSAvLyBhcHBCaWF0ZWNDb25maWdQcm92aWRlcjogQXBwSUQKCWJ5dGUgMHg2OSAvLyAiaSIKCWFwcF9nbG9iYWxfZ2V0X2V4Cglhc3NlcnQKCWZyYW1lX2J1cnkgMCAvLyBpZGVudGl0eUZyb21Db25maWc6IGFueQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czozNzIKCS8vIGFzc2VydCgKCS8vICAgICAgIGFwcEJpYXRlY0lkZW50aXR5UHJvdmlkZXIgPT09IGlkZW50aXR5RnJvbUNvbmZpZywKCS8vICAgICAgICdhcHBCaWF0ZWNJZGVudGl0eVByb3ZpZGVyIG11c3QgbWF0Y2ggdG8gdGhlIGNvbmZpZyBpbiBhcHBCaWF0ZWNDb25maWdQcm92aWRlcicKCS8vICAgICApCglmcmFtZV9kaWcgLTIgLy8gYXBwQmlhdGVjSWRlbnRpdHlQcm92aWRlcjogQXBwSUQKCWZyYW1lX2RpZyAwIC8vIGlkZW50aXR5RnJvbUNvbmZpZzogYW55Cgk9PQoKCS8vIGFwcEJpYXRlY0lkZW50aXR5UHJvdmlkZXIgbXVzdCBtYXRjaCB0byB0aGUgY29uZmlnIGluIGFwcEJpYXRlY0NvbmZpZ1Byb3ZpZGVyCglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6Mzc3CgkvLyB1c2VyID0gc2VuZE1ldGhvZENhbGw8W0FkZHJlc3MsIHVpbnQ4XSwgVXNlckluZm9WMT4oewoJLy8gICAgICAgbmFtZTogJ2dldFVzZXInLAoJLy8gICAgICAgbWV0aG9kQXJnczogW3RoaXMudHhuLnNlbmRlciwgPHVpbnQ4PjFdLAoJLy8gICAgICAgZmVlOiAwLAoJLy8gICAgICAgYXBwbGljYXRpb25JRDogYXBwQmlhdGVjSWRlbnRpdHlQcm92aWRlciwKCS8vICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCW1ldGhvZCAiZ2V0VXNlcihhZGRyZXNzLHVpbnQ4KSh1aW50OCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQyNTYsdWludDI1Nixib29sLHVpbnQ2NCx1aW50NjQsYm9vbCkiCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czozNzkKCS8vIG1ldGhvZEFyZ3M6IFt0aGlzLnR4bi5zZW5kZXIsIDx1aW50OD4xXQoJdHhuIFNlbmRlcgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWJ5dGUgMHgwMQoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MzgwCgkvLyBmZWU6IDAKCWludCAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czozODEKCS8vIGFwcGxpY2F0aW9uSUQ6IGFwcEJpYXRlY0lkZW50aXR5UHJvdmlkZXIKCWZyYW1lX2RpZyAtMiAvLyBhcHBCaWF0ZWNJZGVudGl0eVByb3ZpZGVyOiBBcHBJRAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJaXR4biBOdW1Mb2dzCglpbnQgMQoJLQoJaXR4bmFzIExvZ3MKCWV4dHJhY3QgNCAwCglmcmFtZV9idXJ5IDEgLy8gdXNlcjogKHVpbnQ4LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDI1Nix1aW50MjU2LGJvb2wsdWludDY0LHVpbnQ2NCxib29sKQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czozODMKCS8vIGFzc2VydCghdXNlci5pc0xvY2tlZCwgJ1VzZXIgbXVzdCBub3QgYmUgbG9ja2VkJykKCWZyYW1lX2RpZyAxIC8vIHVzZXI6ICh1aW50OCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQyNTYsdWludDI1Nixib29sLHVpbnQ2NCx1aW50NjQsYm9vbCkKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglpbnQgMTAzMgoJZ2V0Yml0CgkhCgoJLy8gVXNlciBtdXN0IG5vdCBiZSBsb2NrZWQKCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czozODQKCS8vIGFzc2VydCgKCS8vICAgICAgIHVzZXIudmVyaWZpY2F0aW9uQ2xhc3MgPj0gdGhpcy52ZXJpZmljYXRpb25DbGFzcy52YWx1ZSwgLy8gaWYodXNlci52ZXJpZmljYXRpb25DbGFzcyA+PSB0aGlzLnZlcmlmaWNhdGlvbkNsYXNzLnZhbHVlKSB0aGVuIG9rCgkvLyAgICAgICAnVXNlciBjYW5ub3QgaW50ZXJhY3Qgd2l0aCB0aGlzIHNtYXJ0IGNvbnRyYWN0IGFzIGhpcyB2ZXJpZmljYXRpb24gY2xhc3MgaXMgbG93ZXIgdGhlbiByZXF1aXJlZCBoZXJlJwoJLy8gICAgICkKCWZyYW1lX2RpZyAxIC8vIHVzZXI6ICh1aW50OCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQyNTYsdWludDI1Nixib29sLHVpbnQ2NCx1aW50NjQsYm9vbCkKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglleHRyYWN0IDkgOAoJYnRvaQoJYnl0ZSAweDYzIC8vICJjIgoJYXBwX2dsb2JhbF9nZXQKCT49CgoJLy8gVXNlciBjYW5ub3QgaW50ZXJhY3Qgd2l0aCB0aGlzIHNtYXJ0IGNvbnRyYWN0IGFzIGhpcyB2ZXJpZmljYXRpb24gY2xhc3MgaXMgbG93ZXIgdGhlbiByZXF1aXJlZCBoZXJlCglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6Mzg5CgkvLyBhc3NldEFEZWNpbWFscyA9IDYKCWludCA2CglmcmFtZV9idXJ5IDIgLy8gYXNzZXRBRGVjaW1hbHM6IHVpbnQ2NAoKCS8vICppZjRfY29uZGl0aW9uCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MzkwCgkvLyBhc3NldEEuaWQgPiAwCglmcmFtZV9kaWcgLTYgLy8gYXNzZXRBOiBBc3NldElECglpbnQgMAoJPgoJYnogKmlmNF9lbmQKCgkvLyAqaWY0X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czozOTAKCS8vIGFzc2V0QURlY2ltYWxzID0gYXNzZXRBLmRlY2ltYWxzCglmcmFtZV9kaWcgLTYgLy8gYXNzZXRBOiBBc3NldElECglhc3NldF9wYXJhbXNfZ2V0IEFzc2V0RGVjaW1hbHMKCXBvcAoJZnJhbWVfYnVyeSAyIC8vIGFzc2V0QURlY2ltYWxzOiB1aW50NjQKCippZjRfZW5kOgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjM5MgoJLy8gYXNzZXRBRGVsaWNtYWxTY2FsZTJTY2FsZSA9ICgxMCAqKiAoU0NBTEVfREVDSU1BTFMgLSBhc3NldEFEZWNpbWFscykpIGFzIHVpbnQyNTYKCWludCAxMAoJaW50IDkKCWZyYW1lX2RpZyAyIC8vIGFzc2V0QURlY2ltYWxzOiB1aW50NjQKCS0KCWV4cAoJaXRvYgoJZnJhbWVfYnVyeSAzIC8vIGFzc2V0QURlbGljbWFsU2NhbGUyU2NhbGU6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjM5NAoJLy8gYXNzZXRCRGVsaWNtYWxTY2FsZTJTY2FsZSA9ICgxMCAqKiAoU0NBTEVfREVDSU1BTFMgLSBhc3NldEIuZGVjaW1hbHMpKSBhcyB1aW50MjU2CglpbnQgMTAKCWludCA5CglmcmFtZV9kaWcgLTcgLy8gYXNzZXRCOiBBc3NldElECglhc3NldF9wYXJhbXNfZ2V0IEFzc2V0RGVjaW1hbHMKCXBvcAoJLQoJZXhwCglpdG9iCglmcmFtZV9idXJ5IDQgLy8gYXNzZXRCRGVsaWNtYWxTY2FsZTJTY2FsZTogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6Mzk2CgkvLyBhc3NldExQRGVsaWNtYWxTY2FsZTJTY2FsZSA9ICgxMCAqKiAoU0NBTEVfREVDSU1BTFMgLSBMUF9UT0tFTl9ERUNJTUFMUykpIGFzIHVpbnQyNTYKCWludCAxMAoJaW50IDMKCWV4cAoJaXRvYgoJZnJhbWVfYnVyeSA1IC8vIGFzc2V0TFBEZWxpY21hbFNjYWxlMlNjYWxlOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czozOTgKCS8vIGFEZXBvc2l0SW5CYXNlU2NhbGUgPSAodHhBc3NldEFEZXBvc2l0LmFzc2V0QW1vdW50IGFzIHVpbnQyNTYpICogYXNzZXRBRGVsaWNtYWxTY2FsZTJTY2FsZQoJZnJhbWVfZGlnIC0zIC8vIHR4QXNzZXRBRGVwb3NpdDogVHhuCglndHhucyBBc3NldEFtb3VudAoJaXRvYgoJZnJhbWVfZGlnIDMgLy8gYXNzZXRBRGVsaWNtYWxTY2FsZTJTY2FsZTogdW5zYWZlIHVpbnQyNTYKCWIqCglmcmFtZV9idXJ5IDYgLy8gYURlcG9zaXRJbkJhc2VTY2FsZTogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6Mzk5CgkvLyBiRGVwb3NpdEluQmFzZVNjYWxlID0gKHR4QXNzZXRCRGVwb3NpdC5hc3NldEFtb3VudCBhcyB1aW50MjU2KSAqIGFzc2V0QkRlbGljbWFsU2NhbGUyU2NhbGUKCWZyYW1lX2RpZyAtNCAvLyB0eEFzc2V0QkRlcG9zaXQ6IFR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCWl0b2IKCWZyYW1lX2RpZyA0IC8vIGFzc2V0QkRlbGljbWFsU2NhbGUyU2NhbGU6IHVuc2FmZSB1aW50MjU2CgliKgoJZnJhbWVfYnVyeSA3IC8vIGJEZXBvc2l0SW5CYXNlU2NhbGU6IHVuc2FmZSB1aW50MjU2CgoJLy8gKmlmNV9jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo0MDEKCS8vIGFzc2V0QS5pZCA+IDAKCWZyYW1lX2RpZyAtNiAvLyBhc3NldEE6IEFzc2V0SUQKCWludCAwCgk+CglieiAqaWY1X2Vsc2UKCgkvLyAqaWY1X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo0MDIKCS8vIGFzc2VydCh0eEFzc2V0QURlcG9zaXQudHlwZUVudW0gPT09IFRyYW5zYWN0aW9uVHlwZS5Bc3NldFRyYW5zZmVyKQoJZnJhbWVfZGlnIC0zIC8vIHR4QXNzZXRBRGVwb3NpdDogVHhuCglndHhucyBUeXBlRW51bQoJaW50IGF4ZmVyCgk9PQoJYXNzZXJ0CgliICppZjVfZW5kCgoqaWY1X2Vsc2U6CgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NDA0CgkvLyBhc3NlcnQodHhBc3NldEFEZXBvc2l0LnR5cGVFbnVtID09PSBUcmFuc2FjdGlvblR5cGUuUGF5bWVudCkKCWZyYW1lX2RpZyAtMyAvLyB0eEFzc2V0QURlcG9zaXQ6IFR4bgoJZ3R4bnMgVHlwZUVudW0KCWludCBwYXkKCT09Cglhc3NlcnQKCippZjVfZW5kOgoJLy8gKmlmNl9jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo0MDcKCS8vIHR4QXNzZXRBRGVwb3NpdC50eXBlRW51bSA9PT0gVHJhbnNhY3Rpb25UeXBlLkFzc2V0VHJhbnNmZXIKCWZyYW1lX2RpZyAtMyAvLyB0eEFzc2V0QURlcG9zaXQ6IFR4bgoJZ3R4bnMgVHlwZUVudW0KCWludCBheGZlcgoJPT0KCWJ6ICppZjZfZWxzZWlmMV9jb25kaXRpb24KCgkvLyAqaWY2X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo0MDgKCS8vIHhmZXIgPSB0eEFzc2V0QURlcG9zaXQgYXMgQXNzZXRUcmFuc2ZlclR4bgoJZnJhbWVfZGlnIC0zIC8vIHR4QXNzZXRBRGVwb3NpdDogVHhuCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnQgYXhmZXIKCT09Cglhc3NlcnQKCWZyYW1lX2J1cnkgOCAvLyB4ZmVyOiBheGZlcgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo0MDkKCS8vIHZlcmlmeUFzc2V0VHJhbnNmZXJUeG4oeGZlciwgewoJLy8gICAgICAgICBhc3NldFJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gICAgICAgICB4ZmVyQXNzZXQ6IGFzc2V0QSwKCS8vICAgICAgICAgYXNzZXRBbW91bnQ6IHsgZ3JlYXRlclRoYW5FcXVhbFRvOiAwIH0sCgkvLyAgICAgICB9KQoJLy8gdmVyaWZ5IGF4ZmVyCglmcmFtZV9kaWcgOCAvLyB4ZmVyOiBheGZlcgoJZ3R4bnMgVHlwZUVudW0KCWludCBheGZlcgoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSBhc3NldFJlY2VpdmVyCglmcmFtZV9kaWcgOCAvLyB4ZmVyOiBheGZlcgoJZ3R4bnMgQXNzZXRSZWNlaXZlcgoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCT09Cglhc3NlcnQKCgkvLyB2ZXJpZnkgeGZlckFzc2V0CglmcmFtZV9kaWcgOCAvLyB4ZmVyOiBheGZlcgoJZ3R4bnMgWGZlckFzc2V0CglmcmFtZV9kaWcgLTYgLy8gYXNzZXRBOiBBc3NldElECgk9PQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IGFzc2V0QW1vdW50CglmcmFtZV9kaWcgOCAvLyB4ZmVyOiBheGZlcgoJZ3R4bnMgQXNzZXRBbW91bnQKCWludCAwCgk+PQoJYXNzZXJ0CgliICppZjZfZW5kCgoqaWY2X2Vsc2VpZjFfY29uZGl0aW9uOgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjQxNAoJLy8gdHhBc3NldEFEZXBvc2l0LnR5cGVFbnVtID09PSBUcmFuc2FjdGlvblR5cGUuUGF5bWVudAoJZnJhbWVfZGlnIC0zIC8vIHR4QXNzZXRBRGVwb3NpdDogVHhuCglndHhucyBUeXBlRW51bQoJaW50IHBheQoJPT0KCWJ6ICppZjZfZWxzZQoKCS8vICppZjZfZWxzZWlmMV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NDE1CgkvLyBwYXlUeCA9IHR4QXNzZXRBRGVwb3NpdCBhcyBQYXlUeG4KCWZyYW1lX2RpZyAtMyAvLyB0eEFzc2V0QURlcG9zaXQ6IFR4bgoJZHVwCglndHhucyBUeXBlRW51bQoJaW50IHBheQoJPT0KCWFzc2VydAoJZnJhbWVfYnVyeSA5IC8vIHBheVR4OiBwYXkKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NDE2CgkvLyB2ZXJpZnlQYXlUeG4ocGF5VHgsIHsKCS8vICAgICAgICAgcmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MsCgkvLyAgICAgICAgIGFtb3VudDogeyBncmVhdGVyVGhhbkVxdWFsVG86IDAgfSwKCS8vICAgICAgIH0pCgkvLyB2ZXJpZnkgcGF5CglmcmFtZV9kaWcgOSAvLyBwYXlUeDogcGF5CglndHhucyBUeXBlRW51bQoJaW50IHBheQoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSByZWNlaXZlcgoJZnJhbWVfZGlnIDkgLy8gcGF5VHg6IHBheQoJZ3R4bnMgUmVjZWl2ZXIKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IGFtb3VudAoJZnJhbWVfZGlnIDkgLy8gcGF5VHg6IHBheQoJZ3R4bnMgQW1vdW50CglpbnQgMAoJPj0KCWFzc2VydAoJYiAqaWY2X2VuZAoKKmlmNl9lbHNlOgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjQyMQoJLy8gYXNzZXJ0KGZhbHNlLCAnVW5zdXBwb3J0ZWQgdHggdHlwZSBvZiB0aGUgYXNzZXQgQScpCglpbnQgMAoKCS8vIFVuc3VwcG9ydGVkIHR4IHR5cGUgb2YgdGhlIGFzc2V0IEEKCWFzc2VydAoKKmlmNl9lbmQ6CgkvLyAqaWY3X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjQyNAoJLy8gdHhBc3NldEJEZXBvc2l0LnR5cGVFbnVtID09PSBUcmFuc2FjdGlvblR5cGUuQXNzZXRUcmFuc2ZlcgoJZnJhbWVfZGlnIC00IC8vIHR4QXNzZXRCRGVwb3NpdDogVHhuCglndHhucyBUeXBlRW51bQoJaW50IGF4ZmVyCgk9PQoJYnogKmlmN19lbHNlaWYxX2NvbmRpdGlvbgoKCS8vICppZjdfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjQyNQoJLy8geGZlciA9IHR4QXNzZXRCRGVwb3NpdCBhcyBBc3NldFRyYW5zZmVyVHhuCglmcmFtZV9kaWcgLTQgLy8gdHhBc3NldEJEZXBvc2l0OiBUeG4KCWR1cAoJZ3R4bnMgVHlwZUVudW0KCWludCBheGZlcgoJPT0KCWFzc2VydAoJZnJhbWVfYnVyeSAxMCAvLyB4ZmVyOiBheGZlcgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo0MjYKCS8vIHZlcmlmeUFzc2V0VHJhbnNmZXJUeG4oeGZlciwgewoJLy8gICAgICAgICBhc3NldFJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gICAgICAgICB4ZmVyQXNzZXQ6IGFzc2V0QiwKCS8vICAgICAgICAgYXNzZXRBbW91bnQ6IHsgZ3JlYXRlclRoYW5FcXVhbFRvOiAwIH0sCgkvLyAgICAgICB9KQoJLy8gdmVyaWZ5IGF4ZmVyCglmcmFtZV9kaWcgMTAgLy8geGZlcjogYXhmZXIKCWd0eG5zIFR5cGVFbnVtCglpbnQgYXhmZXIKCT09Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYXNzZXRSZWNlaXZlcgoJZnJhbWVfZGlnIDEwIC8vIHhmZXI6IGF4ZmVyCglndHhucyBBc3NldFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSB4ZmVyQXNzZXQKCWZyYW1lX2RpZyAxMCAvLyB4ZmVyOiBheGZlcgoJZ3R4bnMgWGZlckFzc2V0CglmcmFtZV9kaWcgLTcgLy8gYXNzZXRCOiBBc3NldElECgk9PQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IGFzc2V0QW1vdW50CglmcmFtZV9kaWcgMTAgLy8geGZlcjogYXhmZXIKCWd0eG5zIEFzc2V0QW1vdW50CglpbnQgMAoJPj0KCWFzc2VydAoJYiAqaWY3X2VuZAoKKmlmN19lbHNlaWYxX2NvbmRpdGlvbjoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo0MzEKCS8vIHR4QXNzZXRCRGVwb3NpdC50eXBlRW51bSA9PT0gVHJhbnNhY3Rpb25UeXBlLlBheW1lbnQKCWZyYW1lX2RpZyAtNCAvLyB0eEFzc2V0QkRlcG9zaXQ6IFR4bgoJZ3R4bnMgVHlwZUVudW0KCWludCBwYXkKCT09CglieiAqaWY3X2Vsc2UKCgkvLyAqaWY3X2Vsc2VpZjFfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjQzMgoJLy8gcGF5VHggPSB0eEFzc2V0QkRlcG9zaXQgYXMgUGF5VHhuCglmcmFtZV9kaWcgLTQgLy8gdHhBc3NldEJEZXBvc2l0OiBUeG4KCWR1cAoJZ3R4bnMgVHlwZUVudW0KCWludCBwYXkKCT09Cglhc3NlcnQKCWZyYW1lX2J1cnkgMTEgLy8gcGF5VHg6IHBheQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo0MzMKCS8vIHZlcmlmeVBheVR4bihwYXlUeCwgewoJLy8gICAgICAgICByZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgICAgYW1vdW50OiB7IGdyZWF0ZXJUaGFuRXF1YWxUbzogMCB9LAoJLy8gICAgICAgfSkKCS8vIHZlcmlmeSBwYXkKCWZyYW1lX2RpZyAxMSAvLyBwYXlUeDogcGF5CglndHhucyBUeXBlRW51bQoJaW50IHBheQoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSByZWNlaXZlcgoJZnJhbWVfZGlnIDExIC8vIHBheVR4OiBwYXkKCWd0eG5zIFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSBhbW91bnQKCWZyYW1lX2RpZyAxMSAvLyBwYXlUeDogcGF5CglndHhucyBBbW91bnQKCWludCAwCgk+PQoJYXNzZXJ0CgliICppZjdfZW5kCgoqaWY3X2Vsc2U6CgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NDM4CgkvLyBhc3NlcnQoZmFsc2UsICdVbnN1cHBvcnRlZCB0eCB0eXBlIG9mIHRoZSBhc3NldCBCJykKCWludCAwCgoJLy8gVW5zdXBwb3J0ZWQgdHggdHlwZSBvZiB0aGUgYXNzZXQgQgoJYXNzZXJ0CgoqaWY3X2VuZDoKCS8vICppZjhfY29uZGl0aW9uCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NDQxCgkvLyB0aGlzLmFzc2V0QUJhbGFuY2UudmFsdWUgPT09IDx1aW50MjU2PjAgJiYgdGhpcy5hc3NldEJCYWxhbmNlLnZhbHVlID09PSA8dWludDI1Nj4wCglieXRlIDB4NjE2MiAvLyAiYWIiCglhcHBfZ2xvYmFsX2dldAoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKCWI9PQoJZHVwCglieiAqc2tpcF9hbmQwCglieXRlIDB4NjI2MiAvLyAiYmIiCglhcHBfZ2xvYmFsX2dldAoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKCWI9PQoJJiYKCipza2lwX2FuZDA6CglieiAqaWY4X2VuZAoKCS8vICppZjhfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjQ0NgoJLy8gcmV0dXJuIHRoaXMucHJvY2Vzc0FkZExpcXVkaXR5KGFEZXBvc2l0SW5CYXNlU2NhbGUsIGJEZXBvc2l0SW5CYXNlU2NhbGUsIGFzc2V0TFBEZWxpY21hbFNjYWxlMlNjYWxlLCBhc3NldExQKTsKCWZyYW1lX2RpZyAtNSAvLyBhc3NldExQOiBBc3NldElECglmcmFtZV9kaWcgNSAvLyBhc3NldExQRGVsaWNtYWxTY2FsZTJTY2FsZTogdW5zYWZlIHVpbnQyNTYKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJZnJhbWVfZGlnIDcgLy8gYkRlcG9zaXRJbkJhc2VTY2FsZTogdW5zYWZlIHVpbnQyNTYKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJZnJhbWVfZGlnIDYgLy8gYURlcG9zaXRJbkJhc2VTY2FsZTogdW5zYWZlIHVpbnQyNTYKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJY2FsbHN1YiBwcm9jZXNzQWRkTGlxdWRpdHkKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiAxMQoJcmV0c3ViCgoqaWY4X2VuZDoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo0NTMKCS8vIGEgPSB0aGlzLmNhbGN1bGF0ZUFzc2V0QURlcG9zaXRPbkFzc2V0QkRlcG9zaXQoCgkvLyAgICAgICBhRGVwb3NpdEluQmFzZVNjYWxlLAoJLy8gICAgICAgYkRlcG9zaXRJbkJhc2VTY2FsZSwKCS8vICAgICAgIHRoaXMuYXNzZXRBQmFsYW5jZS52YWx1ZSwKCS8vICAgICAgIHRoaXMuYXNzZXRCQmFsYW5jZS52YWx1ZQoJLy8gICAgICkKCWJ5dGUgMHg2MjYyIC8vICJiYiIKCWFwcF9nbG9iYWxfZ2V0CglieXRlIDB4NjE2MiAvLyAiYWIiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIDcgLy8gYkRlcG9zaXRJbkJhc2VTY2FsZTogdW5zYWZlIHVpbnQyNTYKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJZnJhbWVfZGlnIDYgLy8gYURlcG9zaXRJbkJhc2VTY2FsZTogdW5zYWZlIHVpbnQyNTYKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJY2FsbHN1YiBjYWxjdWxhdGVBc3NldEFEZXBvc2l0T25Bc3NldEJEZXBvc2l0CglmcmFtZV9idXJ5IDEyIC8vIGE6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjQ2MAoJLy8gYiA9IHRoaXMuY2FsY3VsYXRlQXNzZXRCRGVwb3NpdE9uQXNzZXRBRGVwb3NpdCgKCS8vICAgICAgIGFEZXBvc2l0SW5CYXNlU2NhbGUsCgkvLyAgICAgICBiRGVwb3NpdEluQmFzZVNjYWxlLAoJLy8gICAgICAgdGhpcy5hc3NldEFCYWxhbmNlLnZhbHVlLAoJLy8gICAgICAgdGhpcy5hc3NldEJCYWxhbmNlLnZhbHVlCgkvLyAgICAgKQoJYnl0ZSAweDYyNjIgLy8gImJiIgoJYXBwX2dsb2JhbF9nZXQKCWJ5dGUgMHg2MTYyIC8vICJhYiIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9kaWcgNyAvLyBiRGVwb3NpdEluQmFzZVNjYWxlOiB1bnNhZmUgdWludDI1NgoJZHVwCgliaXRsZW4KCWludCAyNTYKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDMyCgktCglzd2FwCglzdWJzdHJpbmczCglmcmFtZV9kaWcgNiAvLyBhRGVwb3NpdEluQmFzZVNjYWxlOiB1bnNhZmUgdWludDI1NgoJZHVwCgliaXRsZW4KCWludCAyNTYKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDMyCgktCglzd2FwCglzdWJzdHJpbmczCgljYWxsc3ViIGNhbGN1bGF0ZUFzc2V0QkRlcG9zaXRPbkFzc2V0QURlcG9zaXQKCWZyYW1lX2J1cnkgMTMgLy8gYjogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NDY2CgkvLyBleHBlY3RlZEFEZXBvc2l0QjY0ID0gKGEgLyBhc3NldEFEZWxpY21hbFNjYWxlMlNjYWxlKSBhcyB1aW50NjQKCWZyYW1lX2RpZyAxMiAvLyBhOiB1bnNhZmUgdWludDI1NgoJZnJhbWVfZGlnIDMgLy8gYXNzZXRBRGVsaWNtYWxTY2FsZTJTY2FsZTogdW5zYWZlIHVpbnQyNTYKCWIvCglkdXAKCWJpdGxlbgoJaW50IDY0Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCA4CgktCglzd2FwCglzdWJzdHJpbmczCglidG9pCglmcmFtZV9idXJ5IDE0IC8vIGV4cGVjdGVkQURlcG9zaXRCNjQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo0NjcKCS8vIGV4cGVjdGVkQkRlcG9zaXRCNjQgPSAoYiAvIGFzc2V0QkRlbGljbWFsU2NhbGUyU2NhbGUpIGFzIHVpbnQ2NAoJZnJhbWVfZGlnIDEzIC8vIGI6IHVuc2FmZSB1aW50MjU2CglmcmFtZV9kaWcgNCAvLyBhc3NldEJEZWxpY21hbFNjYWxlMlNjYWxlOiB1bnNhZmUgdWludDI1NgoJYi8KCWR1cAoJYml0bGVuCglpbnQgNjQKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDgKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWJ0b2kKCWZyYW1lX2J1cnkgMTUgLy8gZXhwZWN0ZWRCRGVwb3NpdEI2NDogdWludDY0CgoJLy8gKmlmOV9jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo0NjkKCS8vIGV4cGVjdGVkQURlcG9zaXRCNjQgPiB0eEFzc2V0QURlcG9zaXQuYXNzZXRBbW91bnQKCWZyYW1lX2RpZyAxNCAvLyBleHBlY3RlZEFEZXBvc2l0QjY0OiB1aW50NjQKCWZyYW1lX2RpZyAtMyAvLyB0eEFzc2V0QURlcG9zaXQ6IFR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCT4KCWJ6ICppZjlfZW5kCgoJLy8gKmlmOV9jb25zZXF1ZW50CgkvLyAqaWYxMF9jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo0NzYKCS8vIGV4cGVjdGVkQkRlcG9zaXRCNjQgPiB0eEFzc2V0QkRlcG9zaXQuYXNzZXRBbW91bnQKCWZyYW1lX2RpZyAxNSAvLyBleHBlY3RlZEJEZXBvc2l0QjY0OiB1aW50NjQKCWZyYW1lX2RpZyAtNCAvLyB0eEFzc2V0QkRlcG9zaXQ6IFR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCT4KCWJ6ICppZjEwX2VuZAoKCS8vICppZjEwX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo0NzcKCS8vIGFzc2VydChmYWxzZSwgJ0RvbWluYW50IGlzIGFzc2V0IEInKQoJaW50IDAKCgkvLyBEb21pbmFudCBpcyBhc3NldCBCCglhc3NlcnQKCippZjEwX2VuZDoKCS8vICppZjExX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjQ3OQoJLy8gdHhBc3NldEJEZXBvc2l0LmFzc2V0QW1vdW50IC0gZXhwZWN0ZWRCRGVwb3NpdEI2NCA+IDAKCWZyYW1lX2RpZyAtNCAvLyB0eEFzc2V0QkRlcG9zaXQ6IFR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCWZyYW1lX2RpZyAxNSAvLyBleHBlY3RlZEJEZXBvc2l0QjY0OiB1aW50NjQKCS0KCWludCAwCgk+CglieiAqaWYxMV9lbmQKCgkvLyAqaWYxMV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NDgxCgkvLyB0aGlzLmRvQXhmZXIodGhpcy50eG4uc2VuZGVyLCBhc3NldEIsIHR4QXNzZXRCRGVwb3NpdC5hc3NldEFtb3VudCAtIGV4cGVjdGVkQkRlcG9zaXRCNjQpCglmcmFtZV9kaWcgLTQgLy8gdHhBc3NldEJEZXBvc2l0OiBUeG4KCWd0eG5zIEFzc2V0QW1vdW50CglmcmFtZV9kaWcgMTUgLy8gZXhwZWN0ZWRCRGVwb3NpdEI2NDogdWludDY0CgktCglmcmFtZV9kaWcgLTcgLy8gYXNzZXRCOiBBc3NldElECgl0eG4gU2VuZGVyCgljYWxsc3ViIGRvQXhmZXIKCippZjExX2VuZDoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo0ODMKCS8vIHJlYWxBc3NldEFEZXBvc2l0ID0gYURlcG9zaXRJbkJhc2VTY2FsZQoJZnJhbWVfZGlnIDYgLy8gYURlcG9zaXRJbkJhc2VTY2FsZTogdW5zYWZlIHVpbnQyNTYKCWZyYW1lX2J1cnkgMTYgLy8gcmVhbEFzc2V0QURlcG9zaXQ6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjQ4NAoJLy8gcmVhbEFzc2V0QkRlcG9zaXQgPQoJLy8gICAgICAgICAoKHR4QXNzZXRCRGVwb3NpdC5hc3NldEFtb3VudCAtIGV4cGVjdGVkQkRlcG9zaXRCNjQpIGFzIHVpbnQyNTYpICogYXNzZXRCRGVsaWNtYWxTY2FsZTJTY2FsZQoJZnJhbWVfZGlnIC00IC8vIHR4QXNzZXRCRGVwb3NpdDogVHhuCglndHhucyBBc3NldEFtb3VudAoJZnJhbWVfZGlnIDE1IC8vIGV4cGVjdGVkQkRlcG9zaXRCNjQ6IHVpbnQ2NAoJLQoJaXRvYgoJZnJhbWVfZGlnIDQgLy8gYXNzZXRCRGVsaWNtYWxTY2FsZTJTY2FsZTogdW5zYWZlIHVpbnQyNTYKCWIqCglmcmFtZV9idXJ5IDE3IC8vIHJlYWxBc3NldEJEZXBvc2l0OiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo0ODYKCS8vIHJldHVybiB0aGlzLnByb2Nlc3NBZGRMaXF1ZGl0eShyZWFsQXNzZXRBRGVwb3NpdCwgcmVhbEFzc2V0QkRlcG9zaXQsIGFzc2V0TFBEZWxpY21hbFNjYWxlMlNjYWxlLCBhc3NldExQKTsKCWZyYW1lX2RpZyAtNSAvLyBhc3NldExQOiBBc3NldElECglmcmFtZV9kaWcgNSAvLyBhc3NldExQRGVsaWNtYWxTY2FsZTJTY2FsZTogdW5zYWZlIHVpbnQyNTYKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJZnJhbWVfZGlnIDE3IC8vIHJlYWxBc3NldEJEZXBvc2l0OiB1bnNhZmUgdWludDI1NgoJZHVwCgliaXRsZW4KCWludCAyNTYKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDMyCgktCglzd2FwCglzdWJzdHJpbmczCglmcmFtZV9kaWcgMTYgLy8gcmVhbEFzc2V0QURlcG9zaXQ6IHVuc2FmZSB1aW50MjU2CglkdXAKCWJpdGxlbgoJaW50IDI1NgoJPD0KCWFzc2VydAoJYnl0ZSAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnQgMzIKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWNhbGxzdWIgcHJvY2Vzc0FkZExpcXVkaXR5CgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMTcKCXJldHN1YgoKKmlmOV9lbmQ6CgkvLyAqaWYxMl9jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo0ODkKCS8vIGV4cGVjdGVkQkRlcG9zaXRCNjQgPiB0eEFzc2V0QkRlcG9zaXQuYXNzZXRBbW91bnQKCWZyYW1lX2RpZyAxNSAvLyBleHBlY3RlZEJEZXBvc2l0QjY0OiB1aW50NjQKCWZyYW1lX2RpZyAtNCAvLyB0eEFzc2V0QkRlcG9zaXQ6IFR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCT4KCWJ6ICppZjEyX2VuZAoKCS8vICppZjEyX2NvbnNlcXVlbnQKCS8vICppZjEzX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjQ5NgoJLy8gZXhwZWN0ZWRBRGVwb3NpdEI2NCA+IHR4QXNzZXRBRGVwb3NpdC5hc3NldEFtb3VudAoJZnJhbWVfZGlnIDE0IC8vIGV4cGVjdGVkQURlcG9zaXRCNjQ6IHVpbnQ2NAoJZnJhbWVfZGlnIC0zIC8vIHR4QXNzZXRBRGVwb3NpdDogVHhuCglndHhucyBBc3NldEFtb3VudAoJPgoJYnogKmlmMTNfZW5kCgoJLy8gKmlmMTNfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjQ5NwoJLy8gYXNzZXJ0KGZhbHNlLCAnRG9taW5hbnQgaXMgYXNzZXQgQScpCglpbnQgMAoKCS8vIERvbWluYW50IGlzIGFzc2V0IEEKCWFzc2VydAoKKmlmMTNfZW5kOgoJLy8gKmlmMTRfY29uZGl0aW9uCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NDk5CgkvLyB0eEFzc2V0QURlcG9zaXQuYXNzZXRBbW91bnQgLSBleHBlY3RlZEFEZXBvc2l0QjY0ID4gMAoJZnJhbWVfZGlnIC0zIC8vIHR4QXNzZXRBRGVwb3NpdDogVHhuCglndHhucyBBc3NldEFtb3VudAoJZnJhbWVfZGlnIDE0IC8vIGV4cGVjdGVkQURlcG9zaXRCNjQ6IHVpbnQ2NAoJLQoJaW50IDAKCT4KCWJ6ICppZjE0X2VuZAoKCS8vICppZjE0X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo1MDEKCS8vIHRoaXMuZG9BeGZlcih0aGlzLnR4bi5zZW5kZXIsIGFzc2V0QiwgdHhBc3NldEFEZXBvc2l0LmFzc2V0QW1vdW50IC0gZXhwZWN0ZWRBRGVwb3NpdEI2NCkKCWZyYW1lX2RpZyAtMyAvLyB0eEFzc2V0QURlcG9zaXQ6IFR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCWZyYW1lX2RpZyAxNCAvLyBleHBlY3RlZEFEZXBvc2l0QjY0OiB1aW50NjQKCS0KCWZyYW1lX2RpZyAtNyAvLyBhc3NldEI6IEFzc2V0SUQKCXR4biBTZW5kZXIKCWNhbGxzdWIgZG9BeGZlcgoKKmlmMTRfZW5kOgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjUwMwoJLy8gcmVhbEFzc2V0QURlcG9zaXQgPQoJLy8gICAgICAgICAoKHR4QXNzZXRBRGVwb3NpdC5hc3NldEFtb3VudCAtIGV4cGVjdGVkQURlcG9zaXRCNjQpIGFzIHVpbnQyNTYpICogYXNzZXRBRGVsaWNtYWxTY2FsZTJTY2FsZQoJZnJhbWVfZGlnIC0zIC8vIHR4QXNzZXRBRGVwb3NpdDogVHhuCglndHhucyBBc3NldEFtb3VudAoJZnJhbWVfZGlnIDE0IC8vIGV4cGVjdGVkQURlcG9zaXRCNjQ6IHVpbnQ2NAoJLQoJaXRvYgoJZnJhbWVfZGlnIDMgLy8gYXNzZXRBRGVsaWNtYWxTY2FsZTJTY2FsZTogdW5zYWZlIHVpbnQyNTYKCWIqCglmcmFtZV9idXJ5IDE4IC8vIHJlYWxBc3NldEFEZXBvc2l0OiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo1MDUKCS8vIHJlYWxBc3NldEJEZXBvc2l0ID0gYkRlcG9zaXRJbkJhc2VTY2FsZQoJZnJhbWVfZGlnIDcgLy8gYkRlcG9zaXRJbkJhc2VTY2FsZTogdW5zYWZlIHVpbnQyNTYKCWZyYW1lX2J1cnkgMTkgLy8gcmVhbEFzc2V0QkRlcG9zaXQ6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjUwNgoJLy8gcmV0dXJuIHRoaXMucHJvY2Vzc0FkZExpcXVkaXR5KHJlYWxBc3NldEFEZXBvc2l0LCByZWFsQXNzZXRCRGVwb3NpdCwgYXNzZXRMUERlbGljbWFsU2NhbGUyU2NhbGUsIGFzc2V0TFApOwoJZnJhbWVfZGlnIC01IC8vIGFzc2V0TFA6IEFzc2V0SUQKCWZyYW1lX2RpZyA1IC8vIGFzc2V0TFBEZWxpY21hbFNjYWxlMlNjYWxlOiB1bnNhZmUgdWludDI1NgoJZHVwCgliaXRsZW4KCWludCAyNTYKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDMyCgktCglzd2FwCglzdWJzdHJpbmczCglmcmFtZV9kaWcgMTkgLy8gcmVhbEFzc2V0QkRlcG9zaXQ6IHVuc2FmZSB1aW50MjU2CglkdXAKCWJpdGxlbgoJaW50IDI1NgoJPD0KCWFzc2VydAoJYnl0ZSAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnQgMzIKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWZyYW1lX2RpZyAxOCAvLyByZWFsQXNzZXRBRGVwb3NpdDogdW5zYWZlIHVpbnQyNTYKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJY2FsbHN1YiBwcm9jZXNzQWRkTGlxdWRpdHkKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiAxOQoJcmV0c3ViCgoqaWYxMl9lbmQ6CgkvLyAqaWYxNV9jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo1MDgKCS8vIGV4cGVjdGVkQURlcG9zaXRCNjQgPT09IHR4QXNzZXRBRGVwb3NpdC5hc3NldEFtb3VudCAmJiBleHBlY3RlZEJEZXBvc2l0QjY0ID09PSB0eEFzc2V0QkRlcG9zaXQuYXNzZXRBbW91bnQKCWZyYW1lX2RpZyAxNCAvLyBleHBlY3RlZEFEZXBvc2l0QjY0OiB1aW50NjQKCWZyYW1lX2RpZyAtMyAvLyB0eEFzc2V0QURlcG9zaXQ6IFR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCT09CglkdXAKCWJ6ICpza2lwX2FuZDEKCWZyYW1lX2RpZyAxNSAvLyBleHBlY3RlZEJEZXBvc2l0QjY0OiB1aW50NjQKCWZyYW1lX2RpZyAtNCAvLyB0eEFzc2V0QkRlcG9zaXQ6IFR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCT09CgkmJgoKKnNraXBfYW5kMToKCWJ6ICppZjE1X2VuZAoKCS8vICppZjE1X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo1MDkKCS8vIHJlYWxBc3NldEFEZXBvc2l0ID0gYURlcG9zaXRJbkJhc2VTY2FsZQoJZnJhbWVfZGlnIDYgLy8gYURlcG9zaXRJbkJhc2VTY2FsZTogdW5zYWZlIHVpbnQyNTYKCWZyYW1lX2J1cnkgMjAgLy8gcmVhbEFzc2V0QURlcG9zaXQ6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjUxMAoJLy8gcmVhbEFzc2V0QkRlcG9zaXQgPSBiRGVwb3NpdEluQmFzZVNjYWxlCglmcmFtZV9kaWcgNyAvLyBiRGVwb3NpdEluQmFzZVNjYWxlOiB1bnNhZmUgdWludDI1NgoJZnJhbWVfYnVyeSAyMSAvLyByZWFsQXNzZXRCRGVwb3NpdDogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NTExCgkvLyByZXR1cm4gdGhpcy5wcm9jZXNzQWRkTGlxdWRpdHkocmVhbEFzc2V0QURlcG9zaXQsIHJlYWxBc3NldEJEZXBvc2l0LCBhc3NldExQRGVsaWNtYWxTY2FsZTJTY2FsZSwgYXNzZXRMUCk7CglmcmFtZV9kaWcgLTUgLy8gYXNzZXRMUDogQXNzZXRJRAoJZnJhbWVfZGlnIDUgLy8gYXNzZXRMUERlbGljbWFsU2NhbGUyU2NhbGU6IHVuc2FmZSB1aW50MjU2CglkdXAKCWJpdGxlbgoJaW50IDI1NgoJPD0KCWFzc2VydAoJYnl0ZSAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnQgMzIKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWZyYW1lX2RpZyAyMSAvLyByZWFsQXNzZXRCRGVwb3NpdDogdW5zYWZlIHVpbnQyNTYKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJZnJhbWVfZGlnIDIwIC8vIHJlYWxBc3NldEFEZXBvc2l0OiB1bnNhZmUgdWludDI1NgoJZHVwCgliaXRsZW4KCWludCAyNTYKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDMyCgktCglzd2FwCglzdWJzdHJpbmczCgljYWxsc3ViIHByb2Nlc3NBZGRMaXF1ZGl0eQoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDIxCglyZXRzdWIKCippZjE1X2VuZDoKCS8vICppZjE2X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjUxNAoJLy8gZXhwZWN0ZWRBRGVwb3NpdEI2NCA9PT0gdHhBc3NldEFEZXBvc2l0LmFzc2V0QW1vdW50ICYmIGV4cGVjdGVkQkRlcG9zaXRCNjQgPT09IHR4QXNzZXRCRGVwb3NpdC5hc3NldEFtb3VudAoJZnJhbWVfZGlnIDE0IC8vIGV4cGVjdGVkQURlcG9zaXRCNjQ6IHVpbnQ2NAoJZnJhbWVfZGlnIC0zIC8vIHR4QXNzZXRBRGVwb3NpdDogVHhuCglndHhucyBBc3NldEFtb3VudAoJPT0KCWR1cAoJYnogKnNraXBfYW5kMgoJZnJhbWVfZGlnIDE1IC8vIGV4cGVjdGVkQkRlcG9zaXRCNjQ6IHVpbnQ2NAoJZnJhbWVfZGlnIC00IC8vIHR4QXNzZXRCRGVwb3NpdDogVHhuCglndHhucyBBc3NldEFtb3VudAoJPT0KCSYmCgoqc2tpcF9hbmQyOgoJYnogKmlmMTZfZW5kCgoJLy8gKmlmMTZfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjUxNQoJLy8gcmVhbEFzc2V0QURlcG9zaXQgPSBhRGVwb3NpdEluQmFzZVNjYWxlCglmcmFtZV9kaWcgNiAvLyBhRGVwb3NpdEluQmFzZVNjYWxlOiB1bnNhZmUgdWludDI1NgoJZnJhbWVfYnVyeSAyMiAvLyByZWFsQXNzZXRBRGVwb3NpdDogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NTE2CgkvLyByZWFsQXNzZXRCRGVwb3NpdCA9IGJEZXBvc2l0SW5CYXNlU2NhbGUKCWZyYW1lX2RpZyA3IC8vIGJEZXBvc2l0SW5CYXNlU2NhbGU6IHVuc2FmZSB1aW50MjU2CglmcmFtZV9idXJ5IDIzIC8vIHJlYWxBc3NldEJEZXBvc2l0OiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo1MTcKCS8vIHJldHVybiB0aGlzLnByb2Nlc3NBZGRMaXF1ZGl0eShyZWFsQXNzZXRBRGVwb3NpdCwgcmVhbEFzc2V0QkRlcG9zaXQsIGFzc2V0TFBEZWxpY21hbFNjYWxlMlNjYWxlLCBhc3NldExQKTsKCWZyYW1lX2RpZyAtNSAvLyBhc3NldExQOiBBc3NldElECglmcmFtZV9kaWcgNSAvLyBhc3NldExQRGVsaWNtYWxTY2FsZTJTY2FsZTogdW5zYWZlIHVpbnQyNTYKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJZnJhbWVfZGlnIDIzIC8vIHJlYWxBc3NldEJEZXBvc2l0OiB1bnNhZmUgdWludDI1NgoJZHVwCgliaXRsZW4KCWludCAyNTYKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDMyCgktCglzd2FwCglzdWJzdHJpbmczCglmcmFtZV9kaWcgMjIgLy8gcmVhbEFzc2V0QURlcG9zaXQ6IHVuc2FmZSB1aW50MjU2CglkdXAKCWJpdGxlbgoJaW50IDI1NgoJPD0KCWFzc2VydAoJYnl0ZSAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnQgMzIKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWNhbGxzdWIgcHJvY2Vzc0FkZExpcXVkaXR5CgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMjMKCXJldHN1YgoKKmlmMTZfZW5kOgoJLy8gKmlmMTdfY29uZGl0aW9uCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NTIwCgkvLyBleHBlY3RlZEFEZXBvc2l0QjY0ID09PSAwICYmIGV4cGVjdGVkQkRlcG9zaXRCNjQgPT09IDAKCWZyYW1lX2RpZyAxNCAvLyBleHBlY3RlZEFEZXBvc2l0QjY0OiB1aW50NjQKCWludCAwCgk9PQoJZHVwCglieiAqc2tpcF9hbmQzCglmcmFtZV9kaWcgMTUgLy8gZXhwZWN0ZWRCRGVwb3NpdEI2NDogdWludDY0CglpbnQgMAoJPT0KCSYmCgoqc2tpcF9hbmQzOgoJYnogKmlmMTdfZW5kCgoJLy8gKmlmMTdfY29uc2VxdWVudAoJLy8gKmlmMThfY29uZGl0aW9uCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NTIyCgkvLyB0eEFzc2V0QURlcG9zaXQuYXNzZXRBbW91bnQgPiAwCglmcmFtZV9kaWcgLTMgLy8gdHhBc3NldEFEZXBvc2l0OiBUeG4KCWd0eG5zIEFzc2V0QW1vdW50CglpbnQgMAoJPgoJYnogKmlmMThfZW5kCgoJLy8gKmlmMThfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjUyMwoJLy8gdGhpcy5kb0F4ZmVyKHRoaXMudHhuLnNlbmRlciwgYXNzZXRBLCB0eEFzc2V0QURlcG9zaXQuYXNzZXRBbW91bnQpCglmcmFtZV9kaWcgLTMgLy8gdHhBc3NldEFEZXBvc2l0OiBUeG4KCWd0eG5zIEFzc2V0QW1vdW50CglmcmFtZV9kaWcgLTYgLy8gYXNzZXRBOiBBc3NldElECgl0eG4gU2VuZGVyCgljYWxsc3ViIGRvQXhmZXIKCippZjE4X2VuZDoKCS8vICppZjE5X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjUyNQoJLy8gdHhBc3NldEJEZXBvc2l0LmFzc2V0QW1vdW50ID4gMAoJZnJhbWVfZGlnIC00IC8vIHR4QXNzZXRCRGVwb3NpdDogVHhuCglndHhucyBBc3NldEFtb3VudAoJaW50IDAKCT4KCWJ6ICppZjE5X2VuZAoKCS8vICppZjE5X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo1MjYKCS8vIHRoaXMuZG9BeGZlcih0aGlzLnR4bi5zZW5kZXIsIGFzc2V0QiwgdHhBc3NldEJEZXBvc2l0LmFzc2V0QW1vdW50KQoJZnJhbWVfZGlnIC00IC8vIHR4QXNzZXRCRGVwb3NpdDogVHhuCglndHhucyBBc3NldEFtb3VudAoJZnJhbWVfZGlnIC03IC8vIGFzc2V0QjogQXNzZXRJRAoJdHhuIFNlbmRlcgoJY2FsbHN1YiBkb0F4ZmVyCgoqaWYxOV9lbmQ6CgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NTI4CgkvLyByZXR1cm4gMDsKCWludCAwCgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMjMKCXJldHN1YgoKKmlmMTdfZW5kOgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjUzMAoJLy8gYXNzZXJ0KGZhbHNlLCAnZmFpbGVkIHRvIGNhbGN1bGF0ZSBleGFjdCBsaXF1ZGlkaXR5JykKCWludCAwCgoJLy8gZmFpbGVkIHRvIGNhbGN1bGF0ZSBleGFjdCBsaXF1ZGlkaXR5Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NTMxCgkvLyByZXR1cm4gZXhwZWN0ZWRCRGVwb3NpdEI2NDsKCWZyYW1lX2RpZyAxNSAvLyBleHBlY3RlZEJEZXBvc2l0QjY0OiB1aW50NjQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiAyMwoJcmV0c3ViCgovLyBwcm9jZXNzQWRkTGlxdWRpdHkocmVhbEFzc2V0QURlcG9zaXQ6IHVpbnQyNTYsIHJlYWxBc3NldEJEZXBvc2l0OiB1aW50MjU2LCBhc3NldExQRGVsaWNtYWxTY2FsZTJTY2FsZTogdWludDI1NiwgYXNzZXRMUDogQXNzZXRJRCk6IHVpbnQ2NApwcm9jZXNzQWRkTGlxdWRpdHk6Cglwcm90byA0IDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwbiA3CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjU0MQoJLy8gdGhpcy5hc3NldEFCYWxhbmNlLnZhbHVlID0gdGhpcy5hc3NldEFCYWxhbmNlLnZhbHVlICsgcmVhbEFzc2V0QURlcG9zaXQKCWJ5dGUgMHg2MTYyIC8vICJhYiIKCWR1cAoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAtMSAvLyByZWFsQXNzZXRBRGVwb3NpdDogdWludDI1NgoJYisKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NTQyCgkvLyB0aGlzLmFzc2V0QkJhbGFuY2UudmFsdWUgPSB0aGlzLmFzc2V0QkJhbGFuY2UudmFsdWUgKyByZWFsQXNzZXRCRGVwb3NpdAoJYnl0ZSAweDYyNjIgLy8gImJiIgoJZHVwCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIC0yIC8vIHJlYWxBc3NldEJEZXBvc2l0OiB1aW50MjU2CgliKwoJZHVwCgliaXRsZW4KCWludCAyNTYKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDMyCgktCglzd2FwCglzdWJzdHJpbmczCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo1NDUKCS8vIHggPSB0aGlzLmFzc2V0QUJhbGFuY2UudmFsdWUKCWJ5dGUgMHg2MTYyIC8vICJhYiIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9idXJ5IDAgLy8geDogdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo1NDYKCS8vIHkgPSB0aGlzLmFzc2V0QkJhbGFuY2UudmFsdWUKCWJ5dGUgMHg2MjYyIC8vICJiYiIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9idXJ5IDEgLy8geTogdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo1NDcKCS8vIHByaWNlTWluID0gdGhpcy5wcmljZU1pbi52YWx1ZSBhcyB1aW50MjU2CglieXRlIDB4NzA0ZDY5NmUgLy8gInBNaW4iCglhcHBfZ2xvYmFsX2dldAoJaXRvYgoJZnJhbWVfYnVyeSAyIC8vIHByaWNlTWluOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo1NDgKCS8vIHByaWNlTWF4ID0gdGhpcy5wcmljZU1heC52YWx1ZSBhcyB1aW50MjU2CglieXRlIDB4NzA0ZDYxNzggLy8gInBNYXgiCglhcHBfZ2xvYmFsX2dldAoJaXRvYgoJZnJhbWVfYnVyeSAzIC8vIHByaWNlTWF4OiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo1NDkKCS8vIHByaWNlTWluU3FydCA9IHRoaXMucHJpY2VNaW5TcXJ0LnZhbHVlCglieXRlIDB4NzA0ZDY5NmU1MyAvLyAicE1pblMiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfYnVyeSA0IC8vIHByaWNlTWluU3FydDogdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo1NTAKCS8vIHByaWNlTWF4U3FydCA9IHRoaXMucHJpY2VNYXhTcXJ0LnZhbHVlCglieXRlIDB4NzA0ZDYxNzg1MyAvLyAicE1heFMiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfYnVyeSA1IC8vIHByaWNlTWF4U3FydDogdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo1NTEKCS8vIG5ld0xpcXVkaXR5ID0gdGhpcy5jYWxjdWxhdGVMaXF1aWRpdHkoeCwgeSwgcHJpY2VNaW4sIHByaWNlTWF4LCBwcmljZU1pblNxcnQsIHByaWNlTWF4U3FydCkKCWZyYW1lX2RpZyA1IC8vIHByaWNlTWF4U3FydDogdWludDI1NgoJZnJhbWVfZGlnIDQgLy8gcHJpY2VNaW5TcXJ0OiB1aW50MjU2CglmcmFtZV9kaWcgMyAvLyBwcmljZU1heDogdW5zYWZlIHVpbnQyNTYKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJZnJhbWVfZGlnIDIgLy8gcHJpY2VNaW46IHVuc2FmZSB1aW50MjU2CglkdXAKCWJpdGxlbgoJaW50IDI1NgoJPD0KCWFzc2VydAoJYnl0ZSAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnQgMzIKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWZyYW1lX2RpZyAxIC8vIHk6IHVpbnQyNTYKCWZyYW1lX2RpZyAwIC8vIHg6IHVpbnQyNTYKCWNhbGxzdWIgY2FsY3VsYXRlTGlxdWlkaXR5CglmcmFtZV9idXJ5IDYgLy8gbmV3TGlxdWRpdHk6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjU1NAoJLy8gbHBUb2tlbnNUb1NlbmQgPSAoKG5ld0xpcXVkaXR5IC0gdGhpcy5MaXF1ZGl0eS52YWx1ZSkgLyBhc3NldExQRGVsaWNtYWxTY2FsZTJTY2FsZSkgYXMgdWludDY0CglmcmFtZV9kaWcgNiAvLyBuZXdMaXF1ZGl0eTogdW5zYWZlIHVpbnQyNTYKCWJ5dGUgMHg0YyAvLyAiTCIKCWFwcF9nbG9iYWxfZ2V0CgliLQoJZnJhbWVfZGlnIC0zIC8vIGFzc2V0TFBEZWxpY21hbFNjYWxlMlNjYWxlOiB1aW50MjU2CgliLwoJZHVwCgliaXRsZW4KCWludCA2NAoJPD0KCWFzc2VydAoJYnl0ZSAweEZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnQgOAoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJYnRvaQoJZnJhbWVfYnVyeSA3IC8vIGxwVG9rZW5zVG9TZW5kOiB1aW50NjQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NTU2CgkvLyB0aGlzLkxpcXVkaXR5LnZhbHVlID0gbmV3TGlxdWRpdHkKCWJ5dGUgMHg0YyAvLyAiTCIKCWZyYW1lX2RpZyA2IC8vIG5ld0xpcXVkaXR5OiB1bnNhZmUgdWludDI1NgoJZHVwCgliaXRsZW4KCWludCAyNTYKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDMyCgktCglzd2FwCglzdWJzdHJpbmczCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo1NTgKCS8vIHRoaXMuZG9BeGZlcih0aGlzLnR4bi5zZW5kZXIsIGFzc2V0TFAsIGxwVG9rZW5zVG9TZW5kKQoJZnJhbWVfZGlnIDcgLy8gbHBUb2tlbnNUb1NlbmQ6IHVpbnQ2NAoJZnJhbWVfZGlnIC00IC8vIGFzc2V0TFA6IEFzc2V0SUQKCXR4biBTZW5kZXIKCWNhbGxzdWIgZG9BeGZlcgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo1NTkKCS8vIHJldHVybiBscFRva2Vuc1RvU2VuZDsKCWZyYW1lX2RpZyA3IC8vIGxwVG9rZW5zVG9TZW5kOiB1aW50NjQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiA3CglyZXRzdWIKCi8vIHJlbW92ZUxpcXVpZGl0eShheGZlcix1aW50NjQsdWludDY0LHVpbnQ2NCl1aW50MjU2CiphYmlfcm91dGVfcmVtb3ZlTGlxdWlkaXR5OgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBhc3NldEI6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJYnRvaQoKCS8vIGFzc2V0QTogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gYXNzZXRMUDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gdHhMUFhmZXI6IGF4ZmVyCgl0eG4gR3JvdXBJbmRleAoJaW50IDEKCS0KCWR1cAoJZ3R4bnMgVHlwZUVudW0KCWludCBheGZlcgoJPT0KCWFzc2VydAoKCS8vIGV4ZWN1dGUgcmVtb3ZlTGlxdWlkaXR5KGF4ZmVyLHVpbnQ2NCx1aW50NjQsdWludDY0KXVpbnQyNTYKCWNhbGxzdWIgcmVtb3ZlTGlxdWlkaXR5CglkdXAKCWJpdGxlbgoJaW50IDI1NgoJPD0KCWFzc2VydAoJYnl0ZSAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnQgMzIKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyByZW1vdmVMaXF1aWRpdHkodHhMUFhmZXI6IEFzc2V0VHJhbnNmZXJUeG4sIGFzc2V0TFA6IEFzc2V0SUQsIGFzc2V0QTogQXNzZXRJRCwgYXNzZXRCOiBBc3NldElEKTogdWludDI1NgovLwovLyBUaGlzIG1ldGhvZCByZXRyaWV2ZXMgZnJvbSB0aGUgbGlxdWlkaXR5IHByb3ZpZGVyIExQIHRva2VuIGFuZCByZXR1cm5zIEFzc2V0IEEgYW5kIEFzc2V0IEIgZnJvbSB0aGUgQXV0b21hdGVkIE1hcmtldCBNYWtlciBDb25jZW50cmF0ZWQgTGlxdWRpZGl0eSBQb29sCi8vIEBwYXJhbSB0eExQWGZlciBUcmFuc2ZlciBvZiB0aGUgTFAgdG9rZW4KLy8gQHBhcmFtIGFzc2V0TFAgTFAgcG9vbCBhc3NldAovLyBAcGFyYW0gYXNzZXRBIEFzc2V0IEEKLy8gQHBhcmFtIGFzc2V0QiBBc3NldCBCCi8vIEByZXR1cm5zIExQIHBvc2l0aW9uIHJlZHVjZWQKcmVtb3ZlTGlxdWlkaXR5OgoJcHJvdG8gNCAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gMTcKCgkvLyB3ZWxsIGZvcm1lZCBtaW50CgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NTcyCgkvLyBhc3NlcnQoYXNzZXRBLmlkID09PSB0aGlzLmFzc2V0QS52YWx1ZSkKCWZyYW1lX2RpZyAtMyAvLyBhc3NldEE6IEFzc2V0SUQKCWJ5dGUgMHg2MSAvLyAiYSIKCWFwcF9nbG9iYWxfZ2V0Cgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjU3MwoJLy8gYXNzZXJ0KGFzc2V0Qi5pZCA9PT0gdGhpcy5hc3NldEIudmFsdWUpCglmcmFtZV9kaWcgLTQgLy8gYXNzZXRCOiBBc3NldElECglieXRlIDB4NjIgLy8gImIiCglhcHBfZ2xvYmFsX2dldAoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo1NzQKCS8vIGFzc2VydChhc3NldExQLmlkID09PSB0aGlzLmFzc2V0TFAudmFsdWUpCglmcmFtZV9kaWcgLTIgLy8gYXNzZXRMUDogQXNzZXRJRAoJYnl0ZSAweDZjNzAgLy8gImxwIgoJYXBwX2dsb2JhbF9nZXQKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NTc2CgkvLyB2ZXJpZnlBc3NldFRyYW5zZmVyVHhuKHR4TFBYZmVyLCB7CgkvLyAgICAgICBhc3NldFJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gICAgICAgeGZlckFzc2V0OiBhc3NldExQLAoJLy8gICAgICAgYXNzZXRBbW91bnQ6IHsgZ3JlYXRlclRoYW5FcXVhbFRvOiAwIH0sCgkvLyAgICAgfSkKCS8vIHZlcmlmeSBhc3NldFJlY2VpdmVyCglmcmFtZV9kaWcgLTEgLy8gdHhMUFhmZXI6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIEFzc2V0UmVjZWl2ZXIKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IHhmZXJBc3NldAoJZnJhbWVfZGlnIC0xIC8vIHR4TFBYZmVyOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBYZmVyQXNzZXQKCWZyYW1lX2RpZyAtMiAvLyBhc3NldExQOiBBc3NldElECgk9PQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IGFzc2V0QW1vdW50CglmcmFtZV9kaWcgLTEgLy8gdHhMUFhmZXI6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIEFzc2V0QW1vdW50CglpbnQgMAoJPj0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo1ODMKCS8vIGluY3JlYXNlT3Bjb2RlQnVkZ2V0KCkKCWl0eG5fYmVnaW4KCWludCBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCWJ5dGUgYjY0IENvRUIgLy8gI3ByYWdtYSB2ZXJzaW9uIDEwOyBpbnQgMQoJZHVwCglpdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQoJaXR4bl9maWVsZCBDbGVhclN0YXRlUHJvZ3JhbQoJaW50IERlbGV0ZUFwcGxpY2F0aW9uCglpdHhuX2ZpZWxkIE9uQ29tcGxldGlvbgoJaXR4bl9zdWJtaXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NTg1CgkvLyBhc3NldEFEZWNpbWFscyA9IDYKCWludCA2CglmcmFtZV9idXJ5IDAgLy8gYXNzZXRBRGVjaW1hbHM6IHVpbnQ2NAoKCS8vICppZjIwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjU4NgoJLy8gYXNzZXRBLmlkID4gMAoJZnJhbWVfZGlnIC0zIC8vIGFzc2V0QTogQXNzZXRJRAoJaW50IDAKCT4KCWJ6ICppZjIwX2VuZAoKCS8vICppZjIwX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo1ODYKCS8vIGFzc2V0QURlY2ltYWxzID0gYXNzZXRBLmRlY2ltYWxzCglmcmFtZV9kaWcgLTMgLy8gYXNzZXRBOiBBc3NldElECglhc3NldF9wYXJhbXNfZ2V0IEFzc2V0RGVjaW1hbHMKCXBvcAoJZnJhbWVfYnVyeSAwIC8vIGFzc2V0QURlY2ltYWxzOiB1aW50NjQKCippZjIwX2VuZDoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo1ODgKCS8vIGFzc2V0QURlbGljbWFsU2NhbGUyU2NhbGUgPSAoMTAgKiogKFNDQUxFX0RFQ0lNQUxTIC0gYXNzZXRBRGVjaW1hbHMpKSBhcyB1aW50MjU2CglpbnQgMTAKCWludCA5CglmcmFtZV9kaWcgMCAvLyBhc3NldEFEZWNpbWFsczogdWludDY0CgktCglleHAKCWl0b2IKCWZyYW1lX2J1cnkgMSAvLyBhc3NldEFEZWxpY21hbFNjYWxlMlNjYWxlOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo1OTAKCS8vIGFzc2V0QkRlbGljbWFsU2NhbGUyU2NhbGUgPSAoMTAgKiogKFNDQUxFX0RFQ0lNQUxTIC0gYXNzZXRCLmRlY2ltYWxzKSkgYXMgdWludDI1NgoJaW50IDEwCglpbnQgOQoJZnJhbWVfZGlnIC00IC8vIGFzc2V0QjogQXNzZXRJRAoJYXNzZXRfcGFyYW1zX2dldCBBc3NldERlY2ltYWxzCglwb3AKCS0KCWV4cAoJaXRvYgoJZnJhbWVfYnVyeSAyIC8vIGFzc2V0QkRlbGljbWFsU2NhbGUyU2NhbGU6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjU5MgoJLy8gYXNzZXRMUERlbGljbWFsU2NhbGUyU2NhbGUgPSAoMTAgKiogKFNDQUxFX0RFQ0lNQUxTIC0gTFBfVE9LRU5fREVDSU1BTFMpKSBhcyB1aW50MjU2CglpbnQgMTAKCWludCAzCglleHAKCWl0b2IKCWZyYW1lX2J1cnkgMyAvLyBhc3NldExQRGVsaWNtYWxTY2FsZTJTY2FsZTogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NTk0CgkvLyBzID0gU0NBTEUgYXMgdWludDI1NgoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwM2I5YWNhMDAKCWZyYW1lX2J1cnkgNCAvLyBzOiB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjU5NgoJLy8gbHBEZWx0YSA9IHR4TFBYZmVyLmFzc2V0QW1vdW50IGFzIHVpbnQyNTYKCWZyYW1lX2RpZyAtMSAvLyB0eExQWGZlcjogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCWl0b2IKCWZyYW1lX2J1cnkgNSAvLyBscERlbHRhOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo1OTcKCS8vIGxwRGVsdGFCYXNlID0gbHBEZWx0YSAqIGFzc2V0TFBEZWxpY21hbFNjYWxlMlNjYWxlCglmcmFtZV9kaWcgNSAvLyBscERlbHRhOiB1bnNhZmUgdWludDI1NgoJZnJhbWVfZGlnIDMgLy8gYXNzZXRMUERlbGljbWFsU2NhbGUyU2NhbGU6IHVuc2FmZSB1aW50MjU2CgliKgoJZnJhbWVfYnVyeSA2IC8vIGxwRGVsdGFCYXNlOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo1OTgKCS8vIGxwRGVsdGFXaXRoRmVlcyA9IGxwRGVsdGFCYXNlCglmcmFtZV9kaWcgNiAvLyBscERlbHRhQmFzZTogdW5zYWZlIHVpbnQyNTYKCWZyYW1lX2J1cnkgNyAvLyBscERlbHRhV2l0aEZlZXM6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjU5OQoJLy8gbHBXaXRoT3RoZXJzID0gdGhpcy5jYWxjdWxhdGVEaXN0cmlidXRlZExpcXVpZGl0eShhc3NldExQLCBscERlbHRhKQoJZnJhbWVfZGlnIDUgLy8gbHBEZWx0YTogdW5zYWZlIHVpbnQyNTYKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJZnJhbWVfZGlnIC0yIC8vIGFzc2V0TFA6IEFzc2V0SUQKCWNhbGxzdWIgY2FsY3VsYXRlRGlzdHJpYnV0ZWRMaXF1aWRpdHkKCWZyYW1lX2J1cnkgOCAvLyBscFdpdGhPdGhlcnM6IHVuc2FmZSB1aW50MjU2CgoJLy8gKmlmMjFfY29uZGl0aW9uCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NjAwCgkvLyBscFdpdGhPdGhlcnMgPiA8dWludDI1Nj4wCglmcmFtZV9kaWcgOCAvLyBscFdpdGhPdGhlcnM6IHVuc2FmZSB1aW50MjU2CglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAoJYj4KCWJ6ICppZjIxX2VuZAoKCS8vICppZjIxX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo2MDIKCS8vIG15UG9ydGlvbiA9IChscERlbHRhQmFzZSAqIHMpIC8gbHBXaXRoT3RoZXJzCglmcmFtZV9kaWcgNiAvLyBscERlbHRhQmFzZTogdW5zYWZlIHVpbnQyNTYKCWJ5dGUgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDNiOWFjYTAwIC8vIHM6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgOCAvLyBscFdpdGhPdGhlcnM6IHVuc2FmZSB1aW50MjU2CgliLwoJZnJhbWVfYnVyeSA5IC8vIG15UG9ydGlvbjogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NjAzCgkvLyBteVBvcnRpb25PZkZlZXNDb2xsZWN0ZWQgPSAodGhpcy5MaXF1ZGl0eVVzZXJzRnJvbUZlZXMudmFsdWUgKiBteVBvcnRpb24pIC8gcwoJYnl0ZSAweDRjNzUgLy8gIkx1IgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyA5IC8vIG15UG9ydGlvbjogdW5zYWZlIHVpbnQyNTYKCWIqCglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAzYjlhY2EwMCAvLyBzOiB1aW50MjU2CgliLwoJZnJhbWVfYnVyeSAxMCAvLyBteVBvcnRpb25PZkZlZXNDb2xsZWN0ZWQ6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjYwNAoJLy8gbHBEZWx0YVdpdGhGZWVzID0gbHBEZWx0YUJhc2UgKyBteVBvcnRpb25PZkZlZXNDb2xsZWN0ZWQKCWZyYW1lX2RpZyA2IC8vIGxwRGVsdGFCYXNlOiB1bnNhZmUgdWludDI1NgoJZnJhbWVfZGlnIDEwIC8vIG15UG9ydGlvbk9mRmVlc0NvbGxlY3RlZDogdW5zYWZlIHVpbnQyNTYKCWIrCglmcmFtZV9idXJ5IDcgLy8gbHBEZWx0YVdpdGhGZWVzOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo2MDUKCS8vIHRoaXMuTGlxdWRpdHlVc2Vyc0Zyb21GZWVzLnZhbHVlID0gdGhpcy5MaXF1ZGl0eVVzZXJzRnJvbUZlZXMudmFsdWUgLSBteVBvcnRpb25PZkZlZXNDb2xsZWN0ZWQKCWJ5dGUgMHg0Yzc1IC8vICJMdSIKCWR1cAoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAxMCAvLyBteVBvcnRpb25PZkZlZXNDb2xsZWN0ZWQ6IHVuc2FmZSB1aW50MjU2CgliLQoJZHVwCgliaXRsZW4KCWludCAyNTYKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDMyCgktCglzd2FwCglzdWJzdHJpbmczCglhcHBfZ2xvYmFsX3B1dAoKKmlmMjFfZW5kOgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjYwNwoJLy8gYVRvU2VuZCA9IHRoaXMuY2FsY3VsYXRlQXNzZXRBV2l0aGRyYXdPbkxwRGVwb3NpdCgKCS8vICAgICAgIGxwRGVsdGFXaXRoRmVlcywKCS8vICAgICAgIHRoaXMuYXNzZXRBQmFsYW5jZS52YWx1ZSwKCS8vICAgICAgIHRoaXMuTGlxdWRpdHkudmFsdWUKCS8vICAgICApCglieXRlIDB4NGMgLy8gIkwiCglhcHBfZ2xvYmFsX2dldAoJYnl0ZSAweDYxNjIgLy8gImFiIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyA3IC8vIGxwRGVsdGFXaXRoRmVlczogdW5zYWZlIHVpbnQyNTYKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJY2FsbHN1YiBjYWxjdWxhdGVBc3NldEFXaXRoZHJhd09uTHBEZXBvc2l0CglmcmFtZV9idXJ5IDExIC8vIGFUb1NlbmQ6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjYxMgoJLy8gYVRvU2VuZDY0ID0gKGFUb1NlbmQgLyBhc3NldEFEZWxpY21hbFNjYWxlMlNjYWxlKSBhcyB1aW50NjQKCWZyYW1lX2RpZyAxMSAvLyBhVG9TZW5kOiB1bnNhZmUgdWludDI1NgoJZnJhbWVfZGlnIDEgLy8gYXNzZXRBRGVsaWNtYWxTY2FsZTJTY2FsZTogdW5zYWZlIHVpbnQyNTYKCWIvCglkdXAKCWJpdGxlbgoJaW50IDY0Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCA4CgktCglzd2FwCglzdWJzdHJpbmczCglidG9pCglmcmFtZV9idXJ5IDEyIC8vIGFUb1NlbmQ2NDogdWludDY0CgoJLy8gKmlmMjJfY29uZGl0aW9uCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NjEzCgkvLyBhVG9TZW5kNjQgPiAwCglmcmFtZV9kaWcgMTIgLy8gYVRvU2VuZDY0OiB1aW50NjQKCWludCAwCgk+CglieiAqaWYyMl9lbmQKCgkvLyAqaWYyMl9jb25zZXF1ZW50CgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NjE0CgkvLyB0aGlzLmRvQXhmZXIodGhpcy50eG4uc2VuZGVyLCBhc3NldEEsIGFUb1NlbmQ2NCkKCWZyYW1lX2RpZyAxMiAvLyBhVG9TZW5kNjQ6IHVpbnQ2NAoJZnJhbWVfZGlnIC0zIC8vIGFzc2V0QTogQXNzZXRJRAoJdHhuIFNlbmRlcgoJY2FsbHN1YiBkb0F4ZmVyCgoqaWYyMl9lbmQ6CgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NjE2CgkvLyBiVG9TZW5kID0gdGhpcy5jYWxjdWxhdGVBc3NldEFXaXRoZHJhd09uTHBEZXBvc2l0KAoJLy8gICAgICAgbHBEZWx0YVdpdGhGZWVzLAoJLy8gICAgICAgdGhpcy5hc3NldEJCYWxhbmNlLnZhbHVlLAoJLy8gICAgICAgdGhpcy5MaXF1ZGl0eS52YWx1ZQoJLy8gICAgICkKCWJ5dGUgMHg0YyAvLyAiTCIKCWFwcF9nbG9iYWxfZ2V0CglieXRlIDB4NjI2MiAvLyAiYmIiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIDcgLy8gbHBEZWx0YVdpdGhGZWVzOiB1bnNhZmUgdWludDI1NgoJZHVwCgliaXRsZW4KCWludCAyNTYKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDMyCgktCglzd2FwCglzdWJzdHJpbmczCgljYWxsc3ViIGNhbGN1bGF0ZUFzc2V0QVdpdGhkcmF3T25McERlcG9zaXQKCWZyYW1lX2J1cnkgMTMgLy8gYlRvU2VuZDogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NjIxCgkvLyBiVG9TZW5kNjQgPSAoYlRvU2VuZCAvIGFzc2V0QkRlbGljbWFsU2NhbGUyU2NhbGUpIGFzIHVpbnQ2NAoJZnJhbWVfZGlnIDEzIC8vIGJUb1NlbmQ6IHVuc2FmZSB1aW50MjU2CglmcmFtZV9kaWcgMiAvLyBhc3NldEJEZWxpY21hbFNjYWxlMlNjYWxlOiB1bnNhZmUgdWludDI1NgoJYi8KCWR1cAoJYml0bGVuCglpbnQgNjQKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDgKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWJ0b2kKCWZyYW1lX2J1cnkgMTQgLy8gYlRvU2VuZDY0OiB1aW50NjQKCgkvLyAqaWYyM19jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo2MjIKCS8vIGJUb1NlbmQ2NCA+IDAKCWZyYW1lX2RpZyAxNCAvLyBiVG9TZW5kNjQ6IHVpbnQ2NAoJaW50IDAKCT4KCWJ6ICppZjIzX2VuZAoKCS8vICppZjIzX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo2MjMKCS8vIHRoaXMuZG9BeGZlcih0aGlzLnR4bi5zZW5kZXIsIGFzc2V0QiwgYlRvU2VuZDY0KQoJZnJhbWVfZGlnIDE0IC8vIGJUb1NlbmQ2NDogdWludDY0CglmcmFtZV9kaWcgLTQgLy8gYXNzZXRCOiBBc3NldElECgl0eG4gU2VuZGVyCgljYWxsc3ViIGRvQXhmZXIKCippZjIzX2VuZDoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo2MjYKCS8vIG5ld0Fzc2V0QSA9IHRoaXMuYXNzZXRBQmFsYW5jZS52YWx1ZSAtIGFUb1NlbmQKCWJ5dGUgMHg2MTYyIC8vICJhYiIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9kaWcgMTEgLy8gYVRvU2VuZDogdW5zYWZlIHVpbnQyNTYKCWItCglmcmFtZV9idXJ5IDE1IC8vIG5ld0Fzc2V0QTogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NjI3CgkvLyBuZXdBc3NldEIgPSB0aGlzLmFzc2V0QkJhbGFuY2UudmFsdWUgLSBiVG9TZW5kCglieXRlIDB4NjI2MiAvLyAiYmIiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIDEzIC8vIGJUb1NlbmQ6IHVuc2FmZSB1aW50MjU2CgliLQoJZnJhbWVfYnVyeSAxNiAvLyBuZXdBc3NldEI6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjYyOAoJLy8gdGhpcy5hc3NldEFCYWxhbmNlLnZhbHVlID0gbmV3QXNzZXRBCglieXRlIDB4NjE2MiAvLyAiYWIiCglmcmFtZV9kaWcgMTUgLy8gbmV3QXNzZXRBOiB1bnNhZmUgdWludDI1NgoJZHVwCgliaXRsZW4KCWludCAyNTYKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDMyCgktCglzd2FwCglzdWJzdHJpbmczCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo2MjkKCS8vIHRoaXMuYXNzZXRCQmFsYW5jZS52YWx1ZSA9IG5ld0Fzc2V0QgoJYnl0ZSAweDYyNjIgLy8gImJiIgoJZnJhbWVfZGlnIDE2IC8vIG5ld0Fzc2V0QjogdW5zYWZlIHVpbnQyNTYKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NjMzCgkvLyBsQWZ0ZXIgPSB0aGlzLmNhbGN1bGF0ZUxpcXVpZGl0eSgKCS8vICAgICAgIHRoaXMuYXNzZXRBQmFsYW5jZS52YWx1ZSwKCS8vICAgICAgIHRoaXMuYXNzZXRCQmFsYW5jZS52YWx1ZSwKCS8vICAgICAgIHRoaXMucHJpY2VNaW4udmFsdWUgYXMgdWludDI1NiwgLy8gcHJpY2VNaW46IHVpbnQyNTYsCgkvLyAgICAgICB0aGlzLnByaWNlTWF4LnZhbHVlIGFzIHVpbnQyNTYsIC8vIHByaWNlTWF4OiB1aW50MjU2LAoJLy8gICAgICAgdGhpcy5wcmljZU1pblNxcnQudmFsdWUsIC8vIHByaWNlTWluU3FydDogdWludDI1NiwKCS8vICAgICAgIHRoaXMucHJpY2VNYXhTcXJ0LnZhbHVlIC8vIHByaWNlTWF4U3FydDogdWludDI1NiwKCS8vICAgICApCglieXRlIDB4NzA0ZDYxNzg1MyAvLyAicE1heFMiCglhcHBfZ2xvYmFsX2dldAoJYnl0ZSAweDcwNGQ2OTZlNTMgLy8gInBNaW5TIgoJYXBwX2dsb2JhbF9nZXQKCWJ5dGUgMHg3MDRkNjE3OCAvLyAicE1heCIKCWFwcF9nbG9iYWxfZ2V0CglpdG9iCglkdXAKCWJpdGxlbgoJaW50IDI1NgoJPD0KCWFzc2VydAoJYnl0ZSAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnQgMzIKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWJ5dGUgMHg3MDRkNjk2ZSAvLyAicE1pbiIKCWFwcF9nbG9iYWxfZ2V0CglpdG9iCglkdXAKCWJpdGxlbgoJaW50IDI1NgoJPD0KCWFzc2VydAoJYnl0ZSAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnQgMzIKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWJ5dGUgMHg2MjYyIC8vICJiYiIKCWFwcF9nbG9iYWxfZ2V0CglieXRlIDB4NjE2MiAvLyAiYWIiCglhcHBfZ2xvYmFsX2dldAoJY2FsbHN1YiBjYWxjdWxhdGVMaXF1aWRpdHkKCWZyYW1lX2J1cnkgMTcgLy8gbEFmdGVyOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo2NDEKCS8vIHRoaXMuTGlxdWRpdHkudmFsdWUgPSBsQWZ0ZXIKCWJ5dGUgMHg0YyAvLyAiTCIKCWZyYW1lX2RpZyAxNyAvLyBsQWZ0ZXI6IHVuc2FmZSB1aW50MjU2CglkdXAKCWJpdGxlbgoJaW50IDI1NgoJPD0KCWFzc2VydAoJYnl0ZSAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnQgMzIKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjY0MgoJLy8gcmV0dXJuIGxwRGVsdGFXaXRoRmVlcyAvIGFzc2V0TFBEZWxpY21hbFNjYWxlMlNjYWxlOwoJZnJhbWVfZGlnIDcgLy8gbHBEZWx0YVdpdGhGZWVzOiB1bnNhZmUgdWludDI1NgoJZnJhbWVfZGlnIDMgLy8gYXNzZXRMUERlbGljbWFsU2NhbGUyU2NhbGU6IHVuc2FmZSB1aW50MjU2CgliLwoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDE3CglyZXRzdWIKCi8vIHN3YXAodWludDY0LHVpbnQ2NCx0eG4sdWludDY0LHVpbnQ2NCx1aW50NjQpdWludDI1NgoqYWJpX3JvdXRlX3N3YXA6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIG1pbmltdW1Ub1JlY2VpdmU6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQoJYnRvaQoKCS8vIGFzc2V0QjogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA0CglidG9pCgoJLy8gYXNzZXRBOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWJ0b2kKCgkvLyB0eFN3YXA6IHR4bgoJdHhuIEdyb3VwSW5kZXgKCWludCAxCgktCgoJLy8gYXBwQmlhdGVjSWRlbnRpdHlQcm92aWRlcjogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gYXBwQmlhdGVjQ29uZmlnUHJvdmlkZXI6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgc3dhcCh1aW50NjQsdWludDY0LHR4bix1aW50NjQsdWludDY0LHVpbnQ2NCl1aW50MjU2CgljYWxsc3ViIHN3YXAKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIHN3YXAoYXBwQmlhdGVjQ29uZmlnUHJvdmlkZXI6IEFwcElELCBhcHBCaWF0ZWNJZGVudGl0eVByb3ZpZGVyOiBBcHBJRCwgdHhTd2FwOiBUeG4sIGFzc2V0QTogQXNzZXRJRCwgYXNzZXRCOiBBc3NldElELCBtaW5pbXVtVG9SZWNlaXZlOiB1aW50NjQpOiB1aW50MjU2Ci8vCi8vIFN3YXAgQXNzZXQgQSB0byBBc3NldCBCIG9yIEFzc2V0IEIgdG8gQXNzdCBBCi8vIEBwYXJhbSB0eFN3YXAgVHJhbnNmZXIgb2YgdGhlIHRva2VuIHRvIGJlIGRlcG9zaXRlZCB0byB0aGUgcG9vbC4gVG8gdGhlIG93bmVyIHRoZSBvdGhlciBhc3NldCB3aWxsIGJlIHNlbnQuCi8vIEBwYXJhbSBhc3NldEEgQXNzZXQgQQovLyBAcGFyYW0gYXNzZXRCIEFzc2V0IEIKLy8gQHBhcmFtIG1pbmltdW1Ub1JlY2VpdmUgSWYgbnVtYmVyIGdyZWF0ZXIgdGhlbiB6ZXJvLCB0aGUgY2hlY2sgaXMgcGVyZm9ybWVkIGZvciB0aGUgb3V0cHV0IG9mIHRoZSBvdGhlciBhc3NldApzd2FwOgoJcHJvdG8gNiAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gMjUKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NjYwCgkvLyBpbmNyZWFzZU9wY29kZUJ1ZGdldCgpCglpdHhuX2JlZ2luCglpbnQgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJaW50IDAKCWl0eG5fZmllbGQgRmVlCglieXRlIGI2NCBDb0VCIC8vICNwcmFnbWEgdmVyc2lvbiAxMDsgaW50IDEKCWR1cAoJaXR4bl9maWVsZCBBcHByb3ZhbFByb2dyYW0KCWl0eG5fZmllbGQgQ2xlYXJTdGF0ZVByb2dyYW0KCWludCBEZWxldGVBcHBsaWNhdGlvbgoJaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KCWl0eG5fc3VibWl0CgoJLy8gd2VsbCBmb3JtZWQgc3dhcAoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjY2MwoJLy8gYXNzZXJ0KGFzc2V0QS5pZCA9PT0gdGhpcy5hc3NldEEudmFsdWUpCglmcmFtZV9kaWcgLTQgLy8gYXNzZXRBOiBBc3NldElECglieXRlIDB4NjEgLy8gImEiCglhcHBfZ2xvYmFsX2dldAoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo2NjQKCS8vIGFzc2VydChhc3NldEIuaWQgPT09IHRoaXMuYXNzZXRCLnZhbHVlKQoJZnJhbWVfZGlnIC01IC8vIGFzc2V0QjogQXNzZXRJRAoJYnl0ZSAweDYyIC8vICJiIgoJYXBwX2dsb2JhbF9nZXQKCT09Cglhc3NlcnQKCgkvLyAqaWYyNF9jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo2NjYKCS8vIHR4U3dhcC50eXBlRW51bSA9PT0gVHJhbnNhY3Rpb25UeXBlLlBheW1lbnQKCWZyYW1lX2RpZyAtMyAvLyB0eFN3YXA6IFR4bgoJZ3R4bnMgVHlwZUVudW0KCWludCBwYXkKCT09CglieiAqaWYyNF9lbHNlCgoJLy8gKmlmMjRfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjY2NwoJLy8gYXNzZXJ0KGFzc2V0QS5pZCA9PT0gMCkKCWZyYW1lX2RpZyAtNCAvLyBhc3NldEE6IEFzc2V0SUQKCWludCAwCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjY2OQoJLy8gdmVyaWZ5UGF5VHhuKHR4U3dhcCwgewoJLy8gICAgICAgICBhbW91bnQ6IHsgZ3JlYXRlclRoYW46IDAgfSwKCS8vICAgICAgICAgcmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MsCgkvLyAgICAgICAgIHNlbmRlcjogdGhpcy50eG4uc2VuZGVyLAoJLy8gICAgICAgfSkKCS8vIHZlcmlmeSBwYXkKCWZyYW1lX2RpZyAtMyAvLyB0eFN3YXA6IFR4bgoJZ3R4bnMgVHlwZUVudW0KCWludCBwYXkKCT09Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYW1vdW50CglmcmFtZV9kaWcgLTMgLy8gdHhTd2FwOiBUeG4KCWd0eG5zIEFtb3VudAoJaW50IDAKCT4KCWFzc2VydAoKCS8vIHZlcmlmeSByZWNlaXZlcgoJZnJhbWVfZGlnIC0zIC8vIHR4U3dhcDogVHhuCglndHhucyBSZWNlaXZlcgoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCT09Cglhc3NlcnQKCgkvLyB2ZXJpZnkgc2VuZGVyCglmcmFtZV9kaWcgLTMgLy8gdHhTd2FwOiBUeG4KCWd0eG5zIFNlbmRlcgoJdHhuIFNlbmRlcgoJPT0KCWFzc2VydAoJYiAqaWYyNF9lbmQKCippZjI0X2Vsc2U6CgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6Njc1CgkvLyBhc3NlcnQodHhTd2FwLnR5cGVFbnVtID09PSBUcmFuc2FjdGlvblR5cGUuQXNzZXRUcmFuc2ZlcikKCWZyYW1lX2RpZyAtMyAvLyB0eFN3YXA6IFR4bgoJZ3R4bnMgVHlwZUVudW0KCWludCBheGZlcgoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo2NzcKCS8vIHZlcmlmeUFzc2V0VHJhbnNmZXJUeG4odHhTd2FwLCB7CgkvLyAgICAgICAgIGFzc2V0QW1vdW50OiB7IGdyZWF0ZXJUaGFuOiAwIH0sCgkvLyAgICAgICAgIGFzc2V0UmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MsCgkvLyAgICAgICAgIHNlbmRlcjogdGhpcy50eG4uc2VuZGVyLAoJLy8gICAgICAgICB4ZmVyQXNzZXQ6IHsgaW5jbHVkZWRJbjogW2Fzc2V0QSwgYXNzZXRCXSB9LAoJLy8gICAgICAgfSkKCS8vIHZlcmlmeSBheGZlcgoJZnJhbWVfZGlnIC0zIC8vIHR4U3dhcDogVHhuCglndHhucyBUeXBlRW51bQoJaW50IGF4ZmVyCgk9PQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IGFzc2V0QW1vdW50CglmcmFtZV9kaWcgLTMgLy8gdHhTd2FwOiBUeG4KCWd0eG5zIEFzc2V0QW1vdW50CglpbnQgMAoJPgoJYXNzZXJ0CgoJLy8gdmVyaWZ5IGFzc2V0UmVjZWl2ZXIKCWZyYW1lX2RpZyAtMyAvLyB0eFN3YXA6IFR4bgoJZ3R4bnMgQXNzZXRSZWNlaXZlcgoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCT09Cglhc3NlcnQKCgkvLyB2ZXJpZnkgc2VuZGVyCglmcmFtZV9kaWcgLTMgLy8gdHhTd2FwOiBUeG4KCWd0eG5zIFNlbmRlcgoJdHhuIFNlbmRlcgoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSB4ZmVyQXNzZXQKCWZyYW1lX2RpZyAtMyAvLyB0eFN3YXA6IFR4bgoJZ3R4bnMgWGZlckFzc2V0CglmcmFtZV9kaWcgLTQgLy8gYXNzZXRBOiBBc3NldElECgk9PQoJZnJhbWVfZGlnIC0zIC8vIHR4U3dhcDogVHhuCglndHhucyBYZmVyQXNzZXQKCWZyYW1lX2RpZyAtNSAvLyBhc3NldEI6IEFzc2V0SUQKCT09Cgl8fAoJYXNzZXJ0CgoqaWYyNF9lbmQ6CgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6Njg1CgkvLyBhc3NlcnQoYXBwQmlhdGVjQ29uZmlnUHJvdmlkZXIgPT09IHRoaXMuYXBwQmlhdGVjQ29uZmlnUHJvdmlkZXIudmFsdWUsICdDb25maWd1cmF0aW9uIGFwcCBkb2VzIG5vdCBtYXRjaCcpCglmcmFtZV9kaWcgLTEgLy8gYXBwQmlhdGVjQ29uZmlnUHJvdmlkZXI6IEFwcElECglieXRlIDB4NDIgLy8gIkIiCglhcHBfZ2xvYmFsX2dldAoJPT0KCgkvLyBDb25maWd1cmF0aW9uIGFwcCBkb2VzIG5vdCBtYXRjaAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjY4NgoJLy8gaWRlbnRpdHlGcm9tQ29uZmlnID0gYXBwQmlhdGVjQ29uZmlnUHJvdmlkZXIuZ2xvYmFsU3RhdGUoJ2knKQoJZnJhbWVfZGlnIC0xIC8vIGFwcEJpYXRlY0NvbmZpZ1Byb3ZpZGVyOiBBcHBJRAoJYnl0ZSAweDY5IC8vICJpIgoJYXBwX2dsb2JhbF9nZXRfZXgKCWFzc2VydAoJZnJhbWVfYnVyeSAwIC8vIGlkZW50aXR5RnJvbUNvbmZpZzogYW55CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjY4NwoJLy8gYXNzZXJ0KAoJLy8gICAgICAgYXBwQmlhdGVjSWRlbnRpdHlQcm92aWRlciA9PT0gaWRlbnRpdHlGcm9tQ29uZmlnLAoJLy8gICAgICAgJ2FwcEJpYXRlY0lkZW50aXR5UHJvdmlkZXIgbXVzdCBtYXRjaCB0byB0aGUgY29uZmlnIGluIGFwcEJpYXRlY0NvbmZpZ1Byb3ZpZGVyJwoJLy8gICAgICkKCWZyYW1lX2RpZyAtMiAvLyBhcHBCaWF0ZWNJZGVudGl0eVByb3ZpZGVyOiBBcHBJRAoJZnJhbWVfZGlnIDAgLy8gaWRlbnRpdHlGcm9tQ29uZmlnOiBhbnkKCT09CgoJLy8gYXBwQmlhdGVjSWRlbnRpdHlQcm92aWRlciBtdXN0IG1hdGNoIHRvIHRoZSBjb25maWcgaW4gYXBwQmlhdGVjQ29uZmlnUHJvdmlkZXIKCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo2OTIKCS8vIHVzZXIgPSBzZW5kTWV0aG9kQ2FsbDxbQWRkcmVzcywgdWludDhdLCBVc2VySW5mb1YxPih7CgkvLyAgICAgICBuYW1lOiAnZ2V0VXNlcicsCgkvLyAgICAgICBtZXRob2RBcmdzOiBbdGhpcy50eG4uc2VuZGVyLCA8dWludDg+MV0sCgkvLyAgICAgICBmZWU6IDAsCgkvLyAgICAgICBhcHBsaWNhdGlvbklEOiBhcHBCaWF0ZWNJZGVudGl0eVByb3ZpZGVyLAoJLy8gICAgIH0pCglpdHhuX2JlZ2luCglpbnQgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJbWV0aG9kICJnZXRVc2VyKGFkZHJlc3MsdWludDgpKHVpbnQ4LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDI1Nix1aW50MjU2LGJvb2wsdWludDY0LHVpbnQ2NCxib29sKSIKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjY5NAoJLy8gbWV0aG9kQXJnczogW3RoaXMudHhuLnNlbmRlciwgPHVpbnQ4PjFdCgl0eG4gU2VuZGVyCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJYnl0ZSAweDAxCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo2OTUKCS8vIGZlZTogMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjY5NgoJLy8gYXBwbGljYXRpb25JRDogYXBwQmlhdGVjSWRlbnRpdHlQcm92aWRlcgoJZnJhbWVfZGlnIC0yIC8vIGFwcEJpYXRlY0lkZW50aXR5UHJvdmlkZXI6IEFwcElECglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CglpdHhuIE51bUxvZ3MKCWludCAxCgktCglpdHhuYXMgTG9ncwoJZXh0cmFjdCA0IDAKCWZyYW1lX2J1cnkgMSAvLyB1c2VyOiAodWludDgsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50MjU2LHVpbnQyNTYsYm9vbCx1aW50NjQsdWludDY0LGJvb2wpCgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjY5OAoJLy8gYXNzZXJ0KCF1c2VyLmlzTG9ja2VkLCAnVXNlciBtdXN0IG5vdCBiZSBsb2NrZWQnKQoJZnJhbWVfZGlnIDEgLy8gdXNlcjogKHVpbnQ4LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDI1Nix1aW50MjU2LGJvb2wsdWludDY0LHVpbnQ2NCxib29sKQoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWludCAxMDMyCglnZXRiaXQKCSEKCgkvLyBVc2VyIG11c3Qgbm90IGJlIGxvY2tlZAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjY5OQoJLy8gYXNzZXJ0KAoJLy8gICAgICAgdXNlci52ZXJpZmljYXRpb25DbGFzcyA+PSB0aGlzLnZlcmlmaWNhdGlvbkNsYXNzLnZhbHVlLCAvLyBpZih1c2VyLnZlcmlmaWNhdGlvbkNsYXNzID49IHRoaXMudmVyaWZpY2F0aW9uQ2xhc3MudmFsdWUpIHRoZW4gb2sKCS8vICAgICAgICdVc2VyIGNhbm5vdCBpbnRlcmFjdCB3aXRoIHRoaXMgc21hcnQgY29udHJhY3QgYXMgaGlzIHZlcmlmaWNhdGlvbiBjbGFzcyBpcyBsb3dlciB0aGVuIHJlcXVpcmVkIGhlcmUnCgkvLyAgICAgKQoJZnJhbWVfZGlnIDEgLy8gdXNlcjogKHVpbnQ4LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDI1Nix1aW50MjU2LGJvb2wsdWludDY0LHVpbnQ2NCxib29sKQoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWV4dHJhY3QgOSA4CglidG9pCglieXRlIDB4NjMgLy8gImMiCglhcHBfZ2xvYmFsX2dldAoJPj0KCgkvLyBVc2VyIGNhbm5vdCBpbnRlcmFjdCB3aXRoIHRoaXMgc21hcnQgY29udHJhY3QgYXMgaGlzIHZlcmlmaWNhdGlvbiBjbGFzcyBpcyBsb3dlciB0aGVuIHJlcXVpcmVkIGhlcmUKCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo3MDQKCS8vIGFzc2V0QURlY2ltYWxzID0gNgoJaW50IDYKCWZyYW1lX2J1cnkgMiAvLyBhc3NldEFEZWNpbWFsczogdWludDY0CgoJLy8gKmlmMjVfY29uZGl0aW9uCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NzA1CgkvLyBhc3NldEEuaWQgPiAwCglmcmFtZV9kaWcgLTQgLy8gYXNzZXRBOiBBc3NldElECglpbnQgMAoJPgoJYnogKmlmMjVfZW5kCgoJLy8gKmlmMjVfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjcwNQoJLy8gYXNzZXRBRGVjaW1hbHMgPSBhc3NldEEuZGVjaW1hbHMKCWZyYW1lX2RpZyAtNCAvLyBhc3NldEE6IEFzc2V0SUQKCWFzc2V0X3BhcmFtc19nZXQgQXNzZXREZWNpbWFscwoJcG9wCglmcmFtZV9idXJ5IDIgLy8gYXNzZXRBRGVjaW1hbHM6IHVpbnQ2NAoKKmlmMjVfZW5kOgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjcwNwoJLy8gYXNzZXRBRGVsaWNtYWxTY2FsZTJTY2FsZSA9ICgxMCAqKiAoU0NBTEVfREVDSU1BTFMgLSBhc3NldEFEZWNpbWFscykpIGFzIHVpbnQyNTYKCWludCAxMAoJaW50IDkKCWZyYW1lX2RpZyAyIC8vIGFzc2V0QURlY2ltYWxzOiB1aW50NjQKCS0KCWV4cAoJaXRvYgoJZnJhbWVfYnVyeSAzIC8vIGFzc2V0QURlbGljbWFsU2NhbGUyU2NhbGU6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjcwOQoJLy8gYXNzZXRCRGVsaWNtYWxTY2FsZTJTY2FsZSA9ICgxMCAqKiAoU0NBTEVfREVDSU1BTFMgLSBhc3NldEIuZGVjaW1hbHMpKSBhcyB1aW50MjU2CglpbnQgMTAKCWludCA5CglmcmFtZV9kaWcgLTUgLy8gYXNzZXRCOiBBc3NldElECglhc3NldF9wYXJhbXNfZ2V0IEFzc2V0RGVjaW1hbHMKCXBvcAoJLQoJZXhwCglpdG9iCglmcmFtZV9idXJ5IDQgLy8gYXNzZXRCRGVsaWNtYWxTY2FsZTJTY2FsZTogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NzExCgkvLyBzID0gU0NBTEUgYXMgdWludDI1NgoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwM2I5YWNhMDAKCWZyYW1lX2J1cnkgNSAvLyBzOiB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjcxMgoJLy8gZmVlc011bHRpcGxpZXIgPSAocyAtICgodGhpcy5mZWUudmFsdWUgYXMgdWludDI1NikgKiB1c2VyLmZlZU11bHRpcGxpZXIpIC8gdXNlci5iYXNlKSBhcyB1aW50MjU2CglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAzYjlhY2EwMCAvLyBzOiB1aW50MjU2CglieXRlIDB4NjYgLy8gImYiCglhcHBfZ2xvYmFsX2dldAoJaXRvYgoJZnJhbWVfZGlnIDEgLy8gdXNlcjogKHVpbnQ4LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDI1Nix1aW50MjU2LGJvb2wsdWludDY0LHVpbnQ2NCxib29sKQoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWV4dHJhY3QgNjUgMzIKCWIqCglmcmFtZV9kaWcgMSAvLyB1c2VyOiAodWludDgsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50MjU2LHVpbnQyNTYsYm9vbCx1aW50NjQsdWludDY0LGJvb2wpCglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCA5NyAzMgoJYi8KCWItCglmcmFtZV9idXJ5IDYgLy8gZmVlc011bHRpcGxpZXI6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjcxMwoJLy8gcmV0OiB1aW50NjQgPSAwCglpbnQgMAoJZnJhbWVfYnVyeSA3IC8vIHJldDogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjcxNAoJLy8gaXNBc3NldEEgPSBmYWxzZQoJaW50IDAKCWZyYW1lX2J1cnkgOCAvLyBpc0Fzc2V0QTogYm9vbAoKCS8vICppZjI2X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjcxNQoJLy8gdHhTd2FwLnR5cGVFbnVtID09PSBUcmFuc2FjdGlvblR5cGUuUGF5bWVudAoJZnJhbWVfZGlnIC0zIC8vIHR4U3dhcDogVHhuCglndHhucyBUeXBlRW51bQoJaW50IHBheQoJPT0KCWJ6ICppZjI2X2Vsc2UKCgkvLyAqaWYyNl9jb25zZXF1ZW50CgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NzE2CgkvLyBpc0Fzc2V0QSA9IHRydWUKCWludCAxCglmcmFtZV9idXJ5IDggLy8gaXNBc3NldEE6IGJvb2wKCWIgKmlmMjZfZW5kCgoqaWYyNl9lbHNlOgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjcxOAoJLy8gaXNBc3NldEEgPSB0eFN3YXAueGZlckFzc2V0ID09PSBhc3NldEEKCWZyYW1lX2RpZyAtMyAvLyB0eFN3YXA6IFR4bgoJZ3R4bnMgWGZlckFzc2V0CglmcmFtZV9kaWcgLTQgLy8gYXNzZXRBOiBBc3NldElECgk9PQoJZnJhbWVfYnVyeSA4IC8vIGlzQXNzZXRBOiBib29sCgoqaWYyNl9lbmQ6CgkvLyAqaWYyN19jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo3MjEKCS8vIGlzQXNzZXRBCglmcmFtZV9kaWcgOCAvLyBpc0Fzc2V0QTogYm9vbAoJYnogKmlmMjdfZW5kCgoJLy8gKmlmMjdfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjcyMgoJLy8gYXNzZXRJbkFzc2V0RGVjaW1hbHMgPSA8dWludDI1Nj4wCglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAoJZnJhbWVfYnVyeSA5IC8vIGFzc2V0SW5Bc3NldERlY2ltYWxzOiB1bnNhZmUgdWludDI1NgoKCS8vICppZjI4X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjcyMwoJLy8gdHhTd2FwLnR5cGVFbnVtID09PSBUcmFuc2FjdGlvblR5cGUuUGF5bWVudAoJZnJhbWVfZGlnIC0zIC8vIHR4U3dhcDogVHhuCglndHhucyBUeXBlRW51bQoJaW50IHBheQoJPT0KCWJ6ICppZjI4X2Vsc2UKCgkvLyAqaWYyOF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NzI0CgkvLyBhc3NldEluQXNzZXREZWNpbWFscyA9IHR4U3dhcC5hbW91bnQgYXMgdWludDI1NgoJZnJhbWVfZGlnIC0zIC8vIHR4U3dhcDogVHhuCglndHhucyBBbW91bnQKCWl0b2IKCWZyYW1lX2J1cnkgOSAvLyBhc3NldEluQXNzZXREZWNpbWFsczogdW5zYWZlIHVpbnQyNTYKCWIgKmlmMjhfZW5kCgoqaWYyOF9lbHNlOgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjcyNgoJLy8gYXNzZXRJbkFzc2V0RGVjaW1hbHMgPSB0eFN3YXAuYXNzZXRBbW91bnQgYXMgdWludDI1NgoJZnJhbWVfZGlnIC0zIC8vIHR4U3dhcDogVHhuCglndHhucyBBc3NldEFtb3VudAoJaXRvYgoJZnJhbWVfYnVyeSA5IC8vIGFzc2V0SW5Bc3NldERlY2ltYWxzOiB1bnNhZmUgdWludDI1NgoKKmlmMjhfZW5kOgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjcyOAoJLy8gaW5Bc3NldCA9IChhc3NldEluQXNzZXREZWNpbWFscyAqIGFzc2V0QURlbGljbWFsU2NhbGUyU2NhbGUpIGFzIHVpbnQyNTYKCWZyYW1lX2RpZyA5IC8vIGFzc2V0SW5Bc3NldERlY2ltYWxzOiB1bnNhZmUgdWludDI1NgoJZnJhbWVfZGlnIDMgLy8gYXNzZXRBRGVsaWNtYWxTY2FsZTJTY2FsZTogdW5zYWZlIHVpbnQyNTYKCWIqCglmcmFtZV9idXJ5IDEwIC8vIGluQXNzZXQ6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjcyOQoJLy8gaW5Bc3NldEFmdGVyRmVlID0gKGluQXNzZXQgKiBmZWVzTXVsdGlwbGllcikgLyBzCglmcmFtZV9kaWcgMTAgLy8gaW5Bc3NldDogdW5zYWZlIHVpbnQyNTYKCWZyYW1lX2RpZyA2IC8vIGZlZXNNdWx0aXBsaWVyOiB1bnNhZmUgdWludDI1NgoJYioKCWJ5dGUgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDNiOWFjYTAwIC8vIHM6IHVpbnQyNTYKCWIvCglmcmFtZV9idXJ5IDExIC8vIGluQXNzZXRBZnRlckZlZTogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NzMxCgkvLyB0b1N3YXAgPSB0aGlzLmNhbGN1bGF0ZUFzc2V0QldpdGhkcmF3T25Bc3NldEFEZXBvc2l0KAoJLy8gICAgICAgICBpbkFzc2V0QWZ0ZXJGZWUsCgkvLyAgICAgICAgIHRoaXMuYXNzZXRBQmFsYW5jZS52YWx1ZSwKCS8vICAgICAgICAgdGhpcy5hc3NldEJCYWxhbmNlLnZhbHVlLAoJLy8gICAgICAgICB0aGlzLnByaWNlTWluU3FydC52YWx1ZSwKCS8vICAgICAgICAgdGhpcy5wcmljZU1heFNxcnQudmFsdWUsCgkvLyAgICAgICAgIHRoaXMuTGlxdWRpdHkudmFsdWUKCS8vICAgICAgICkKCWJ5dGUgMHg0YyAvLyAiTCIKCWFwcF9nbG9iYWxfZ2V0CglieXRlIDB4NzA0ZDYxNzg1MyAvLyAicE1heFMiCglhcHBfZ2xvYmFsX2dldAoJYnl0ZSAweDcwNGQ2OTZlNTMgLy8gInBNaW5TIgoJYXBwX2dsb2JhbF9nZXQKCWJ5dGUgMHg2MjYyIC8vICJiYiIKCWFwcF9nbG9iYWxfZ2V0CglieXRlIDB4NjE2MiAvLyAiYWIiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIDExIC8vIGluQXNzZXRBZnRlckZlZTogdW5zYWZlIHVpbnQyNTYKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJY2FsbHN1YiBjYWxjdWxhdGVBc3NldEJXaXRoZHJhd09uQXNzZXRBRGVwb3NpdAoJZnJhbWVfYnVyeSAxMiAvLyB0b1N3YXA6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjc0MAoJLy8gdG9Td2FwQkRlY2ltYWxzID0gKHRvU3dhcCAvIGFzc2V0QkRlbGljbWFsU2NhbGUyU2NhbGUpIGFzIHVpbnQ2NAoJZnJhbWVfZGlnIDEyIC8vIHRvU3dhcDogdW5zYWZlIHVpbnQyNTYKCWZyYW1lX2RpZyA0IC8vIGFzc2V0QkRlbGljbWFsU2NhbGUyU2NhbGU6IHVuc2FmZSB1aW50MjU2CgliLwoJZHVwCgliaXRsZW4KCWludCA2NAoJPD0KCWFzc2VydAoJYnl0ZSAweEZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnQgOAoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJYnRvaQoJZnJhbWVfYnVyeSAxMyAvLyB0b1N3YXBCRGVjaW1hbHM6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo3NDEKCS8vIHJldCA9IHRvU3dhcEJEZWNpbWFscwoJZnJhbWVfZGlnIDEzIC8vIHRvU3dhcEJEZWNpbWFsczogdWludDY0CglmcmFtZV9idXJ5IDcgLy8gcmV0OiB1aW50NjQKCgkvLyAqaWYyOV9jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo3NDIKCS8vIG1pbmltdW1Ub1JlY2VpdmUgPiAwCglmcmFtZV9kaWcgLTYgLy8gbWluaW11bVRvUmVjZWl2ZTogdWludDY0CglpbnQgMAoJPgoJYnogKmlmMjlfZW5kCgoJLy8gKmlmMjlfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjc0NAoJLy8gYXNzZXJ0KG1pbmltdW1Ub1JlY2VpdmUgPj0gdG9Td2FwQkRlY2ltYWxzKQoJZnJhbWVfZGlnIC02IC8vIG1pbmltdW1Ub1JlY2VpdmU6IHVpbnQ2NAoJZnJhbWVfZGlnIDEzIC8vIHRvU3dhcEJEZWNpbWFsczogdWludDY0Cgk+PQoJYXNzZXJ0CgoqaWYyOV9lbmQ6CgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NzQ3CgkvLyB0aGlzLmRvQXhmZXIodGhpcy50eG4uc2VuZGVyLCBhc3NldEIsIHRvU3dhcEJEZWNpbWFscykKCWZyYW1lX2RpZyAxMyAvLyB0b1N3YXBCRGVjaW1hbHM6IHVpbnQ2NAoJZnJhbWVfZGlnIC01IC8vIGFzc2V0QjogQXNzZXRJRAoJdHhuIFNlbmRlcgoJY2FsbHN1YiBkb0F4ZmVyCgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjc0OQoJLy8gdGhpcy5hc3NldEFCYWxhbmNlLnZhbHVlID0gdGhpcy5hc3NldEFCYWxhbmNlLnZhbHVlICsgaW5Bc3NldAoJYnl0ZSAweDYxNjIgLy8gImFiIgoJZHVwCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIDEwIC8vIGluQXNzZXQ6IHVuc2FmZSB1aW50MjU2CgliKwoJZHVwCgliaXRsZW4KCWludCAyNTYKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDMyCgktCglzd2FwCglzdWJzdHJpbmczCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo3NTAKCS8vIHRoaXMuYXNzZXRCQmFsYW5jZS52YWx1ZSA9IHRoaXMuYXNzZXRCQmFsYW5jZS52YWx1ZSAtIHRvU3dhcAoJYnl0ZSAweDYyNjIgLy8gImJiIgoJZHVwCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIDEyIC8vIHRvU3dhcDogdW5zYWZlIHVpbnQyNTYKCWItCglkdXAKCWJpdGxlbgoJaW50IDI1NgoJPD0KCWFzc2VydAoJYnl0ZSAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnQgMzIKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWFwcF9nbG9iYWxfcHV0CgoqaWYyN19lbmQ6CgkvLyAqaWYzMF9jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo3NTMKCS8vICFpc0Fzc2V0QQoJZnJhbWVfZGlnIDggLy8gaXNBc3NldEE6IGJvb2wKCSEKCWJ6ICppZjMwX2VuZAoKCS8vICppZjMwX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo3NTQKCS8vIGFzc2V0SW5Bc3NldERlY2ltYWxzID0gdHhTd2FwLmFzc2V0QW1vdW50IGFzIHVpbnQyNTYKCWZyYW1lX2RpZyAtMyAvLyB0eFN3YXA6IFR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCWl0b2IKCWZyYW1lX2J1cnkgMTQgLy8gYXNzZXRJbkFzc2V0RGVjaW1hbHM6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjc1NQoJLy8gaW5Bc3NldCA9IChhc3NldEluQXNzZXREZWNpbWFscyAqIGFzc2V0QkRlbGljbWFsU2NhbGUyU2NhbGUpIGFzIHVpbnQyNTYKCWZyYW1lX2RpZyAxNCAvLyBhc3NldEluQXNzZXREZWNpbWFsczogdW5zYWZlIHVpbnQyNTYKCWZyYW1lX2RpZyA0IC8vIGFzc2V0QkRlbGljbWFsU2NhbGUyU2NhbGU6IHVuc2FmZSB1aW50MjU2CgliKgoJZnJhbWVfYnVyeSAxNSAvLyBpbkFzc2V0OiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo3NTYKCS8vIGluQXNzZXRBZnRlckZlZSA9IChpbkFzc2V0ICogZmVlc011bHRpcGxpZXIpIC8gcwoJZnJhbWVfZGlnIDE1IC8vIGluQXNzZXQ6IHVuc2FmZSB1aW50MjU2CglmcmFtZV9kaWcgNiAvLyBmZWVzTXVsdGlwbGllcjogdW5zYWZlIHVpbnQyNTYKCWIqCglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAzYjlhY2EwMCAvLyBzOiB1aW50MjU2CgliLwoJZnJhbWVfYnVyeSAxNiAvLyBpbkFzc2V0QWZ0ZXJGZWU6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjc1NwoJLy8gdG9Td2FwID0gdGhpcy5jYWxjdWxhdGVBc3NldEFXaXRoZHJhd09uQXNzZXRCRGVwb3NpdCgKCS8vICAgICAgICAgaW5Bc3NldEFmdGVyRmVlLAoJLy8gICAgICAgICB0aGlzLmFzc2V0QUJhbGFuY2UudmFsdWUsCgkvLyAgICAgICAgIHRoaXMuYXNzZXRCQmFsYW5jZS52YWx1ZSwKCS8vICAgICAgICAgdGhpcy5wcmljZU1pblNxcnQudmFsdWUsCgkvLyAgICAgICAgIHRoaXMucHJpY2VNYXhTcXJ0LnZhbHVlLAoJLy8gICAgICAgICB0aGlzLkxpcXVkaXR5LnZhbHVlCgkvLyAgICAgICApCglieXRlIDB4NGMgLy8gIkwiCglhcHBfZ2xvYmFsX2dldAoJYnl0ZSAweDcwNGQ2MTc4NTMgLy8gInBNYXhTIgoJYXBwX2dsb2JhbF9nZXQKCWJ5dGUgMHg3MDRkNjk2ZTUzIC8vICJwTWluUyIKCWFwcF9nbG9iYWxfZ2V0CglieXRlIDB4NjI2MiAvLyAiYmIiCglhcHBfZ2xvYmFsX2dldAoJYnl0ZSAweDYxNjIgLy8gImFiIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAxNiAvLyBpbkFzc2V0QWZ0ZXJGZWU6IHVuc2FmZSB1aW50MjU2CglkdXAKCWJpdGxlbgoJaW50IDI1NgoJPD0KCWFzc2VydAoJYnl0ZSAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnQgMzIKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWNhbGxzdWIgY2FsY3VsYXRlQXNzZXRBV2l0aGRyYXdPbkFzc2V0QkRlcG9zaXQKCWZyYW1lX2J1cnkgMTcgLy8gdG9Td2FwOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo3NjYKCS8vIHRvU3dhcEFEZWNpbWFscyA9ICh0b1N3YXAgLyBhc3NldEFEZWxpY21hbFNjYWxlMlNjYWxlKSBhcyB1aW50NjQKCWZyYW1lX2RpZyAxNyAvLyB0b1N3YXA6IHVuc2FmZSB1aW50MjU2CglmcmFtZV9kaWcgMyAvLyBhc3NldEFEZWxpY21hbFNjYWxlMlNjYWxlOiB1bnNhZmUgdWludDI1NgoJYi8KCWR1cAoJYml0bGVuCglpbnQgNjQKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDgKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWJ0b2kKCWZyYW1lX2J1cnkgMTggLy8gdG9Td2FwQURlY2ltYWxzOiB1aW50NjQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NzY3CgkvLyByZXQgPSB0b1N3YXBBRGVjaW1hbHMKCWZyYW1lX2RpZyAxOCAvLyB0b1N3YXBBRGVjaW1hbHM6IHVpbnQ2NAoJZnJhbWVfYnVyeSA3IC8vIHJldDogdWludDY0CgoJLy8gKmlmMzFfY29uZGl0aW9uCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NzY4CgkvLyBtaW5pbXVtVG9SZWNlaXZlID4gMAoJZnJhbWVfZGlnIC02IC8vIG1pbmltdW1Ub1JlY2VpdmU6IHVpbnQ2NAoJaW50IDAKCT4KCWJ6ICppZjMxX2VuZAoKCS8vICppZjMxX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo3NzAKCS8vIGFzc2VydChtaW5pbXVtVG9SZWNlaXZlID49IHRvU3dhcEFEZWNpbWFscykKCWZyYW1lX2RpZyAtNiAvLyBtaW5pbXVtVG9SZWNlaXZlOiB1aW50NjQKCWZyYW1lX2RpZyAxOCAvLyB0b1N3YXBBRGVjaW1hbHM6IHVpbnQ2NAoJPj0KCWFzc2VydAoKKmlmMzFfZW5kOgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjc3MwoJLy8gdGhpcy5kb0F4ZmVyKHRoaXMudHhuLnNlbmRlciwgYXNzZXRBLCB0b1N3YXBBRGVjaW1hbHMpCglmcmFtZV9kaWcgMTggLy8gdG9Td2FwQURlY2ltYWxzOiB1aW50NjQKCWZyYW1lX2RpZyAtNCAvLyBhc3NldEE6IEFzc2V0SUQKCXR4biBTZW5kZXIKCWNhbGxzdWIgZG9BeGZlcgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo3NzUKCS8vIHRoaXMuYXNzZXRCQmFsYW5jZS52YWx1ZSA9IHRoaXMuYXNzZXRCQmFsYW5jZS52YWx1ZSArIGluQXNzZXQKCWJ5dGUgMHg2MjYyIC8vICJiYiIKCWR1cAoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAxNSAvLyBpbkFzc2V0OiB1bnNhZmUgdWludDI1NgoJYisKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6Nzc2CgkvLyB0aGlzLmFzc2V0QUJhbGFuY2UudmFsdWUgPSB0aGlzLmFzc2V0QUJhbGFuY2UudmFsdWUgLSB0b1N3YXAKCWJ5dGUgMHg2MTYyIC8vICJhYiIKCWR1cAoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAxNyAvLyB0b1N3YXA6IHVuc2FmZSB1aW50MjU2CgliLQoJZHVwCgliaXRsZW4KCWludCAyNTYKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDMyCgktCglzd2FwCglzdWJzdHJpbmczCglhcHBfZ2xvYmFsX3B1dAoKKmlmMzBfZW5kOgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjc3OQoJLy8gbmV3TCA9IHRoaXMuY2FsY3VsYXRlTGlxdWlkaXR5KAoJLy8gICAgICAgdGhpcy5hc3NldEFCYWxhbmNlLnZhbHVlLAoJLy8gICAgICAgdGhpcy5hc3NldEJCYWxhbmNlLnZhbHVlLAoJLy8gICAgICAgdGhpcy5wcmljZU1pbi52YWx1ZSBhcyB1aW50MjU2LCAvLyBwcmljZU1pbjogdWludDI1NiwKCS8vICAgICAgIHRoaXMucHJpY2VNYXgudmFsdWUgYXMgdWludDI1NiwgLy8gcHJpY2VNYXg6IHVpbnQyNTYsCgkvLyAgICAgICB0aGlzLnByaWNlTWluU3FydC52YWx1ZSwgLy8gcHJpY2VNaW5TcXJ0OiB1aW50MjU2LAoJLy8gICAgICAgdGhpcy5wcmljZU1heFNxcnQudmFsdWUgLy8gcHJpY2VNYXhTcXJ0OiB1aW50MjU2LAoJLy8gICAgICkKCWJ5dGUgMHg3MDRkNjE3ODUzIC8vICJwTWF4UyIKCWFwcF9nbG9iYWxfZ2V0CglieXRlIDB4NzA0ZDY5NmU1MyAvLyAicE1pblMiCglhcHBfZ2xvYmFsX2dldAoJYnl0ZSAweDcwNGQ2MTc4IC8vICJwTWF4IgoJYXBwX2dsb2JhbF9nZXQKCWl0b2IKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJYnl0ZSAweDcwNGQ2OTZlIC8vICJwTWluIgoJYXBwX2dsb2JhbF9nZXQKCWl0b2IKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJYnl0ZSAweDYyNjIgLy8gImJiIgoJYXBwX2dsb2JhbF9nZXQKCWJ5dGUgMHg2MTYyIC8vICJhYiIKCWFwcF9nbG9iYWxfZ2V0CgljYWxsc3ViIGNhbGN1bGF0ZUxpcXVpZGl0eQoJZnJhbWVfYnVyeSAxOSAvLyBuZXdMOiB1bnNhZmUgdWludDI1NgoKCS8vICppZjMyX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjc4OAoJLy8gbmV3TCAhPT0gdGhpcy5MaXF1ZGl0eS52YWx1ZQoJZnJhbWVfZGlnIDE5IC8vIG5ld0w6IHVuc2FmZSB1aW50MjU2CglieXRlIDB4NGMgLy8gIkwiCglhcHBfZ2xvYmFsX2dldAoJYiE9CglieiAqaWYzMl9lbmQKCgkvLyAqaWYzMl9jb25zZXF1ZW50CgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6NzkxCgkvLyBkaWZmID0gKG5ld0wgLSB0aGlzLkxpcXVkaXR5LnZhbHVlKSBhcyB1aW50MjU2CglmcmFtZV9kaWcgMTkgLy8gbmV3TDogdW5zYWZlIHVpbnQyNTYKCWJ5dGUgMHg0YyAvLyAiTCIKCWFwcF9nbG9iYWxfZ2V0CgliLQoJZnJhbWVfYnVyeSAyMCAvLyBkaWZmOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo3OTIKCS8vIHRoaXMuTGlxdWRpdHkudmFsdWUgPSBuZXdMCglieXRlIDB4NGMgLy8gIkwiCglmcmFtZV9kaWcgMTkgLy8gbmV3TDogdW5zYWZlIHVpbnQyNTYKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6Nzk0CgkvLyBiaWF0ZWNGZWUgPSB0aGlzLmFwcEJpYXRlY0NvbmZpZ1Byb3ZpZGVyLnZhbHVlLmdsb2JhbFN0YXRlKCdmJykgYXMgdWludDI1NgoJYnl0ZSAweDQyIC8vICJCIgoJYXBwX2dsb2JhbF9nZXQKCWJ5dGUgMHg2NiAvLyAiZiIKCWFwcF9nbG9iYWxfZ2V0X2V4Cglhc3NlcnQKCWZyYW1lX2J1cnkgMjEgLy8gYmlhdGVjRmVlOiB1aW50MjU2CgoJLy8gKmlmMzNfY29uZGl0aW9uCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6Nzk1CgkvLyBiaWF0ZWNGZWUgPT09IDx1aW50MjU2PjAKCWZyYW1lX2RpZyAyMSAvLyBiaWF0ZWNGZWU6IHVpbnQyNTYKCWJ5dGUgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwCgliPT0KCWJ6ICppZjMzX2Vsc2UKCgkvLyAqaWYzM19jb25zZXF1ZW50CgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6Nzk2CgkvLyB1c2Vyc0xpcXVpZGl0eUZyb21GZWVJbmNyZW1lbnQgPSBkaWZmCglmcmFtZV9kaWcgMjAgLy8gZGlmZjogdW5zYWZlIHVpbnQyNTYKCWZyYW1lX2J1cnkgMjIgLy8gdXNlcnNMaXF1aWRpdHlGcm9tRmVlSW5jcmVtZW50OiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo3OTcKCS8vIHRoaXMuTGlxdWRpdHlVc2Vyc0Zyb21GZWVzLnZhbHVlID0gdGhpcy5MaXF1ZGl0eVVzZXJzRnJvbUZlZXMudmFsdWUgKyB1c2Vyc0xpcXVpZGl0eUZyb21GZWVJbmNyZW1lbnQKCWJ5dGUgMHg0Yzc1IC8vICJMdSIKCWR1cAoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAyMiAvLyB1c2Vyc0xpcXVpZGl0eUZyb21GZWVJbmNyZW1lbnQ6IHVuc2FmZSB1aW50MjU2CgliKwoJZHVwCgliaXRsZW4KCWludCAyNTYKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDMyCgktCglzd2FwCglzdWJzdHJpbmczCglhcHBfZ2xvYmFsX3B1dAoJYiAqaWYzM19lbmQKCippZjMzX2Vsc2U6CgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6Nzk5CgkvLyB1c2Vyc0xpcXVpZGl0eUZyb21GZWVJbmNyZW1lbnQgPSAoZGlmZiAqIChzIC0gYmlhdGVjRmVlKSkgLyBzCglmcmFtZV9kaWcgMjAgLy8gZGlmZjogdW5zYWZlIHVpbnQyNTYKCWJ5dGUgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDNiOWFjYTAwIC8vIHM6IHVpbnQyNTYKCWZyYW1lX2RpZyAyMSAvLyBiaWF0ZWNGZWU6IHVpbnQyNTYKCWItCgliKgoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwM2I5YWNhMDAgLy8gczogdWludDI1NgoJYi8KCWZyYW1lX2J1cnkgMjMgLy8gdXNlcnNMaXF1aWRpdHlGcm9tRmVlSW5jcmVtZW50OiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo4MDAKCS8vIGJpYXRlY0xpcXVpZGl0eUZyb21GZWVJbmNyZW1lbnQgPSBkaWZmIC0gdXNlcnNMaXF1aWRpdHlGcm9tRmVlSW5jcmVtZW50CglmcmFtZV9kaWcgMjAgLy8gZGlmZjogdW5zYWZlIHVpbnQyNTYKCWZyYW1lX2RpZyAyMyAvLyB1c2Vyc0xpcXVpZGl0eUZyb21GZWVJbmNyZW1lbnQ6IHVuc2FmZSB1aW50MjU2CgliLQoJZnJhbWVfYnVyeSAyNCAvLyBiaWF0ZWNMaXF1aWRpdHlGcm9tRmVlSW5jcmVtZW50OiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo4MDEKCS8vIHRoaXMuTGlxdWRpdHlVc2Vyc0Zyb21GZWVzLnZhbHVlID0gdGhpcy5MaXF1ZGl0eVVzZXJzRnJvbUZlZXMudmFsdWUgKyB1c2Vyc0xpcXVpZGl0eUZyb21GZWVJbmNyZW1lbnQKCWJ5dGUgMHg0Yzc1IC8vICJMdSIKCWR1cAoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAyMyAvLyB1c2Vyc0xpcXVpZGl0eUZyb21GZWVJbmNyZW1lbnQ6IHVuc2FmZSB1aW50MjU2CgliKwoJZHVwCgliaXRsZW4KCWludCAyNTYKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDMyCgktCglzd2FwCglzdWJzdHJpbmczCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo4MDIKCS8vIHRoaXMuTGlxdWRpdHlCaWF0ZWNGcm9tRmVlcy52YWx1ZSA9IHRoaXMuTGlxdWRpdHlCaWF0ZWNGcm9tRmVlcy52YWx1ZSArIGJpYXRlY0xpcXVpZGl0eUZyb21GZWVJbmNyZW1lbnQKCWJ5dGUgMHg0YzYyIC8vICJMYiIKCWR1cAoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAyNCAvLyBiaWF0ZWNMaXF1aWRpdHlGcm9tRmVlSW5jcmVtZW50OiB1bnNhZmUgdWludDI1NgoJYisKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJYXBwX2dsb2JhbF9wdXQKCippZjMzX2VuZDoKCippZjMyX2VuZDoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo4MDUKCS8vIG5ld1ByaWNlID0gdGhpcy5jYWxjdWxhdGVQcmljZSgKCS8vICAgICAgIHRoaXMuYXNzZXRBQmFsYW5jZS52YWx1ZSwgLy8gYXNzZXRBUXVhbnRpdHk6IHVpbnQyNTYsCgkvLyAgICAgICB0aGlzLmFzc2V0QkJhbGFuY2UudmFsdWUsIC8vIGFzc2V0QlF1YW50aXR5OiB1aW50MjU2LAoJLy8gICAgICAgdGhpcy5wcmljZU1pblNxcnQudmFsdWUsIC8vIHByaWNlTWluU3FydDogdWludDI1NiwKCS8vICAgICAgIHRoaXMucHJpY2VNYXhTcXJ0LnZhbHVlLCAvLyBwcmljZU1heFNxcnQ6IHVpbnQyNTYsCgkvLyAgICAgICB0aGlzLkxpcXVkaXR5LnZhbHVlIC8vIGxpcXVpZGl0eTogdWludDI1NgoJLy8gICAgICkKCWJ5dGUgMHg0YyAvLyAiTCIKCWFwcF9nbG9iYWxfZ2V0CglieXRlIDB4NzA0ZDYxNzg1MyAvLyAicE1heFMiCglhcHBfZ2xvYmFsX2dldAoJYnl0ZSAweDcwNGQ2OTZlNTMgLy8gInBNaW5TIgoJYXBwX2dsb2JhbF9nZXQKCWJ5dGUgMHg2MjYyIC8vICJiYiIKCWFwcF9nbG9iYWxfZ2V0CglieXRlIDB4NjE2MiAvLyAiYWIiCglhcHBfZ2xvYmFsX2dldAoJY2FsbHN1YiBjYWxjdWxhdGVQcmljZQoJZnJhbWVfYnVyeSAyNSAvLyBuZXdQcmljZTogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6ODEyCgkvLyB0aGlzLnJhdGlvLnZhbHVlID0gbmV3UHJpY2UgYXMgdWludDY0CglieXRlIDB4NzIgLy8gInIiCglmcmFtZV9kaWcgMjUgLy8gbmV3UHJpY2U6IHVuc2FmZSB1aW50MjU2CglkdXAKCWJpdGxlbgoJaW50IDY0Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCA4CgktCglzd2FwCglzdWJzdHJpbmczCglidG9pCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo4MTMKCS8vIHJldHVybiByZXQgYXMgdWludDI1NjsKCWZyYW1lX2RpZyA3IC8vIHJldDogdWludDY0CglpdG9iCgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMjUKCXJldHN1YgoKLy8gY2FsY3VsYXRlRGlzdHJpYnV0ZWRMaXF1aWRpdHkodWludDY0LHVpbnQyNTYpdWludDI1NgoqYWJpX3JvdXRlX2NhbGN1bGF0ZURpc3RyaWJ1dGVkTGlxdWlkaXR5OgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBjdXJyZW50RGVwb3NpdDogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIGFzc2V0TFA6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgY2FsY3VsYXRlRGlzdHJpYnV0ZWRMaXF1aWRpdHkodWludDY0LHVpbnQyNTYpdWludDI1NgoJY2FsbHN1YiBjYWxjdWxhdGVEaXN0cmlidXRlZExpcXVpZGl0eQoJZHVwCgliaXRsZW4KCWludCAyNTYKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDMyCgktCglzd2FwCglzdWJzdHJpbmczCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gY2FsY3VsYXRlRGlzdHJpYnV0ZWRMaXF1aWRpdHkoYXNzZXRMUDogQXNzZXRJRCwgY3VycmVudERlcG9zaXQ6IHVpbnQyNTYpOiB1aW50MjU2Ci8vCi8vIENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBMUCB0b2tlbnMgaXNzdWVkIHRvIHVzZXJzCmNhbGN1bGF0ZURpc3RyaWJ1dGVkTGlxdWlkaXR5OgoJcHJvdG8gMiAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gNAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo4MjEKCS8vIGN1cnJlbnQgPSAodGhpcy5hcHAuYWRkcmVzcy5hc3NldEJhbGFuY2UoYXNzZXRMUCkgYXMgdWludDI1NikgLSBjdXJyZW50RGVwb3NpdAoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWZyYW1lX2RpZyAtMSAvLyBhc3NldExQOiBBc3NldElECglhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKCXBvcAoJaXRvYgoJZnJhbWVfZGlnIC0yIC8vIGN1cnJlbnREZXBvc2l0OiB1aW50MjU2CgliLQoJZnJhbWVfYnVyeSAwIC8vIGN1cnJlbnQ6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjgyMgoJLy8gbWludGVkID0gVE9UQUxfU1VQUExZIGFzIHVpbnQyNTYKCWJ5dGUgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIzODZmMjZmYzEwMDAwCglmcmFtZV9idXJ5IDEgLy8gbWludGVkOiB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjgyMwoJLy8gZGlzdHJpYnV0ZWRMUFRva2VucyA9IG1pbnRlZCAtIGN1cnJlbnQKCWJ5dGUgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIzODZmMjZmYzEwMDAwIC8vIG1pbnRlZDogdWludDI1NgoJZnJhbWVfZGlnIDAgLy8gY3VycmVudDogdW5zYWZlIHVpbnQyNTYKCWItCglmcmFtZV9idXJ5IDIgLy8gZGlzdHJpYnV0ZWRMUFRva2VuczogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6ODI1CgkvLyBhc3NldExQRGVsaWNtYWxTY2FsZTJTY2FsZSA9ICgxMCAqKiAoU0NBTEVfREVDSU1BTFMgLSBMUF9UT0tFTl9ERUNJTUFMUykpIGFzIHVpbnQyNTYKCWludCAxMAoJaW50IDMKCWV4cAoJaXRvYgoJZnJhbWVfYnVyeSAzIC8vIGFzc2V0TFBEZWxpY21hbFNjYWxlMlNjYWxlOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo4MjYKCS8vIHJldCA9IGRpc3RyaWJ1dGVkTFBUb2tlbnMgKiBhc3NldExQRGVsaWNtYWxTY2FsZTJTY2FsZQoJZnJhbWVfZGlnIDIgLy8gZGlzdHJpYnV0ZWRMUFRva2VuczogdW5zYWZlIHVpbnQyNTYKCWZyYW1lX2RpZyAzIC8vIGFzc2V0TFBEZWxpY21hbFNjYWxlMlNjYWxlOiB1bnNhZmUgdWludDI1NgoJYioKCWZyYW1lX2J1cnkgNCAvLyByZXQ6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjgyNwoJLy8gcmV0dXJuIHJldDsKCWZyYW1lX2RpZyA0IC8vIHJldDogdW5zYWZlIHVpbnQyNTYKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiA0CglyZXRzdWIKCi8vIGNhbGN1bGF0ZUxpcXVpZGl0eSh1aW50MjU2LHVpbnQyNTYsdWludDI1Nix1aW50MjU2LHVpbnQyNTYsdWludDI1Nil1aW50MjU2CiphYmlfcm91dGVfY2FsY3VsYXRlTGlxdWlkaXR5OgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBwcmljZU1heFNxcnQ6IHVpbnQyNTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDYKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBwcmljZU1pblNxcnQ6IHVpbnQyNTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDUKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBwcmljZU1heDogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIHByaWNlTWluOiB1aW50MjU2Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8geTogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIHg6IHVpbnQyNTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBleGVjdXRlIGNhbGN1bGF0ZUxpcXVpZGl0eSh1aW50MjU2LHVpbnQyNTYsdWludDI1Nix1aW50MjU2LHVpbnQyNTYsdWludDI1Nil1aW50MjU2CgljYWxsc3ViIGNhbGN1bGF0ZUxpcXVpZGl0eQoJZHVwCgliaXRsZW4KCWludCAyNTYKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDMyCgktCglzd2FwCglzdWJzdHJpbmczCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gY2FsY3VsYXRlTGlxdWlkaXR5KHg6IHVpbnQyNTYsIHk6IHVpbnQyNTYsIHByaWNlTWluOiB1aW50MjU2LCBwcmljZU1heDogdWludDI1NiwgcHJpY2VNaW5TcXJ0OiB1aW50MjU2LCBwcmljZU1heFNxcnQ6IHVpbnQyNTYpOiB1aW50MjU2Ci8vCi8vIENhbGN1bGF0ZXMgdGhlIGxpcXVpZGl0eSAgZnJvbSB0aGUgeCAtIEFzc2V0IEEgcG9zaXRpb24gYW5kIHkgLSBBc3NldCBCIHBvc2l0aW9uCi8vCi8vIEBwYXJhbSB4IEFzc2V0IEEgcG9zaXRpb24gYmFsYW5jZWQgb24gdGhlIGN1cnZlCi8vIEBwYXJhbSB5IEFzc2V0IEIgcG9zaXRpb24gYmFsYW5jZWQgb24gdGhlIGN1cnZlCi8vIEBwYXJhbSBwcmljZU1pbiBNaW5pbXVtIHByaWNlIHZhcmlhYmxlIGluIGJhc2Ugc2NhbGUgZGVjaW1hbHMgKHBhKQovLyBAcGFyYW0gcHJpY2VNYXggTWF4aW11bSBwcmljZSB2YXJpYWJsZSBpbiBiYXNlIHNjYWxlIGRlY2ltYWxzIChwYikKLy8gQHBhcmFtIHByaWNlTWluU3FydCBzcXJ0KHByaWNlTWluKSBpbiBiYXNlIHNjYWxlIGRlY2ltYWxzIFZhcmlhYmxlIHBhcwovLyBAcGFyYW0gcHJpY2VNYXhTcXJ0IHNxcnQocHJpY2VNYXgpIGluIGJhc2Ugc2NhbGUgZGVjaW1hbHMgVmFyaWFibGUgcGJzCi8vIEByZXR1cm5zIExpcXVpZGl0eSBpcyBjb25zdGFudCBpbiBzd2FwcGluZyBlYWNoIGRpcmVjdGlvbi4gT24gZGVwb3NpdCB0aGUgZGlmZiBiZXR3ZWVuIHRoZSBsaXF1aWRpdHkgaXMgbnVtYmVyIG9mIExQIHRva2VucyByZWNlaXZlZCBieSB1c2VyLgpjYWxjdWxhdGVMaXF1aWRpdHk6Cglwcm90byA2IDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwbiAxOQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo4NTAKCS8vIGluY3JlYXNlT3Bjb2RlQnVkZ2V0KCkKCWl0eG5fYmVnaW4KCWludCBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCWJ5dGUgYjY0IENvRUIgLy8gI3ByYWdtYSB2ZXJzaW9uIDEwOyBpbnQgMQoJZHVwCglpdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQoJaXR4bl9maWVsZCBDbGVhclN0YXRlUHJvZ3JhbQoJaW50IERlbGV0ZUFwcGxpY2F0aW9uCglpdHhuX2ZpZWxkIE9uQ29tcGxldGlvbgoJaXR4bl9zdWJtaXQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6ODc4CgkvLyBzID0gU0NBTEUgYXMgdWludDI1NgoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwM2I5YWNhMDAKCWZyYW1lX2J1cnkgMCAvLyBzOiB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjg4MAoJLy8gRDEgPSAoKCh4ICogeCkgLyBzKSAqIHByaWNlTWluKSAvIHMKCWZyYW1lX2RpZyAtMSAvLyB4OiB1aW50MjU2CglmcmFtZV9kaWcgLTEgLy8geDogdWludDI1NgoJYioKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIvCglmcmFtZV9kaWcgLTMgLy8gcHJpY2VNaW46IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMCAvLyBzOiB1aW50MjU2CgliLwoJZnJhbWVfYnVyeSAxIC8vIEQxOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo4ODIKCS8vIEQyID0gKHkgKiB5KSAvIHByaWNlTWF4CglmcmFtZV9kaWcgLTIgLy8geTogdWludDI1NgoJZnJhbWVfZGlnIC0yIC8vIHk6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgLTQgLy8gcHJpY2VNYXg6IHVpbnQyNTYKCWIvCglmcmFtZV9idXJ5IDIgLy8gRDI6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjg4NAoJLy8gRDMgPSAoKCg8dWludDI1Nj4yICogeCAqIHkpIC8gcykgKiBwcmljZU1pblNxcnQpIC8gcyAvIHByaWNlTWF4U3FydAoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIKCWZyYW1lX2RpZyAtMSAvLyB4OiB1aW50MjU2CgliKgoJZnJhbWVfZGlnIC0yIC8vIHk6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMCAvLyBzOiB1aW50MjU2CgliLwoJZnJhbWVfZGlnIC01IC8vIHByaWNlTWluU3FydDogdWludDI1NgoJYioKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIvCglmcmFtZV9kaWcgLTYgLy8gcHJpY2VNYXhTcXJ0OiB1aW50MjU2CgliLwoJZnJhbWVfYnVyeSAzIC8vIEQzOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo4ODcKCS8vIEQ0ID0gKDx1aW50MjU2PjQgKiB4ICogeSkgLyBzCglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNAoJZnJhbWVfZGlnIC0xIC8vIHg6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgLTIgLy8geTogdWludDI1NgoJYioKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIvCglmcmFtZV9idXJ5IDQgLy8gRDQ6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjg4OQoJLy8gRDUgPSAoKCg8dWludDI1Nj40ICogeCAqIHkpIC8gcykgKiBwcmljZU1pblNxcnQpIC8gcyAvIHByaWNlTWF4U3FydAoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQKCWZyYW1lX2RpZyAtMSAvLyB4OiB1aW50MjU2CgliKgoJZnJhbWVfZGlnIC0yIC8vIHk6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMCAvLyBzOiB1aW50MjU2CgliLwoJZnJhbWVfZGlnIC01IC8vIHByaWNlTWluU3FydDogdWludDI1NgoJYioKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIvCglmcmFtZV9kaWcgLTYgLy8gcHJpY2VNYXhTcXJ0OiB1aW50MjU2CgliLwoJZnJhbWVfYnVyeSA1IC8vIEQ1OiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo4OTAKCS8vIEQgPSBEMSArIEQyICsgRDMgKyBENCAtIEQ1CglmcmFtZV9kaWcgMSAvLyBEMTogdW5zYWZlIHVpbnQyNTYKCWZyYW1lX2RpZyAyIC8vIEQyOiB1bnNhZmUgdWludDI1NgoJYisKCWZyYW1lX2RpZyAzIC8vIEQzOiB1bnNhZmUgdWludDI1NgoJYisKCWZyYW1lX2RpZyA0IC8vIEQ0OiB1bnNhZmUgdWludDI1NgoJYisKCWZyYW1lX2RpZyA1IC8vIEQ1OiB1bnNhZmUgdWludDI1NgoJYi0KCWZyYW1lX2J1cnkgNiAvLyBEOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo4OTQKCS8vIEwxID0gKHggKiBwcmljZU1pblNxcnQpIC8gcwoJZnJhbWVfZGlnIC0xIC8vIHg6IHVpbnQyNTYKCWZyYW1lX2RpZyAtNSAvLyBwcmljZU1pblNxcnQ6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMCAvLyBzOiB1aW50MjU2CgliLwoJZnJhbWVfYnVyeSA3IC8vIEwxOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo4OTcKCS8vIEwyID0gKHkgKiBzKSAvIHByaWNlTWF4U3FydAoJZnJhbWVfZGlnIC0yIC8vIHk6IHVpbnQyNTYKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgLTYgLy8gcHJpY2VNYXhTcXJ0OiB1aW50MjU2CgliLwoJZnJhbWVfYnVyeSA4IC8vIEwyOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo4OTkKCS8vIEwzXzAgPSA8dWludDI1Nj4yCglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMgoJZnJhbWVfYnVyeSA5IC8vIEwzXzA6IHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6OTAwCgkvLyBMM18xID0gTDNfMCAqIHByaWNlTWluU3FydAoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIgLy8gTDNfMDogdWludDI1NgoJZnJhbWVfZGlnIC01IC8vIHByaWNlTWluU3FydDogdWludDI1NgoJYioKCWZyYW1lX2J1cnkgMTAgLy8gTDNfMTogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6OTAyCgkvLyBMM18yID0gTDNfMSAqIHMKCWZyYW1lX2RpZyAxMCAvLyBMM18xOiB1bnNhZmUgdWludDI1NgoJZnJhbWVfZGlnIDAgLy8gczogdWludDI1NgoJYioKCWZyYW1lX2J1cnkgMTEgLy8gTDNfMjogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6OTAzCgkvLyBMMyA9IEwzXzIgLyBwcmljZU1heFNxcnQKCWZyYW1lX2RpZyAxMSAvLyBMM18yOiB1bnNhZmUgdWludDI1NgoJZnJhbWVfZGlnIC02IC8vIHByaWNlTWF4U3FydDogdWludDI1NgoJYi8KCWZyYW1lX2J1cnkgMTIgLy8gTDM6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjkwNgoJLy8gRF9TUVJUID0gc3FydChzICogRCkKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWZyYW1lX2RpZyA2IC8vIEQ6IHVuc2FmZSB1aW50MjU2CgliKgoJYnNxcnQKCWZyYW1lX2J1cnkgMTMgLy8gRF9TUVJUOiB1bnNhZmUgdWludDI1NgoKCS8vICppZjM0X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjkwOAoJLy8gPHVpbnQyNTY+MiAqIHMgPiBMMwoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMTIgLy8gTDM6IHVuc2FmZSB1aW50MjU2CgliPgoJYnogKmlmMzRfZW5kCgoJLy8gKmlmMzRfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjkwOQoJLy8gbm9tID0gTDEgKyBMMiArIERfU1FSVAoJZnJhbWVfZGlnIDcgLy8gTDE6IHVuc2FmZSB1aW50MjU2CglmcmFtZV9kaWcgOCAvLyBMMjogdW5zYWZlIHVpbnQyNTYKCWIrCglmcmFtZV9kaWcgMTMgLy8gRF9TUVJUOiB1bnNhZmUgdWludDI1NgoJYisKCWZyYW1lX2J1cnkgMTQgLy8gbm9tOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo5MTAKCS8vIGRlbiA9IDx1aW50MjU2PjIgKiBzIC0gTDMKCWJ5dGUgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyCglmcmFtZV9kaWcgMCAvLyBzOiB1aW50MjU2CgliKgoJZnJhbWVfZGlnIDEyIC8vIEwzOiB1bnNhZmUgdWludDI1NgoJYi0KCWZyYW1lX2J1cnkgMTUgLy8gZGVuOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo5MTEKCS8vIHJldCA9IChzICogbm9tKSAvIGRlbgoJZnJhbWVfZGlnIDAgLy8gczogdWludDI1NgoJZnJhbWVfZGlnIDE0IC8vIG5vbTogdW5zYWZlIHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMTUgLy8gZGVuOiB1bnNhZmUgdWludDI1NgoJYi8KCWZyYW1lX2J1cnkgMTYgLy8gcmV0OiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo5MTIKCS8vIHJldHVybiByZXQ7CglmcmFtZV9kaWcgMTYgLy8gcmV0OiB1bnNhZmUgdWludDI1NgoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDE2CglyZXRzdWIKCippZjM0X2VuZDoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo5MTQKCS8vIG5vbSA9IEwxICsgTDIgLSBEX1NRUlQKCWZyYW1lX2RpZyA3IC8vIEwxOiB1bnNhZmUgdWludDI1NgoJZnJhbWVfZGlnIDggLy8gTDI6IHVuc2FmZSB1aW50MjU2CgliKwoJZnJhbWVfZGlnIDEzIC8vIERfU1FSVDogdW5zYWZlIHVpbnQyNTYKCWItCglmcmFtZV9idXJ5IDE3IC8vIG5vbTogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6OTE1CgkvLyBkZW4gPSBMMyAtIDx1aW50MjU2PjIgKiBzCglmcmFtZV9kaWcgMTIgLy8gTDM6IHVuc2FmZSB1aW50MjU2CglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMgoJZnJhbWVfZGlnIDAgLy8gczogdWludDI1NgoJYioKCWItCglmcmFtZV9idXJ5IDE4IC8vIGRlbjogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6OTE2CgkvLyByZXQgPSAocyAqIG5vbSkgLyBkZW4KCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWZyYW1lX2RpZyAxNyAvLyBub206IHVuc2FmZSB1aW50MjU2CgliKgoJZnJhbWVfZGlnIDE4IC8vIGRlbjogdW5zYWZlIHVpbnQyNTYKCWIvCglmcmFtZV9idXJ5IDE5IC8vIHJldDogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6OTE3CgkvLyByZXR1cm4gcmV0OwoJZnJhbWVfZGlnIDE5IC8vIHJldDogdW5zYWZlIHVpbnQyNTYKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiAxOQoJcmV0c3ViCgovLyBjYWxjdWxhdGVQcmljZSh1aW50MjU2LHVpbnQyNTYsdWludDI1Nix1aW50MjU2LHVpbnQyNTYpdWludDI1NgoqYWJpX3JvdXRlX2NhbGN1bGF0ZVByaWNlOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBsaXF1aWRpdHk6IHVpbnQyNTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDUKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBwcmljZU1heFNxcnQ6IHVpbnQyNTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDQKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBwcmljZU1pblNxcnQ6IHVpbnQyNTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBhc3NldEJRdWFudGl0eTogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIGFzc2V0QVF1YW50aXR5OiB1aW50MjU2Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBjYWxjdWxhdGVQcmljZSh1aW50MjU2LHVpbnQyNTYsdWludDI1Nix1aW50MjU2LHVpbnQyNTYpdWludDI1NgoJY2FsbHN1YiBjYWxjdWxhdGVQcmljZQoJZHVwCgliaXRsZW4KCWludCAyNTYKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDMyCgktCglzd2FwCglzdWJzdHJpbmczCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gY2FsY3VsYXRlUHJpY2UoYXNzZXRBUXVhbnRpdHk6IHVpbnQyNTYsIGFzc2V0QlF1YW50aXR5OiB1aW50MjU2LCBwcmljZU1pblNxcnQ6IHVpbnQyNTYsIHByaWNlTWF4U3FydDogdWludDI1NiwgbGlxdWlkaXR5OiB1aW50MjU2KTogdWludDI1NgovLwovLyBHZXQgdGhlIGN1cnJlbnQgcHJpY2Ugd2hlbiBhc3NldCBhIGhhcyB4Ci8vIEBwYXJhbSBhc3NldEFRdWFudGl0eSB4Ci8vIEBwYXJhbSBhc3NldEJRdWFudGl0eSB5Ci8vIEBwYXJhbSBwcmljZU1pblNxcnQgc3FydChwcmljZU1pbikKLy8gQHBhcmFtIHByaWNlTWF4U3FydCBzcXJ0KHByaWNlTWF4KQovLyBAcGFyYW0gbGlxdWlkaXR5IEN1cnJlbnQgcG9vbCBsaXF1aWRpdHkgLSBMIHZhcmlhYmxlCi8vIEByZXR1cm5zIHRoZSBwcmljZSB3aXRoIHNwZWNpZmllZCBxdWFudGl0eSB3aXRoIHRoZSBwcmljZSByYW5nZSBzZXQgaW4gdGhlIGNvbnRyYWN0CmNhbGN1bGF0ZVByaWNlOgoJcHJvdG8gNSAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gNwoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo5NDEKCS8vIHMgPSBTQ0FMRSBhcyB1aW50MjU2CglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAzYjlhY2EwMAoJZnJhbWVfYnVyeSAwIC8vIHM6IHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6OTQyCgkvLyBhID0gcHJpY2VNaW5TcXJ0CglmcmFtZV9kaWcgLTMgLy8gcHJpY2VNaW5TcXJ0OiB1aW50MjU2CglmcmFtZV9idXJ5IDEgLy8gYTogdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo5NDMKCS8vIGIgPSBwcmljZU1heFNxcnQKCWZyYW1lX2RpZyAtNCAvLyBwcmljZU1heFNxcnQ6IHVpbnQyNTYKCWZyYW1lX2J1cnkgMiAvLyBiOiB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjk0NAoJLy8gUDEgPSAobGlxdWlkaXR5ICogYSkgLyBzCglmcmFtZV9kaWcgLTUgLy8gbGlxdWlkaXR5OiB1aW50MjU2CglmcmFtZV9kaWcgMSAvLyBhOiB1aW50MjU2CgliKgoJZnJhbWVfZGlnIDAgLy8gczogdWludDI1NgoJYi8KCWZyYW1lX2J1cnkgMyAvLyBQMTogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6OTQ1CgkvLyBQMiA9IChsaXF1aWRpdHkgKiBzKSAvIGIKCWZyYW1lX2RpZyAtNSAvLyBsaXF1aWRpdHk6IHVpbnQyNTYKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMiAvLyBiOiB1aW50MjU2CgliLwoJZnJhbWVfYnVyeSA0IC8vIFAyOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo5NDYKCS8vIE5vbSA9IGFzc2V0QlF1YW50aXR5ICsgUDEKCWZyYW1lX2RpZyAtMiAvLyBhc3NldEJRdWFudGl0eTogdWludDI1NgoJZnJhbWVfZGlnIDMgLy8gUDE6IHVuc2FmZSB1aW50MjU2CgliKwoJZnJhbWVfYnVyeSA1IC8vIE5vbTogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6OTQ3CgkvLyBEZW5vbSA9IGFzc2V0QVF1YW50aXR5ICsgUDIKCWZyYW1lX2RpZyAtMSAvLyBhc3NldEFRdWFudGl0eTogdWludDI1NgoJZnJhbWVfZGlnIDQgLy8gUDI6IHVuc2FmZSB1aW50MjU2CgliKwoJZnJhbWVfYnVyeSA2IC8vIERlbm9tOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo5NDgKCS8vIHJldCA9IChOb20gKiBzKSAvIERlbm9tCglmcmFtZV9kaWcgNSAvLyBOb206IHVuc2FmZSB1aW50MjU2CglmcmFtZV9kaWcgMCAvLyBzOiB1aW50MjU2CgliKgoJZnJhbWVfZGlnIDYgLy8gRGVub206IHVuc2FmZSB1aW50MjU2CgliLwoJZnJhbWVfYnVyeSA3IC8vIHJldDogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6OTQ5CgkvLyByZXR1cm4gcmV0OwoJZnJhbWVfZGlnIDcgLy8gcmV0OiB1bnNhZmUgdWludDI1NgoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDcKCXJldHN1YgoKLy8gY2FsY3VsYXRlQXNzZXRCV2l0aGRyYXdPbkFzc2V0QURlcG9zaXQodWludDI1Nix1aW50MjU2LHVpbnQyNTYsdWludDI1Nix1aW50MjU2LHVpbnQyNTYpdWludDI1NgoqYWJpX3JvdXRlX2NhbGN1bGF0ZUFzc2V0QldpdGhkcmF3T25Bc3NldEFEZXBvc2l0OgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBsaXF1ZGl0eTogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIHByaWNlTWF4U3FydDogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIHByaWNlTWluU3FydDogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIGFzc2V0QkJhbGFuY2U6IHVpbnQyNTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBhc3NldEFCYWxhbmNlOiB1aW50MjU2Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gaW5BbW91bnQ6IHVpbnQyNTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBleGVjdXRlIGNhbGN1bGF0ZUFzc2V0QldpdGhkcmF3T25Bc3NldEFEZXBvc2l0KHVpbnQyNTYsdWludDI1Nix1aW50MjU2LHVpbnQyNTYsdWludDI1Nix1aW50MjU2KXVpbnQyNTYKCWNhbGxzdWIgY2FsY3VsYXRlQXNzZXRCV2l0aGRyYXdPbkFzc2V0QURlcG9zaXQKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGNhbGN1bGF0ZUFzc2V0QldpdGhkcmF3T25Bc3NldEFEZXBvc2l0KGluQW1vdW50OiB1aW50MjU2LCBhc3NldEFCYWxhbmNlOiB1aW50MjU2LCBhc3NldEJCYWxhbmNlOiB1aW50MjU2LCBwcmljZU1pblNxcnQ6IHVpbnQyNTYsIHByaWNlTWF4U3FydDogdWludDI1NiwgbGlxdWRpdHk6IHVpbnQyNTYpOiB1aW50MjU2Ci8vCi8vIENhbGN1bGF0ZXMgaG93IG11Y2ggYXNzZXQgQiB3aWxsIGJlIHRha2VuIGZyb20gdGhlIHNtYXJ0IGNvbnRyYWN0IG9uIGFzc2V0IEEgZGVwb3NpdAovLyBAcGFyYW0gaW5BbW91bnQgQXNzZXQgQSBhbW91bnQgaW4gQmFzZSBkZWNpbWFsIHJlcHJlc2VudGF0aW9uLi4gSWYgYXNzZXQgaGFzIDYgZGVjaW1hbHMsIDEgaXMgcmVwcmVzZW50ZWQgYXMgMTAwMDAwMDAwMAovLyBAcGFyYW0gYXNzZXRBQmFsYW5jZSBBc3NldCBBIGJhbGFuY2UuIFZhcmlhYmxlIGFiLCBpbiBiYXNlIHNjYWxlCi8vIEBwYXJhbSBhc3NldEJCYWxhbmNlIEFzc2V0IEIgYmFsYW5jZS4gVmFyaWFibGUgYmIsIGluIGJhc2Ugc2NhbGUKLy8gQHBhcmFtIHByaWNlTWluU3FydCBzcXJ0KE1pbiBwcmljZSkuIFZhcmlhYmxlIHBNaW5TLCBpbiBiYXNlIHNjYWxlCi8vIEBwYXJhbSBwcmljZU1heFNxcnQgc3FydChNYXggcHJpY2UpLiBWYXJpYWJsZSBwTWF4UywgaW4gYmFzZSBzY2FsZQovLyBAcGFyYW0gbGlxdWRpdHkgc3FydChNYXggcHJpY2UpLiBWYXJpYWJsZSBMLCBpbiBiYXNlIHNjYWxlCi8vIEByZXR1cm5zIEFtb3VudCBvZiBhc3NldCBCIHRvIGJlIGdpdmVuIHRvIHRoZSBjYWxsZXIgYmVmb3JlIGZlZXMuIFRoZSByZXN1bHQgaXMgaW4gQmFzZSBkZWNpbWFscyAoOSkKY2FsY3VsYXRlQXNzZXRCV2l0aGRyYXdPbkFzc2V0QURlcG9zaXQ6Cglwcm90byA2IDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwbiAxMgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo5ODcKCS8vIHMgPSBTQ0FMRSBhcyB1aW50MjU2CglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAzYjlhY2EwMAoJZnJhbWVfYnVyeSAwIC8vIHM6IHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6OTg4CgkvLyB4ID0gYXNzZXRBQmFsYW5jZQoJZnJhbWVfZGlnIC0yIC8vIGFzc2V0QUJhbGFuY2U6IHVpbnQyNTYKCWZyYW1lX2J1cnkgMSAvLyB4OiB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjk4OQoJLy8geSA9IGFzc2V0QkJhbGFuY2UKCWZyYW1lX2RpZyAtMyAvLyBhc3NldEJCYWxhbmNlOiB1aW50MjU2CglmcmFtZV9idXJ5IDIgLy8geTogdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czo5OTAKCS8vIGEgPSBwcmljZU1pblNxcnQKCWZyYW1lX2RpZyAtNCAvLyBwcmljZU1pblNxcnQ6IHVpbnQyNTYKCWZyYW1lX2J1cnkgMyAvLyBhOiB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjk5MQoJLy8gYiA9IHByaWNlTWF4U3FydAoJZnJhbWVfZGlnIC01IC8vIHByaWNlTWF4U3FydDogdWludDI1NgoJZnJhbWVfYnVyeSA0IC8vIGI6IHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6OTkyCgkvLyBMID0gbGlxdWRpdHkKCWZyYW1lX2RpZyAtNiAvLyBsaXF1ZGl0eTogdWludDI1NgoJZnJhbWVfYnVyeSA1IC8vIEw6IHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6OTk0CgkvLyBQMSA9ICgoKCgoYSAvKiAxMEQgKi8gKiBiKSAvKiAxMEQgKi8gLyBzKSAqIGluQW1vdW50KSAvKiBBRCAqLyAvIHMpICogTCkgLyogMTBEICovIC8gcwoJZnJhbWVfZGlnIDMgLy8gYTogdWludDI1NgoJZnJhbWVfZGlnIDQgLy8gYjogdWludDI1NgoJYioKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIvCglmcmFtZV9kaWcgLTEgLy8gaW5BbW91bnQ6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMCAvLyBzOiB1aW50MjU2CgliLwoJZnJhbWVfZGlnIDUgLy8gTDogdWludDI1NgoJYioKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIvCglmcmFtZV9idXJ5IDYgLy8gUDE6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjk5NgoJLy8gUDIgPSAoKChiIC8qIDEwRCAqLyAqIGluQW1vdW50KSAvKiBBRCAqLyAvIHMpICogeSkgLyogQkQgKi8gLyBzCglmcmFtZV9kaWcgNCAvLyBiOiB1aW50MjU2CglmcmFtZV9kaWcgLTEgLy8gaW5BbW91bnQ6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMCAvLyBzOiB1aW50MjU2CgliLwoJZnJhbWVfZGlnIDIgLy8geTogdWludDI1NgoJYioKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIvCglmcmFtZV9idXJ5IDcgLy8gUDI6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjk5OAoJLy8gUDMgPSAoYiAvKiAxMEQgKi8gKiBpbkFtb3VudCkgLyogQUQgKi8gLyBzCglmcmFtZV9kaWcgNCAvLyBiOiB1aW50MjU2CglmcmFtZV9kaWcgLTEgLy8gaW5BbW91bnQ6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMCAvLyBzOiB1aW50MjU2CgliLwoJZnJhbWVfYnVyeSA4IC8vIFAzOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czoxMDAwCgkvLyBQNCA9IChiIC8qIDEwRCAqLyAqIHgpIC8qIDEwRCAqLyAvIHMKCWZyYW1lX2RpZyA0IC8vIGI6IHVpbnQyNTYKCWZyYW1lX2RpZyAxIC8vIHg6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMCAvLyBzOiB1aW50MjU2CgliLwoJZnJhbWVfYnVyeSA5IC8vIFA0OiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czoxMDAyCgkvLyBQMTIgPSBQMSArIFAyCglmcmFtZV9kaWcgNiAvLyBQMTogdW5zYWZlIHVpbnQyNTYKCWZyYW1lX2RpZyA3IC8vIFAyOiB1bnNhZmUgdWludDI1NgoJYisKCWZyYW1lX2J1cnkgMTAgLy8gUDEyOiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czoxMDA0CgkvLyBQMzQ1ID0gUDMgKyBQNCArIEwKCWZyYW1lX2RpZyA4IC8vIFAzOiB1bnNhZmUgdWludDI1NgoJZnJhbWVfZGlnIDkgLy8gUDQ6IHVuc2FmZSB1aW50MjU2CgliKwoJZnJhbWVfZGlnIDUgLy8gTDogdWludDI1NgoJYisKCWZyYW1lX2J1cnkgMTEgLy8gUDM0NTogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MTAwNgoJLy8gcmV0ID0gKFAxMiAqIHMpIC8gUDM0NQoJZnJhbWVfZGlnIDEwIC8vIFAxMjogdW5zYWZlIHVpbnQyNTYKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMTEgLy8gUDM0NTogdW5zYWZlIHVpbnQyNTYKCWIvCglmcmFtZV9idXJ5IDEyIC8vIHJldDogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MTAwNwoJLy8gcmV0dXJuIHJldDsKCWZyYW1lX2RpZyAxMiAvLyByZXQ6IHVuc2FmZSB1aW50MjU2CgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMTIKCXJldHN1YgoKLy8gY2FsY3VsYXRlQXNzZXRBV2l0aGRyYXdPbkFzc2V0QkRlcG9zaXQodWludDI1Nix1aW50MjU2LHVpbnQyNTYsdWludDI1Nix1aW50MjU2LHVpbnQyNTYpdWludDI1NgoqYWJpX3JvdXRlX2NhbGN1bGF0ZUFzc2V0QVdpdGhkcmF3T25Bc3NldEJEZXBvc2l0OgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBsaXF1ZGl0eTogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIHByaWNlTWF4U3FydDogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIHByaWNlTWluU3FydDogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIGFzc2V0QkJhbGFuY2U6IHVpbnQyNTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBhc3NldEFCYWxhbmNlOiB1aW50MjU2Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gaW5BbW91bnQ6IHVpbnQyNTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBleGVjdXRlIGNhbGN1bGF0ZUFzc2V0QVdpdGhkcmF3T25Bc3NldEJEZXBvc2l0KHVpbnQyNTYsdWludDI1Nix1aW50MjU2LHVpbnQyNTYsdWludDI1Nix1aW50MjU2KXVpbnQyNTYKCWNhbGxzdWIgY2FsY3VsYXRlQXNzZXRBV2l0aGRyYXdPbkFzc2V0QkRlcG9zaXQKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGNhbGN1bGF0ZUFzc2V0QVdpdGhkcmF3T25Bc3NldEJEZXBvc2l0KGluQW1vdW50OiB1aW50MjU2LCBhc3NldEFCYWxhbmNlOiB1aW50MjU2LCBhc3NldEJCYWxhbmNlOiB1aW50MjU2LCBwcmljZU1pblNxcnQ6IHVpbnQyNTYsIHByaWNlTWF4U3FydDogdWludDI1NiwgbGlxdWRpdHk6IHVpbnQyNTYpOiB1aW50MjU2Ci8vCi8vIENhbGN1bGF0ZXMgaG93IG11Y2ggYXNzZXQgQSB3aWxsIGJlIHRha2VuIGZyb20gdGhlIHNtYXJ0IGNvbnRyYWN0IG9uIGFzc2V0IEIgZGVwb3NpdAovLyBAcGFyYW0gaW5BbW91bnQgQXNzZXQgQiBhbW91bnQgaW4gQmFzZSBkZWNpbWFsIHJlcHJlc2VudGF0aW9uLi4gSWYgYXNzZXQgaGFzIDYgZGVjaW1hbHMsIDEgaXMgcmVwcmVzZW50ZWQgYXMgMTAwMDAwMDAwMAovLyBAcGFyYW0gYXNzZXRBQmFsYW5jZSBBc3NldCBBIGJhbGFuY2UuIFZhcmlhYmxlIGFiLCBpbiBiYXNlIHNjYWxlCi8vIEBwYXJhbSBhc3NldEJCYWxhbmNlIEFzc2V0IEIgYmFsYW5jZS4gVmFyaWFibGUgYmIsIGluIGJhc2Ugc2NhbGUKLy8gQHBhcmFtIHByaWNlTWluU3FydCBzcXJ0KE1pbiBwcmljZSkuIFZhcmlhYmxlIHBNaW5TLCBpbiBiYXNlIHNjYWxlCi8vIEBwYXJhbSBwcmljZU1heFNxcnQgc3FydChNYXggcHJpY2UpLiBWYXJpYWJsZSBwTWF4UywgaW4gYmFzZSBzY2FsZQovLyBAcGFyYW0gbGlxdWRpdHkgc3FydChNYXggcHJpY2UpLiBWYXJpYWJsZSBMLCBpbiBiYXNlIHNjYWxlCi8vCi8vIEByZXR1cm5zIEFtb3VudCBvZiBhc3NldCBBIHRvIGJlIGdpdmVuIHRvIHRoZSBjYWxsZXIgYmVmb3JlIGZlZXMuIFRoZSByZXN1bHQgaXMgaW4gQmFzZSBkZWNpbWFscyAoOSkKY2FsY3VsYXRlQXNzZXRBV2l0aGRyYXdPbkFzc2V0QkRlcG9zaXQ6Cglwcm90byA2IDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwbiAxMwoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czoxMDQyCgkvLyBzID0gU0NBTEUgYXMgdWludDI1NgoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwM2I5YWNhMDAKCWZyYW1lX2J1cnkgMCAvLyBzOiB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjEwNDMKCS8vIHggPSBhc3NldEFCYWxhbmNlCglmcmFtZV9kaWcgLTIgLy8gYXNzZXRBQmFsYW5jZTogdWludDI1NgoJZnJhbWVfYnVyeSAxIC8vIHg6IHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MTA0NAoJLy8geSA9IGFzc2V0QkJhbGFuY2UKCWZyYW1lX2RpZyAtMyAvLyBhc3NldEJCYWxhbmNlOiB1aW50MjU2CglmcmFtZV9idXJ5IDIgLy8geTogdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czoxMDQ1CgkvLyBhID0gcHJpY2VNaW5TcXJ0CglmcmFtZV9kaWcgLTQgLy8gcHJpY2VNaW5TcXJ0OiB1aW50MjU2CglmcmFtZV9idXJ5IDMgLy8gYTogdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czoxMDQ2CgkvLyBiID0gcHJpY2VNYXhTcXJ0CglmcmFtZV9kaWcgLTUgLy8gcHJpY2VNYXhTcXJ0OiB1aW50MjU2CglmcmFtZV9idXJ5IDQgLy8gYjogdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czoxMDQ3CgkvLyBMID0gbGlxdWRpdHkKCWZyYW1lX2RpZyAtNiAvLyBsaXF1ZGl0eTogdWludDI1NgoJZnJhbWVfYnVyeSA1IC8vIEw6IHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MTA1MAoJLy8gUDEgPSAoaW5BbW91bnQgKiBMKSAvIHMKCWZyYW1lX2RpZyAtMSAvLyBpbkFtb3VudDogdWludDI1NgoJZnJhbWVfZGlnIDUgLy8gTDogdWludDI1NgoJYioKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIvCglmcmFtZV9idXJ5IDYgLy8gUDE6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjEwNTIKCS8vIFAyID0gKCgoYiAqIGluQW1vdW50KSAvIHMpICogeCkgLyBzCglmcmFtZV9kaWcgNCAvLyBiOiB1aW50MjU2CglmcmFtZV9kaWcgLTEgLy8gaW5BbW91bnQ6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMCAvLyBzOiB1aW50MjU2CgliLwoJZnJhbWVfZGlnIDEgLy8geDogdWludDI1NgoJYioKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIvCglmcmFtZV9idXJ5IDcgLy8gUDI6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjEwNTQKCS8vIG5vbSA9IFAxICsgUDIKCWZyYW1lX2RpZyA2IC8vIFAxOiB1bnNhZmUgdWludDI1NgoJZnJhbWVfZGlnIDcgLy8gUDI6IHVuc2FmZSB1aW50MjU2CgliKwoJZnJhbWVfYnVyeSA4IC8vIG5vbTogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MTA1NgoJLy8gUDMgPSAoKChhICogYikgLyBzKSAqIEwpIC8gcwoJZnJhbWVfZGlnIDMgLy8gYTogdWludDI1NgoJZnJhbWVfZGlnIDQgLy8gYjogdWludDI1NgoJYioKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIvCglmcmFtZV9kaWcgNSAvLyBMOiB1aW50MjU2CgliKgoJZnJhbWVfZGlnIDAgLy8gczogdWludDI1NgoJYi8KCWZyYW1lX2J1cnkgOSAvLyBQMzogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MTA1OAoJLy8gUDQgPSAoYiAqIGluQW1vdW50KSAvIHMKCWZyYW1lX2RpZyA0IC8vIGI6IHVpbnQyNTYKCWZyYW1lX2RpZyAtMSAvLyBpbkFtb3VudDogdWludDI1NgoJYioKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIvCglmcmFtZV9idXJ5IDEwIC8vIFA0OiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czoxMDYwCgkvLyBQNSA9IChiICogeSkgLyBzCglmcmFtZV9kaWcgNCAvLyBiOiB1aW50MjU2CglmcmFtZV9kaWcgMiAvLyB5OiB1aW50MjU2CgliKgoJZnJhbWVfZGlnIDAgLy8gczogdWludDI1NgoJYi8KCWZyYW1lX2J1cnkgMTEgLy8gUDU6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjEwNjIKCS8vIGRlbm9tID0gUDMgKyBQNCArIFA1CglmcmFtZV9kaWcgOSAvLyBQMzogdW5zYWZlIHVpbnQyNTYKCWZyYW1lX2RpZyAxMCAvLyBQNDogdW5zYWZlIHVpbnQyNTYKCWIrCglmcmFtZV9kaWcgMTEgLy8gUDU6IHVuc2FmZSB1aW50MjU2CgliKwoJZnJhbWVfYnVyeSAxMiAvLyBkZW5vbTogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MTA2NAoJLy8gcmV0ID0gKG5vbSAqIHMpIC8gZGVub20KCWZyYW1lX2RpZyA4IC8vIG5vbTogdW5zYWZlIHVpbnQyNTYKCWZyYW1lX2RpZyAwIC8vIHM6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgMTIgLy8gZGVub206IHVuc2FmZSB1aW50MjU2CgliLwoJZnJhbWVfYnVyeSAxMyAvLyByZXQ6IHVuc2FmZSB1aW50MjU2CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjEwNjUKCS8vIHJldHVybiByZXQ7CglmcmFtZV9kaWcgMTMgLy8gcmV0OiB1bnNhZmUgdWludDI1NgoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDEzCglyZXRzdWIKCi8vIGNhbGN1bGF0ZUFzc2V0QVdpdGhkcmF3T25McERlcG9zaXQodWludDI1Nix1aW50MjU2LHVpbnQyNTYpdWludDI1NgoqYWJpX3JvdXRlX2NhbGN1bGF0ZUFzc2V0QVdpdGhkcmF3T25McERlcG9zaXQ6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIGxpcXVkaXR5OiB1aW50MjU2Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gYXNzZXRBQmFsYW5jZTogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIGluQW1vdW50OiB1aW50MjU2Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBjYWxjdWxhdGVBc3NldEFXaXRoZHJhd09uTHBEZXBvc2l0KHVpbnQyNTYsdWludDI1Nix1aW50MjU2KXVpbnQyNTYKCWNhbGxzdWIgY2FsY3VsYXRlQXNzZXRBV2l0aGRyYXdPbkxwRGVwb3NpdAoJZHVwCgliaXRsZW4KCWludCAyNTYKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDMyCgktCglzd2FwCglzdWJzdHJpbmczCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gY2FsY3VsYXRlQXNzZXRBV2l0aGRyYXdPbkxwRGVwb3NpdChpbkFtb3VudDogdWludDI1NiwgYXNzZXRBQmFsYW5jZTogdWludDI1NiwgbGlxdWRpdHk6IHVpbnQyNTYpOiB1aW50MjU2Ci8vCi8vIENhbGN1bGF0ZXMgaG93IG11Y2ggYXNzZXQgQSB3aWxsIGJlIHRha2VuIGZyb20gdGhlIHNtYXJ0IGNvbnRyYWN0IG9uIExQIGFzc2V0IGRlcG9zaXQKLy8gQHBhcmFtIGluQW1vdW50IExQIEFzc2V0IGFtb3VudCBpbiBCYXNlIGRlY2ltYWwgcmVwcmVzZW50YXRpb24uLgovLyBAcGFyYW0gYXNzZXRBQmFsYW5jZSBBc3NldCBBIGJhbGFuY2UuIFZhcmlhYmxlIGFiLCBpbiBiYXNlIHNjYWxlCi8vIEBwYXJhbSBsaXF1ZGl0eSBDdXJyZW50IGxpcXVkaXR5LiBWYXJpYWJsZSBMLCBpbiBiYXNlIHNjYWxlCi8vCi8vIEByZXR1cm5zIEFtb3VudCBvZiBhc3NldCBBIHRvIGJlIGdpdmVuIHRvIHRoZSBjYWxsZXIgYmVmb3JlIGZlZXMuIFRoZSByZXN1bHQgaXMgaW4gQmFzZSBkZWNpbWFscyAoOSkKY2FsY3VsYXRlQXNzZXRBV2l0aGRyYXdPbkxwRGVwb3NpdDoKCXByb3RvIDMgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjEwODEKCS8vIHJldCA9IChhc3NldEFCYWxhbmNlICogaW5BbW91bnQpIC8gbGlxdWRpdHkKCWZyYW1lX2RpZyAtMiAvLyBhc3NldEFCYWxhbmNlOiB1aW50MjU2CglmcmFtZV9kaWcgLTEgLy8gaW5BbW91bnQ6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgLTMgLy8gbGlxdWRpdHk6IHVpbnQyNTYKCWIvCglmcmFtZV9idXJ5IDAgLy8gcmV0OiB1bnNhZmUgdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czoxMDgyCgkvLyByZXR1cm4gcmV0OwoJZnJhbWVfZGlnIDAgLy8gcmV0OiB1bnNhZmUgdWludDI1NgoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoJcmV0c3ViCgovLyBjYWxjdWxhdGVBc3NldEJXaXRoZHJhd09uTHBEZXBvc2l0KHVpbnQyNTYsdWludDI1Nix1aW50MjU2KXVpbnQyNTYKKmFiaV9yb3V0ZV9jYWxjdWxhdGVBc3NldEJXaXRoZHJhd09uTHBEZXBvc2l0OgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBsaXF1ZGl0eTogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIGFzc2V0QkJhbGFuY2U6IHVpbnQyNTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBpbkFtb3VudDogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIGV4ZWN1dGUgY2FsY3VsYXRlQXNzZXRCV2l0aGRyYXdPbkxwRGVwb3NpdCh1aW50MjU2LHVpbnQyNTYsdWludDI1Nil1aW50MjU2CgljYWxsc3ViIGNhbGN1bGF0ZUFzc2V0QldpdGhkcmF3T25McERlcG9zaXQKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGNhbGN1bGF0ZUFzc2V0QldpdGhkcmF3T25McERlcG9zaXQoaW5BbW91bnQ6IHVpbnQyNTYsIGFzc2V0QkJhbGFuY2U6IHVpbnQyNTYsIGxpcXVkaXR5OiB1aW50MjU2KTogdWludDI1NgovLwovLyBDYWxjdWxhdGVzIGhvdyBtdWNoIGFzc2V0IEIgd2lsbCBiZSB0YWtlbiBmcm9tIHRoZSBzbWFydCBjb250cmFjdCBvbiBMUCBhc3NldCBkZXBvc2l0Ci8vIEBwYXJhbSBpbkFtb3VudCBMUCBBc3NldCBhbW91bnQgaW4gQmFzZSBkZWNpbWFsIHJlcHJlc2VudGF0aW9uLi4KLy8gQHBhcmFtIGFzc2V0QkJhbGFuY2UgQXNzZXQgQiBiYWxhbmNlLiBWYXJpYWJsZSBhYiwgaW4gYmFzZSBzY2FsZQovLyBAcGFyYW0gbGlxdWRpdHkgQ3VycmVudCBsaXF1ZGl0eS4gVmFyaWFibGUgTCwgaW4gYmFzZSBzY2FsZQovLwovLyBAcmV0dXJucyBBbW91bnQgb2YgYXNzZXQgQiB0byBiZSBnaXZlbiB0byB0aGUgY2FsbGVyIGJlZm9yZSBmZWVzLiBUaGUgcmVzdWx0IGlzIGluIEJhc2UgZGVjaW1hbHMgKDkpCmNhbGN1bGF0ZUFzc2V0QldpdGhkcmF3T25McERlcG9zaXQ6Cglwcm90byAzIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czoxMDk4CgkvLyByZXQgPSAoYXNzZXRCQmFsYW5jZSAqIGluQW1vdW50KSAvIGxpcXVkaXR5CglmcmFtZV9kaWcgLTIgLy8gYXNzZXRCQmFsYW5jZTogdWludDI1NgoJZnJhbWVfZGlnIC0xIC8vIGluQW1vdW50OiB1aW50MjU2CgliKgoJZnJhbWVfZGlnIC0zIC8vIGxpcXVkaXR5OiB1aW50MjU2CgliLwoJZnJhbWVfYnVyeSAwIC8vIHJldDogdW5zYWZlIHVpbnQyNTYKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MTA5OQoJLy8gcmV0dXJuIHJldDsKCWZyYW1lX2RpZyAwIC8vIHJldDogdW5zYWZlIHVpbnQyNTYKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCXJldHN1YgoKLy8gY2FsY3VsYXRlQXNzZXRCRGVwb3NpdE9uQXNzZXRBRGVwb3NpdCh1aW50MjU2LHVpbnQyNTYsdWludDI1Nix1aW50MjU2KXVpbnQyNTYKKmFiaV9yb3V0ZV9jYWxjdWxhdGVBc3NldEJEZXBvc2l0T25Bc3NldEFEZXBvc2l0OgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBhc3NldEJCYWxhbmNlOiB1aW50MjU2Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA0CglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gYXNzZXRBQmFsYW5jZTogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIGluQW1vdW50QjogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIGluQW1vdW50QTogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIGV4ZWN1dGUgY2FsY3VsYXRlQXNzZXRCRGVwb3NpdE9uQXNzZXRBRGVwb3NpdCh1aW50MjU2LHVpbnQyNTYsdWludDI1Nix1aW50MjU2KXVpbnQyNTYKCWNhbGxzdWIgY2FsY3VsYXRlQXNzZXRCRGVwb3NpdE9uQXNzZXRBRGVwb3NpdAoJZHVwCgliaXRsZW4KCWludCAyNTYKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDMyCgktCglzd2FwCglzdWJzdHJpbmczCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gY2FsY3VsYXRlQXNzZXRCRGVwb3NpdE9uQXNzZXRBRGVwb3NpdChpbkFtb3VudEE6IHVpbnQyNTYsIGluQW1vdW50QjogdWludDI1NiwgYXNzZXRBQmFsYW5jZTogdWludDI1NiwgYXNzZXRCQmFsYW5jZTogdWludDI1Nik6IHVpbnQyNTYKLy8KLy8gQ2FsY3VsYXRlcyBob3cgbXVjaCBhc3NldCBCIHNob3VsZCBiZSBkZXBvc2l0ZWQgd2hlbiB1c2VyIGRlcG9zaXQgYXNzZXQgYSBhbmQgYi4KLy8KLy8gT24gZGVwb3NpdCBtaW4oY2FsY3VsYXRlQXNzZXRCRGVwb3NpdE9uQXNzZXRBRGVwb3NpdCwgY2FsY3VsYXRlQXNzZXRBRGVwb3NpdE9uQXNzZXRCRGVwb3NpdCkgc2hvdWxkIGJlIGNvbnNpZGVyZWQgZm9yIHRoZSByZWFsIGRlcG9zaXQgYW5kIHJlc3Qgc2hvdWxkIGJlIHN3YXBwZWQgb3IgcmV0dXJuZWQgYmFjayB0byB1c2VyCi8vCi8vIEBwYXJhbSBpbkFtb3VudEEgQXNzZXQgQSBhbW91bnQgaW4gQmFzZSBkZWNpbWFsIHJlcHJlc2VudGF0aW9uCi8vIEBwYXJhbSBpbkFtb3VudEIgQXNzZXQgQiBhbW91bnQgaW4gQmFzZSBkZWNpbWFsIHJlcHJlc2VudGF0aW9uCi8vIEBwYXJhbSBhc3NldEFCYWxhbmNlIEFzc2V0IEEgYmFsYW5jZS4gVmFyaWFibGUgYWIsIGluIGJhc2Ugc2NhbGUKLy8gQHBhcmFtIGFzc2V0QkJhbGFuY2UgQXNzZXQgQiBiYWxhbmNlLiBWYXJpYWJsZSBiYiwgaW4gYmFzZSBzY2FsZQovLwovLyBAcmV0dXJucyBBbW91bnQgb2YgYXNzZXQgQiB0byBiZSBnaXZlbiB0byB0aGUgY2FsbGVyIGJlZm9yZSBmZWVzLiBUaGUgcmVzdWx0IGlzIGluIEJhc2UgZGVjaW1hbHMgKDkpCmNhbGN1bGF0ZUFzc2V0QkRlcG9zaXRPbkFzc2V0QURlcG9zaXQ6Cglwcm90byA0IDEKCgkvLyAqaWYzNV9jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czoxMTIxCgkvLyBhc3NldEFCYWxhbmNlID4gPHVpbnQyNTY+MAoJZnJhbWVfZGlnIC0zIC8vIGFzc2V0QUJhbGFuY2U6IHVpbnQyNTYKCWJ5dGUgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwCgliPgoJYnogKmlmMzVfZW5kCgoJLy8gKmlmMzVfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjExMjIKCS8vIHJldHVybiAoaW5BbW91bnRBICogYXNzZXRCQmFsYW5jZSkgLyBhc3NldEFCYWxhbmNlOwoJZnJhbWVfZGlnIC0xIC8vIGluQW1vdW50QTogdWludDI1NgoJZnJhbWVfZGlnIC00IC8vIGFzc2V0QkJhbGFuY2U6IHVpbnQyNTYKCWIqCglmcmFtZV9kaWcgLTMgLy8gYXNzZXRBQmFsYW5jZTogdWludDI1NgoJYi8KCXJldHN1YgoKKmlmMzVfZW5kOgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjExMjUKCS8vIHJldHVybiBpbkFtb3VudEI7CglmcmFtZV9kaWcgLTIgLy8gaW5BbW91bnRCOiB1aW50MjU2CglyZXRzdWIKCi8vIGNhbGN1bGF0ZUFzc2V0QURlcG9zaXRPbkFzc2V0QkRlcG9zaXQodWludDI1Nix1aW50MjU2LHVpbnQyNTYsdWludDI1Nil1aW50MjU2CiphYmlfcm91dGVfY2FsY3VsYXRlQXNzZXRBRGVwb3NpdE9uQXNzZXRCRGVwb3NpdDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gYXNzZXRCQmFsYW5jZTogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIGFzc2V0QUJhbGFuY2U6IHVpbnQyNTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBpbkFtb3VudEI6IHVpbnQyNTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBpbkFtb3VudEE6IHVpbnQyNTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBleGVjdXRlIGNhbGN1bGF0ZUFzc2V0QURlcG9zaXRPbkFzc2V0QkRlcG9zaXQodWludDI1Nix1aW50MjU2LHVpbnQyNTYsdWludDI1Nil1aW50MjU2CgljYWxsc3ViIGNhbGN1bGF0ZUFzc2V0QURlcG9zaXRPbkFzc2V0QkRlcG9zaXQKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGNhbGN1bGF0ZUFzc2V0QURlcG9zaXRPbkFzc2V0QkRlcG9zaXQoaW5BbW91bnRBOiB1aW50MjU2LCBpbkFtb3VudEI6IHVpbnQyNTYsIGFzc2V0QUJhbGFuY2U6IHVpbnQyNTYsIGFzc2V0QkJhbGFuY2U6IHVpbnQyNTYpOiB1aW50MjU2Ci8vCi8vIENhbGN1bGF0ZXMgaG93IG11Y2ggYXNzZXQgQSBzaG91bGQgYmUgZGVwb3NpdGVkIHdoZW4gdXNlciBkZXBvc2l0IGFzc2V0IGEgYW5kIGIKLy8KLy8gT24gZGVwb3NpdCBtaW4oY2FsY3VsYXRlQXNzZXRCRGVwb3NpdE9uQXNzZXRBRGVwb3NpdCwgY2FsY3VsYXRlQXNzZXRBRGVwb3NpdE9uQXNzZXRCRGVwb3NpdCkgc2hvdWxkIGJlIGNvbnNpZGVyZWQgZm9yIHRoZSByZWFsIGRlcG9zaXQgYW5kIHJlc3Qgc2hvdWxkIGJlIHN3YXBwZWQgb3IgcmV0dXJuZWQgYmFjayB0byB1c2VyCi8vCi8vIEBwYXJhbSBpbkFtb3VudEEgQXNzZXQgQSBhbW91bnQgaW4gQmFzZSBkZWNpbWFsIHJlcHJlc2VudGF0aW9uCi8vIEBwYXJhbSBpbkFtb3VudEIgQXNzZXQgQiBhbW91bnQgaW4gQmFzZSBkZWNpbWFsIHJlcHJlc2VudGF0aW9uCi8vIEBwYXJhbSBhc3NldEFCYWxhbmNlIEFzc2V0IEEgYmFsYW5jZS4gVmFyaWFibGUgYWIsIGluIGJhc2Ugc2NhbGUKLy8gQHBhcmFtIGFzc2V0QkJhbGFuY2UgQXNzZXQgQiBiYWxhbmNlLiBWYXJpYWJsZSBiYiwgaW4gYmFzZSBzY2FsZQovLwovLyBAcmV0dXJucyBBbW91bnQgb2YgYXNzZXQgQSB0byBiZSBkZXBvc2l0ZWQuIFRoZSByZXN1bHQgaXMgaW4gQmFzZSBkZWNpbWFscyAoOSkKY2FsY3VsYXRlQXNzZXRBRGVwb3NpdE9uQXNzZXRCRGVwb3NpdDoKCXByb3RvIDQgMQoKCS8vICppZjM2X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjExNDcKCS8vIGFzc2V0QkJhbGFuY2UgPiA8dWludDI1Nj4wCglmcmFtZV9kaWcgLTQgLy8gYXNzZXRCQmFsYW5jZTogdWludDI1NgoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKCWI+CglieiAqaWYzNl9lbmQKCgkvLyAqaWYzNl9jb25zZXF1ZW50CgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MTE0OAoJLy8gcmV0dXJuIChpbkFtb3VudEIgKiBhc3NldEFCYWxhbmNlKSAvIGFzc2V0QkJhbGFuY2U7CglmcmFtZV9kaWcgLTIgLy8gaW5BbW91bnRCOiB1aW50MjU2CglmcmFtZV9kaWcgLTMgLy8gYXNzZXRBQmFsYW5jZTogdWludDI1NgoJYioKCWZyYW1lX2RpZyAtNCAvLyBhc3NldEJCYWxhbmNlOiB1aW50MjU2CgliLwoJcmV0c3ViCgoqaWYzNl9lbmQ6CgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MTE1MQoJLy8gcmV0dXJuIGluQW1vdW50QTsKCWZyYW1lX2RpZyAtMSAvLyBpbkFtb3VudEE6IHVpbnQyNTYKCXJldHN1YgoKLy8gc3RhdHVzKHVpbnQ2NCx1aW50NjQpKHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKKmFiaV9yb3V0ZV9zdGF0dXM6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIGFzc2V0TFA6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIGFwcEJpYXRlY0NvbmZpZ1Byb3ZpZGVyOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIHN0YXR1cyh1aW50NjQsdWludDY0KSh1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCgljYWxsc3ViIHN0YXR1cwoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIHN0YXR1cyhhcHBCaWF0ZWNDb25maWdQcm92aWRlcjogQXBwSUQsIGFzc2V0TFA6IEFzc2V0SUQpOiBBbW1TdGF0dXMKc3RhdHVzOgoJcHJvdG8gMiAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MTE1NgoJLy8gYXNzZXJ0KAoJLy8gICAgICAgYXBwQmlhdGVjQ29uZmlnUHJvdmlkZXIgPT09IHRoaXMuYXBwQmlhdGVjQ29uZmlnUHJvdmlkZXIudmFsdWUsCgkvLyAgICAgICAnYXBwQmlhdGVjQ29uZmlnUHJvdmlkZXIgbXVzdCBtYXRjaCB0byB0aGUgZ2xvYmFsIHZhcmlhYmxlIGFwcCBpZCcKCS8vICAgICApCglmcmFtZV9kaWcgLTEgLy8gYXBwQmlhdGVjQ29uZmlnUHJvdmlkZXI6IEFwcElECglieXRlIDB4NDIgLy8gIkIiCglhcHBfZ2xvYmFsX2dldAoJPT0KCgkvLyBhcHBCaWF0ZWNDb25maWdQcm92aWRlciBtdXN0IG1hdGNoIHRvIHRoZSBnbG9iYWwgdmFyaWFibGUgYXBwIGlkCglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjQ2xhbW1Qb29sLmFsZ28udHM6MTE2MAoJLy8gYXNzZXJ0KHRoaXMuYXNzZXRMUC52YWx1ZSA9PT0gYXNzZXRMUC5pZCwgJ0xQIGFzc2V0IGRvZXMgbm90IG1hdGNoJykKCWJ5dGUgMHg2YzcwIC8vICJscCIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9kaWcgLTIgLy8gYXNzZXRMUDogQXNzZXRJRAoJPT0KCgkvLyBMUCBhc3NldCBkb2VzIG5vdCBtYXRjaAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY0NsYW1tUG9vbC5hbGdvLnRzOjExNjEKCS8vIGJpYXRlY0ZlZSA9IHRoaXMuYXBwQmlhdGVjQ29uZmlnUHJvdmlkZXIudmFsdWUuZ2xvYmFsU3RhdGUoJ2YnKSBhcyB1aW50MjU2CglieXRlIDB4NDIgLy8gIkIiCglhcHBfZ2xvYmFsX2dldAoJYnl0ZSAweDY2IC8vICJmIgoJYXBwX2dsb2JhbF9nZXRfZXgKCWFzc2VydAoJZnJhbWVfYnVyeSAwIC8vIGJpYXRlY0ZlZTogdWludDI1NgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNDbGFtbVBvb2wuYWxnby50czoxMTYzCgkvLyByZXR1cm4gewoJLy8gICAgICAgYXNzZXRBOiB0aGlzLmFzc2V0QS52YWx1ZSwKCS8vICAgICAgIGFzc2V0QjogdGhpcy5hc3NldEIudmFsdWUsCgkvLyAgICAgICBwb29sVG9rZW46IHRoaXMuYXNzZXRMUC52YWx1ZSwKCS8vICAgICAgIGFzc2V0QUJhbGFuY2U6IHRoaXMuYXNzZXRBQmFsYW5jZS52YWx1ZSBhcyB1aW50NjQsCgkvLyAgICAgICBhc3NldEJCYWxhbmNlOiB0aGlzLmFzc2V0QkJhbGFuY2UudmFsdWUgYXMgdWludDY0LAoJLy8gICAgICAgZmVlOiB0aGlzLmZlZS52YWx1ZSwKCS8vICAgICAgIGJpYXRlY0ZlZTogYmlhdGVjRmVlIGFzIHVpbnQ2NCwKCS8vICAgICAgIGN1cnJlbnRMaXF1ZGl0eTogdGhpcy5MaXF1ZGl0eS52YWx1ZSBhcyB1aW50NjQsCgkvLyAgICAgICBsaXF1ZGl0eUJpYXRlY0Zyb21GZWVzOiB0aGlzLkxpcXVkaXR5QmlhdGVjRnJvbUZlZXMudmFsdWUgYXMgdWludDY0LAoJLy8gICAgICAgbGlxdWRpdHlVc2Vyc0Zyb21GZWVzOiB0aGlzLkxpcXVkaXR5VXNlcnNGcm9tRmVlcy52YWx1ZSBhcyB1aW50NjQsCgkvLyAgICAgICBwcmljZTogdGhpcy5yYXRpby52YWx1ZSBhcyB1aW50NjQsCgkvLyAgICAgICBwcmljZU1heFNxcnQ6IHRoaXMucHJpY2VNYXhTcXJ0LnZhbHVlIGFzIHVpbnQ2NCwKCS8vICAgICAgIHByaWNlTWluU3FydDogdGhpcy5wcmljZU1pblNxcnQudmFsdWUgYXMgdWludDY0LAoJLy8gICAgICAgcmVsZWFzZWRMaXF1ZGl0eTogdGhpcy5jYWxjdWxhdGVEaXN0cmlidXRlZExpcXVpZGl0eShhc3NldExQLCA8dWludDI1Nj4wKSBhcyB1aW50NjQsCgkvLyAgICAgICBzY2FsZTogU0NBTEUsCgkvLyAgICAgICB2ZXJpZmljYXRpb25DbGFzczogdGhpcy52ZXJpZmljYXRpb25DbGFzcy52YWx1ZSwKCS8vICAgICB9OwoJYnl0ZSAweDAwMDAwMDAwM2I5YWNhMDAKCWJ5dGUgMHg2MTYyIC8vICJhYiIKCWFwcF9nbG9iYWxfZ2V0CglkdXAKCWJpdGxlbgoJaW50IDY0Cgk8PQoJYXNzZXJ0CglleHRyYWN0IDI0IDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJYnl0ZSAweDYyNjIgLy8gImJiIgoJYXBwX2dsb2JhbF9nZXQKCWR1cAoJYml0bGVuCglpbnQgNjQKCTw9Cglhc3NlcnQKCWV4dHJhY3QgMjQgOAoJYnRvaQoJaXRvYgoJY29uY2F0CglieXRlIDB4NzA0ZDY5NmU1MyAvLyAicE1pblMiCglhcHBfZ2xvYmFsX2dldAoJZHVwCgliaXRsZW4KCWludCA2NAoJPD0KCWFzc2VydAoJZXh0cmFjdCAyNCA4CglidG9pCglpdG9iCgljb25jYXQKCWJ5dGUgMHg3MDRkNjE3ODUzIC8vICJwTWF4UyIKCWFwcF9nbG9iYWxfZ2V0CglkdXAKCWJpdGxlbgoJaW50IDY0Cgk8PQoJYXNzZXJ0CglleHRyYWN0IDI0IDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJYnl0ZSAweDRjIC8vICJMIgoJYXBwX2dsb2JhbF9nZXQKCWR1cAoJYml0bGVuCglpbnQgNjQKCTw9Cglhc3NlcnQKCWV4dHJhY3QgMjQgOAoJYnRvaQoJaXRvYgoJY29uY2F0CglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAoJZnJhbWVfZGlnIC0yIC8vIGFzc2V0TFA6IEFzc2V0SUQKCWNhbGxzdWIgY2FsY3VsYXRlRGlzdHJpYnV0ZWRMaXF1aWRpdHkKCWR1cAoJYml0bGVuCglpbnQgNjQKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDgKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJYnl0ZSAweDRjNzUgLy8gIkx1IgoJYXBwX2dsb2JhbF9nZXQKCWR1cAoJYml0bGVuCglpbnQgNjQKCTw9Cglhc3NlcnQKCWV4dHJhY3QgMjQgOAoJYnRvaQoJaXRvYgoJY29uY2F0CglieXRlIDB4NGM2MiAvLyAiTGIiCglhcHBfZ2xvYmFsX2dldAoJZHVwCgliaXRsZW4KCWludCA2NAoJPD0KCWFzc2VydAoJZXh0cmFjdCAyNCA4CglidG9pCglpdG9iCgljb25jYXQKCWJ5dGUgMHg2MSAvLyAiYSIKCWFwcF9nbG9iYWxfZ2V0CglpdG9iCgljb25jYXQKCWJ5dGUgMHg2MiAvLyAiYiIKCWFwcF9nbG9iYWxfZ2V0CglpdG9iCgljb25jYXQKCWJ5dGUgMHg2YzcwIC8vICJscCIKCWFwcF9nbG9iYWxfZ2V0CglpdG9iCgljb25jYXQKCWJ5dGUgMHg3MiAvLyAiciIKCWFwcF9nbG9iYWxfZ2V0CglpdG9iCgljb25jYXQKCWJ5dGUgMHg2NiAvLyAiZiIKCWFwcF9nbG9iYWxfZ2V0CglpdG9iCgljb25jYXQKCWZyYW1lX2RpZyAwIC8vIGJpYXRlY0ZlZTogdWludDI1NgoJZHVwCgliaXRsZW4KCWludCA2NAoJPD0KCWFzc2VydAoJZXh0cmFjdCAyNCA4CglidG9pCglpdG9iCgljb25jYXQKCWJ5dGUgMHg2MyAvLyAiYyIKCWFwcF9nbG9iYWxfZ2V0CglpdG9iCgljb25jYXQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCXJldHN1YgoKKmNyZWF0ZV9Ob09wOgoJbWV0aG9kICJjcmVhdGVBcHBsaWNhdGlvbigpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb24KCWVycgoKKmNhbGxfTm9PcDoKCW1ldGhvZCAiZ2V0Q3VycmVudFByaWNlKCl1aW50NjQiCgltZXRob2QgImdldFByaWNlRGl2aWRlcigpdWludDY0IgoJbWV0aG9kICJnZXRMUFRva2VuSWQoKXVpbnQ2NCIKCW1ldGhvZCAiYm9vdHN0cmFwKHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCxwYXksdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ4KXVpbnQ2NCIKCW1ldGhvZCAiYWRkTGlxdWlkaXR5KHVpbnQ2NCx1aW50NjQsdHhuLHR4bix1aW50NjQsdWludDY0LHVpbnQ2NCl1aW50NjQiCgltZXRob2QgInJlbW92ZUxpcXVpZGl0eShheGZlcix1aW50NjQsdWludDY0LHVpbnQ2NCl1aW50MjU2IgoJbWV0aG9kICJzd2FwKHVpbnQ2NCx1aW50NjQsdHhuLHVpbnQ2NCx1aW50NjQsdWludDY0KXVpbnQyNTYiCgltZXRob2QgImNhbGN1bGF0ZURpc3RyaWJ1dGVkTGlxdWlkaXR5KHVpbnQ2NCx1aW50MjU2KXVpbnQyNTYiCgltZXRob2QgImNhbGN1bGF0ZUxpcXVpZGl0eSh1aW50MjU2LHVpbnQyNTYsdWludDI1Nix1aW50MjU2LHVpbnQyNTYsdWludDI1Nil1aW50MjU2IgoJbWV0aG9kICJjYWxjdWxhdGVQcmljZSh1aW50MjU2LHVpbnQyNTYsdWludDI1Nix1aW50MjU2LHVpbnQyNTYpdWludDI1NiIKCW1ldGhvZCAiY2FsY3VsYXRlQXNzZXRCV2l0aGRyYXdPbkFzc2V0QURlcG9zaXQodWludDI1Nix1aW50MjU2LHVpbnQyNTYsdWludDI1Nix1aW50MjU2LHVpbnQyNTYpdWludDI1NiIKCW1ldGhvZCAiY2FsY3VsYXRlQXNzZXRBV2l0aGRyYXdPbkFzc2V0QkRlcG9zaXQodWludDI1Nix1aW50MjU2LHVpbnQyNTYsdWludDI1Nix1aW50MjU2LHVpbnQyNTYpdWludDI1NiIKCW1ldGhvZCAiY2FsY3VsYXRlQXNzZXRBV2l0aGRyYXdPbkxwRGVwb3NpdCh1aW50MjU2LHVpbnQyNTYsdWludDI1Nil1aW50MjU2IgoJbWV0aG9kICJjYWxjdWxhdGVBc3NldEJXaXRoZHJhd09uTHBEZXBvc2l0KHVpbnQyNTYsdWludDI1Nix1aW50MjU2KXVpbnQyNTYiCgltZXRob2QgImNhbGN1bGF0ZUFzc2V0QkRlcG9zaXRPbkFzc2V0QURlcG9zaXQodWludDI1Nix1aW50MjU2LHVpbnQyNTYsdWludDI1Nil1aW50MjU2IgoJbWV0aG9kICJjYWxjdWxhdGVBc3NldEFEZXBvc2l0T25Bc3NldEJEZXBvc2l0KHVpbnQyNTYsdWludDI1Nix1aW50MjU2LHVpbnQyNTYpdWludDI1NiIKCW1ldGhvZCAic3RhdHVzKHVpbnQ2NCx1aW50NjQpKHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCAqYWJpX3JvdXRlX2dldEN1cnJlbnRQcmljZSAqYWJpX3JvdXRlX2dldFByaWNlRGl2aWRlciAqYWJpX3JvdXRlX2dldExQVG9rZW5JZCAqYWJpX3JvdXRlX2Jvb3RzdHJhcCAqYWJpX3JvdXRlX2FkZExpcXVpZGl0eSAqYWJpX3JvdXRlX3JlbW92ZUxpcXVpZGl0eSAqYWJpX3JvdXRlX3N3YXAgKmFiaV9yb3V0ZV9jYWxjdWxhdGVEaXN0cmlidXRlZExpcXVpZGl0eSAqYWJpX3JvdXRlX2NhbGN1bGF0ZUxpcXVpZGl0eSAqYWJpX3JvdXRlX2NhbGN1bGF0ZVByaWNlICphYmlfcm91dGVfY2FsY3VsYXRlQXNzZXRCV2l0aGRyYXdPbkFzc2V0QURlcG9zaXQgKmFiaV9yb3V0ZV9jYWxjdWxhdGVBc3NldEFXaXRoZHJhd09uQXNzZXRCRGVwb3NpdCAqYWJpX3JvdXRlX2NhbGN1bGF0ZUFzc2V0QVdpdGhkcmF3T25McERlcG9zaXQgKmFiaV9yb3V0ZV9jYWxjdWxhdGVBc3NldEJXaXRoZHJhd09uTHBEZXBvc2l0ICphYmlfcm91dGVfY2FsY3VsYXRlQXNzZXRCRGVwb3NpdE9uQXNzZXRBRGVwb3NpdCAqYWJpX3JvdXRlX2NhbGN1bGF0ZUFzc2V0QURlcG9zaXRPbkFzc2V0QkRlcG9zaXQgKmFiaV9yb3V0ZV9zdGF0dXMKCWVycg==",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEw"
  },
  "contract": {
    "name": "BiatecClammPool",
    "desc": "",
    "methods": [
      {
        "name": "createApplication",
        "desc": "Initial setup",
        "args": [],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "getCurrentPrice",
        "readonly": true,
        "args": [],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "getPriceDivider",
        "readonly": true,
        "args": [],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "getLPTokenId",
        "readonly": true,
        "args": [],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "bootstrap",
        "desc": "Anybody can deploy the clamm smart contract",
        "args": [
          {
            "name": "assetA",
            "type": "uint64",
            "desc": "Asset A ID must be lower then Asset B ID"
          },
          {
            "name": "assetB",
            "type": "uint64",
            "desc": "Asset B"
          },
          {
            "name": "appBiatecConfigProvider",
            "type": "uint64",
            "desc": "Biatec amm provider"
          },
          {
            "name": "appBiatecPoolProvider",
            "type": "uint64",
            "desc": "Pool provider"
          },
          {
            "name": "txSeed",
            "type": "pay",
            "desc": "Seed transaction so that smart contract can opt in to the assets"
          },
          {
            "name": "fee",
            "type": "uint64",
            "desc": "Fee in base level (9 decimals). value 1_000_000_000 = 1 = 100%. 10_000_000 = 1%. 1_000_000 = 0.1%"
          },
          {
            "name": "priceMin",
            "type": "uint64",
            "desc": "Min price range. At this point all assets are in asset A."
          },
          {
            "name": "priceMax",
            "type": "uint64",
            "desc": "Max price range. At this point all assets are in asset B."
          },
          {
            "name": "currentPrice",
            "type": "uint64",
            "desc": "Deployer can specify the current price for easier deployemnt."
          },
          {
            "name": "verificationClass",
            "type": "uint8",
            "desc": "Minimum verification level from the biatec identity. Level 0 means no kyc."
          }
        ],
        "returns": {
          "type": "uint64",
          "desc": "LP token ID"
        }
      },
      {
        "name": "addLiquidity",
        "desc": "This method adds Asset A and Asset B to the Automated Market Maker Concentrated Liqudidity Pool and send to the liqudidty provider the liqudity token",
        "args": [
          {
            "name": "appBiatecConfigProvider",
            "type": "uint64"
          },
          {
            "name": "appBiatecIdentityProvider",
            "type": "uint64"
          },
          {
            "name": "txAssetADeposit",
            "type": "txn",
            "desc": "Transfer of asset A to the LP pool"
          },
          {
            "name": "txAssetBDeposit",
            "type": "txn",
            "desc": "Transfer of asset B to the LP pool"
          },
          {
            "name": "assetLP",
            "type": "uint64",
            "desc": "Liquidity pool asset"
          },
          {
            "name": "assetA",
            "type": "uint64",
            "desc": "Asset A"
          },
          {
            "name": "assetB",
            "type": "uint64",
            "desc": "Asset B"
          }
        ],
        "returns": {
          "type": "uint64",
          "desc": "LP Token quantity distributed"
        }
      },
      {
        "name": "removeLiquidity",
        "desc": "This method retrieves from the liquidity provider LP token and returns Asset A and Asset B from the Automated Market Maker Concentrated Liqudidity Pool",
        "args": [
          {
            "name": "txLPXfer",
            "type": "axfer",
            "desc": "Transfer of the LP token"
          },
          {
            "name": "assetLP",
            "type": "uint64",
            "desc": "LP pool asset"
          },
          {
            "name": "assetA",
            "type": "uint64",
            "desc": "Asset A"
          },
          {
            "name": "assetB",
            "type": "uint64",
            "desc": "Asset B"
          }
        ],
        "returns": {
          "type": "uint256",
          "desc": "LP position reduced"
        }
      },
      {
        "name": "swap",
        "desc": "Swap Asset A to Asset B or Asset B to Asst A",
        "args": [
          {
            "name": "appBiatecConfigProvider",
            "type": "uint64"
          },
          {
            "name": "appBiatecIdentityProvider",
            "type": "uint64"
          },
          {
            "name": "txSwap",
            "type": "txn",
            "desc": "Transfer of the token to be deposited to the pool. To the owner the other asset will be sent."
          },
          {
            "name": "assetA",
            "type": "uint64",
            "desc": "Asset A"
          },
          {
            "name": "assetB",
            "type": "uint64",
            "desc": "Asset B"
          },
          {
            "name": "minimumToReceive",
            "type": "uint64",
            "desc": "If number greater then zero, the check is performed for the output of the other asset"
          }
        ],
        "returns": {
          "type": "uint256"
        }
      },
      {
        "name": "calculateDistributedLiquidity",
        "desc": "Calculates the number of LP tokens issued to users",
        "readonly": true,
        "args": [
          {
            "name": "assetLP",
            "type": "uint64"
          },
          {
            "name": "currentDeposit",
            "type": "uint256"
          }
        ],
        "returns": {
          "type": "uint256"
        }
      },
      {
        "name": "calculateLiquidity",
        "desc": "Calculates the liquidity  from the x - Asset A position and y - Asset B position",
        "readonly": true,
        "args": [
          {
            "name": "x",
            "type": "uint256",
            "desc": "Asset A position balanced on the curve"
          },
          {
            "name": "y",
            "type": "uint256",
            "desc": "Asset B position balanced on the curve"
          },
          {
            "name": "priceMin",
            "type": "uint256",
            "desc": "Minimum price variable in base scale decimals (pa)"
          },
          {
            "name": "priceMax",
            "type": "uint256",
            "desc": "Maximum price variable in base scale decimals (pb)"
          },
          {
            "name": "priceMinSqrt",
            "type": "uint256",
            "desc": "sqrt(priceMin) in base scale decimals Variable pas"
          },
          {
            "name": "priceMaxSqrt",
            "type": "uint256",
            "desc": "sqrt(priceMax) in base scale decimals Variable pbs"
          }
        ],
        "returns": {
          "type": "uint256",
          "desc": "Liquidity is constant in swapping each direction. On deposit the diff between the liquidity is number of LP tokens received by user."
        }
      },
      {
        "name": "calculatePrice",
        "desc": "Get the current price when asset a has x",
        "readonly": true,
        "args": [
          {
            "name": "assetAQuantity",
            "type": "uint256",
            "desc": "x"
          },
          {
            "name": "assetBQuantity",
            "type": "uint256",
            "desc": "y"
          },
          {
            "name": "priceMinSqrt",
            "type": "uint256",
            "desc": "sqrt(priceMin)"
          },
          {
            "name": "priceMaxSqrt",
            "type": "uint256",
            "desc": "sqrt(priceMax)"
          },
          {
            "name": "liquidity",
            "type": "uint256",
            "desc": "Current pool liquidity - L variable"
          }
        ],
        "returns": {
          "type": "uint256",
          "desc": "the price with specified quantity with the price range set in the contract"
        }
      },
      {
        "name": "calculateAssetBWithdrawOnAssetADeposit",
        "desc": "Calculates how much asset B will be taken from the smart contract on asset A deposit",
        "readonly": true,
        "args": [
          {
            "name": "inAmount",
            "type": "uint256",
            "desc": "Asset A amount in Base decimal representation.. If asset has 6 decimals, 1 is represented as 1000000000"
          },
          {
            "name": "assetABalance",
            "type": "uint256",
            "desc": "Asset A balance. Variable ab, in base scale"
          },
          {
            "name": "assetBBalance",
            "type": "uint256",
            "desc": "Asset B balance. Variable bb, in base scale"
          },
          {
            "name": "priceMinSqrt",
            "type": "uint256",
            "desc": "sqrt(Min price). Variable pMinS, in base scale"
          },
          {
            "name": "priceMaxSqrt",
            "type": "uint256",
            "desc": "sqrt(Max price). Variable pMaxS, in base scale"
          },
          {
            "name": "liqudity",
            "type": "uint256",
            "desc": "sqrt(Max price). Variable L, in base scale"
          }
        ],
        "returns": {
          "type": "uint256",
          "desc": "Amount of asset B to be given to the caller before fees. The result is in Base decimals (9)"
        }
      },
      {
        "name": "calculateAssetAWithdrawOnAssetBDeposit",
        "desc": "Calculates how much asset A will be taken from the smart contract on asset B deposit",
        "readonly": true,
        "args": [
          {
            "name": "inAmount",
            "type": "uint256",
            "desc": "Asset B amount in Base decimal representation.. If asset has 6 decimals, 1 is represented as 1000000000"
          },
          {
            "name": "assetABalance",
            "type": "uint256",
            "desc": "Asset A balance. Variable ab, in base scale"
          },
          {
            "name": "assetBBalance",
            "type": "uint256",
            "desc": "Asset B balance. Variable bb, in base scale"
          },
          {
            "name": "priceMinSqrt",
            "type": "uint256",
            "desc": "sqrt(Min price). Variable pMinS, in base scale"
          },
          {
            "name": "priceMaxSqrt",
            "type": "uint256",
            "desc": "sqrt(Max price). Variable pMaxS, in base scale"
          },
          {
            "name": "liqudity",
            "type": "uint256",
            "desc": "sqrt(Max price). Variable L, in base scale"
          }
        ],
        "returns": {
          "type": "uint256",
          "desc": "Amount of asset A to be given to the caller before fees. The result is in Base decimals (9)"
        }
      },
      {
        "name": "calculateAssetAWithdrawOnLpDeposit",
        "desc": "Calculates how much asset A will be taken from the smart contract on LP asset deposit",
        "readonly": true,
        "args": [
          {
            "name": "inAmount",
            "type": "uint256",
            "desc": "LP Asset amount in Base decimal representation.."
          },
          {
            "name": "assetABalance",
            "type": "uint256",
            "desc": "Asset A balance. Variable ab, in base scale"
          },
          {
            "name": "liqudity",
            "type": "uint256",
            "desc": "Current liqudity. Variable L, in base scale"
          }
        ],
        "returns": {
          "type": "uint256",
          "desc": "Amount of asset A to be given to the caller before fees. The result is in Base decimals (9)"
        }
      },
      {
        "name": "calculateAssetBWithdrawOnLpDeposit",
        "desc": "Calculates how much asset B will be taken from the smart contract on LP asset deposit",
        "readonly": true,
        "args": [
          {
            "name": "inAmount",
            "type": "uint256",
            "desc": "LP Asset amount in Base decimal representation.."
          },
          {
            "name": "assetBBalance",
            "type": "uint256",
            "desc": "Asset B balance. Variable ab, in base scale"
          },
          {
            "name": "liqudity",
            "type": "uint256",
            "desc": "Current liqudity. Variable L, in base scale"
          }
        ],
        "returns": {
          "type": "uint256",
          "desc": "Amount of asset B to be given to the caller before fees. The result is in Base decimals (9)"
        }
      },
      {
        "name": "calculateAssetBDepositOnAssetADeposit",
        "desc": "Calculates how much asset B should be deposited when user deposit asset a and b.On deposit min(calculateAssetBDepositOnAssetADeposit, calculateAssetADepositOnAssetBDeposit) should be considered for the real deposit and rest should be swapped or returned back to user",
        "readonly": true,
        "args": [
          {
            "name": "inAmountA",
            "type": "uint256",
            "desc": "Asset A amount in Base decimal representation"
          },
          {
            "name": "inAmountB",
            "type": "uint256",
            "desc": "Asset B amount in Base decimal representation"
          },
          {
            "name": "assetABalance",
            "type": "uint256",
            "desc": "Asset A balance. Variable ab, in base scale"
          },
          {
            "name": "assetBBalance",
            "type": "uint256",
            "desc": "Asset B balance. Variable bb, in base scale"
          }
        ],
        "returns": {
          "type": "uint256",
          "desc": "Amount of asset B to be given to the caller before fees. The result is in Base decimals (9)"
        }
      },
      {
        "name": "calculateAssetADepositOnAssetBDeposit",
        "desc": "Calculates how much asset A should be deposited when user deposit asset a and bOn deposit min(calculateAssetBDepositOnAssetADeposit, calculateAssetADepositOnAssetBDeposit) should be considered for the real deposit and rest should be swapped or returned back to user",
        "readonly": true,
        "args": [
          {
            "name": "inAmountA",
            "type": "uint256",
            "desc": "Asset A amount in Base decimal representation"
          },
          {
            "name": "inAmountB",
            "type": "uint256",
            "desc": "Asset B amount in Base decimal representation"
          },
          {
            "name": "assetABalance",
            "type": "uint256",
            "desc": "Asset A balance. Variable ab, in base scale"
          },
          {
            "name": "assetBBalance",
            "type": "uint256",
            "desc": "Asset B balance. Variable bb, in base scale"
          }
        ],
        "returns": {
          "type": "uint256",
          "desc": "Amount of asset A to be deposited. The result is in Base decimals (9)"
        }
      },
      {
        "name": "status",
        "readonly": true,
        "args": [
          {
            "name": "appBiatecConfigProvider",
            "type": "uint64"
          },
          {
            "name": "assetLP",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)"
        }
      }
    ]
  }
}

/**
 * Defines an onCompletionAction of 'no_op'
 */
export type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }
/**
 * Defines an onCompletionAction of 'opt_in'
 */
export type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }
/**
 * Defines an onCompletionAction of 'close_out'
 */
export type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }
/**
 * Defines an onCompletionAction of 'delete_application'
 */
export type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }
/**
 * Defines an onCompletionAction of 'update_application'
 */
export type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }
/**
 * A state record containing a single unsigned integer
 */
export type IntegerState = {
  /**
   * Gets the state value as a BigInt 
   */
  asBigInt(): bigint
  /**
   * Gets the state value as a number.
   */
  asNumber(): number
}
/**
 * A state record containing binary data
 */
export type BinaryState = {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array
  /**
   * Gets the state value as a string
   */
  asString(): string
}

export type AppCreateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult> & AppReference
export type AppUpdateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult>

/**
 * Defines the types of available calls and state of the BiatecClammPool smart contract.
 */
export type BiatecClammPool = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'createApplication()void' | 'createApplication', {
      argsObj: {
      }
      argsTuple: []
      returns: void
    }>
    & Record<'getCurrentPrice()uint64' | 'getCurrentPrice', {
      argsObj: {
      }
      argsTuple: []
      returns: bigint
    }>
    & Record<'getPriceDivider()uint64' | 'getPriceDivider', {
      argsObj: {
      }
      argsTuple: []
      returns: bigint
    }>
    & Record<'getLPTokenId()uint64' | 'getLPTokenId', {
      argsObj: {
      }
      argsTuple: []
      returns: bigint
    }>
    & Record<'bootstrap(uint64,uint64,uint64,uint64,pay,uint64,uint64,uint64,uint64,uint8)uint64' | 'bootstrap', {
      argsObj: {
        /**
         * Asset A ID must be lower then Asset B ID
         */
        assetA: bigint | number
        /**
         * Asset B
         */
        assetB: bigint | number
        /**
         * Biatec amm provider
         */
        appBiatecConfigProvider: bigint | number
        /**
         * Pool provider
         */
        appBiatecPoolProvider: bigint | number
        /**
         * Seed transaction so that smart contract can opt in to the assets
         */
        txSeed: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * Fee in base level (9 decimals). value 1_000_000_000 = 1 = 100%. 10_000_000 = 1%. 1_000_000 = 0.1%
         */
        fee: bigint | number
        /**
         * Min price range. At this point all assets are in asset A.
         */
        priceMin: bigint | number
        /**
         * Max price range. At this point all assets are in asset B.
         */
        priceMax: bigint | number
        /**
         * Deployer can specify the current price for easier deployemnt.
         */
        currentPrice: bigint | number
        /**
         * Minimum verification level from the biatec identity. Level 0 means no kyc.
         */
        verificationClass: number
      }
      argsTuple: [assetA: bigint | number, assetB: bigint | number, appBiatecConfigProvider: bigint | number, appBiatecPoolProvider: bigint | number, txSeed: TransactionToSign | Transaction | Promise<SendTransactionResult>, fee: bigint | number, priceMin: bigint | number, priceMax: bigint | number, currentPrice: bigint | number, verificationClass: number]
      /**
       * LP token ID
       */
      returns: bigint
    }>
    & Record<'addLiquidity(uint64,uint64,txn,txn,uint64,uint64,uint64)uint64' | 'addLiquidity', {
      argsObj: {
        appBiatecConfigProvider: bigint | number
        appBiatecIdentityProvider: bigint | number
        /**
         * Transfer of asset A to the LP pool
         */
        txAssetADeposit: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * Transfer of asset B to the LP pool
         */
        txAssetBDeposit: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * Liquidity pool asset
         */
        assetLP: bigint | number
        /**
         * Asset A
         */
        assetA: bigint | number
        /**
         * Asset B
         */
        assetB: bigint | number
      }
      argsTuple: [appBiatecConfigProvider: bigint | number, appBiatecIdentityProvider: bigint | number, txAssetADeposit: TransactionToSign | Transaction | Promise<SendTransactionResult>, txAssetBDeposit: TransactionToSign | Transaction | Promise<SendTransactionResult>, assetLP: bigint | number, assetA: bigint | number, assetB: bigint | number]
      /**
       * LP Token quantity distributed
       */
      returns: bigint
    }>
    & Record<'removeLiquidity(axfer,uint64,uint64,uint64)uint256' | 'removeLiquidity', {
      argsObj: {
        /**
         * Transfer of the LP token
         */
        txLPXfer: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * LP pool asset
         */
        assetLP: bigint | number
        /**
         * Asset A
         */
        assetA: bigint | number
        /**
         * Asset B
         */
        assetB: bigint | number
      }
      argsTuple: [txLPXfer: TransactionToSign | Transaction | Promise<SendTransactionResult>, assetLP: bigint | number, assetA: bigint | number, assetB: bigint | number]
      /**
       * LP position reduced
       */
      returns: bigint
    }>
    & Record<'swap(uint64,uint64,txn,uint64,uint64,uint64)uint256' | 'swap', {
      argsObj: {
        appBiatecConfigProvider: bigint | number
        appBiatecIdentityProvider: bigint | number
        /**
         * Transfer of the token to be deposited to the pool. To the owner the other asset will be sent.
         */
        txSwap: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * Asset A
         */
        assetA: bigint | number
        /**
         * Asset B
         */
        assetB: bigint | number
        /**
         * If number greater then zero, the check is performed for the output of the other asset
         */
        minimumToReceive: bigint | number
      }
      argsTuple: [appBiatecConfigProvider: bigint | number, appBiatecIdentityProvider: bigint | number, txSwap: TransactionToSign | Transaction | Promise<SendTransactionResult>, assetA: bigint | number, assetB: bigint | number, minimumToReceive: bigint | number]
      returns: bigint
    }>
    & Record<'calculateDistributedLiquidity(uint64,uint256)uint256' | 'calculateDistributedLiquidity', {
      argsObj: {
        assetLP: bigint | number
        currentDeposit: bigint | number
      }
      argsTuple: [assetLP: bigint | number, currentDeposit: bigint | number]
      returns: bigint
    }>
    & Record<'calculateLiquidity(uint256,uint256,uint256,uint256,uint256,uint256)uint256' | 'calculateLiquidity', {
      argsObj: {
        /**
         * Asset A position balanced on the curve
         */
        x: bigint | number
        /**
         * Asset B position balanced on the curve
         */
        y: bigint | number
        /**
         * Minimum price variable in base scale decimals (pa)
         */
        priceMin: bigint | number
        /**
         * Maximum price variable in base scale decimals (pb)
         */
        priceMax: bigint | number
        /**
         * sqrt(priceMin) in base scale decimals Variable pas
         */
        priceMinSqrt: bigint | number
        /**
         * sqrt(priceMax) in base scale decimals Variable pbs
         */
        priceMaxSqrt: bigint | number
      }
      argsTuple: [x: bigint | number, y: bigint | number, priceMin: bigint | number, priceMax: bigint | number, priceMinSqrt: bigint | number, priceMaxSqrt: bigint | number]
      /**
       * Liquidity is constant in swapping each direction. On deposit the diff between the liquidity is number of LP tokens received by user.
       */
      returns: bigint
    }>
    & Record<'calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256' | 'calculatePrice', {
      argsObj: {
        /**
         * x
         */
        assetAQuantity: bigint | number
        /**
         * y
         */
        assetBQuantity: bigint | number
        /**
         * sqrt(priceMin)
         */
        priceMinSqrt: bigint | number
        /**
         * sqrt(priceMax)
         */
        priceMaxSqrt: bigint | number
        /**
         * Current pool liquidity - L variable
         */
        liquidity: bigint | number
      }
      argsTuple: [assetAQuantity: bigint | number, assetBQuantity: bigint | number, priceMinSqrt: bigint | number, priceMaxSqrt: bigint | number, liquidity: bigint | number]
      /**
       * the price with specified quantity with the price range set in the contract
       */
      returns: bigint
    }>
    & Record<'calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256' | 'calculateAssetBWithdrawOnAssetADeposit', {
      argsObj: {
        /**
         * Asset A amount in Base decimal representation.. If asset has 6 decimals, 1 is represented as 1000000000
         */
        inAmount: bigint | number
        /**
         * Asset A balance. Variable ab, in base scale
         */
        assetABalance: bigint | number
        /**
         * Asset B balance. Variable bb, in base scale
         */
        assetBBalance: bigint | number
        /**
         * sqrt(Min price). Variable pMinS, in base scale
         */
        priceMinSqrt: bigint | number
        /**
         * sqrt(Max price). Variable pMaxS, in base scale
         */
        priceMaxSqrt: bigint | number
        /**
         * sqrt(Max price). Variable L, in base scale
         */
        liqudity: bigint | number
      }
      argsTuple: [inAmount: bigint | number, assetABalance: bigint | number, assetBBalance: bigint | number, priceMinSqrt: bigint | number, priceMaxSqrt: bigint | number, liqudity: bigint | number]
      /**
       * Amount of asset B to be given to the caller before fees. The result is in Base decimals (9)
       */
      returns: bigint
    }>
    & Record<'calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256' | 'calculateAssetAWithdrawOnAssetBDeposit', {
      argsObj: {
        /**
         * Asset B amount in Base decimal representation.. If asset has 6 decimals, 1 is represented as 1000000000
         */
        inAmount: bigint | number
        /**
         * Asset A balance. Variable ab, in base scale
         */
        assetABalance: bigint | number
        /**
         * Asset B balance. Variable bb, in base scale
         */
        assetBBalance: bigint | number
        /**
         * sqrt(Min price). Variable pMinS, in base scale
         */
        priceMinSqrt: bigint | number
        /**
         * sqrt(Max price). Variable pMaxS, in base scale
         */
        priceMaxSqrt: bigint | number
        /**
         * sqrt(Max price). Variable L, in base scale
         */
        liqudity: bigint | number
      }
      argsTuple: [inAmount: bigint | number, assetABalance: bigint | number, assetBBalance: bigint | number, priceMinSqrt: bigint | number, priceMaxSqrt: bigint | number, liqudity: bigint | number]
      /**
       * Amount of asset A to be given to the caller before fees. The result is in Base decimals (9)
       */
      returns: bigint
    }>
    & Record<'calculateAssetAWithdrawOnLpDeposit(uint256,uint256,uint256)uint256' | 'calculateAssetAWithdrawOnLpDeposit', {
      argsObj: {
        /**
         * LP Asset amount in Base decimal representation..
         */
        inAmount: bigint | number
        /**
         * Asset A balance. Variable ab, in base scale
         */
        assetABalance: bigint | number
        /**
         * Current liqudity. Variable L, in base scale
         */
        liqudity: bigint | number
      }
      argsTuple: [inAmount: bigint | number, assetABalance: bigint | number, liqudity: bigint | number]
      /**
       * Amount of asset A to be given to the caller before fees. The result is in Base decimals (9)
       */
      returns: bigint
    }>
    & Record<'calculateAssetBWithdrawOnLpDeposit(uint256,uint256,uint256)uint256' | 'calculateAssetBWithdrawOnLpDeposit', {
      argsObj: {
        /**
         * LP Asset amount in Base decimal representation..
         */
        inAmount: bigint | number
        /**
         * Asset B balance. Variable ab, in base scale
         */
        assetBBalance: bigint | number
        /**
         * Current liqudity. Variable L, in base scale
         */
        liqudity: bigint | number
      }
      argsTuple: [inAmount: bigint | number, assetBBalance: bigint | number, liqudity: bigint | number]
      /**
       * Amount of asset B to be given to the caller before fees. The result is in Base decimals (9)
       */
      returns: bigint
    }>
    & Record<'calculateAssetBDepositOnAssetADeposit(uint256,uint256,uint256,uint256)uint256' | 'calculateAssetBDepositOnAssetADeposit', {
      argsObj: {
        /**
         * Asset A amount in Base decimal representation
         */
        inAmountA: bigint | number
        /**
         * Asset B amount in Base decimal representation
         */
        inAmountB: bigint | number
        /**
         * Asset A balance. Variable ab, in base scale
         */
        assetABalance: bigint | number
        /**
         * Asset B balance. Variable bb, in base scale
         */
        assetBBalance: bigint | number
      }
      argsTuple: [inAmountA: bigint | number, inAmountB: bigint | number, assetABalance: bigint | number, assetBBalance: bigint | number]
      /**
       * Amount of asset B to be given to the caller before fees. The result is in Base decimals (9)
       */
      returns: bigint
    }>
    & Record<'calculateAssetADepositOnAssetBDeposit(uint256,uint256,uint256,uint256)uint256' | 'calculateAssetADepositOnAssetBDeposit', {
      argsObj: {
        /**
         * Asset A amount in Base decimal representation
         */
        inAmountA: bigint | number
        /**
         * Asset B amount in Base decimal representation
         */
        inAmountB: bigint | number
        /**
         * Asset A balance. Variable ab, in base scale
         */
        assetABalance: bigint | number
        /**
         * Asset B balance. Variable bb, in base scale
         */
        assetBBalance: bigint | number
      }
      argsTuple: [inAmountA: bigint | number, inAmountB: bigint | number, assetABalance: bigint | number, assetBBalance: bigint | number]
      /**
       * Amount of asset A to be deposited. The result is in Base decimals (9)
       */
      returns: bigint
    }>
    & Record<'status(uint64,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)' | 'status', {
      argsObj: {
        appBiatecConfigProvider: bigint | number
        assetLP: bigint | number
      }
      argsTuple: [appBiatecConfigProvider: bigint | number, assetLP: bigint | number]
      returns: [bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint]
    }>
  /**
   * Defines the shape of the global and local state of the application.
   */
  state: {
    global: {
      'a'?: IntegerState
      'b'?: IntegerState
      'lp'?: IntegerState
      'ab'?: BinaryState
      'bb'?: BinaryState
      'pMin'?: IntegerState
      'pMax'?: IntegerState
      'pMinS'?: BinaryState
      'pMaxS'?: BinaryState
      'L'?: BinaryState
      'Lu'?: BinaryState
      'Lb'?: BinaryState
      'f'?: IntegerState
      'r'?: IntegerState
      'scale'?: IntegerState
      'B'?: IntegerState
      'pp'?: IntegerState
      'c'?: IntegerState
    }
  }
}
/**
 * Defines the possible abi call signatures
 */
export type BiatecClammPoolSig = keyof BiatecClammPool['methods']
/**
 * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made
 */
export type TypedCallParams<TSignature extends BiatecClammPoolSig | undefined> = {
  method: TSignature
  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>
} & AppClientCallCoreParams & CoreAppCallArgs
/**
 * Defines the arguments required for a bare call
 */
export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>
/**
 * Maps a method signature from the BiatecClammPool smart contract to the method's arguments in either tuple of struct form
 */
export type MethodArgs<TSignature extends BiatecClammPoolSig> = BiatecClammPool['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the BiatecClammPool smart contract to the method's return type
 */
export type MethodReturn<TSignature extends BiatecClammPoolSig> = BiatecClammPool['methods'][TSignature]['returns']

/**
 * A factory for available 'create' calls
 */
export type BiatecClammPoolCreateCalls = (typeof BiatecClammPoolCallFactory)['create']
/**
 * Defines supported create methods for this smart contract
 */
export type BiatecClammPoolCreateCallParams =
  | (TypedCallParams<'createApplication()void'> & (OnCompleteNoOp))
/**
 * Defines arguments required for the deploy method.
 */
export type BiatecClammPoolDeployArgs = {
  deployTimeParams?: TealTemplateParams
  /**
   * A delegate which takes a create call factory and returns the create call params for this smart contract
   */
  createCall?: (callFactory: BiatecClammPoolCreateCalls) => BiatecClammPoolCreateCallParams
}


/**
 * Exposes methods for constructing all available smart contract calls
 */
export abstract class BiatecClammPoolCallFactory {
  /**
   * Gets available create call factories
   */
  static get create() {
    return {
      /**
       * Constructs a create call for the BiatecClammPool smart contract using the createApplication()void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      createApplication(args: MethodArgs<'createApplication()void'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return {
          method: 'createApplication()void' as const,
          methodArgs: Array.isArray(args) ? args : [],
          ...params,
        }
      },
    }
  }

  /**
   * Constructs a no op call for the getCurrentPrice()uint64 ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getCurrentPrice(args: MethodArgs<'getCurrentPrice()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getCurrentPrice()uint64' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the getPriceDivider()uint64 ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getPriceDivider(args: MethodArgs<'getPriceDivider()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getPriceDivider()uint64' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the getLPTokenId()uint64 ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getLpTokenId(args: MethodArgs<'getLPTokenId()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getLPTokenId()uint64' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the bootstrap(uint64,uint64,uint64,uint64,pay,uint64,uint64,uint64,uint64,uint8)uint64 ABI method
   *
   * Anybody can deploy the clamm smart contract
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static bootstrap(args: MethodArgs<'bootstrap(uint64,uint64,uint64,uint64,pay,uint64,uint64,uint64,uint64,uint8)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'bootstrap(uint64,uint64,uint64,uint64,pay,uint64,uint64,uint64,uint64,uint8)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.assetA, args.assetB, args.appBiatecConfigProvider, args.appBiatecPoolProvider, args.txSeed, args.fee, args.priceMin, args.priceMax, args.currentPrice, args.verificationClass],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the addLiquidity(uint64,uint64,txn,txn,uint64,uint64,uint64)uint64 ABI method
   *
   * This method adds Asset A and Asset B to the Automated Market Maker Concentrated Liqudidity Pool and send to the liqudidty provider the liqudity token
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static addLiquidity(args: MethodArgs<'addLiquidity(uint64,uint64,txn,txn,uint64,uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'addLiquidity(uint64,uint64,txn,txn,uint64,uint64,uint64)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.appBiatecConfigProvider, args.appBiatecIdentityProvider, args.txAssetADeposit, args.txAssetBDeposit, args.assetLP, args.assetA, args.assetB],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the removeLiquidity(axfer,uint64,uint64,uint64)uint256 ABI method
   *
   * This method retrieves from the liquidity provider LP token and returns Asset A and Asset B from the Automated Market Maker Concentrated Liqudidity Pool
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static removeLiquidity(args: MethodArgs<'removeLiquidity(axfer,uint64,uint64,uint64)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'removeLiquidity(axfer,uint64,uint64,uint64)uint256' as const,
      methodArgs: Array.isArray(args) ? args : [args.txLPXfer, args.assetLP, args.assetA, args.assetB],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the swap(uint64,uint64,txn,uint64,uint64,uint64)uint256 ABI method
   *
   * Swap Asset A to Asset B or Asset B to Asst A
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static swap(args: MethodArgs<'swap(uint64,uint64,txn,uint64,uint64,uint64)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'swap(uint64,uint64,txn,uint64,uint64,uint64)uint256' as const,
      methodArgs: Array.isArray(args) ? args : [args.appBiatecConfigProvider, args.appBiatecIdentityProvider, args.txSwap, args.assetA, args.assetB, args.minimumToReceive],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the calculateDistributedLiquidity(uint64,uint256)uint256 ABI method
   *
   * Calculates the number of LP tokens issued to users
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static calculateDistributedLiquidity(args: MethodArgs<'calculateDistributedLiquidity(uint64,uint256)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'calculateDistributedLiquidity(uint64,uint256)uint256' as const,
      methodArgs: Array.isArray(args) ? args : [args.assetLP, args.currentDeposit],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the calculateLiquidity(uint256,uint256,uint256,uint256,uint256,uint256)uint256 ABI method
   *
   * Calculates the liquidity  from the x - Asset A position and y - Asset B position
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static calculateLiquidity(args: MethodArgs<'calculateLiquidity(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'calculateLiquidity(uint256,uint256,uint256,uint256,uint256,uint256)uint256' as const,
      methodArgs: Array.isArray(args) ? args : [args.x, args.y, args.priceMin, args.priceMax, args.priceMinSqrt, args.priceMaxSqrt],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256 ABI method
   *
   * Get the current price when asset a has x
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static calculatePrice(args: MethodArgs<'calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256' as const,
      methodArgs: Array.isArray(args) ? args : [args.assetAQuantity, args.assetBQuantity, args.priceMinSqrt, args.priceMaxSqrt, args.liquidity],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256 ABI method
   *
   * Calculates how much asset B will be taken from the smart contract on asset A deposit
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static calculateAssetBWithdrawOnAssetADeposit(args: MethodArgs<'calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256' as const,
      methodArgs: Array.isArray(args) ? args : [args.inAmount, args.assetABalance, args.assetBBalance, args.priceMinSqrt, args.priceMaxSqrt, args.liqudity],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256 ABI method
   *
   * Calculates how much asset A will be taken from the smart contract on asset B deposit
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static calculateAssetAWithdrawOnAssetBDeposit(args: MethodArgs<'calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256' as const,
      methodArgs: Array.isArray(args) ? args : [args.inAmount, args.assetABalance, args.assetBBalance, args.priceMinSqrt, args.priceMaxSqrt, args.liqudity],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the calculateAssetAWithdrawOnLpDeposit(uint256,uint256,uint256)uint256 ABI method
   *
   * Calculates how much asset A will be taken from the smart contract on LP asset deposit
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static calculateAssetAWithdrawOnLpDeposit(args: MethodArgs<'calculateAssetAWithdrawOnLpDeposit(uint256,uint256,uint256)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'calculateAssetAWithdrawOnLpDeposit(uint256,uint256,uint256)uint256' as const,
      methodArgs: Array.isArray(args) ? args : [args.inAmount, args.assetABalance, args.liqudity],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the calculateAssetBWithdrawOnLpDeposit(uint256,uint256,uint256)uint256 ABI method
   *
   * Calculates how much asset B will be taken from the smart contract on LP asset deposit
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static calculateAssetBWithdrawOnLpDeposit(args: MethodArgs<'calculateAssetBWithdrawOnLpDeposit(uint256,uint256,uint256)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'calculateAssetBWithdrawOnLpDeposit(uint256,uint256,uint256)uint256' as const,
      methodArgs: Array.isArray(args) ? args : [args.inAmount, args.assetBBalance, args.liqudity],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the calculateAssetBDepositOnAssetADeposit(uint256,uint256,uint256,uint256)uint256 ABI method
   *
   * Calculates how much asset B should be deposited when user deposit asset a and b.On deposit min(calculateAssetBDepositOnAssetADeposit, calculateAssetADepositOnAssetBDeposit) should be considered for the real deposit and rest should be swapped or returned back to user
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static calculateAssetBDepositOnAssetADeposit(args: MethodArgs<'calculateAssetBDepositOnAssetADeposit(uint256,uint256,uint256,uint256)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'calculateAssetBDepositOnAssetADeposit(uint256,uint256,uint256,uint256)uint256' as const,
      methodArgs: Array.isArray(args) ? args : [args.inAmountA, args.inAmountB, args.assetABalance, args.assetBBalance],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the calculateAssetADepositOnAssetBDeposit(uint256,uint256,uint256,uint256)uint256 ABI method
   *
   * Calculates how much asset A should be deposited when user deposit asset a and bOn deposit min(calculateAssetBDepositOnAssetADeposit, calculateAssetADepositOnAssetBDeposit) should be considered for the real deposit and rest should be swapped or returned back to user
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static calculateAssetADepositOnAssetBDeposit(args: MethodArgs<'calculateAssetADepositOnAssetBDeposit(uint256,uint256,uint256,uint256)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'calculateAssetADepositOnAssetBDeposit(uint256,uint256,uint256,uint256)uint256' as const,
      methodArgs: Array.isArray(args) ? args : [args.inAmountA, args.inAmountB, args.assetABalance, args.assetBBalance],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the status(uint64,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64) ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static status(args: MethodArgs<'status(uint64,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'status(uint64,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)' as const,
      methodArgs: Array.isArray(args) ? args : [args.appBiatecConfigProvider, args.assetLP],
      ...params,
    }
  }
}

/**
 * A client to make calls to the BiatecClammPool smart contract
 */
export class BiatecClammPoolClient {
  /**
   * The underlying `ApplicationClient` for when you want to have more flexibility
   */
  public readonly appClient: ApplicationClient

  private readonly sender: SendTransactionFrom | undefined

  /**
   * Creates a new instance of `BiatecClammPoolClient`
   *
   * @param appDetails appDetails The details to identify the app to deploy
   * @param algod An algod client instance
   */
  constructor(appDetails: AppDetails, private algod: Algodv2) {
    this.sender = appDetails.sender
    this.appClient = algokit.getAppClient({
      ...appDetails,
      app: APP_SPEC
    }, algod)
  }

  /**
   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type
   *
   * @param result The AppCallTransactionResult to be mapped
   * @param returnValueFormatter An optional delegate to format the return value if required
   * @returns The smart contract response with an updated return value
   */
  protected mapReturnValue<TReturn, TResult extends AppCallTransactionResult = AppCallTransactionResult>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> & TResult {
    if(result.return?.decodeError) {
      throw result.return.decodeError
    }
    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined
      ? returnValueFormatter(result.return.returnValue)
      : result.return?.returnValue as TReturn | undefined
      return { ...result, return: returnValue } as AppCallTransactionResultOfType<TReturn> & TResult
  }

  /**
   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP
   *
   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters
   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type
   * @returns The result of the smart contract call
   */
  public async call<TSignature extends keyof BiatecClammPool['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {
    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)
  }

  /**
   * Idempotently deploys the BiatecClammPool smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public deploy(params: BiatecClammPoolDeployArgs & AppClientDeployCoreParams = {}): ReturnType<ApplicationClient['deploy']> {
    const createArgs = params.createCall?.(BiatecClammPoolCallFactory.create)
    return this.appClient.deploy({
      ...params,
      createArgs,
      createOnCompleteAction: createArgs?.onCompleteAction,
    })
  }

  /**
   * Gets available create methods
   */
  public get create() {
    const $this = this
    return {
      /**
       * Creates a new instance of the BiatecClammPool smart contract using the createApplication()void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The create result
       */
      async createApplication(args: MethodArgs<'createApplication()void'>, params: AppClientCallCoreParams & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return $this.mapReturnValue<MethodReturn<'createApplication()void'>, AppCreateCallTransactionResult>(await $this.appClient.create(BiatecClammPoolCallFactory.create.createApplication(args, params)))
      },
    }
  }

  /**
   * Makes a clear_state call to an existing instance of the BiatecClammPool smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The clear_state result
   */
  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.appClient.clearState(args)
  }

  /**
   * Calls the getCurrentPrice()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getCurrentPrice(args: MethodArgs<'getCurrentPrice()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammPoolCallFactory.getCurrentPrice(args, params))
  }

  /**
   * Calls the getPriceDivider()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getPriceDivider(args: MethodArgs<'getPriceDivider()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammPoolCallFactory.getPriceDivider(args, params))
  }

  /**
   * Calls the getLPTokenId()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getLpTokenId(args: MethodArgs<'getLPTokenId()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammPoolCallFactory.getLpTokenId(args, params))
  }

  /**
   * Calls the bootstrap(uint64,uint64,uint64,uint64,pay,uint64,uint64,uint64,uint64,uint8)uint64 ABI method.
   *
   * Anybody can deploy the clamm smart contract
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: LP token ID
   */
  public bootstrap(args: MethodArgs<'bootstrap(uint64,uint64,uint64,uint64,pay,uint64,uint64,uint64,uint64,uint8)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammPoolCallFactory.bootstrap(args, params))
  }

  /**
   * Calls the addLiquidity(uint64,uint64,txn,txn,uint64,uint64,uint64)uint64 ABI method.
   *
   * This method adds Asset A and Asset B to the Automated Market Maker Concentrated Liqudidity Pool and send to the liqudidty provider the liqudity token
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: LP Token quantity distributed
   */
  public addLiquidity(args: MethodArgs<'addLiquidity(uint64,uint64,txn,txn,uint64,uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammPoolCallFactory.addLiquidity(args, params))
  }

  /**
   * Calls the removeLiquidity(axfer,uint64,uint64,uint64)uint256 ABI method.
   *
   * This method retrieves from the liquidity provider LP token and returns Asset A and Asset B from the Automated Market Maker Concentrated Liqudidity Pool
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: LP position reduced
   */
  public removeLiquidity(args: MethodArgs<'removeLiquidity(axfer,uint64,uint64,uint64)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammPoolCallFactory.removeLiquidity(args, params))
  }

  /**
   * Calls the swap(uint64,uint64,txn,uint64,uint64,uint64)uint256 ABI method.
   *
   * Swap Asset A to Asset B or Asset B to Asst A
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public swap(args: MethodArgs<'swap(uint64,uint64,txn,uint64,uint64,uint64)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammPoolCallFactory.swap(args, params))
  }

  /**
   * Calls the calculateDistributedLiquidity(uint64,uint256)uint256 ABI method.
   *
   * Calculates the number of LP tokens issued to users
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public calculateDistributedLiquidity(args: MethodArgs<'calculateDistributedLiquidity(uint64,uint256)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammPoolCallFactory.calculateDistributedLiquidity(args, params))
  }

  /**
   * Calls the calculateLiquidity(uint256,uint256,uint256,uint256,uint256,uint256)uint256 ABI method.
   *
   * Calculates the liquidity  from the x - Asset A position and y - Asset B position
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Liquidity is constant in swapping each direction. On deposit the diff between the liquidity is number of LP tokens received by user.
   */
  public calculateLiquidity(args: MethodArgs<'calculateLiquidity(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammPoolCallFactory.calculateLiquidity(args, params))
  }

  /**
   * Calls the calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256 ABI method.
   *
   * Get the current price when asset a has x
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: the price with specified quantity with the price range set in the contract
   */
  public calculatePrice(args: MethodArgs<'calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammPoolCallFactory.calculatePrice(args, params))
  }

  /**
   * Calls the calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256 ABI method.
   *
   * Calculates how much asset B will be taken from the smart contract on asset A deposit
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Amount of asset B to be given to the caller before fees. The result is in Base decimals (9)
   */
  public calculateAssetBWithdrawOnAssetADeposit(args: MethodArgs<'calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammPoolCallFactory.calculateAssetBWithdrawOnAssetADeposit(args, params))
  }

  /**
   * Calls the calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256 ABI method.
   *
   * Calculates how much asset A will be taken from the smart contract on asset B deposit
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Amount of asset A to be given to the caller before fees. The result is in Base decimals (9)
   */
  public calculateAssetAWithdrawOnAssetBDeposit(args: MethodArgs<'calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammPoolCallFactory.calculateAssetAWithdrawOnAssetBDeposit(args, params))
  }

  /**
   * Calls the calculateAssetAWithdrawOnLpDeposit(uint256,uint256,uint256)uint256 ABI method.
   *
   * Calculates how much asset A will be taken from the smart contract on LP asset deposit
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Amount of asset A to be given to the caller before fees. The result is in Base decimals (9)
   */
  public calculateAssetAWithdrawOnLpDeposit(args: MethodArgs<'calculateAssetAWithdrawOnLpDeposit(uint256,uint256,uint256)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammPoolCallFactory.calculateAssetAWithdrawOnLpDeposit(args, params))
  }

  /**
   * Calls the calculateAssetBWithdrawOnLpDeposit(uint256,uint256,uint256)uint256 ABI method.
   *
   * Calculates how much asset B will be taken from the smart contract on LP asset deposit
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Amount of asset B to be given to the caller before fees. The result is in Base decimals (9)
   */
  public calculateAssetBWithdrawOnLpDeposit(args: MethodArgs<'calculateAssetBWithdrawOnLpDeposit(uint256,uint256,uint256)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammPoolCallFactory.calculateAssetBWithdrawOnLpDeposit(args, params))
  }

  /**
   * Calls the calculateAssetBDepositOnAssetADeposit(uint256,uint256,uint256,uint256)uint256 ABI method.
   *
   * Calculates how much asset B should be deposited when user deposit asset a and b.On deposit min(calculateAssetBDepositOnAssetADeposit, calculateAssetADepositOnAssetBDeposit) should be considered for the real deposit and rest should be swapped or returned back to user
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Amount of asset B to be given to the caller before fees. The result is in Base decimals (9)
   */
  public calculateAssetBDepositOnAssetADeposit(args: MethodArgs<'calculateAssetBDepositOnAssetADeposit(uint256,uint256,uint256,uint256)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammPoolCallFactory.calculateAssetBDepositOnAssetADeposit(args, params))
  }

  /**
   * Calls the calculateAssetADepositOnAssetBDeposit(uint256,uint256,uint256,uint256)uint256 ABI method.
   *
   * Calculates how much asset A should be deposited when user deposit asset a and bOn deposit min(calculateAssetBDepositOnAssetADeposit, calculateAssetADepositOnAssetBDeposit) should be considered for the real deposit and rest should be swapped or returned back to user
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Amount of asset A to be deposited. The result is in Base decimals (9)
   */
  public calculateAssetADepositOnAssetBDeposit(args: MethodArgs<'calculateAssetADepositOnAssetBDeposit(uint256,uint256,uint256,uint256)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammPoolCallFactory.calculateAssetADepositOnAssetBDeposit(args, params))
  }

  /**
   * Calls the status(uint64,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public status(args: MethodArgs<'status(uint64,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(BiatecClammPoolCallFactory.status(args, params))
  }

  /**
   * Extracts a binary state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns A BinaryState instance containing the state value, or undefined if the key was not found
   */
  private static getBinaryState(state: AppState, key: string): BinaryState | undefined {
    const value = state[key]
    if (!value) return undefined
    if (!('valueRaw' in value))
      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`)
    return {
      asString(): string {
        return value.value
      },
      asByteArray(): Uint8Array {
        return value.valueRaw
      }
    }
  }

  /**
   * Extracts a integer state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns An IntegerState instance containing the state value, or undefined if the key was not found
   */
  private static getIntegerState(state: AppState, key: string): IntegerState | undefined {
    const value = state[key]
    if (!value) return undefined
    if ('valueRaw' in value)
      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`)
    return {
      asBigInt() {
        return typeof value.value === 'bigint' ? value.value : BigInt(value.value)
      },
      asNumber(): number {
        return typeof value.value === 'bigint' ? Number(value.value) : value.value
      },
    }
  }

  /**
   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value
   */
  public async getGlobalState(): Promise<BiatecClammPool['state']['global']> {
    const state = await this.appClient.getGlobalState()
    return {
      get a() {
        return BiatecClammPoolClient.getIntegerState(state, 'a')
      },
      get b() {
        return BiatecClammPoolClient.getIntegerState(state, 'b')
      },
      get lp() {
        return BiatecClammPoolClient.getIntegerState(state, 'lp')
      },
      get ab() {
        return BiatecClammPoolClient.getBinaryState(state, 'ab')
      },
      get bb() {
        return BiatecClammPoolClient.getBinaryState(state, 'bb')
      },
      get pMin() {
        return BiatecClammPoolClient.getIntegerState(state, 'pMin')
      },
      get pMax() {
        return BiatecClammPoolClient.getIntegerState(state, 'pMax')
      },
      get pMinS() {
        return BiatecClammPoolClient.getBinaryState(state, 'pMinS')
      },
      get pMaxS() {
        return BiatecClammPoolClient.getBinaryState(state, 'pMaxS')
      },
      get L() {
        return BiatecClammPoolClient.getBinaryState(state, 'L')
      },
      get Lu() {
        return BiatecClammPoolClient.getBinaryState(state, 'Lu')
      },
      get Lb() {
        return BiatecClammPoolClient.getBinaryState(state, 'Lb')
      },
      get f() {
        return BiatecClammPoolClient.getIntegerState(state, 'f')
      },
      get r() {
        return BiatecClammPoolClient.getIntegerState(state, 'r')
      },
      get scale() {
        return BiatecClammPoolClient.getIntegerState(state, 'scale')
      },
      get B() {
        return BiatecClammPoolClient.getIntegerState(state, 'B')
      },
      get pp() {
        return BiatecClammPoolClient.getIntegerState(state, 'pp')
      },
      get c() {
        return BiatecClammPoolClient.getIntegerState(state, 'c')
      },
    }
  }

  public compose(): BiatecClammPoolComposer {
    const client = this
    const atc = new AtomicTransactionComposer()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: any) => any)> = []
    return {
      getCurrentPrice(args: MethodArgs<'getCurrentPrice()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getCurrentPrice(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      getPriceDivider(args: MethodArgs<'getPriceDivider()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getPriceDivider(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      getLpTokenId(args: MethodArgs<'getLPTokenId()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getLpTokenId(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      bootstrap(args: MethodArgs<'bootstrap(uint64,uint64,uint64,uint64,pay,uint64,uint64,uint64,uint64,uint8)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.bootstrap(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addLiquidity(args: MethodArgs<'addLiquidity(uint64,uint64,txn,txn,uint64,uint64,uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.addLiquidity(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      removeLiquidity(args: MethodArgs<'removeLiquidity(axfer,uint64,uint64,uint64)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.removeLiquidity(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      swap(args: MethodArgs<'swap(uint64,uint64,txn,uint64,uint64,uint64)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.swap(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      calculateDistributedLiquidity(args: MethodArgs<'calculateDistributedLiquidity(uint64,uint256)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.calculateDistributedLiquidity(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      calculateLiquidity(args: MethodArgs<'calculateLiquidity(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.calculateLiquidity(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      calculatePrice(args: MethodArgs<'calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.calculatePrice(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      calculateAssetBWithdrawOnAssetADeposit(args: MethodArgs<'calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.calculateAssetBWithdrawOnAssetADeposit(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      calculateAssetAWithdrawOnAssetBDeposit(args: MethodArgs<'calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.calculateAssetAWithdrawOnAssetBDeposit(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      calculateAssetAWithdrawOnLpDeposit(args: MethodArgs<'calculateAssetAWithdrawOnLpDeposit(uint256,uint256,uint256)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.calculateAssetAWithdrawOnLpDeposit(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      calculateAssetBWithdrawOnLpDeposit(args: MethodArgs<'calculateAssetBWithdrawOnLpDeposit(uint256,uint256,uint256)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.calculateAssetBWithdrawOnLpDeposit(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      calculateAssetBDepositOnAssetADeposit(args: MethodArgs<'calculateAssetBDepositOnAssetADeposit(uint256,uint256,uint256,uint256)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.calculateAssetBDepositOnAssetADeposit(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      calculateAssetADepositOnAssetBDeposit(args: MethodArgs<'calculateAssetADepositOnAssetBDeposit(uint256,uint256,uint256,uint256)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.calculateAssetADepositOnAssetBDeposit(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      status(args: MethodArgs<'status(uint64,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.status(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {
        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))
        return this
      },
      async atc() {
        await promiseChain
        return atc
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await atc.simulate(client.algod, new modelsv2.SimulateRequest({ txnGroups: [], ...options }))
        return {
          ...result,
          returns: result.methodResults?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      },
      async execute() {
        await promiseChain
        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams: {} }, client.algod)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      }
    } as unknown as BiatecClammPoolComposer
  }
}
export type BiatecClammPoolComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the getCurrentPrice()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getCurrentPrice(args: MethodArgs<'getCurrentPrice()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammPoolComposer<[...TReturns, MethodReturn<'getCurrentPrice()uint64'>]>

  /**
   * Calls the getPriceDivider()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getPriceDivider(args: MethodArgs<'getPriceDivider()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammPoolComposer<[...TReturns, MethodReturn<'getPriceDivider()uint64'>]>

  /**
   * Calls the getLPTokenId()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getLpTokenId(args: MethodArgs<'getLPTokenId()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammPoolComposer<[...TReturns, MethodReturn<'getLPTokenId()uint64'>]>

  /**
   * Calls the bootstrap(uint64,uint64,uint64,uint64,pay,uint64,uint64,uint64,uint64,uint8)uint64 ABI method.
   *
   * Anybody can deploy the clamm smart contract
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  bootstrap(args: MethodArgs<'bootstrap(uint64,uint64,uint64,uint64,pay,uint64,uint64,uint64,uint64,uint8)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammPoolComposer<[...TReturns, MethodReturn<'bootstrap(uint64,uint64,uint64,uint64,pay,uint64,uint64,uint64,uint64,uint8)uint64'>]>

  /**
   * Calls the addLiquidity(uint64,uint64,txn,txn,uint64,uint64,uint64)uint64 ABI method.
   *
   * This method adds Asset A and Asset B to the Automated Market Maker Concentrated Liqudidity Pool and send to the liqudidty provider the liqudity token
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  addLiquidity(args: MethodArgs<'addLiquidity(uint64,uint64,txn,txn,uint64,uint64,uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammPoolComposer<[...TReturns, MethodReturn<'addLiquidity(uint64,uint64,txn,txn,uint64,uint64,uint64)uint64'>]>

  /**
   * Calls the removeLiquidity(axfer,uint64,uint64,uint64)uint256 ABI method.
   *
   * This method retrieves from the liquidity provider LP token and returns Asset A and Asset B from the Automated Market Maker Concentrated Liqudidity Pool
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  removeLiquidity(args: MethodArgs<'removeLiquidity(axfer,uint64,uint64,uint64)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammPoolComposer<[...TReturns, MethodReturn<'removeLiquidity(axfer,uint64,uint64,uint64)uint256'>]>

  /**
   * Calls the swap(uint64,uint64,txn,uint64,uint64,uint64)uint256 ABI method.
   *
   * Swap Asset A to Asset B or Asset B to Asst A
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  swap(args: MethodArgs<'swap(uint64,uint64,txn,uint64,uint64,uint64)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammPoolComposer<[...TReturns, MethodReturn<'swap(uint64,uint64,txn,uint64,uint64,uint64)uint256'>]>

  /**
   * Calls the calculateDistributedLiquidity(uint64,uint256)uint256 ABI method.
   *
   * Calculates the number of LP tokens issued to users
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  calculateDistributedLiquidity(args: MethodArgs<'calculateDistributedLiquidity(uint64,uint256)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammPoolComposer<[...TReturns, MethodReturn<'calculateDistributedLiquidity(uint64,uint256)uint256'>]>

  /**
   * Calls the calculateLiquidity(uint256,uint256,uint256,uint256,uint256,uint256)uint256 ABI method.
   *
   * Calculates the liquidity  from the x - Asset A position and y - Asset B position
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  calculateLiquidity(args: MethodArgs<'calculateLiquidity(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammPoolComposer<[...TReturns, MethodReturn<'calculateLiquidity(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>]>

  /**
   * Calls the calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256 ABI method.
   *
   * Get the current price when asset a has x
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  calculatePrice(args: MethodArgs<'calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammPoolComposer<[...TReturns, MethodReturn<'calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256'>]>

  /**
   * Calls the calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256 ABI method.
   *
   * Calculates how much asset B will be taken from the smart contract on asset A deposit
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  calculateAssetBWithdrawOnAssetADeposit(args: MethodArgs<'calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammPoolComposer<[...TReturns, MethodReturn<'calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>]>

  /**
   * Calls the calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256 ABI method.
   *
   * Calculates how much asset A will be taken from the smart contract on asset B deposit
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  calculateAssetAWithdrawOnAssetBDeposit(args: MethodArgs<'calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammPoolComposer<[...TReturns, MethodReturn<'calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256'>]>

  /**
   * Calls the calculateAssetAWithdrawOnLpDeposit(uint256,uint256,uint256)uint256 ABI method.
   *
   * Calculates how much asset A will be taken from the smart contract on LP asset deposit
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  calculateAssetAWithdrawOnLpDeposit(args: MethodArgs<'calculateAssetAWithdrawOnLpDeposit(uint256,uint256,uint256)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammPoolComposer<[...TReturns, MethodReturn<'calculateAssetAWithdrawOnLpDeposit(uint256,uint256,uint256)uint256'>]>

  /**
   * Calls the calculateAssetBWithdrawOnLpDeposit(uint256,uint256,uint256)uint256 ABI method.
   *
   * Calculates how much asset B will be taken from the smart contract on LP asset deposit
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  calculateAssetBWithdrawOnLpDeposit(args: MethodArgs<'calculateAssetBWithdrawOnLpDeposit(uint256,uint256,uint256)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammPoolComposer<[...TReturns, MethodReturn<'calculateAssetBWithdrawOnLpDeposit(uint256,uint256,uint256)uint256'>]>

  /**
   * Calls the calculateAssetBDepositOnAssetADeposit(uint256,uint256,uint256,uint256)uint256 ABI method.
   *
   * Calculates how much asset B should be deposited when user deposit asset a and b.On deposit min(calculateAssetBDepositOnAssetADeposit, calculateAssetADepositOnAssetBDeposit) should be considered for the real deposit and rest should be swapped or returned back to user
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  calculateAssetBDepositOnAssetADeposit(args: MethodArgs<'calculateAssetBDepositOnAssetADeposit(uint256,uint256,uint256,uint256)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammPoolComposer<[...TReturns, MethodReturn<'calculateAssetBDepositOnAssetADeposit(uint256,uint256,uint256,uint256)uint256'>]>

  /**
   * Calls the calculateAssetADepositOnAssetBDeposit(uint256,uint256,uint256,uint256)uint256 ABI method.
   *
   * Calculates how much asset A should be deposited when user deposit asset a and bOn deposit min(calculateAssetBDepositOnAssetADeposit, calculateAssetADepositOnAssetBDeposit) should be considered for the real deposit and rest should be swapped or returned back to user
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  calculateAssetADepositOnAssetBDeposit(args: MethodArgs<'calculateAssetADepositOnAssetBDeposit(uint256,uint256,uint256,uint256)uint256'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammPoolComposer<[...TReturns, MethodReturn<'calculateAssetADepositOnAssetBDeposit(uint256,uint256,uint256,uint256)uint256'>]>

  /**
   * Calls the status(uint64,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  status(args: MethodArgs<'status(uint64,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'>, params?: AppClientCallCoreParams & CoreAppCallArgs): BiatecClammPoolComposer<[...TReturns, MethodReturn<'status(uint64,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'>]>

  /**
   * Makes a clear_state call to an existing instance of the BiatecClammPool smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs): BiatecClammPoolComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)
   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.
   */
  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): BiatecClammPoolComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  atc(): Promise<AtomicTransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(options?: SimulateOptions): Promise<BiatecClammPoolComposerSimulateResult<TReturns>>
  /**
   * Executes the transaction group and returns the results
   */
  execute(): Promise<BiatecClammPoolComposerResults<TReturns>>
}
export type SimulateOptions = Omit<ConstructorParameters<typeof modelsv2.SimulateRequest>[0], 'txnGroups'>
export type BiatecClammPoolComposerSimulateResult<TReturns extends [...any[]]> = {
  returns: TReturns
  methodResults: ABIResult[]
  simulateResponse: modelsv2.SimulateResponse
}
export type BiatecClammPoolComposerResults<TReturns extends [...any[]]> = {
  returns: TReturns
  groupId: string
  txIds: string[]
  transactions: Transaction[]
}

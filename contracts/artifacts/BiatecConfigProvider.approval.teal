#pragma version 10

// This TEAL was generated by TEALScript v0.97.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_UpdateApplication *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	int 1
	return

// createApplication(): void
//
// Initial setup
createApplication:
	proto 0 0

	// contracts\BiatecConfigProvider.algo.ts:61
	// this.version.value = version
	byte 0x7363766572 // "scver"
	byte "BIATEC-CONFIG-01-01-01"
	app_global_put

	// contracts\BiatecConfigProvider.algo.ts:62
	// this.addressExecutive.value = this.txn.sender
	byte 0x65 // "e"
	txn Sender
	app_global_put

	// contracts\BiatecConfigProvider.algo.ts:63
	// this.addressGov.value = this.txn.sender
	byte 0x67 // "g"
	txn Sender
	app_global_put

	// contracts\BiatecConfigProvider.algo.ts:64
	// this.addressUdpater.value = this.txn.sender
	byte 0x75 // "u"
	txn Sender
	app_global_put

	// contracts\BiatecConfigProvider.algo.ts:65
	// this.addressExecutiveFee.value = this.txn.sender
	byte 0x6566 // "ef"
	txn Sender
	app_global_put

	// contracts\BiatecConfigProvider.algo.ts:66
	// this.suspended.value = 0
	byte 0x73 // "s"
	int 0
	app_global_put
	retsub

// updateApplication(byte[])void
*abi_route_updateApplication:
	// newVersion: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute updateApplication(byte[])void
	callsub updateApplication
	int 1
	return

// updateApplication(newVersion: bytes): void
//
// addressUdpater from global biatec configuration is allowed to update application
updateApplication:
	proto 1 0

	// contracts\BiatecConfigProvider.algo.ts:73
	// assert(
	//       this.txn.sender === this.addressUdpater.value,
	//       'Only addressUdpater setup in the config can update application'
	//     )
	txn Sender
	byte 0x75 // "u"
	app_global_get
	==

	// Only addressUdpater setup in the config can update application
	assert

	// contracts\BiatecConfigProvider.algo.ts:77
	// this.version.value = newVersion
	byte 0x7363766572 // "scver"
	frame_dig -1 // newVersion: bytes
	app_global_put
	retsub

// bootstrap(uint256,uint64,uint64)void
*abi_route_bootstrap:
	// appBiatecPoolProvider: uint64
	txna ApplicationArgs 3
	btoi

	// appBiatecIdentityProvider: uint64
	txna ApplicationArgs 2
	btoi

	// biatecFee: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 2 (biatecFee) for bootstrap must be a uint256
	assert

	// execute bootstrap(uint256,uint64,uint64)void
	callsub bootstrap
	int 1
	return

// bootstrap(biatecFee: uint256, appBiatecIdentityProvider: AppID, appBiatecPoolProvider: AppID): void
//
// Setup the contract
// @param biatecFee Biatec fees
bootstrap:
	proto 3 0

	// contracts\BiatecConfigProvider.algo.ts:85
	// assert(this.txn.sender === this.addressUdpater.value, 'Only updater can call bootstrap method')
	txn Sender
	byte 0x75 // "u"
	app_global_get
	==

	// Only updater can call bootstrap method
	assert

	// contracts\BiatecConfigProvider.algo.ts:86
	// assert(biatecFee <= (SCALE as uint256) / 2, 'Biatec cannot set fees higher then 50% of lp fees')
	frame_dig -1 // biatecFee: uint256
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	byte 0x0000000000000000000000000000000000000000000000000000000000000002
	b/
	b<=

	// Biatec cannot set fees higher then 50% of lp fees
	assert

	// contracts\BiatecConfigProvider.algo.ts:87
	// this.biatecFee.value = biatecFee
	byte 0x66 // "f"
	frame_dig -1 // biatecFee: uint256
	app_global_put

	// contracts\BiatecConfigProvider.algo.ts:88
	// this.appBiatecIdentityProvider.value = appBiatecIdentityProvider
	byte 0x69 // "i"
	frame_dig -2 // appBiatecIdentityProvider: AppID
	app_global_put

	// contracts\BiatecConfigProvider.algo.ts:89
	// this.appBiatecPoolProvider.value = appBiatecPoolProvider
	byte 0x70 // "p"
	frame_dig -3 // appBiatecPoolProvider: AppID
	app_global_put
	retsub

// setAddressUdpater(address)void
*abi_route_setAddressUdpater:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for setAddressUdpater must be a address
	assert

	// execute setAddressUdpater(address)void
	callsub setAddressUdpater
	int 1
	return

// setAddressUdpater(a: Address): void
//
// Top secret account with which it is possible update contracts or identity provider
//
// @param a Address
setAddressUdpater:
	proto 1 0

	// contracts\BiatecConfigProvider.algo.ts:98
	// assert(this.txn.sender === this.addressUdpater.value, 'Only updater can change updater address')
	txn Sender
	byte 0x75 // "u"
	app_global_get
	==

	// Only updater can change updater address
	assert

	// contracts\BiatecConfigProvider.algo.ts:99
	// this.addressUdpater.value = a
	byte 0x75 // "u"
	frame_dig -1 // a: Address
	app_global_put
	retsub

// setPaused(uint64)void
*abi_route_setPaused:
	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute setPaused(uint64)void
	callsub setPaused
	int 1
	return

// setPaused(a: uint64): void
//
// Kill switch. In the extreme case all services (deposit, trading, withdrawal, identity modifications and more) can be suspended.
//
// @param a Address
setPaused:
	proto 1 0

	// contracts\BiatecConfigProvider.algo.ts:108
	// assert(this.txn.sender === this.addressUdpater.value, 'Only updater can pause and unpause the biatec services')
	txn Sender
	byte 0x75 // "u"
	app_global_get
	==

	// Only updater can pause and unpause the biatec services
	assert

	// contracts\BiatecConfigProvider.algo.ts:109
	// this.suspended.value = a
	byte 0x73 // "s"
	frame_dig -1 // a: uint64
	app_global_put
	retsub

// setAddressGov(address)void
*abi_route_setAddressGov:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for setAddressGov must be a address
	assert

	// execute setAddressGov(address)void
	callsub setAddressGov
	int 1
	return

// setAddressGov(a: Address): void
//
// Execution address with which it is possible to opt in for governance
//
// @param a Address
setAddressGov:
	proto 1 0

	// contracts\BiatecConfigProvider.algo.ts:118
	// assert(this.txn.sender === this.addressUdpater.value, 'Only updater can change gov address')
	txn Sender
	byte 0x75 // "u"
	app_global_get
	==

	// Only updater can change gov address
	assert

	// contracts\BiatecConfigProvider.algo.ts:119
	// this.addressGov.value = a
	byte 0x67 // "g"
	frame_dig -1 // a: Address
	app_global_put
	retsub

// setAddressExecutive(address)void
*abi_route_setAddressExecutive:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for setAddressExecutive must be a address
	assert

	// execute setAddressExecutive(address)void
	callsub setAddressExecutive
	int 1
	return

// setAddressExecutive(a: Address): void
//
// Execution address with which it is possible to change global biatec fees
//
// @param a Address
setAddressExecutive:
	proto 1 0

	// contracts\BiatecConfigProvider.algo.ts:128
	// assert(this.txn.sender === this.addressUdpater.value, 'Only updater can change addressExecutive')
	txn Sender
	byte 0x75 // "u"
	app_global_get
	==

	// Only updater can change addressExecutive
	assert

	// contracts\BiatecConfigProvider.algo.ts:129
	// this.addressExecutive.value = a
	byte 0x65 // "e"
	frame_dig -1 // a: Address
	app_global_put
	retsub

// setAddressExecutiveFee(address)void
*abi_route_setAddressExecutiveFee:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for setAddressExecutiveFee must be a address
	assert

	// execute setAddressExecutiveFee(address)void
	callsub setAddressExecutiveFee
	int 1
	return

// setAddressExecutiveFee(a: Address): void
//
// Execution fee address is address which can take fees from pools.
//
// @param a Address
setAddressExecutiveFee:
	proto 1 0

	// contracts\BiatecConfigProvider.algo.ts:138
	// assert(this.txn.sender === this.addressExecutive.value, 'Only addressExecutive can change fee executor address')
	txn Sender
	byte 0x65 // "e"
	app_global_get
	==

	// Only addressExecutive can change fee executor address
	assert

	// contracts\BiatecConfigProvider.algo.ts:139
	// this.addressExecutiveFee.value = a
	byte 0x6566 // "ef"
	frame_dig -1 // a: Address
	app_global_put
	retsub

// setBiatecIdentity(uint64)void
*abi_route_setBiatecIdentity:
	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute setBiatecIdentity(uint64)void
	callsub setBiatecIdentity
	int 1
	return

// setBiatecIdentity(a: AppID): void
//
// App identity setter
//
// @param a Address
setBiatecIdentity:
	proto 1 0

	// contracts\BiatecConfigProvider.algo.ts:148
	// assert(this.txn.sender === this.addressUdpater.value, 'Only updater can change appIdentityProvider')
	txn Sender
	byte 0x75 // "u"
	app_global_get
	==

	// Only updater can change appIdentityProvider
	assert

	// contracts\BiatecConfigProvider.algo.ts:149
	// this.appBiatecIdentityProvider.value = a
	byte 0x69 // "i"
	frame_dig -1 // a: AppID
	app_global_put
	retsub

// setBiatecPool(uint64)void
*abi_route_setBiatecPool:
	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute setBiatecPool(uint64)void
	callsub setBiatecPool
	int 1
	return

// setBiatecPool(a: AppID): void
//
// App identity setter
//
// @param a Address
setBiatecPool:
	proto 1 0

	// contracts\BiatecConfigProvider.algo.ts:158
	// assert(this.txn.sender === this.addressUdpater.value, 'Only updater can change appPoolProvider')
	txn Sender
	byte 0x75 // "u"
	app_global_get
	==

	// Only updater can change appPoolProvider
	assert

	// contracts\BiatecConfigProvider.algo.ts:159
	// this.appBiatecPoolProvider.value = a
	byte 0x70 // "p"
	frame_dig -1 // a: AppID
	app_global_put
	retsub

// setBiatecFee(uint256)void
*abi_route_setBiatecFee:
	// biatecFee: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (biatecFee) for setBiatecFee must be a uint256
	assert

	// execute setBiatecFee(uint256)void
	callsub setBiatecFee
	int 1
	return

// setBiatecFee(biatecFee: uint256): void
//
// Fees in 9 decimals. 1_000_000_000 = 100%
// Fees in 9 decimals. 10_000_000 = 1%
// Fees in 9 decimals. 100_000 = 0,01%
//
// Fees are respectful from the all fees taken to the LP providers. If LPs charge 1% fee, and biatec charges 10% fee, LP will receive 0.09% fee and biatec 0.01% fee
//
// @param biatecFee Fee
setBiatecFee:
	proto 1 0

	// contracts\BiatecConfigProvider.algo.ts:172
	// assert(this.txn.sender === this.addressExecutive.value, 'Only executive address can change fees')
	txn Sender
	byte 0x65 // "e"
	app_global_get
	==

	// Only executive address can change fees
	assert

	// contracts\BiatecConfigProvider.algo.ts:173
	// assert(biatecFee <= (SCALE as uint256) / 2, 'Biatec cannot set fees higher then 50% of lp fees')
	frame_dig -1 // biatecFee: uint256
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	byte 0x0000000000000000000000000000000000000000000000000000000000000002
	b/
	b<=

	// Biatec cannot set fees higher then 50% of lp fees
	assert

	// contracts\BiatecConfigProvider.algo.ts:174
	// this.biatecFee.value = biatecFee
	byte 0x66 // "f"
	frame_dig -1 // biatecFee: uint256
	app_global_put
	retsub

// sendOnlineKeyRegistration(byte[],byte[],byte[],uint64,uint64,uint64)void
*abi_route_sendOnlineKeyRegistration:
	// voteKeyDilution: uint64
	txna ApplicationArgs 6
	btoi

	// voteLast: uint64
	txna ApplicationArgs 5
	btoi

	// voteFirst: uint64
	txna ApplicationArgs 4
	btoi

	// stateProofPK: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// selectionPK: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// votePK: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute sendOnlineKeyRegistration(byte[],byte[],byte[],uint64,uint64,uint64)void
	callsub sendOnlineKeyRegistration
	int 1
	return

// sendOnlineKeyRegistration(votePK: bytes, selectionPK: bytes, stateProofPK: bytes, voteFirst: uint64, voteLast: uint64, voteKeyDilution: uint64): void
//
// addressExecutiveFee can perfom key registration for this LP pool
//
// Only addressExecutiveFee is allowed to execute this method.
sendOnlineKeyRegistration:
	proto 6 0

	// contracts\BiatecConfigProvider.algo.ts:190
	// assert(
	//       this.txn.sender === this.addressExecutiveFee.value,
	//       'Only fee executor setup in the config can take the collected fees'
	//     )
	txn Sender
	byte 0x6566 // "ef"
	app_global_get
	==

	// Only fee executor setup in the config can take the collected fees
	assert

	// contracts\BiatecConfigProvider.algo.ts:194
	// sendOnlineKeyRegistration({
	//       selectionPK: selectionPK,
	//       stateProofPK: stateProofPK,
	//       voteFirst: voteFirst,
	//       voteKeyDilution: voteKeyDilution,
	//       voteLast: voteLast,
	//       votePK: votePK,
	//       fee: 0,
	//     })
	itxn_begin
	int keyreg
	itxn_field TypeEnum

	// contracts\BiatecConfigProvider.algo.ts:195
	// selectionPK: selectionPK
	frame_dig -2 // selectionPK: bytes
	itxn_field SelectionPK

	// contracts\BiatecConfigProvider.algo.ts:196
	// stateProofPK: stateProofPK
	frame_dig -3 // stateProofPK: bytes
	itxn_field StateProofPK

	// contracts\BiatecConfigProvider.algo.ts:197
	// voteFirst: voteFirst
	frame_dig -4 // voteFirst: uint64
	itxn_field VoteFirst

	// contracts\BiatecConfigProvider.algo.ts:198
	// voteKeyDilution: voteKeyDilution
	frame_dig -6 // voteKeyDilution: uint64
	itxn_field VoteKeyDilution

	// contracts\BiatecConfigProvider.algo.ts:199
	// voteLast: voteLast
	frame_dig -5 // voteLast: uint64
	itxn_field VoteLast

	// contracts\BiatecConfigProvider.algo.ts:200
	// votePK: votePK
	frame_dig -1 // votePK: bytes
	itxn_field VotePK

	// contracts\BiatecConfigProvider.algo.ts:201
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// withdrawExcessAssets(uint64,uint64)uint64
*abi_route_withdrawExcessAssets:
	// The ABI return prefix
	byte 0x151f7c75

	// amount: uint64
	txna ApplicationArgs 2
	btoi

	// asset: uint64
	txna ApplicationArgs 1
	btoi

	// execute withdrawExcessAssets(uint64,uint64)uint64
	callsub withdrawExcessAssets
	itob
	concat
	log
	int 1
	return

// withdrawExcessAssets(asset: AssetID, amount: uint64): uint64
//
// If someone deposits excess assets to this smart contract biatec can use them.
//
// Only addressExecutiveFee is allowed to execute this method.
//
// @param asset Asset to withdraw. If native token, then zero
// @param amount Amount of the asset to be withdrawn
withdrawExcessAssets:
	proto 2 1

	// contracts\BiatecConfigProvider.algo.ts:214
	// assert(
	//       this.txn.sender === this.addressExecutiveFee.value,
	//       'Only fee executor setup in the config can take the collected fees'
	//     )
	txn Sender
	byte 0x6566 // "ef"
	app_global_get
	==

	// Only fee executor setup in the config can take the collected fees
	assert

	// contracts\BiatecConfigProvider.algo.ts:219
	// this.doAxfer(this.txn.sender, asset, amount)
	frame_dig -2 // amount: uint64
	frame_dig -1 // asset: AssetID
	txn Sender
	callsub doAxfer

	// contracts\BiatecConfigProvider.algo.ts:221
	// return amount;
	frame_dig -2 // amount: uint64
	retsub

// doAxfer(receiver: Address, asset: AssetID, amount: uint64): void
//
// Executes xfer of pay payment methods to specified receiver from smart contract aggregated account with specified asset and amount in tokens decimals
// @param receiver Receiver
// @param asset Asset. Zero for algo
// @param amount Amount to transfer
doAxfer:
	proto 3 0

	// *if0_condition
	// contracts\BiatecConfigProvider.algo.ts:231
	// asset.id === 0
	frame_dig -2 // asset: AssetID
	int 0
	==
	bz *if0_else

	// *if0_consequent
	// contracts\BiatecConfigProvider.algo.ts:232
	// sendPayment({
	//         receiver: receiver,
	//         amount: amount,
	//         fee: 0,
	//       })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts\BiatecConfigProvider.algo.ts:233
	// receiver: receiver
	frame_dig -1 // receiver: Address
	itxn_field Receiver

	// contracts\BiatecConfigProvider.algo.ts:234
	// amount: amount
	frame_dig -3 // amount: uint64
	itxn_field Amount

	// contracts\BiatecConfigProvider.algo.ts:235
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if0_end

*if0_else:
	// contracts\BiatecConfigProvider.algo.ts:238
	// sendAssetTransfer({
	//         assetReceiver: receiver,
	//         xferAsset: asset,
	//         assetAmount: amount,
	//         fee: 0,
	//       })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts\BiatecConfigProvider.algo.ts:239
	// assetReceiver: receiver
	frame_dig -1 // receiver: Address
	itxn_field AssetReceiver

	// contracts\BiatecConfigProvider.algo.ts:240
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// contracts\BiatecConfigProvider.algo.ts:241
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// contracts\BiatecConfigProvider.algo.ts:242
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if0_end:
	retsub

*create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	method "bootstrap(uint256,uint64,uint64)void"
	method "setAddressUdpater(address)void"
	method "setPaused(uint64)void"
	method "setAddressGov(address)void"
	method "setAddressExecutive(address)void"
	method "setAddressExecutiveFee(address)void"
	method "setBiatecIdentity(uint64)void"
	method "setBiatecPool(uint64)void"
	method "setBiatecFee(uint256)void"
	method "sendOnlineKeyRegistration(byte[],byte[],byte[],uint64,uint64,uint64)void"
	method "withdrawExcessAssets(uint64,uint64)uint64"
	txna ApplicationArgs 0
	match *abi_route_bootstrap *abi_route_setAddressUdpater *abi_route_setPaused *abi_route_setAddressGov *abi_route_setAddressExecutive *abi_route_setAddressExecutiveFee *abi_route_setBiatecIdentity *abi_route_setBiatecPool *abi_route_setBiatecFee *abi_route_sendOnlineKeyRegistration *abi_route_withdrawExcessAssets

	// this contract does not implement the given ABI method for call NoOp
	err

*call_UpdateApplication:
	method "updateApplication(byte[])void"
	txna ApplicationArgs 0
	match *abi_route_updateApplication

	// this contract does not implement the given ABI method for call UpdateApplication
	err
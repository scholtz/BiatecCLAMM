#pragma version 10
intcblock 0 1 32 2 64 1000000000 816 50 52
bytecblock 0x 0x0000000000000000 0x00 0x69 0x42 0x73 0x151f7c75 0x30303030303030302d303030302d303030302d303030302d303030303030303030303030 0x0000000077359400 0x000000003b9aca00 0x7363766572 0x6566 0x0068 0x0000 0x65

// This TEAL was generated by TEALScript v0.106.3
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_UpdateApplication *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	intc 1 // 1
	return

// createApplication(): void
//
// Initial setup
createApplication:
	proto 0 0

	// contracts/BiatecIdentityProvider.algo.ts:207
	// this.version.value = version
	bytec 10 //  "scver"
	pushbytes "BIATEC-IDENT-01-03-01"
	app_global_put
	retsub

// bootstrap(uint64,address,address,address)void
*abi_route_bootstrap:
	// engagementSetter: address
	txna ApplicationArgs 4
	dup
	len
	intc 2 // 32
	==

	// argument 0 (engagementSetter) for bootstrap must be a address
	assert

	// verificationSetter: address
	txna ApplicationArgs 3
	dup
	len
	intc 2 // 32
	==

	// argument 1 (verificationSetter) for bootstrap must be a address
	assert

	// governor: address
	txna ApplicationArgs 2
	dup
	len
	intc 2 // 32
	==

	// argument 2 (governor) for bootstrap must be a address
	assert

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute bootstrap(uint64,address,address,address)void
	callsub bootstrap
	intc 1 // 1
	return

// bootstrap(appBiatecConfigProvider: AppID, governor: Address, verificationSetter: Address, engagementSetter: Address): void
//
// Biatec deploys single identity provider smart contract
// @param appBiatecConfigProvider Biatec amm provider
bootstrap:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/BiatecIdentityProvider.algo.ts:220
	// assert(this.txn.sender === this.app.creator, 'Only creator of the app can set it up')
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==

	// Only creator of the app can set it up
	assert

	// contracts/BiatecIdentityProvider.algo.ts:221
	// this.appBiatecConfigProvider.value = appBiatecConfigProvider
	bytec 4 //  "B"
	frame_dig -1 // appBiatecConfigProvider: AppID
	app_global_put

	// contracts/BiatecIdentityProvider.algo.ts:222
	// this.governor.value = governor
	pushbytes 0x67 // "g"
	frame_dig -2 // governor: Address
	app_global_put

	// contracts/BiatecIdentityProvider.algo.ts:223
	// this.verificationSetter.value = verificationSetter
	pushbytes 0x76 // "v"
	frame_dig -3 // verificationSetter: Address
	app_global_put

	// contracts/BiatecIdentityProvider.algo.ts:224
	// this.engagementSetter.value = engagementSetter
	bytec 14 //  "e"
	frame_dig -4 // engagementSetter: Address
	app_global_put

	// contracts/BiatecIdentityProvider.algo.ts:226
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 5 //  "s"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('s')
	assert
	frame_bury 0 // paused: uint64

	// contracts/BiatecIdentityProvider.algo.ts:227
	// assert(paused === 0, 'ERR_PAUSED')
	frame_dig 0 // paused: uint64
	intc 0 // 0
	==

	// ERR_PAUSED
	assert
	retsub

// updateApplication(uint64,byte[])void
*abi_route_updateApplication:
	// newVersion: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateApplication(uint64,byte[])void
	callsub updateApplication
	intc 1 // 1
	return

// updateApplication(appBiatecConfigProvider: AppID, newVersion: bytes): void
//
// addressUdpater from global biatec configuration is allowed to update application
updateApplication:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/BiatecIdentityProvider.algo.ts:234
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value, 'Configuration app does not match')
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 4 //  "B"
	app_global_get
	==

	// Configuration app does not match
	assert

	// contracts/BiatecIdentityProvider.algo.ts:235
	// addressUdpater = appBiatecConfigProvider.globalState('u') as Address
	frame_dig -1 // appBiatecConfigProvider: AppID
	pushbytes 0x75 // "u"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('u')
	assert
	frame_bury 0 // addressUdpater: address

	// contracts/BiatecIdentityProvider.algo.ts:236
	// assert(this.txn.sender === addressUdpater, 'Only addressUdpater setup in the config can update application')
	txn Sender
	frame_dig 0 // addressUdpater: address
	==

	// Only addressUdpater setup in the config can update application
	assert

	// contracts/BiatecIdentityProvider.algo.ts:237
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 5 //  "s"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('s')
	assert
	frame_bury 1 // paused: uint64

	// contracts/BiatecIdentityProvider.algo.ts:238
	// assert(paused === 0, 'ERR_PAUSED')
	frame_dig 1 // paused: uint64
	intc 0 // 0
	==

	// ERR_PAUSED
	assert

	// contracts/BiatecIdentityProvider.algo.ts:239
	// this.version.value = newVersion
	bytec 10 //  "scver"
	frame_dig -2 // newVersion: bytes
	app_global_put
	retsub

// selfRegistration(address,(uint64,bool,uint64,uint64,uint64,uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,bool))void
*abi_route_selfRegistration:
	// info: (uint64,bool,uint64,uint64,uint64,uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,bool)
	txna ApplicationArgs 2

	// user: address
	txna ApplicationArgs 1
	dup
	len
	intc 2 // 32
	==

	// argument 1 (user) for selfRegistration must be a address
	assert

	// execute selfRegistration(address,(uint64,bool,uint64,uint64,uint64,uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,bool))void
	callsub selfRegistration
	intc 1 // 1
	return

// selfRegistration(user: Address, info: IdentityInfo): void
selfRegistration:
	proto 2 0

	// contracts/BiatecIdentityProvider.algo.ts:243
	// assert(!this.identities(user).exists, 'Self registration cannot be executed if address is already registered')
	bytec 3 //  "i"
	frame_dig -1 // user: Address
	concat
	box_len
	swap
	pop
	!

	// Self registration cannot be executed if address is already registered
	assert

	// contracts/BiatecIdentityProvider.algo.ts:246
	// assert(info.verificationStatus === 1, 'Verification status must be empty')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 41 8
	btoi
	intc 1 // 1
	==

	// Verification status must be empty
	assert

	// contracts/BiatecIdentityProvider.algo.ts:248
	// assert(info.verificationClass === 0, 'verificationClass must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	intc 0 // 0
	==

	// verificationClass must equal to 0
	assert

	// contracts/BiatecIdentityProvider.algo.ts:251
	// assert(
	//       info.personUUID === '00000000-0000-0000-0000-000000000000',
	//       'personUUID must equal to 00000000-0000-0000-0000-000000000000'
	//     )
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	intc 7 // 50
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	intc 1 //  get type length
	* // multiply by type length
	intc 3 // 2
	+ // add two for length
	extract3
	extract 2 0
	bytec 7 //  "00000000-0000-0000-0000-000000000000"
	==

	// personUUID must equal to 00000000-0000-0000-0000-000000000000
	assert

	// contracts/BiatecIdentityProvider.algo.ts:256
	// assert(
	//       info.legalEntityUUID === '00000000-0000-0000-0000-000000000000',
	//       'legalEntityUUID must equal to 00000000-0000-0000-0000-000000000000'
	//     )
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	intc 8 // 52
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	intc 1 //  get type length
	* // multiply by type length
	intc 3 // 2
	+ // add two for length
	extract3
	extract 2 0
	bytec 7 //  "00000000-0000-0000-0000-000000000000"
	==

	// legalEntityUUID must equal to 00000000-0000-0000-0000-000000000000
	assert

	// contracts/BiatecIdentityProvider.algo.ts:261
	// assert(info.biatecEngagementPoints === 0, 'biatecEngagementPoints must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 54 8
	btoi
	intc 0 // 0
	==

	// biatecEngagementPoints must equal to 0
	assert

	// contracts/BiatecIdentityProvider.algo.ts:263
	// assert(info.biatecEngagementRank === 0, 'biatecEngagementRank must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 62 8
	btoi
	intc 0 // 0
	==

	// biatecEngagementRank must equal to 0
	assert

	// contracts/BiatecIdentityProvider.algo.ts:265
	// assert(info.avmEngagementPoints === 0, 'avmEngagementPoints must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 70 8
	btoi
	intc 0 // 0
	==

	// avmEngagementPoints must equal to 0
	assert

	// contracts/BiatecIdentityProvider.algo.ts:267
	// assert(info.avmEngagementRank === 0, 'avmEngagementRank must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 78 8
	btoi
	intc 0 // 0
	==

	// avmEngagementRank must equal to 0
	assert

	// contracts/BiatecIdentityProvider.algo.ts:269
	// assert(info.tradingEngagementPoints === 0, 'tradingEngagementPoints must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 86 8
	btoi
	intc 0 // 0
	==

	// tradingEngagementPoints must equal to 0
	assert

	// contracts/BiatecIdentityProvider.algo.ts:271
	// assert(info.tradingEngagementRank === 0, 'tradingEngagementRank must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 94 8
	btoi
	intc 0 // 0
	==

	// tradingEngagementRank must equal to 0
	assert

	// contracts/BiatecIdentityProvider.algo.ts:273
	// assert(info.isLocked === false, 'isLocked must equal to false')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	intc 4 // 64
	getbit
	intc 0 // 0
	==

	// isLocked must equal to false
	assert

	// contracts/BiatecIdentityProvider.algo.ts:275
	// assert(info.kycExpiration === 0, 'kycExpiration must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 25 8
	btoi
	intc 0 // 0
	==

	// kycExpiration must equal to 0
	assert

	// contracts/BiatecIdentityProvider.algo.ts:277
	// assert(info.investorForExpiration === 0, 'investorForExpiration must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 33 8
	btoi
	intc 0 // 0
	==

	// investorForExpiration must equal to 0
	assert

	// contracts/BiatecIdentityProvider.algo.ts:279
	// assert(info.isProfessionalInvestor === false, 'isProfessionalInvestor must equal to false')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	intc 6 // 816
	getbit
	intc 0 // 0
	==

	// isProfessionalInvestor must equal to false
	assert

	// contracts/BiatecIdentityProvider.algo.ts:281
	// assert(info.feeMultiplierBase === SCALE, 'FeeMultiplierBase must be set properly')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 17 8
	btoi
	intc 5 // 1000000000
	==

	// FeeMultiplierBase must be set properly
	assert

	// contracts/BiatecIdentityProvider.algo.ts:282
	// assert(info.feeMultiplier === ((2 * SCALE) as uint64), 'Initial fee multiplier must be set to 2 * SCALE')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 9 8
	btoi
	pushint 2000000000
	==

	// Initial fee multiplier must be set to 2 * SCALE
	assert

	// contracts/BiatecIdentityProvider.algo.ts:283
	// this.identities(user).value = info
	bytec 3 //  "i"
	frame_dig -1 // user: Address
	concat
	dup
	box_del
	pop
	frame_dig -2 // info: IdentityInfo
	box_put
	retsub

// setInfo(address,(uint64,bool,uint64,uint64,uint64,uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,bool))void
*abi_route_setInfo:
	// info: (uint64,bool,uint64,uint64,uint64,uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,bool)
	txna ApplicationArgs 2

	// user: address
	txna ApplicationArgs 1
	dup
	len
	intc 2 // 32
	==

	// argument 1 (user) for setInfo must be a address
	assert

	// execute setInfo(address,(uint64,bool,uint64,uint64,uint64,uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,bool))void
	callsub setInfo
	intc 1 // 1
	return

// setInfo(user: Address, info: IdentityInfo): void
setInfo:
	proto 2 0

	// contracts/BiatecIdentityProvider.algo.ts:287
	// assert(this.txn.sender === this.engagementSetter.value)
	txn Sender
	bytec 14 //  "e"
	app_global_get
	==
	assert

	// contracts/BiatecIdentityProvider.algo.ts:288
	// assert(info.feeMultiplierBase === SCALE, 'FeeMultiplierBase must be set properly')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 17 8
	btoi
	intc 5 // 1000000000
	==

	// FeeMultiplierBase must be set properly
	assert

	// contracts/BiatecIdentityProvider.algo.ts:289
	// this.identities(user).value = info
	bytec 3 //  "i"
	frame_dig -1 // user: Address
	concat
	dup
	box_del
	pop
	frame_dig -2 // info: IdentityInfo
	box_put
	retsub

// sendOnlineKeyRegistration(uint64,byte[],byte[],byte[],uint64,uint64,uint64)void
*abi_route_sendOnlineKeyRegistration:
	// voteKeyDilution: uint64
	txna ApplicationArgs 7
	btoi

	// voteLast: uint64
	txna ApplicationArgs 6
	btoi

	// voteFirst: uint64
	txna ApplicationArgs 5
	btoi

	// stateProofPK: byte[]
	txna ApplicationArgs 4
	extract 2 0

	// selectionPK: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// votePK: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute sendOnlineKeyRegistration(uint64,byte[],byte[],byte[],uint64,uint64,uint64)void
	callsub sendOnlineKeyRegistration
	intc 1 // 1
	return

// sendOnlineKeyRegistration(appBiatecConfigProvider: AppID, votePK: bytes, selectionPK: bytes, stateProofPK: bytes, voteFirst: uint64, voteLast: uint64, voteKeyDilution: uint64): void
//
// addressExecutiveFee can perfom key registration for this LP pool
//
// Only addressExecutiveFee is allowed to execute this method.
sendOnlineKeyRegistration:
	proto 7 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/BiatecIdentityProvider.algo.ts:306
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value, 'Configuration app does not match')
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 4 //  "B"
	app_global_get
	==

	// Configuration app does not match
	assert

	// contracts/BiatecIdentityProvider.algo.ts:307
	// addressExecutiveFee = appBiatecConfigProvider.globalState('ef') as Address
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 11 //  "ef"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('ef')
	assert
	frame_bury 0 // addressExecutiveFee: address

	// contracts/BiatecIdentityProvider.algo.ts:308
	// assert(
	//       this.txn.sender === addressExecutiveFee,
	//       'Only fee executor setup in the config can take the collected fees'
	//     )
	txn Sender
	frame_dig 0 // addressExecutiveFee: address
	==

	// Only fee executor setup in the config can take the collected fees
	assert

	// contracts/BiatecIdentityProvider.algo.ts:312
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 5 //  "s"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('s')
	assert
	frame_bury 1 // paused: uint64

	// contracts/BiatecIdentityProvider.algo.ts:313
	// assert(paused === 0, 'ERR_PAUSED')
	frame_dig 1 // paused: uint64
	intc 0 // 0
	==

	// ERR_PAUSED
	assert

	// contracts/BiatecIdentityProvider.algo.ts:314
	// sendOnlineKeyRegistration({
	//       selectionPK: selectionPK,
	//       stateProofPK: stateProofPK,
	//       voteFirst: voteFirst,
	//       voteKeyDilution: voteKeyDilution,
	//       voteLast: voteLast,
	//       votePK: votePK,
	//       fee: 0,
	//     })
	itxn_begin
	intc 3 //  keyreg
	itxn_field TypeEnum

	// contracts/BiatecIdentityProvider.algo.ts:315
	// selectionPK: selectionPK
	frame_dig -3 // selectionPK: bytes
	itxn_field SelectionPK

	// contracts/BiatecIdentityProvider.algo.ts:316
	// stateProofPK: stateProofPK
	frame_dig -4 // stateProofPK: bytes
	itxn_field StateProofPK

	// contracts/BiatecIdentityProvider.algo.ts:317
	// voteFirst: voteFirst
	frame_dig -5 // voteFirst: uint64
	itxn_field VoteFirst

	// contracts/BiatecIdentityProvider.algo.ts:318
	// voteKeyDilution: voteKeyDilution
	frame_dig -7 // voteKeyDilution: uint64
	itxn_field VoteKeyDilution

	// contracts/BiatecIdentityProvider.algo.ts:319
	// voteLast: voteLast
	frame_dig -6 // voteLast: uint64
	itxn_field VoteLast

	// contracts/BiatecIdentityProvider.algo.ts:320
	// votePK: votePK
	frame_dig -2 // votePK: bytes
	itxn_field VotePK

	// contracts/BiatecIdentityProvider.algo.ts:321
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// getUser(address,uint8)(uint8,uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64,bool)
*abi_route_getUser:
	// The ABI return prefix
	bytec 6 // 0x151f7c75

	// v: uint8
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 0 (v) for getUser must be a uint8
	assert
	btoi

	// user: address
	txna ApplicationArgs 1
	dup
	len
	intc 2 // 32
	==

	// argument 1 (user) for getUser must be a address
	assert

	// execute getUser(address,uint8)(uint8,uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64,bool)
	callsub getUser
	concat
	log
	intc 1 // 1
	return

// getUser(user: Address, v: uint8): UserInfoV1
//
// Returns user information - fee multiplier, verification class, engagement class ..
//
// @param user Get info for specific user address
// @param v Version of the data structure to return
getUser:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts/BiatecIdentityProvider.algo.ts:333
	// assert(v === 1, "Currently supported version of the data structure is '1'")
	frame_dig -2 // v: uint8
	intc 1 // 1
	==

	// Currently supported version of the data structure is '1'
	assert

	// *if0_condition
	// contracts/BiatecIdentityProvider.algo.ts:334
	// !this.identities(user).exists
	bytec 3 //  "i"
	frame_dig -1 // user: Address
	concat
	box_len
	swap
	pop
	!
	bz *if0_end

	// *if0_consequent
	// contracts/BiatecIdentityProvider.algo.ts:335
	// retNoIdentity: UserInfoV1 = {
	//         version: v,
	//         base: SCALE as uint64,
	//         feeMultiplier: (2 * SCALE) as uint64,
	//         isLocked: false,
	//         verificationClass: 0,
	//         verificationStatus: 0,
	//         biatecEngagementPoints: 0,
	//         biatecEngagementRank: 0,
	//         avmEngagementPoints: 0,
	//         avmEngagementRank: 0,
	//         tradingEngagementPoints: 0,
	//         tradingEngagementRank: 0,
	//         kycExpiration: 0,
	//         investorForExpiration: 0,
	//         isProfessionalInvestor: false,
	//         isCompany: false,
	//         personUUID: '',
	//         legalEntityUUID: '',
	//       }
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 12 //  initial head offset
	frame_dig -2 // v: uint8
	itob
	extract 7 1
	callsub *process_static_tuple_element
	bytec 1 // 0x0000000000000000
	callsub *process_static_tuple_element
	bytec 1 // 0x0000000000000000
	callsub *process_static_tuple_element
	bytec 2 // 0x00
	intc 0 // 0
	dup
	setbit
	callsub *process_static_tuple_element
	bytec 13 // 0x0000
	callsub *process_dynamic_tuple_element
	bytec 13 // 0x0000
	callsub *process_dynamic_tuple_element
	bytec 1 // 0x0000000000000000
	callsub *process_static_tuple_element
	bytec 1 // 0x0000000000000000
	callsub *process_static_tuple_element
	bytec 1 // 0x0000000000000000
	callsub *process_static_tuple_element
	bytec 1 // 0x0000000000000000
	callsub *process_static_tuple_element
	bytec 1 // 0x0000000000000000
	callsub *process_static_tuple_element
	bytec 1 // 0x0000000000000000
	callsub *process_static_tuple_element
	bytec 8 // 0x0000000077359400
	callsub *process_static_tuple_element
	bytec 9 // 0x000000003b9aca00
	callsub *process_static_tuple_element
	bytec 2 // 0x00
	intc 0 // 0
	dup
	setbit
	callsub *process_static_tuple_element
	bytec 1 // 0x0000000000000000
	callsub *process_static_tuple_element
	bytec 1 // 0x0000000000000000
	callsub *process_static_tuple_element
	bytec 2 // 0x00
	intc 0 // 0
	dup
	setbit
	callsub *process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 0 // retNoIdentity: UserInfoV1

	// contracts/BiatecIdentityProvider.algo.ts:355
	// return retNoIdentity;
	frame_dig 0 // retNoIdentity: UserInfoV1
	b *getUser*return

*if0_end:
	// contracts/BiatecIdentityProvider.algo.ts:357
	// identity = this.identities(user).value
	bytec 3 //  "i"
	frame_dig -1 // user: Address
	concat
	frame_bury 1 // storage key//identity

	// contracts/BiatecIdentityProvider.algo.ts:359
	// ret: UserInfoV1 = {
	//       version: v,
	//       base: identity.feeMultiplierBase,
	//       feeMultiplier: identity.feeMultiplier,
	//       isLocked: identity.isLocked,
	//       verificationClass: identity.verificationClass,
	//       verificationStatus: identity.verificationStatus,
	//       biatecEngagementPoints: identity.biatecEngagementPoints,
	//       biatecEngagementRank: identity.biatecEngagementRank,
	//       avmEngagementPoints: identity.avmEngagementPoints,
	//       avmEngagementRank: identity.avmEngagementRank,
	//       tradingEngagementPoints: identity.tradingEngagementPoints,
	//       tradingEngagementRank: identity.tradingEngagementRank,
	//       kycExpiration: identity.kycExpiration,
	//       investorForExpiration: identity.investorForExpiration,
	//       isProfessionalInvestor: identity.isProfessionalInvestor,
	//       isCompany: identity.isCompany,
	//       personUUID: identity.personUUID,
	//       legalEntityUUID: identity.legalEntityUUID,
	//     }
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 12 //  initial head offset
	frame_dig -2 // v: uint8
	itob
	extract 7 1
	callsub *process_static_tuple_element
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	extract 41 8
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	itob
	callsub *process_static_tuple_element
	bytec 2 // 0x00
	intc 0 // 0
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	pushint 392
	getbit
	setbit
	callsub *process_static_tuple_element
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	intc 7 // 50
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	intc 1 //  get type length
	* // multiply by type length
	intc 3 // 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	intc 8 // 52
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	intc 1 //  get type length
	* // multiply by type length
	intc 3 // 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	extract 54 8
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	extract 62 8
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	extract 70 8
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	extract 78 8
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	extract 86 8
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	extract 94 8
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	extract 9 8
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	extract 17 8
	btoi
	itob
	callsub *process_static_tuple_element
	bytec 2 // 0x00
	intc 0 // 0
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	intc 4 // 64
	getbit
	setbit
	callsub *process_static_tuple_element
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	extract 25 8
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	extract 33 8
	btoi
	itob
	callsub *process_static_tuple_element
	bytec 2 // 0x00
	intc 0 // 0
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	intc 6 // 816
	getbit
	setbit
	callsub *process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 2 // ret: UserInfoV1

	// contracts/BiatecIdentityProvider.algo.ts:379
	// return ret;
	frame_dig 2 // ret: UserInfoV1

*getUser*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// getUserShort(address,uint8)(uint8,uint64,uint64,uint64,bool)
*abi_route_getUserShort:
	// The ABI return prefix
	bytec 6 // 0x151f7c75

	// v: uint8
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 0 (v) for getUserShort must be a uint8
	assert
	btoi

	// user: address
	txna ApplicationArgs 1
	dup
	len
	intc 2 // 32
	==

	// argument 1 (user) for getUserShort must be a address
	assert

	// execute getUserShort(address,uint8)(uint8,uint64,uint64,uint64,bool)
	callsub getUserShort
	concat
	log
	intc 1 // 1
	return

// getUserShort(user: Address, v: uint8): UserInfoShortV1
//
// Returns short user information - fee multiplier, verification class, engagement class ..
//
// @param user Get info for specific user address
// @param v Version of the data structure to return
getUserShort:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts/BiatecIdentityProvider.algo.ts:390
	// assert(v === 1, "Currently supported version of the data structure is '1'")
	frame_dig -2 // v: uint8
	intc 1 // 1
	==

	// Currently supported version of the data structure is '1'
	assert

	// *if1_condition
	// contracts/BiatecIdentityProvider.algo.ts:391
	// !this.identities(user).exists
	bytec 3 //  "i"
	frame_dig -1 // user: Address
	concat
	box_len
	swap
	pop
	!
	bz *if1_end

	// *if1_consequent
	// contracts/BiatecIdentityProvider.algo.ts:392
	// retNoIdentity: UserInfoShortV1 = {
	//         version: v,
	//         base: SCALE as uint64,
	//         feeMultiplier: (2 * SCALE) as uint64,
	//         isLocked: false,
	//         verificationClass: 0,
	//       }
	frame_dig -2 // v: uint8
	itob
	extract 7 1
	bytec 1 // 0x0000000000000000
	concat
	bytec 8 // 0x0000000077359400
	concat
	bytec 9 // 0x000000003b9aca00
	concat
	bytec 2 // 0x00
	intc 0 // 0
	dup
	setbit
	concat
	frame_bury 0 // retNoIdentity: UserInfoShortV1

	// contracts/BiatecIdentityProvider.algo.ts:399
	// return retNoIdentity;
	frame_dig 0 // retNoIdentity: UserInfoShortV1
	b *getUserShort*return

*if1_end:
	// contracts/BiatecIdentityProvider.algo.ts:401
	// identity = this.identities(user).value
	bytec 3 //  "i"
	frame_dig -1 // user: Address
	concat
	frame_bury 1 // storage key//identity

	// contracts/BiatecIdentityProvider.algo.ts:403
	// ret: UserInfoShortV1 = {
	//       version: v,
	//       base: identity.feeMultiplierBase,
	//       feeMultiplier: identity.feeMultiplier,
	//       isLocked: identity.isLocked,
	//       verificationClass: identity.verificationClass,
	//     }
	frame_dig -2 // v: uint8
	itob
	extract 7 1
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	itob
	concat
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	extract 9 8
	btoi
	itob
	concat
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	extract 17 8
	btoi
	itob
	concat
	bytec 2 // 0x00
	intc 0 // 0
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	intc 4 // 64
	getbit
	setbit
	concat
	frame_bury 2 // ret: UserInfoShortV1

	// contracts/BiatecIdentityProvider.algo.ts:410
	// return ret;
	frame_dig 2 // ret: UserInfoShortV1

*getUserShort*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// withdrawExcessAssets(uint64,uint64,uint64)uint64
*abi_route_withdrawExcessAssets:
	// The ABI return prefix
	bytec 6 // 0x151f7c75

	// amount: uint64
	txna ApplicationArgs 3
	btoi

	// asset: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute withdrawExcessAssets(uint64,uint64,uint64)uint64
	callsub withdrawExcessAssets
	itob
	concat
	log
	intc 1 // 1
	return

// withdrawExcessAssets(appBiatecConfigProvider: AppID, asset: AssetID, amount: uint64): uint64
//
// If someone deposits excess assets to this smart contract biatec can use them.
//
// Only addressExecutiveFee is allowed to execute this method.
//
// @param appBiatecConfigProvider Biatec config app. Only addressExecutiveFee is allowed to execute this method.
// @param asset Asset to withdraw. If native token, then zero
// @param amount Amount of the asset to be withdrawn
withdrawExcessAssets:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/BiatecIdentityProvider.algo.ts:422
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value, 'Configuration app does not match')
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 4 //  "B"
	app_global_get
	==

	// Configuration app does not match
	assert

	// contracts/BiatecIdentityProvider.algo.ts:423
	// addressExecutiveFee = appBiatecConfigProvider.globalState('ef') as Address
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 11 //  "ef"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('ef')
	assert
	frame_bury 0 // addressExecutiveFee: address

	// contracts/BiatecIdentityProvider.algo.ts:424
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 5 //  "s"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('s')
	assert
	frame_bury 1 // paused: uint64

	// contracts/BiatecIdentityProvider.algo.ts:425
	// assert(paused === 0, 'ERR_PAUSED')
	frame_dig 1 // paused: uint64
	intc 0 // 0
	==

	// ERR_PAUSED
	assert

	// contracts/BiatecIdentityProvider.algo.ts:426
	// assert(
	//       this.txn.sender === addressExecutiveFee,
	//       'Only fee executor setup in the config can take the collected fees'
	//     )
	txn Sender
	frame_dig 0 // addressExecutiveFee: address
	==

	// Only fee executor setup in the config can take the collected fees
	assert

	// contracts/BiatecIdentityProvider.algo.ts:431
	// this.doAxfer(this.txn.sender, asset, amount)
	frame_dig -3 // amount: uint64
	frame_dig -2 // asset: AssetID
	txn Sender
	callsub doAxfer

	// contracts/BiatecIdentityProvider.algo.ts:433
	// return amount;
	frame_dig -3 // amount: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// doAxfer(receiver: Address, asset: AssetID, amount: uint64): void
//
// Executes xfer of pay payment methods to specified receiver from smart contract aggregated account with specified asset and amount in tokens decimals
// @param receiver Receiver
// @param asset Asset. Zero for algo
// @param amount Amount to transfer
doAxfer:
	proto 3 0

	// *if2_condition
	// contracts/BiatecIdentityProvider.algo.ts:443
	// asset.id === 0
	frame_dig -2 // asset: AssetID
	intc 0 // 0
	==
	bz *if2_else

	// *if2_consequent
	// contracts/BiatecIdentityProvider.algo.ts:444
	// sendPayment({
	//         receiver: receiver,
	//         amount: amount,
	//         fee: 0,
	//       })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/BiatecIdentityProvider.algo.ts:445
	// receiver: receiver
	frame_dig -1 // receiver: Address
	itxn_field Receiver

	// contracts/BiatecIdentityProvider.algo.ts:446
	// amount: amount
	frame_dig -3 // amount: uint64
	itxn_field Amount

	// contracts/BiatecIdentityProvider.algo.ts:447
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if2_end

*if2_else:
	// contracts/BiatecIdentityProvider.algo.ts:450
	// sendAssetTransfer({
	//         assetReceiver: receiver,
	//         xferAsset: asset,
	//         assetAmount: amount,
	//         fee: 0,
	//       })
	itxn_begin
	pushint 4 // axfer
	itxn_field TypeEnum

	// contracts/BiatecIdentityProvider.algo.ts:451
	// assetReceiver: receiver
	frame_dig -1 // receiver: Address
	itxn_field AssetReceiver

	// contracts/BiatecIdentityProvider.algo.ts:452
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// contracts/BiatecIdentityProvider.algo.ts:453
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// contracts/BiatecIdentityProvider.algo.ts:454
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if2_end:
	retsub

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0xe3bf5c1f // method "bootstrap(uint64,address,address,address)void"
	pushbytes 0xae64c167 // method "selfRegistration(address,(uint64,bool,uint64,uint64,uint64,uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,bool))void"
	pushbytes 0xa48cfbbc // method "setInfo(address,(uint64,bool,uint64,uint64,uint64,uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,bool))void"
	pushbytes 0x83925c17 // method "sendOnlineKeyRegistration(uint64,byte[],byte[],byte[],uint64,uint64,uint64)void"
	pushbytes 0xe8ad1892 // method "getUser(address,uint8)(uint8,uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64,bool)"
	pushbytes 0x127ffb7b // method "getUserShort(address,uint8)(uint8,uint64,uint64,uint64,bool)"
	pushbytes 0xcba2e95d // method "withdrawExcessAssets(uint64,uint64,uint64)uint64"
	txna ApplicationArgs 0
	match *abi_route_bootstrap *abi_route_selfRegistration *abi_route_setInfo *abi_route_sendOnlineKeyRegistration *abi_route_getUser *abi_route_getUserShort *abi_route_withdrawExcessAssets

	// this contract does not implement the given ABI method for call NoOp
	err

*call_UpdateApplication:
	pushbytes 0x5fc885a0 // method "updateApplication(uint64,byte[])void"
	txna ApplicationArgs 0
	match *abi_route_updateApplication

	// this contract does not implement the given ABI method for call UpdateApplication
	err

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub
#pragma version 10

// This TEAL was generated by TEALScript v0.88.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	err

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	int 1
	return

// createApplication(): void
//
// Initial setup
createApplication:
	proto 0 0

	// contracts\BiatecIdentityProvider.algo.ts:149
	// log(version)
	byte "BIATEC-IDENT-01-01-01"
	log
	retsub

// selfRegistration(address,(uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64,bool))void
*abi_route_selfRegistration:
	// info: (uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64,bool)
	txna ApplicationArgs 2

	// user: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute selfRegistration(address,(uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64,bool))void
	callsub selfRegistration
	int 1
	return

// selfRegistration(user: Address, info: IdentityInfo): void
selfRegistration:
	proto 2 0

	// contracts\BiatecIdentityProvider.algo.ts:153
	// assert(!this.identities(user).exists, 'Self registration cannot be executed if address is already registered')
	byte 0x69 // "i"
	frame_dig -1 // user: Address
	concat
	box_len
	swap
	pop
	!

	// Self registration cannot be executed if address is already registered
	assert

	// contracts\BiatecIdentityProvider.algo.ts:156
	// assert(info.verificationStatus === 1, 'Verification status must be empty')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	int 1
	==

	// Verification status must be empty
	assert

	// contracts\BiatecIdentityProvider.algo.ts:158
	// assert(info.verificationClass === 0, 'verificationClass must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	int 0
	==

	// verificationClass must equal to 0
	assert

	// contracts\BiatecIdentityProvider.algo.ts:161
	// assert(
	//       info.personUUID === '00000000-0000-0000-0000-000000000000',
	//       'personUUID must equal to 00000000-0000-0000-0000-000000000000'
	//     )
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	int 17
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	byte 0x30303030303030302d303030302d303030302d303030302d303030303030303030303030 // "00000000-0000-0000-0000-000000000000"
	==

	// personUUID must equal to 00000000-0000-0000-0000-000000000000
	assert

	// contracts\BiatecIdentityProvider.algo.ts:166
	// assert(
	//       info.legalEntityUUID === '00000000-0000-0000-0000-000000000000',
	//       'legalEntityUUID must equal to 00000000-0000-0000-0000-000000000000'
	//     )
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	int 20
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	byte 0x30303030303030302d303030302d303030302d303030302d303030303030303030303030 // "00000000-0000-0000-0000-000000000000"
	==

	// legalEntityUUID must equal to 00000000-0000-0000-0000-000000000000
	assert

	// contracts\BiatecIdentityProvider.algo.ts:171
	// assert(info.biatecEngagementPoints === 0, 'biatecEngagementPoints must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 23 8
	btoi
	int 0
	==

	// biatecEngagementPoints must equal to 0
	assert

	// contracts\BiatecIdentityProvider.algo.ts:173
	// assert(info.biatecEngagementRank === 0, 'biatecEngagementRank must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 32 8
	btoi
	int 0
	==

	// biatecEngagementRank must equal to 0
	assert

	// contracts\BiatecIdentityProvider.algo.ts:175
	// assert(info.avmEngagementPoints === 0, 'avmEngagementPoints must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 41 8
	btoi
	int 0
	==

	// avmEngagementPoints must equal to 0
	assert

	// contracts\BiatecIdentityProvider.algo.ts:177
	// assert(info.avmEngagementRank === 0, 'avmEngagementRank must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 50 8
	btoi
	int 0
	==

	// avmEngagementRank must equal to 0
	assert

	// contracts\BiatecIdentityProvider.algo.ts:179
	// assert(info.tradingEngagementPoints === 0, 'tradingEngagementPoints must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 59 8
	btoi
	int 0
	==

	// tradingEngagementPoints must equal to 0
	assert

	// contracts\BiatecIdentityProvider.algo.ts:181
	// assert(info.tradingEngagementRank === 0, 'tradingEngagementRank must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 68 8
	btoi
	int 0
	==

	// tradingEngagementRank must equal to 0
	assert

	// contracts\BiatecIdentityProvider.algo.ts:183
	// assert(info.isLocked === false, 'isLocked must equal to false')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	int 608
	getbit
	int 0
	==

	// isLocked must equal to false
	assert

	// contracts\BiatecIdentityProvider.algo.ts:185
	// assert(info.kycExpiration === 0, 'kycExpiration must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 77 8
	btoi
	int 0
	==

	// kycExpiration must equal to 0
	assert

	// contracts\BiatecIdentityProvider.algo.ts:187
	// assert(info.investorForExpiration === 0, 'investorForExpiration must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 86 8
	btoi
	int 0
	==

	// investorForExpiration must equal to 0
	assert

	// contracts\BiatecIdentityProvider.algo.ts:189
	// assert(info.isProfessionalInvestor === false, 'isProfessionalInvestor must equal to false')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	int 752
	getbit
	int 0
	==

	// isProfessionalInvestor must equal to false
	assert

	// contracts\BiatecIdentityProvider.algo.ts:191
	// this.identities(user).value = info
	byte 0x69 // "i"
	frame_dig -1 // user: Address
	concat
	dup
	box_del
	pop
	frame_dig -2 // info: IdentityInfo
	box_put
	retsub

// setInfo(address,(uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64,bool))void
*abi_route_setInfo:
	// info: (uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64,bool)
	txna ApplicationArgs 2

	// user: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute setInfo(address,(uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64,bool))void
	callsub setInfo
	int 1
	return

// setInfo(user: Address, info: IdentityInfo): void
setInfo:
	proto 2 0

	// contracts\BiatecIdentityProvider.algo.ts:195
	// assert(this.txn.sender === this.engagementSetter.value)
	txn Sender
	byte 0x65 // "e"
	app_global_get
	==
	assert

	// contracts\BiatecIdentityProvider.algo.ts:196
	// this.identities(user).value = info
	byte 0x69 // "i"
	frame_dig -1 // user: Address
	concat
	dup
	box_del
	pop
	frame_dig -2 // info: IdentityInfo
	box_put
	retsub

// getUser(address,uint8)(uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint256,uint256,bool,uint64,uint64,bool)
*abi_route_getUser:
	// The ABI return prefix
	byte 0x151f7c75

	// v: uint8
	txna ApplicationArgs 2
	dup
	len
	int 1
	==
	assert
	btoi

	// user: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute getUser(address,uint8)(uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint256,uint256,bool,uint64,uint64,bool)
	callsub getUser
	concat
	log
	int 1
	return

// getUser(user: Address, v: uint8): UserInfoV1
//
// Returns user information - fee multiplier, verification class, engagement class ..
//
// @param user Get info for specific user address
// @param v Version of the data structure to return
getUser:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts\BiatecIdentityProvider.algo.ts:207
	// assert(v === 1, "Currently supported version of the data structure is '1'")
	frame_dig -2 // v: uint8
	int 1
	==

	// Currently supported version of the data structure is '1'
	assert

	// *if0_condition
	// contracts\BiatecIdentityProvider.algo.ts:208
	// !this.identities(user).exists
	byte 0x69 // "i"
	frame_dig -1 // user: Address
	concat
	box_len
	swap
	pop
	!
	bz *if0_end

	// *if0_consequent
	// contracts\BiatecIdentityProvider.algo.ts:209
	// retNoIdentity: UserInfoV1 = {
	//         version: v,
	//         base: SCALE as uint256,
	//         feeMultiplier: (2 * SCALE) as uint256,
	//         isLocked: false,
	//         verificationClass: 0,
	//         verificationStatus: 0,
	//         biatecEngagementPoints: 0,
	//         biatecEngagementRank: 0,
	//         avmEngagementPoints: 0,
	//         avmEngagementRank: 0,
	//         tradingEngagementPoints: 0,
	//         tradingEngagementRank: 0,
	//         kycExpiration: 0,
	//         investorForExpiration: 0,
	//         isProfessionalInvestor: false,
	//       }
	frame_dig -2 // v: uint8
	itob
	extract 7 1
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000077359400
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	concat
	byte 0x00
	int 0
	dup
	setbit
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x00
	int 0
	dup
	setbit
	concat
	frame_bury 0 // retNoIdentity: UserInfoV1

	// contracts\BiatecIdentityProvider.algo.ts:226
	// return retNoIdentity;
	frame_dig 0 // retNoIdentity: UserInfoV1

	// set the subroutine return value
	frame_bury 0
	retsub

*if0_end:
	// contracts\BiatecIdentityProvider.algo.ts:228
	// identity = this.identities(user).value
	byte 0x69 // "i"
	frame_dig -1 // user: Address
	concat
	frame_bury 1 // storage key//identity

	// contracts\BiatecIdentityProvider.algo.ts:230
	// ret: UserInfoV1 = {
	//       version: v,
	//       base: SCALE as uint256,
	//       feeMultiplier: (1 * SCALE) as uint256,
	//       isLocked: identity.isLocked,
	//       verificationClass: identity.verificationClass,
	//       verificationStatus: identity.verificationStatus,
	//       biatecEngagementPoints: identity.biatecEngagementPoints,
	//       biatecEngagementRank: identity.biatecEngagementRank,
	//       avmEngagementPoints: identity.avmEngagementPoints,
	//       avmEngagementRank: identity.avmEngagementRank,
	//       tradingEngagementPoints: identity.tradingEngagementPoints,
	//       tradingEngagementRank: identity.tradingEngagementRank,
	//       kycExpiration: identity.kycExpiration,
	//       investorForExpiration: identity.investorForExpiration,
	//       isProfessionalInvestor: identity.isProfessionalInvestor,
	//     }
	frame_dig -2 // v: uint8
	itob
	extract 7 1
	frame_dig 1 // storage key//identity
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	itob
	concat
	frame_dig 1 // storage key//identity
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	itob
	concat
	frame_dig 1 // storage key//identity
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 23 8
	btoi
	itob
	concat
	frame_dig 1 // storage key//identity
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 32 8
	btoi
	itob
	concat
	frame_dig 1 // storage key//identity
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 41 8
	btoi
	itob
	concat
	frame_dig 1 // storage key//identity
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 50 8
	btoi
	itob
	concat
	frame_dig 1 // storage key//identity
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 59 8
	btoi
	itob
	concat
	frame_dig 1 // storage key//identity
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 68 8
	btoi
	itob
	concat
	byte 0x000000003b9aca00
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	concat
	byte 0x00
	int 0
	frame_dig 1 // storage key//identity
	box_get
	assert
	store 255 // full array
	load 255 // full array
	int 608
	getbit
	setbit
	concat
	frame_dig 1 // storage key//identity
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 77 8
	btoi
	itob
	concat
	frame_dig 1 // storage key//identity
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 86 8
	btoi
	itob
	concat
	byte 0x00
	int 0
	frame_dig 1 // storage key//identity
	box_get
	assert
	store 255 // full array
	load 255 // full array
	int 752
	getbit
	setbit
	concat
	frame_bury 2 // ret: UserInfoV1

	// contracts\BiatecIdentityProvider.algo.ts:247
	// return ret;
	frame_dig 2 // ret: UserInfoV1

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

*create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication
	err

*call_NoOp:
	method "selfRegistration(address,(uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64,bool))void"
	method "setInfo(address,(uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64,bool))void"
	method "getUser(address,uint8)(uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint256,uint256,bool,uint64,uint64,bool)"
	txna ApplicationArgs 0
	match *abi_route_selfRegistration *abi_route_setInfo *abi_route_getUser
	err
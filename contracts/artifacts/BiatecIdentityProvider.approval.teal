#pragma version 10
intcblock 0 1 32 2 256 552 688
bytecblock 0x0000000000000000 0x 0x69 0x42 0x73 0x00 0x30303030303030302d303030302d303030302d303030302d303030303030303030303030 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 0x000000000000000000000000000000000000000000000000000000003b9aca00 0x0000000077359400 0x000000003b9aca00 0x7363766572 0x151f7c75 0x6566

// This TEAL was generated by TEALScript v0.105.3
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_UpdateApplication *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	intc 1 // 1
	return

// createApplication(): void
//
// Initial setup
createApplication:
	proto 0 0

	// contracts\BiatecIdentityProvider.algo.ts:159
	// this.version.value = version
	bytec 11 //  "scver"
	pushbytes "BIATEC-IDENT-01-01-01"
	app_global_put
	retsub

// bootstrap(uint64)void
*abi_route_bootstrap:
	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute bootstrap(uint64)void
	callsub bootstrap
	intc 1 // 1
	return

// bootstrap(appBiatecConfigProvider: AppID): void
//
// Biatec deploys single identity provider smart contract
// @param appBiatecConfigProvider Biatec amm provider
bootstrap:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts\BiatecIdentityProvider.algo.ts:167
	// assert(this.txn.sender === this.app.creator, 'Only creator of the app can set it up')
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==

	// Only creator of the app can set it up
	assert

	// contracts\BiatecIdentityProvider.algo.ts:168
	// this.appBiatecConfigProvider.value = appBiatecConfigProvider
	bytec 3 //  "B"
	frame_dig -1 // appBiatecConfigProvider: AppID
	app_global_put

	// contracts\BiatecIdentityProvider.algo.ts:169
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 4 //  "s"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('s')
	assert
	frame_bury 0 // paused: uint64

	// contracts\BiatecIdentityProvider.algo.ts:170
	// assert(paused === 0, 'ERR_PAUSED')
	frame_dig 0 // paused: uint64
	intc 0 // 0
	==

	// ERR_PAUSED
	assert
	retsub

// updateApplication(uint64,byte[])void
*abi_route_updateApplication:
	// newVersion: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateApplication(uint64,byte[])void
	callsub updateApplication
	intc 1 // 1
	return

// updateApplication(appBiatecConfigProvider: AppID, newVersion: bytes): void
//
// addressUdpater from global biatec configuration is allowed to update application
updateApplication:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dup

	// contracts\BiatecIdentityProvider.algo.ts:177
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value, 'Configuration app does not match')
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 3 //  "B"
	app_global_get
	==

	// Configuration app does not match
	assert

	// contracts\BiatecIdentityProvider.algo.ts:178
	// addressUdpater = appBiatecConfigProvider.globalState('u') as Address
	frame_dig -1 // appBiatecConfigProvider: AppID
	pushbytes 0x75 // "u"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('u')
	assert
	frame_bury 0 // addressUdpater: address

	// contracts\BiatecIdentityProvider.algo.ts:179
	// assert(this.txn.sender === addressUdpater, 'Only addressUdpater setup in the config can update application')
	txn Sender
	frame_dig 0 // addressUdpater: address
	==

	// Only addressUdpater setup in the config can update application
	assert

	// contracts\BiatecIdentityProvider.algo.ts:180
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 4 //  "s"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('s')
	assert
	frame_bury 1 // paused: uint64

	// contracts\BiatecIdentityProvider.algo.ts:181
	// assert(paused === 0, 'ERR_PAUSED')
	frame_dig 1 // paused: uint64
	intc 0 // 0
	==

	// ERR_PAUSED
	assert

	// contracts\BiatecIdentityProvider.algo.ts:182
	// this.version.value = newVersion
	bytec 11 //  "scver"
	frame_dig -2 // newVersion: bytes
	app_global_put
	retsub

// selfRegistration(address,(uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64,bool))void
*abi_route_selfRegistration:
	// info: (uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64,bool)
	txna ApplicationArgs 2

	// user: address
	txna ApplicationArgs 1
	dup
	len
	intc 2 // 32
	==

	// argument 1 (user) for selfRegistration must be a address
	assert

	// execute selfRegistration(address,(uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64,bool))void
	callsub selfRegistration
	intc 1 // 1
	return

// selfRegistration(user: Address, info: IdentityInfo): void
selfRegistration:
	proto 2 0

	// contracts\BiatecIdentityProvider.algo.ts:186
	// assert(!this.identities(user).exists, 'Self registration cannot be executed if address is already registered')
	bytec 2 //  "i"
	frame_dig -1 // user: Address
	concat
	box_len
	swap
	pop
	!

	// Self registration cannot be executed if address is already registered
	assert

	// contracts\BiatecIdentityProvider.algo.ts:189
	// assert(info.verificationStatus === 1, 'Verification status must be empty')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	intc 1 // 1
	==

	// Verification status must be empty
	assert

	// contracts\BiatecIdentityProvider.algo.ts:191
	// assert(info.verificationClass === 0, 'verificationClass must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	intc 0 // 0
	==

	// verificationClass must equal to 0
	assert

	// contracts\BiatecIdentityProvider.algo.ts:194
	// assert(
	//       info.personUUID === '00000000-0000-0000-0000-000000000000',
	//       'personUUID must equal to 00000000-0000-0000-0000-000000000000'
	//     )
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	pushint 17
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	intc 1 //  get type length
	* // multiply by type length
	intc 3 // 2
	+ // add two for length
	extract3
	extract 2 0
	bytec 6 //  "00000000-0000-0000-0000-000000000000"
	==

	// personUUID must equal to 00000000-0000-0000-0000-000000000000
	assert

	// contracts\BiatecIdentityProvider.algo.ts:199
	// assert(
	//       info.legalEntityUUID === '00000000-0000-0000-0000-000000000000',
	//       'legalEntityUUID must equal to 00000000-0000-0000-0000-000000000000'
	//     )
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	pushint 19
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	intc 1 //  get type length
	* // multiply by type length
	intc 3 // 2
	+ // add two for length
	extract3
	extract 2 0
	bytec 6 //  "00000000-0000-0000-0000-000000000000"
	==

	// legalEntityUUID must equal to 00000000-0000-0000-0000-000000000000
	assert

	// contracts\BiatecIdentityProvider.algo.ts:204
	// assert(info.biatecEngagementPoints === 0, 'biatecEngagementPoints must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 21 8
	btoi
	intc 0 // 0
	==

	// biatecEngagementPoints must equal to 0
	assert

	// contracts\BiatecIdentityProvider.algo.ts:206
	// assert(info.biatecEngagementRank === 0, 'biatecEngagementRank must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 29 8
	btoi
	intc 0 // 0
	==

	// biatecEngagementRank must equal to 0
	assert

	// contracts\BiatecIdentityProvider.algo.ts:208
	// assert(info.avmEngagementPoints === 0, 'avmEngagementPoints must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 37 8
	btoi
	intc 0 // 0
	==

	// avmEngagementPoints must equal to 0
	assert

	// contracts\BiatecIdentityProvider.algo.ts:210
	// assert(info.avmEngagementRank === 0, 'avmEngagementRank must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 45 8
	btoi
	intc 0 // 0
	==

	// avmEngagementRank must equal to 0
	assert

	// contracts\BiatecIdentityProvider.algo.ts:212
	// assert(info.tradingEngagementPoints === 0, 'tradingEngagementPoints must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 53 8
	btoi
	intc 0 // 0
	==

	// tradingEngagementPoints must equal to 0
	assert

	// contracts\BiatecIdentityProvider.algo.ts:214
	// assert(info.tradingEngagementRank === 0, 'tradingEngagementRank must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 61 8
	btoi
	intc 0 // 0
	==

	// tradingEngagementRank must equal to 0
	assert

	// contracts\BiatecIdentityProvider.algo.ts:216
	// assert(info.isLocked === false, 'isLocked must equal to false')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	intc 5 // 552
	getbit
	intc 0 // 0
	==

	// isLocked must equal to false
	assert

	// contracts\BiatecIdentityProvider.algo.ts:218
	// assert(info.kycExpiration === 0, 'kycExpiration must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 70 8
	btoi
	intc 0 // 0
	==

	// kycExpiration must equal to 0
	assert

	// contracts\BiatecIdentityProvider.algo.ts:220
	// assert(info.investorForExpiration === 0, 'investorForExpiration must equal to 0')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	extract 78 8
	btoi
	intc 0 // 0
	==

	// investorForExpiration must equal to 0
	assert

	// contracts\BiatecIdentityProvider.algo.ts:222
	// assert(info.isProfessionalInvestor === false, 'isProfessionalInvestor must equal to false')
	frame_dig -2 // info: IdentityInfo
	store 255 // full array
	load 255 // full array
	intc 6 // 688
	getbit
	intc 0 // 0
	==

	// isProfessionalInvestor must equal to false
	assert

	// contracts\BiatecIdentityProvider.algo.ts:224
	// this.identities(user).value = info
	bytec 2 //  "i"
	frame_dig -1 // user: Address
	concat
	dup
	box_del
	pop
	frame_dig -2 // info: IdentityInfo
	box_put
	retsub

// setInfo(address,(uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64,bool))void
*abi_route_setInfo:
	// info: (uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64,bool)
	txna ApplicationArgs 2

	// user: address
	txna ApplicationArgs 1
	dup
	len
	intc 2 // 32
	==

	// argument 1 (user) for setInfo must be a address
	assert

	// execute setInfo(address,(uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64,bool))void
	callsub setInfo
	intc 1 // 1
	return

// setInfo(user: Address, info: IdentityInfo): void
setInfo:
	proto 2 0

	// contracts\BiatecIdentityProvider.algo.ts:228
	// assert(this.txn.sender === this.engagementSetter.value)
	txn Sender
	pushbytes 0x65 // "e"
	app_global_get
	==
	assert

	// contracts\BiatecIdentityProvider.algo.ts:229
	// this.identities(user).value = info
	bytec 2 //  "i"
	frame_dig -1 // user: Address
	concat
	dup
	box_del
	pop
	frame_dig -2 // info: IdentityInfo
	box_put
	retsub

// sendOnlineKeyRegistration(uint64,byte[],byte[],byte[],uint64,uint64,uint64)void
*abi_route_sendOnlineKeyRegistration:
	// voteKeyDilution: uint64
	txna ApplicationArgs 7
	btoi

	// voteLast: uint64
	txna ApplicationArgs 6
	btoi

	// voteFirst: uint64
	txna ApplicationArgs 5
	btoi

	// stateProofPK: byte[]
	txna ApplicationArgs 4
	extract 2 0

	// selectionPK: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// votePK: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute sendOnlineKeyRegistration(uint64,byte[],byte[],byte[],uint64,uint64,uint64)void
	callsub sendOnlineKeyRegistration
	intc 1 // 1
	return

// sendOnlineKeyRegistration(appBiatecConfigProvider: AppID, votePK: bytes, selectionPK: bytes, stateProofPK: bytes, voteFirst: uint64, voteLast: uint64, voteKeyDilution: uint64): void
//
// addressExecutiveFee can perfom key registration for this LP pool
//
// Only addressExecutiveFee is allowed to execute this method.
sendOnlineKeyRegistration:
	proto 7 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dup

	// contracts\BiatecIdentityProvider.algo.ts:246
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value, 'Configuration app does not match')
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 3 //  "B"
	app_global_get
	==

	// Configuration app does not match
	assert

	// contracts\BiatecIdentityProvider.algo.ts:247
	// addressExecutiveFee = appBiatecConfigProvider.globalState('ef') as Address
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 13 //  "ef"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('ef')
	assert
	frame_bury 0 // addressExecutiveFee: address

	// contracts\BiatecIdentityProvider.algo.ts:248
	// assert(
	//       this.txn.sender === addressExecutiveFee,
	//       'Only fee executor setup in the config can take the collected fees'
	//     )
	txn Sender
	frame_dig 0 // addressExecutiveFee: address
	==

	// Only fee executor setup in the config can take the collected fees
	assert

	// contracts\BiatecIdentityProvider.algo.ts:252
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 4 //  "s"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('s')
	assert
	frame_bury 1 // paused: uint64

	// contracts\BiatecIdentityProvider.algo.ts:253
	// assert(paused === 0, 'ERR_PAUSED')
	frame_dig 1 // paused: uint64
	intc 0 // 0
	==

	// ERR_PAUSED
	assert

	// contracts\BiatecIdentityProvider.algo.ts:254
	// sendOnlineKeyRegistration({
	//       selectionPK: selectionPK,
	//       stateProofPK: stateProofPK,
	//       voteFirst: voteFirst,
	//       voteKeyDilution: voteKeyDilution,
	//       voteLast: voteLast,
	//       votePK: votePK,
	//       fee: 0,
	//     })
	itxn_begin
	intc 3 //  keyreg
	itxn_field TypeEnum

	// contracts\BiatecIdentityProvider.algo.ts:255
	// selectionPK: selectionPK
	frame_dig -3 // selectionPK: bytes
	itxn_field SelectionPK

	// contracts\BiatecIdentityProvider.algo.ts:256
	// stateProofPK: stateProofPK
	frame_dig -4 // stateProofPK: bytes
	itxn_field StateProofPK

	// contracts\BiatecIdentityProvider.algo.ts:257
	// voteFirst: voteFirst
	frame_dig -5 // voteFirst: uint64
	itxn_field VoteFirst

	// contracts\BiatecIdentityProvider.algo.ts:258
	// voteKeyDilution: voteKeyDilution
	frame_dig -7 // voteKeyDilution: uint64
	itxn_field VoteKeyDilution

	// contracts\BiatecIdentityProvider.algo.ts:259
	// voteLast: voteLast
	frame_dig -6 // voteLast: uint64
	itxn_field VoteLast

	// contracts\BiatecIdentityProvider.algo.ts:260
	// votePK: votePK
	frame_dig -2 // votePK: bytes
	itxn_field VotePK

	// contracts\BiatecIdentityProvider.algo.ts:261
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// getUser(address,uint8)(uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint256,uint256,bool,uint64,uint64,bool)
*abi_route_getUser:
	// The ABI return prefix
	bytec 12 // 0x151f7c75

	// v: uint8
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 0 (v) for getUser must be a uint8
	assert
	btoi

	// user: address
	txna ApplicationArgs 1
	dup
	len
	intc 2 // 32
	==

	// argument 1 (user) for getUser must be a address
	assert

	// execute getUser(address,uint8)(uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint256,uint256,bool,uint64,uint64,bool)
	callsub getUser
	concat
	log
	intc 1 // 1
	return

// getUser(user: Address, v: uint8): UserInfoV1
//
// Returns user information - fee multiplier, verification class, engagement class ..
//
// @param user Get info for specific user address
// @param v Version of the data structure to return
getUser:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 2

	// contracts\BiatecIdentityProvider.algo.ts:273
	// assert(v === 1, "Currently supported version of the data structure is '1'")
	frame_dig -2 // v: uint8
	intc 1 // 1
	==

	// Currently supported version of the data structure is '1'
	assert

	// *if0_condition
	// contracts\BiatecIdentityProvider.algo.ts:274
	// !this.identities(user).exists
	bytec 2 //  "i"
	frame_dig -1 // user: Address
	concat
	box_len
	swap
	pop
	!
	bz *if0_end

	// *if0_consequent
	// contracts\BiatecIdentityProvider.algo.ts:275
	// retNoIdentity: UserInfoV1 = {
	//         version: v,
	//         base: SCALE as uint256,
	//         feeMultiplier: (2 * SCALE) as uint256,
	//         isLocked: false,
	//         verificationClass: 0,
	//         verificationStatus: 0,
	//         biatecEngagementPoints: 0,
	//         biatecEngagementRank: 0,
	//         avmEngagementPoints: 0,
	//         avmEngagementRank: 0,
	//         tradingEngagementPoints: 0,
	//         tradingEngagementRank: 0,
	//         kycExpiration: 0,
	//         investorForExpiration: 0,
	//         isProfessionalInvestor: false,
	//       }
	frame_dig -2 // v: uint8
	itob
	extract 7 1
	bytec 0 // 0x0000000000000000
	concat
	bytec 0 // 0x0000000000000000
	concat
	bytec 0 // 0x0000000000000000
	concat
	bytec 0 // 0x0000000000000000
	concat
	bytec 0 // 0x0000000000000000
	concat
	bytec 0 // 0x0000000000000000
	concat
	bytec 0 // 0x0000000000000000
	concat
	bytec 0 // 0x0000000000000000
	concat
	bytec 9 // 0x0000000077359400
	dup
	bitlen
	intc 4 // 256
	<=

	// (2 * SCALE) as uint256 overflowed 256 bits
	assert
	bytec 7 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 2 // 32
	-
	swap
	substring3
	concat
	bytec 8 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	concat
	bytec 5 // 0x00
	intc 0 // 0
	dup
	setbit
	concat // 12
	bytec 0 // 0x0000000000000000
	concat
	bytec 0 // 0x0000000000000000
	concat
	bytec 5 // 0x00
	intc 0 // 0
	dup
	setbit
	concat
	frame_bury 0 // retNoIdentity: UserInfoV1

	// contracts\BiatecIdentityProvider.algo.ts:292
	// return retNoIdentity;
	frame_dig 0 // retNoIdentity: UserInfoV1
	b *getUser*return

*if0_end:
	// contracts\BiatecIdentityProvider.algo.ts:294
	// identity = this.identities(user).value
	bytec 2 //  "i"
	frame_dig -1 // user: Address
	concat
	frame_bury 1 // storage key//identity

	// contracts\BiatecIdentityProvider.algo.ts:296
	// ret: UserInfoV1 = {
	//       version: v,
	//       base: SCALE as uint256,
	//       feeMultiplier: (1 * SCALE) as uint256,
	//       isLocked: identity.isLocked,
	//       verificationClass: identity.verificationClass,
	//       verificationStatus: identity.verificationStatus,
	//       biatecEngagementPoints: identity.biatecEngagementPoints,
	//       biatecEngagementRank: identity.biatecEngagementRank,
	//       avmEngagementPoints: identity.avmEngagementPoints,
	//       avmEngagementRank: identity.avmEngagementRank,
	//       tradingEngagementPoints: identity.tradingEngagementPoints,
	//       tradingEngagementRank: identity.tradingEngagementRank,
	//       kycExpiration: identity.kycExpiration,
	//       investorForExpiration: identity.investorForExpiration,
	//       isProfessionalInvestor: identity.isProfessionalInvestor,
	//     }
	frame_dig -2 // v: uint8
	itob
	extract 7 1
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	itob
	concat
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	itob
	concat
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	extract 21 8
	btoi
	itob
	concat
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	extract 29 8
	btoi
	itob
	concat
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	extract 37 8
	btoi
	itob
	concat
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	extract 45 8
	btoi
	itob
	concat
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	extract 53 8
	btoi
	itob
	concat
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	extract 61 8
	btoi
	itob
	concat
	bytec 10 // 0x000000003b9aca00
	dup
	bitlen
	intc 4 // 256
	<=

	// (1 * SCALE) as uint256 overflowed 256 bits
	assert
	bytec 7 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 2 // 32
	-
	swap
	substring3
	concat
	bytec 8 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	concat
	bytec 5 // 0x00
	intc 0 // 0
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	intc 5 // 552
	getbit
	setbit
	concat // 12
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	extract 70 8
	btoi
	itob
	concat
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	extract 78 8
	btoi
	itob
	concat
	bytec 5 // 0x00
	intc 0 // 0
	frame_dig 1 // storage key//identity
	box_get

	// box value does not exist: this.identities(user).value
	assert
	store 255 // full array
	load 255 // full array
	intc 6 // 688
	getbit
	setbit
	concat
	frame_bury 2 // ret: UserInfoV1

	// contracts\BiatecIdentityProvider.algo.ts:313
	// return ret;
	frame_dig 2 // ret: UserInfoV1

*getUser*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// withdrawExcessAssets(uint64,uint64,uint64)uint64
*abi_route_withdrawExcessAssets:
	// The ABI return prefix
	bytec 12 // 0x151f7c75

	// amount: uint64
	txna ApplicationArgs 3
	btoi

	// asset: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute withdrawExcessAssets(uint64,uint64,uint64)uint64
	callsub withdrawExcessAssets
	itob
	concat
	log
	intc 1 // 1
	return

// withdrawExcessAssets(appBiatecConfigProvider: AppID, asset: AssetID, amount: uint64): uint64
//
// If someone deposits excess assets to this smart contract biatec can use them.
//
// Only addressExecutiveFee is allowed to execute this method.
//
// @param appBiatecConfigProvider Biatec config app. Only addressExecutiveFee is allowed to execute this method.
// @param asset Asset to withdraw. If native token, then zero
// @param amount Amount of the asset to be withdrawn
withdrawExcessAssets:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dup

	// contracts\BiatecIdentityProvider.algo.ts:326
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value, 'Configuration app does not match')
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 3 //  "B"
	app_global_get
	==

	// Configuration app does not match
	assert

	// contracts\BiatecIdentityProvider.algo.ts:327
	// addressExecutiveFee = appBiatecConfigProvider.globalState('ef') as Address
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 13 //  "ef"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('ef')
	assert
	frame_bury 0 // addressExecutiveFee: address

	// contracts\BiatecIdentityProvider.algo.ts:328
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 4 //  "s"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('s')
	assert
	frame_bury 1 // paused: uint64

	// contracts\BiatecIdentityProvider.algo.ts:329
	// assert(paused === 0, 'ERR_PAUSED')
	frame_dig 1 // paused: uint64
	intc 0 // 0
	==

	// ERR_PAUSED
	assert

	// contracts\BiatecIdentityProvider.algo.ts:330
	// assert(
	//       this.txn.sender === addressExecutiveFee,
	//       'Only fee executor setup in the config can take the collected fees'
	//     )
	txn Sender
	frame_dig 0 // addressExecutiveFee: address
	==

	// Only fee executor setup in the config can take the collected fees
	assert

	// contracts\BiatecIdentityProvider.algo.ts:335
	// this.doAxfer(this.txn.sender, asset, amount)
	frame_dig -3 // amount: uint64
	frame_dig -2 // asset: AssetID
	txn Sender
	callsub doAxfer

	// contracts\BiatecIdentityProvider.algo.ts:337
	// return amount;
	frame_dig -3 // amount: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// doAxfer(receiver: Address, asset: AssetID, amount: uint64): void
//
// Executes xfer of pay payment methods to specified receiver from smart contract aggregated account with specified asset and amount in tokens decimals
// @param receiver Receiver
// @param asset Asset. Zero for algo
// @param amount Amount to transfer
doAxfer:
	proto 3 0

	// *if1_condition
	// contracts\BiatecIdentityProvider.algo.ts:347
	// asset.id === 0
	frame_dig -2 // asset: AssetID
	intc 0 // 0
	==
	bz *if1_else

	// *if1_consequent
	// contracts\BiatecIdentityProvider.algo.ts:348
	// sendPayment({
	//         receiver: receiver,
	//         amount: amount,
	//         fee: 0,
	//       })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts\BiatecIdentityProvider.algo.ts:349
	// receiver: receiver
	frame_dig -1 // receiver: Address
	itxn_field Receiver

	// contracts\BiatecIdentityProvider.algo.ts:350
	// amount: amount
	frame_dig -3 // amount: uint64
	itxn_field Amount

	// contracts\BiatecIdentityProvider.algo.ts:351
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if1_end

*if1_else:
	// contracts\BiatecIdentityProvider.algo.ts:354
	// sendAssetTransfer({
	//         assetReceiver: receiver,
	//         xferAsset: asset,
	//         assetAmount: amount,
	//         fee: 0,
	//       })
	itxn_begin
	pushint 4 // axfer
	itxn_field TypeEnum

	// contracts\BiatecIdentityProvider.algo.ts:355
	// assetReceiver: receiver
	frame_dig -1 // receiver: Address
	itxn_field AssetReceiver

	// contracts\BiatecIdentityProvider.algo.ts:356
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// contracts\BiatecIdentityProvider.algo.ts:357
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// contracts\BiatecIdentityProvider.algo.ts:358
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if1_end:
	retsub

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0xa0cadf8a // method "bootstrap(uint64)void"
	pushbytes 0xe8c8eed9 // method "selfRegistration(address,(uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64,bool))void"
	pushbytes 0xd583a759 // method "setInfo(address,(uint64,uint64,bool,string,string,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64,bool))void"
	pushbytes 0x83925c17 // method "sendOnlineKeyRegistration(uint64,byte[],byte[],byte[],uint64,uint64,uint64)void"
	pushbytes 0x9936a16d // method "getUser(address,uint8)(uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint256,uint256,bool,uint64,uint64,bool)"
	pushbytes 0xcba2e95d // method "withdrawExcessAssets(uint64,uint64,uint64)uint64"
	txna ApplicationArgs 0
	match *abi_route_bootstrap *abi_route_selfRegistration *abi_route_setInfo *abi_route_sendOnlineKeyRegistration *abi_route_getUser *abi_route_withdrawExcessAssets

	// this contract does not implement the given ABI method for call NoOp
	err

*call_UpdateApplication:
	pushbytes 0x5fc885a0 // method "updateApplication(uint64,byte[])void"
	txna ApplicationArgs 0
	match *abi_route_updateApplication

	// this contract does not implement the given ABI method for call UpdateApplication
	err
#pragma version 10

// This TEAL was generated by TEALScript v0.88.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_UpdateApplication *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	err

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	int 1
	return

// createApplication(): void
//
// Initial setup
createApplication:
	proto 0 0

	// contracts\BiatecClammPool.algo.ts:214
	// log(version)
	byte "BIATEC-CLAMM-01-01-01"
	log

	// contracts\BiatecClammPool.algo.ts:215
	// this.scale.value = SCALE
	byte 0x7363616c65 // "scale"
	int 1000000000
	app_global_put

	// contracts\BiatecClammPool.algo.ts:216
	// this.fee.value = <uint64>0
	byte 0x66 // "f"
	int 0
	app_global_put

	// contracts\BiatecClammPool.algo.ts:217
	// this.Liqudity.value = <uint256>0
	byte 0x4c // "L"
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	app_global_put

	// contracts\BiatecClammPool.algo.ts:218
	// this.LiqudityBiatecFromFees.value = <uint256>0
	byte 0x4c62 // "Lb"
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	app_global_put

	// contracts\BiatecClammPool.algo.ts:219
	// this.LiqudityUsersFromFees.value = <uint256>0
	byte 0x4c75 // "Lu"
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	app_global_put

	// contracts\BiatecClammPool.algo.ts:220
	// this.priceMax.value = 0
	byte 0x704d6178 // "pMax"
	int 0
	app_global_put

	// contracts\BiatecClammPool.algo.ts:221
	// this.version.value = version
	byte 0x7363766572 // "scver"
	byte "BIATEC-CLAMM-01-01-01"
	app_global_put
	retsub

// updateApplication(uint64,byte[])void
*abi_route_updateApplication:
	// newVersion: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateApplication(uint64,byte[])void
	callsub updateApplication
	int 1
	return

// updateApplication(appBiatecConfigProvider: AppID, newVersion: bytes): void
//
// addressUdpater from global biatec configuration is allowed to update application
updateApplication:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts\BiatecClammPool.algo.ts:228
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value, 'ERR_CONFIG')
	frame_dig -1 // appBiatecConfigProvider: AppID
	byte 0x42 // "B"
	app_global_get
	==

	// ERR_CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:229
	// addressUdpater = appBiatecConfigProvider.globalState('u')
	frame_dig -1 // appBiatecConfigProvider: AppID
	byte 0x75 // "u"
	app_global_get_ex
	assert
	frame_bury 0 // addressUdpater: any

	// contracts\BiatecClammPool.algo.ts:230
	// assert(this.txn.sender === addressUdpater, 'ERR_UPDATER')
	txn Sender
	frame_dig 0 // addressUdpater: any
	==

	// ERR_UPDATER
	assert

	// contracts\BiatecClammPool.algo.ts:231
	// this.version.value = newVersion
	byte 0x7363766572 // "scver"
	frame_dig -2 // newVersion: bytes
	app_global_put
	retsub

// getCurrentPrice()uint64
*abi_route_getCurrentPrice:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getCurrentPrice()uint64
	callsub getCurrentPrice
	itob
	concat
	log
	int 1
	return

// getCurrentPrice(): uint64
getCurrentPrice:
	proto 0 1

	// contracts\BiatecClammPool.algo.ts:236
	// return this.currentPrice.value;
	byte 0x7072696365 // "price"
	app_global_get
	retsub

// getPriceDivider()uint64
*abi_route_getPriceDivider:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getPriceDivider()uint64
	callsub getPriceDivider
	itob
	concat
	log
	int 1
	return

// getPriceDivider(): uint64
getPriceDivider:
	proto 0 1

	// contracts\BiatecClammPool.algo.ts:241
	// return this.scale.value;
	byte 0x7363616c65 // "scale"
	app_global_get
	retsub

// getLPTokenId()uint64
*abi_route_getLPTokenId:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getLPTokenId()uint64
	callsub getLPTokenId
	itob
	concat
	log
	int 1
	return

// getLPTokenId(): uint64
getLPTokenId:
	proto 0 1

	// contracts\BiatecClammPool.algo.ts:246
	// return this.assetLP.value;
	byte 0x6c70 // "lp"
	app_global_get
	retsub

// bootstrap(uint64,uint64,uint64,uint64,pay,uint64,uint64,uint64,uint64,uint8)uint64
*abi_route_bootstrap:
	// The ABI return prefix
	byte 0x151f7c75

	// verificationClass: uint8
	txna ApplicationArgs 9
	dup
	len
	int 1
	==
	assert
	btoi

	// currentPrice: uint64
	txna ApplicationArgs 8
	btoi

	// priceMax: uint64
	txna ApplicationArgs 7
	btoi

	// priceMin: uint64
	txna ApplicationArgs 6
	btoi

	// fee: uint64
	txna ApplicationArgs 5
	btoi

	// txSeed: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// appBiatecPoolProvider: uint64
	txna ApplicationArgs 4
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 3
	btoi

	// assetB: uint64
	txna ApplicationArgs 2
	btoi

	// assetA: uint64
	txna ApplicationArgs 1
	btoi

	// execute bootstrap(uint64,uint64,uint64,uint64,pay,uint64,uint64,uint64,uint64,uint8)uint64
	callsub bootstrap
	itob
	concat
	log
	int 1
	return

// bootstrap(assetA: AssetID, assetB: AssetID, appBiatecConfigProvider: AppID, appBiatecPoolProvider: AppID, txSeed: PayTxn, fee: uint64, priceMin: uint64, priceMax: uint64, currentPrice: uint64, verificationClass: uint8): uint64
//
// Anybody can deploy the clamm smart contract
// @param assetA Asset A ID must be lower then Asset B ID
// @param assetB Asset B
// @param appBiatecConfigProvider Biatec amm provider
// @param appBiatecPoolProvider Pool provider
// @param txSeed Seed transaction so that smart contract can opt in to the assets
// @param fee Fee in base level (9 decimals). value 1_000_000_000 = 1 = 100%. 10_000_000 = 1%. 1_000_000 = 0.1%
// @param priceMin Min price range. At this point all assets are in asset A.
// @param priceMax Max price range. At this point all assets are in asset B.
// @param currentPrice Deployer can specify the current price for easier deployemnt.
// @param verificationClass Minimum verification level from the biatec identity. Level 0 means no kyc.
// @returns LP token ID
bootstrap:
	proto 10 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts\BiatecClammPool.algo.ts:275
	// verifyPayTxn(txSeed, { receiver: this.app.address, amount: { greaterThanEqualTo: 300_000 } })
	// verify receiver
	frame_dig -5 // txSeed: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -5 // txSeed: PayTxn
	gtxns Amount
	int 300_000
	>=
	assert

	// contracts\BiatecClammPool.algo.ts:276
	// assert(this.priceMax.value === 0, 'ERR_PRICE_MAX')
	byte 0x704d6178 // "pMax"
	app_global_get
	int 0
	==

	// ERR_PRICE_MAX
	assert

	// contracts\BiatecClammPool.algo.ts:277
	// assert(this.txn.sender === this.app.creator, 'ERR_SENDER')
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==

	// ERR_SENDER
	assert

	// contracts\BiatecClammPool.algo.ts:278
	// assert(priceMax > 0, 'ERR_PRICE')
	frame_dig -8 // priceMax: uint64
	int 0
	>

	// ERR_PRICE
	assert

	// contracts\BiatecClammPool.algo.ts:279
	// assert(assetA < assetB)
	frame_dig -1 // assetA: AssetID
	frame_dig -2 // assetB: AssetID
	<
	assert

	// contracts\BiatecClammPool.algo.ts:280
	// assert(fee <= SCALE / 10)
	frame_dig -6 // fee: uint64
	int 100000000
	<=
	assert

	// contracts\BiatecClammPool.algo.ts:281
	// assert(verificationClass <= 4)
	frame_dig -10 // verificationClass: uint8
	int 4
	<=
	assert

	// contracts\BiatecClammPool.algo.ts:282
	// assert(!this.currentPrice.exists)
	txna Applications 0
	byte 0x7072696365 // "price"
	app_global_get_ex
	swap
	pop
	!
	assert

	// *if0_condition
	// contracts\BiatecClammPool.algo.ts:283
	// assetA.id > 0
	frame_dig -1 // assetA: AssetID
	int 0
	>
	bz *if0_end

	// *if0_consequent
	// contracts\BiatecClammPool.algo.ts:284
	// assert(assetA.decimals <= SCALE_DECIMALS)
	frame_dig -1 // assetA: AssetID
	asset_params_get AssetDecimals
	pop
	int 9
	<=
	assert

*if0_end:
	// contracts\BiatecClammPool.algo.ts:286
	// assert(assetB.decimals <= SCALE_DECIMALS)
	frame_dig -2 // assetB: AssetID
	asset_params_get AssetDecimals
	pop
	int 9
	<=
	assert

	// contracts\BiatecClammPool.algo.ts:288
	// assert(this.fee.value <= 0, 'ERR_FEE')
	byte 0x66 // "f"
	app_global_get
	int 0
	<=

	// ERR_FEE
	assert

	// contracts\BiatecClammPool.algo.ts:290
	// poolProviderFromConfig = appBiatecConfigProvider.globalState('p')
	frame_dig -3 // appBiatecConfigProvider: AppID
	byte 0x70 // "p"
	app_global_get_ex
	assert
	frame_bury 0 // poolProviderFromConfig: any

	// contracts\BiatecClammPool.algo.ts:291
	// assert(
	//       appBiatecPoolProvider === poolProviderFromConfig,
	//       'ERR_CONFIG' // 'appBiatecPoolProvider must match to the config in appBiatecConfigProvider'
	//     )
	frame_dig -4 // appBiatecPoolProvider: AppID
	frame_dig 0 // poolProviderFromConfig: any
	==

	// ERR_CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:295
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -3 // appBiatecConfigProvider: AppID
	byte 0x73 // "s"
	app_global_get_ex
	assert
	frame_bury 1 // paused: uint64

	// contracts\BiatecClammPool.algo.ts:296
	// assert(paused === 0, 'ERR_PAUSED')
	frame_dig 1 // paused: uint64
	int 0
	==

	// ERR_PAUSED
	assert

	// contracts\BiatecClammPool.algo.ts:298
	// this.appBiatecConfigProvider.value = appBiatecConfigProvider
	byte 0x42 // "B"
	frame_dig -3 // appBiatecConfigProvider: AppID
	app_global_put

	// contracts\BiatecClammPool.algo.ts:300
	// this.priceMin.value = priceMin
	byte 0x704d696e // "pMin"
	frame_dig -7 // priceMin: uint64
	app_global_put

	// contracts\BiatecClammPool.algo.ts:301
	// this.priceMax.value = priceMax
	byte 0x704d6178 // "pMax"
	frame_dig -8 // priceMax: uint64
	app_global_put

	// contracts\BiatecClammPool.algo.ts:302
	// this.priceMinSqrt.value = sqrt((priceMin as uint256) * s)
	byte 0x704d696e53 // "pMinS"
	frame_dig -7 // priceMin: uint64
	itob
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	bsqrt
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:303
	// this.priceMaxSqrt.value = sqrt((priceMax as uint256) * s)
	byte 0x704d617853 // "pMaxS"
	frame_dig -8 // priceMax: uint64
	itob
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	bsqrt
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:304
	// this.assetABalance.value = <uint256>0
	byte 0x6162 // "ab"
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	app_global_put

	// contracts\BiatecClammPool.algo.ts:305
	// this.assetBBalance.value = <uint256>0
	byte 0x6262 // "bb"
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	app_global_put

	// contracts\BiatecClammPool.algo.ts:306
	// this.currentPrice.value = currentPrice
	byte 0x7072696365 // "price"
	frame_dig -9 // currentPrice: uint64
	app_global_put

	// contracts\BiatecClammPool.algo.ts:308
	// this.assetA.value = assetA.id
	byte 0x61 // "a"
	frame_dig -1 // assetA: AssetID
	app_global_put

	// contracts\BiatecClammPool.algo.ts:309
	// this.assetB.value = assetB.id
	byte 0x62 // "b"
	frame_dig -2 // assetB: AssetID
	app_global_put

	// contracts\BiatecClammPool.algo.ts:310
	// this.assetLP.value = this.doCreatePoolToken(assetA, assetB).id
	byte 0x6c70 // "lp"
	frame_dig -2 // assetB: AssetID
	frame_dig -1 // assetA: AssetID
	callsub doCreatePoolToken
	app_global_put

	// contracts\BiatecClammPool.algo.ts:311
	// this.fee.value = fee
	byte 0x66 // "f"
	frame_dig -6 // fee: uint64
	app_global_put

	// contracts\BiatecClammPool.algo.ts:312
	// this.doOptIn(assetA)
	frame_dig -1 // assetA: AssetID
	callsub doOptIn

	// contracts\BiatecClammPool.algo.ts:313
	// this.doOptIn(assetB)
	frame_dig -2 // assetB: AssetID
	callsub doOptIn

	// contracts\BiatecClammPool.algo.ts:315
	// sendMethodCall<[AppID, AssetID, AssetID, uint8], void>({
	//       name: 'registerPool',
	//       methodArgs: [globals.currentApplicationID, assetA, assetB, verificationClass],
	//       fee: 0,
	//       applicationID: appBiatecPoolProvider,
	//     })
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "registerPool(uint64,uint64,uint64,uint8)void"
	itxn_field ApplicationArgs

	// contracts\BiatecClammPool.algo.ts:317
	// methodArgs: [globals.currentApplicationID, assetA, assetB, verificationClass]
	global CurrentApplicationID
	itob
	itxn_field ApplicationArgs
	frame_dig -1 // assetA: AssetID
	itob
	itxn_field ApplicationArgs
	frame_dig -2 // assetB: AssetID
	itob
	itxn_field ApplicationArgs
	frame_dig -10 // verificationClass: uint8
	itob
	extract 7 1
	itxn_field ApplicationArgs

	// contracts\BiatecClammPool.algo.ts:318
	// fee: 0
	int 0
	itxn_field Fee

	// contracts\BiatecClammPool.algo.ts:319
	// applicationID: appBiatecPoolProvider
	frame_dig -4 // appBiatecPoolProvider: AppID
	itxn_field ApplicationID

	// Submit inner transaction
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:322
	// return this.assetLP.value;
	byte 0x6c70 // "lp"
	app_global_get

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// doAxfer(receiver: Address, asset: AssetID, amount: uint64): void
//
// Executes xfer of pay payment methods to specified receiver from smart contract aggregated account with specified asset and amount in tokens decimals
// @param receiver Receiver
// @param asset Asset. Zero for algo
// @param amount Amount to transfer
doAxfer:
	proto 3 0

	// *if1_condition
	// contracts\BiatecClammPool.algo.ts:332
	// asset.id === 0
	frame_dig -2 // asset: AssetID
	int 0
	==
	bz *if1_else

	// *if1_consequent
	// contracts\BiatecClammPool.algo.ts:333
	// sendPayment({
	//         receiver: receiver,
	//         amount: amount,
	//         fee: 0,
	//       })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts\BiatecClammPool.algo.ts:334
	// receiver: receiver
	frame_dig -1 // receiver: Address
	itxn_field Receiver

	// contracts\BiatecClammPool.algo.ts:335
	// amount: amount
	frame_dig -3 // amount: uint64
	itxn_field Amount

	// contracts\BiatecClammPool.algo.ts:336
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if1_end

*if1_else:
	// contracts\BiatecClammPool.algo.ts:339
	// sendAssetTransfer({
	//         assetReceiver: receiver,
	//         xferAsset: asset,
	//         assetAmount: amount,
	//         fee: 0,
	//       })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts\BiatecClammPool.algo.ts:340
	// assetReceiver: receiver
	frame_dig -1 // receiver: Address
	itxn_field AssetReceiver

	// contracts\BiatecClammPool.algo.ts:341
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// contracts\BiatecClammPool.algo.ts:342
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// contracts\BiatecClammPool.algo.ts:343
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if1_end:
	retsub

// doOptIn(asset: AssetID): void
//
// Performs opt in to the asset. If native token is provided (0) it does not perform any action
// @param asset Asset to opt in to
doOptIn:
	proto 1 0

	// *if2_condition
	// contracts\BiatecClammPool.algo.ts:353
	// asset.id > 0
	frame_dig -1 // asset: AssetID
	int 0
	>
	bz *if2_end

	// *if2_consequent
	// contracts\BiatecClammPool.algo.ts:355
	// this.doAxfer(this.app.address, asset, 0)
	int 0
	frame_dig -1 // asset: AssetID
	global CurrentApplicationAddress
	callsub doAxfer

*if2_end:
	retsub

// doCreatePoolToken(assetA: AssetID, assetB: AssetID): AssetID
//
// Creates LP token
// @param assetA Asset A
// @param assetB Asset B
// @returns id of the token
doCreatePoolToken:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts\BiatecClammPool.algo.ts:369
	// nameAssetA = 'ALGO'
	byte 0x414c474f // "ALGO"
	frame_bury 0 // nameAssetA: byte[]

	// *if3_condition
	// contracts\BiatecClammPool.algo.ts:370
	// assetA.id > 0
	frame_dig -1 // assetA: AssetID
	int 0
	>
	bz *if3_end

	// *if3_consequent
	// contracts\BiatecClammPool.algo.ts:371
	// nameAssetA = assetA.unitName
	frame_dig -1 // assetA: AssetID
	asset_params_get AssetUnitName
	pop
	frame_bury 0 // nameAssetA: byte[]

*if3_end:
	// contracts\BiatecClammPool.algo.ts:374
	// name =
	//       'B-' + itob(this.verificationClass.value) + '-' + nameAssetA + '-' + assetB.unitName + '-' + itob(this.fee.value)
	byte 0x422d // "B-"
	byte 0x63 // "c"
	app_global_get
	itob
	concat
	byte 0x2d // "-"
	concat
	frame_dig 0 // nameAssetA: byte[]
	concat
	byte 0x2d // "-"
	concat
	frame_dig -2 // assetB: AssetID
	asset_params_get AssetUnitName
	pop
	concat
	byte 0x2d // "-"
	concat
	byte 0x66 // "f"
	app_global_get
	itob
	concat
	frame_bury 1 // name: byte[]

	// contracts\BiatecClammPool.algo.ts:377
	// return sendAssetCreation({
	//       configAssetName: name,
	//       configAssetUnitName: 'BLP', // Biatec LP token
	//       configAssetTotal: TOTAL_SUPPLY,
	//       configAssetDecimals: LP_TOKEN_DECIMALS,
	//       configAssetManager: this.app.address,
	//       configAssetReserve: this.app.address,
	//     });
	itxn_begin
	int acfg
	itxn_field TypeEnum

	// contracts\BiatecClammPool.algo.ts:378
	// configAssetName: name
	frame_dig 1 // name: byte[]
	itxn_field ConfigAssetName

	// contracts\BiatecClammPool.algo.ts:379
	// configAssetUnitName: 'BLP'
	byte 0x424c50 // "BLP"
	itxn_field ConfigAssetUnitName

	// contracts\BiatecClammPool.algo.ts:380
	// configAssetTotal: TOTAL_SUPPLY
	int 10000000000000000
	itxn_field ConfigAssetTotal

	// contracts\BiatecClammPool.algo.ts:381
	// configAssetDecimals: LP_TOKEN_DECIMALS
	int 6
	itxn_field ConfigAssetDecimals

	// contracts\BiatecClammPool.algo.ts:382
	// configAssetManager: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetManager

	// contracts\BiatecClammPool.algo.ts:383
	// configAssetReserve: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetReserve

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn CreatedAssetID

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// checkAssetsAB(assetA: AssetID, assetB: AssetID): void
checkAssetsAB:
	proto 2 0

	// contracts\BiatecClammPool.algo.ts:388
	// assert(assetA.id === this.assetA.value, 'assetA does not match')
	frame_dig -1 // assetA: AssetID
	byte 0x61 // "a"
	app_global_get
	==

	// assetA does not match
	assert

	// contracts\BiatecClammPool.algo.ts:389
	// assert(assetB.id === this.assetB.value, 'assetB does not match')
	frame_dig -2 // assetB: AssetID
	byte 0x62 // "b"
	app_global_get
	==

	// assetB does not match
	assert
	retsub

// checkAssets(assetA: AssetID, assetB: AssetID, assetLP: AssetID): void
checkAssets:
	proto 3 0

	// contracts\BiatecClammPool.algo.ts:393
	// this.checkAssetsAB(assetA, assetB)
	frame_dig -2 // assetB: AssetID
	frame_dig -1 // assetA: AssetID
	callsub checkAssetsAB

	// contracts\BiatecClammPool.algo.ts:394
	// assert(assetLP.id === this.assetLP.value, 'assetLP does not match')
	frame_dig -3 // assetLP: AssetID
	byte 0x6c70 // "lp"
	app_global_get
	==

	// assetLP does not match
	assert
	retsub

// addLiquidity(uint64,uint64,txn,txn,uint64,uint64,uint64)uint64
*abi_route_addLiquidity:
	// The ABI return prefix
	byte 0x151f7c75

	// assetLP: uint64
	txna ApplicationArgs 5
	btoi

	// assetB: uint64
	txna ApplicationArgs 4
	btoi

	// assetA: uint64
	txna ApplicationArgs 3
	btoi

	// txAssetBDeposit: txn
	txn GroupIndex
	int 1
	-

	// txAssetADeposit: txn
	txn GroupIndex
	int 2
	-

	// appBiatecIdentityProvider: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute addLiquidity(uint64,uint64,txn,txn,uint64,uint64,uint64)uint64
	callsub addLiquidity
	itob
	concat
	log
	int 1
	return

// addLiquidity(appBiatecConfigProvider: AppID, appBiatecIdentityProvider: AppID, txAssetADeposit: Txn, txAssetBDeposit: Txn, assetA: AssetID, assetB: AssetID, assetLP: AssetID): uint64
//
// This method adds Asset A and Asset B to the Automated Market Maker Concentrated Liqudidity Pool and send to the liqudidty provider the liqudity token
// @param appBiatecConfigProvider Configuration reference
// @param appBiatecIdentityProvider Identity service reference
// @param txAssetADeposit Transfer of asset A to the LP pool
// @param txAssetBDeposit Transfer of asset B to the LP pool
// @param assetLP Liquidity pool asset
// @param assetA Asset A
// @param assetB Asset B
// @returns LP Token quantity distributed
addLiquidity:
	proto 7 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 23

	// contracts\BiatecClammPool.algo.ts:417
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:418
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// well formed mint
	// contracts\BiatecClammPool.algo.ts:420
	// this.checkAssets(assetA, assetB, assetLP)
	frame_dig -7 // assetLP: AssetID
	frame_dig -6 // assetB: AssetID
	frame_dig -5 // assetA: AssetID
	callsub checkAssets

	// contracts\BiatecClammPool.algo.ts:422
	// this.verifyIdentity(appBiatecConfigProvider, appBiatecIdentityProvider)
	frame_dig -2 // appBiatecIdentityProvider: AppID
	frame_dig -1 // appBiatecConfigProvider: AppID
	callsub verifyIdentity

	// contracts\BiatecClammPool.algo.ts:424
	// assetADecimals = 6
	int 6
	frame_bury 0 // assetADecimals: uint64

	// *if4_condition
	// contracts\BiatecClammPool.algo.ts:425
	// assetA.id > 0
	frame_dig -5 // assetA: AssetID
	int 0
	>
	bz *if4_end

	// *if4_consequent
	// contracts\BiatecClammPool.algo.ts:425
	// assetADecimals = assetA.decimals
	frame_dig -5 // assetA: AssetID
	asset_params_get AssetDecimals
	pop
	frame_bury 0 // assetADecimals: uint64

*if4_end:
	// contracts\BiatecClammPool.algo.ts:427
	// assetADelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetADecimals)) as uint256
	int 10
	int 9
	frame_dig 0 // assetADecimals: uint64
	-
	exp
	itob
	frame_bury 1 // assetADelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:429
	// assetBDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetB.decimals)) as uint256
	int 10
	int 9
	frame_dig -6 // assetB: AssetID
	asset_params_get AssetDecimals
	pop
	-
	exp
	itob
	frame_bury 2 // assetBDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:431
	// assetLPDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - LP_TOKEN_DECIMALS)) as uint256
	int 10
	int 3
	exp
	itob
	frame_bury 3 // assetLPDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:433
	// aDepositInBaseScale = (txAssetADeposit.assetAmount as uint256) * assetADelicmalScale2Scale
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	itob
	frame_dig 1 // assetADelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 4 // aDepositInBaseScale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:434
	// bDepositInBaseScale = (txAssetBDeposit.assetAmount as uint256) * assetBDelicmalScale2Scale
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	itob
	frame_dig 2 // assetBDelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 5 // bDepositInBaseScale: unsafe uint256

	// *if5_condition
	// contracts\BiatecClammPool.algo.ts:436
	// assetA.id > 0
	frame_dig -5 // assetA: AssetID
	int 0
	>
	bz *if5_else

	// *if5_consequent
	// contracts\BiatecClammPool.algo.ts:437
	// assert(txAssetADeposit.typeEnum === TransactionType.AssetTransfer)
	frame_dig -3 // txAssetADeposit: Txn
	gtxns TypeEnum
	int axfer
	==
	assert
	b *if5_end

*if5_else:
	// contracts\BiatecClammPool.algo.ts:439
	// assert(txAssetADeposit.typeEnum === TransactionType.Payment)
	frame_dig -3 // txAssetADeposit: Txn
	gtxns TypeEnum
	int pay
	==
	assert

*if5_end:
	// *if6_condition
	// contracts\BiatecClammPool.algo.ts:442
	// txAssetADeposit.typeEnum === TransactionType.AssetTransfer
	frame_dig -3 // txAssetADeposit: Txn
	gtxns TypeEnum
	int axfer
	==
	bz *if6_elseif1_condition

	// *if6_consequent
	// contracts\BiatecClammPool.algo.ts:443
	// xfer = txAssetADeposit as AssetTransferTxn
	frame_dig -3 // txAssetADeposit: Txn
	dup
	gtxns TypeEnum
	int axfer
	==
	assert
	frame_bury 6 // xfer: axfer

	// contracts\BiatecClammPool.algo.ts:444
	// verifyAssetTransferTxn(xfer, {
	//         assetReceiver: this.app.address,
	//         xferAsset: assetA,
	//         assetAmount: { greaterThanEqualTo: 0 },
	//       })
	// verify axfer
	frame_dig 6 // xfer: axfer
	gtxns TypeEnum
	int axfer
	==
	assert

	// verify assetReceiver
	frame_dig 6 // xfer: axfer
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert

	// verify xferAsset
	frame_dig 6 // xfer: axfer
	gtxns XferAsset
	frame_dig -5 // assetA: AssetID
	==
	assert

	// verify assetAmount
	frame_dig 6 // xfer: axfer
	gtxns AssetAmount
	int 0
	>=
	assert
	b *if6_end

*if6_elseif1_condition:
	// contracts\BiatecClammPool.algo.ts:449
	// txAssetADeposit.typeEnum === TransactionType.Payment
	frame_dig -3 // txAssetADeposit: Txn
	gtxns TypeEnum
	int pay
	==
	bz *if6_else

	// *if6_elseif1_consequent
	// contracts\BiatecClammPool.algo.ts:450
	// payTx = txAssetADeposit as PayTxn
	frame_dig -3 // txAssetADeposit: Txn
	dup
	gtxns TypeEnum
	int pay
	==
	assert
	frame_bury 7 // payTx: pay

	// contracts\BiatecClammPool.algo.ts:451
	// verifyPayTxn(payTx, {
	//         receiver: this.app.address,
	//         amount: { greaterThanEqualTo: 0 },
	//       })
	// verify pay
	frame_dig 7 // payTx: pay
	gtxns TypeEnum
	int pay
	==
	assert

	// verify receiver
	frame_dig 7 // payTx: pay
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig 7 // payTx: pay
	gtxns Amount
	int 0
	>=
	assert
	b *if6_end

*if6_else:
	// contracts\BiatecClammPool.algo.ts:456
	// assert(false, 'Unsupported tx type of the asset A')
	int 0

	// Unsupported tx type of the asset A
	assert

*if6_end:
	// *if7_condition
	// contracts\BiatecClammPool.algo.ts:459
	// txAssetBDeposit.typeEnum === TransactionType.AssetTransfer
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns TypeEnum
	int axfer
	==
	bz *if7_elseif1_condition

	// *if7_consequent
	// contracts\BiatecClammPool.algo.ts:460
	// xfer = txAssetBDeposit as AssetTransferTxn
	frame_dig -4 // txAssetBDeposit: Txn
	dup
	gtxns TypeEnum
	int axfer
	==
	assert
	frame_bury 8 // xfer: axfer

	// contracts\BiatecClammPool.algo.ts:461
	// verifyAssetTransferTxn(xfer, {
	//         assetReceiver: this.app.address,
	//         xferAsset: assetB,
	//         assetAmount: { greaterThanEqualTo: 0 },
	//       })
	// verify axfer
	frame_dig 8 // xfer: axfer
	gtxns TypeEnum
	int axfer
	==
	assert

	// verify assetReceiver
	frame_dig 8 // xfer: axfer
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert

	// verify xferAsset
	frame_dig 8 // xfer: axfer
	gtxns XferAsset
	frame_dig -6 // assetB: AssetID
	==
	assert

	// verify assetAmount
	frame_dig 8 // xfer: axfer
	gtxns AssetAmount
	int 0
	>=
	assert
	b *if7_end

*if7_elseif1_condition:
	// contracts\BiatecClammPool.algo.ts:466
	// txAssetBDeposit.typeEnum === TransactionType.Payment
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns TypeEnum
	int pay
	==
	bz *if7_else

	// *if7_elseif1_consequent
	// contracts\BiatecClammPool.algo.ts:467
	// payTx = txAssetBDeposit as PayTxn
	frame_dig -4 // txAssetBDeposit: Txn
	dup
	gtxns TypeEnum
	int pay
	==
	assert
	frame_bury 9 // payTx: pay

	// contracts\BiatecClammPool.algo.ts:468
	// verifyPayTxn(payTx, {
	//         receiver: this.app.address,
	//         amount: { greaterThanEqualTo: 0 },
	//       })
	// verify pay
	frame_dig 9 // payTx: pay
	gtxns TypeEnum
	int pay
	==
	assert

	// verify receiver
	frame_dig 9 // payTx: pay
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig 9 // payTx: pay
	gtxns Amount
	int 0
	>=
	assert
	b *if7_end

*if7_else:
	// contracts\BiatecClammPool.algo.ts:473
	// assert(false, 'Unsupported tx type of the asset B')
	int 0

	// Unsupported tx type of the asset B
	assert

*if7_end:
	// *if8_condition
	// contracts\BiatecClammPool.algo.ts:478
	// this.priceMinSqrt.value === this.priceMaxSqrt.value
	byte 0x704d696e53 // "pMinS"
	app_global_get
	byte 0x704d617853 // "pMaxS"
	app_global_get
	b==
	bz *if8_end

	// *if8_consequent
	// contracts\BiatecClammPool.algo.ts:479
	// return this.processAddLiqudity(aDepositInBaseScale, bDepositInBaseScale, assetLPDelicmalScale2Scale, assetLP);
	frame_dig -7 // assetLP: AssetID
	frame_dig 3 // assetLPDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 5 // bDepositInBaseScale: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 4 // aDepositInBaseScale: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub processAddLiqudity

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 9
	retsub

*if8_end:
	// *if9_condition
	// contracts\BiatecClammPool.algo.ts:484
	// this.assetABalance.value === <uint256>0 && this.assetBBalance.value === <uint256>0
	byte 0x6162 // "ab"
	app_global_get
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	b==
	dup
	bz *skip_and0
	byte 0x6262 // "bb"
	app_global_get
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	b==
	&&

*skip_and0:
	bz *if9_end

	// *if9_consequent
	// contracts\BiatecClammPool.algo.ts:489
	// ret = this.processAddLiqudity(
	//         aDepositInBaseScale,
	//         bDepositInBaseScale,
	//         assetLPDelicmalScale2Scale,
	//         assetLP
	//       )
	frame_dig -7 // assetLP: AssetID
	frame_dig 3 // assetLPDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 5 // bDepositInBaseScale: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 4 // aDepositInBaseScale: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub processAddLiqudity
	frame_bury 10 // ret: uint64

	// contracts\BiatecClammPool.algo.ts:496
	// newPrice = this.calculatePrice(
	//         this.assetABalance.value, // assetAQuantity: uint256,
	//         this.assetBBalance.value, // assetBQuantity: uint256,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value, // priceMaxSqrt: uint256,
	//         this.Liqudity.value // liquidity: uint256
	//       )
	byte 0x4c // "L"
	app_global_get
	byte 0x704d617853 // "pMaxS"
	app_global_get
	byte 0x704d696e53 // "pMinS"
	app_global_get
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	callsub calculatePrice
	frame_bury 11 // newPrice: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:504
	// this.currentPrice.value = newPrice as uint64
	byte 0x7072696365 // "price"
	frame_dig 11 // newPrice: unsafe uint256
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	app_global_put

	// contracts\BiatecClammPool.algo.ts:505
	// return ret;
	frame_dig 10 // ret: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 11
	retsub

*if9_end:
	// contracts\BiatecClammPool.algo.ts:512
	// a = this.calculateAssetADepositOnAssetBDeposit(
	//       aDepositInBaseScale,
	//       bDepositInBaseScale,
	//       this.assetABalance.value,
	//       this.assetBBalance.value
	//     )
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	frame_dig 5 // bDepositInBaseScale: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 4 // aDepositInBaseScale: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub calculateAssetADepositOnAssetBDeposit
	frame_bury 12 // a: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:519
	// b = this.calculateAssetBDepositOnAssetADeposit(
	//       aDepositInBaseScale,
	//       bDepositInBaseScale,
	//       this.assetABalance.value,
	//       this.assetBBalance.value
	//     )
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	frame_dig 5 // bDepositInBaseScale: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 4 // aDepositInBaseScale: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub calculateAssetBDepositOnAssetADeposit
	frame_bury 13 // b: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:525
	// expectedADepositB64 = (a / assetADelicmalScale2Scale) as uint64
	frame_dig 12 // a: unsafe uint256
	frame_dig 1 // assetADelicmalScale2Scale: unsafe uint256
	b/
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	frame_bury 14 // expectedADepositB64: uint64

	// contracts\BiatecClammPool.algo.ts:526
	// expectedBDepositB64 = (b / assetBDelicmalScale2Scale) as uint64
	frame_dig 13 // b: unsafe uint256
	frame_dig 2 // assetBDelicmalScale2Scale: unsafe uint256
	b/
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	frame_bury 15 // expectedBDepositB64: uint64

	// *if10_condition
	// contracts\BiatecClammPool.algo.ts:528
	// expectedADepositB64 > txAssetADeposit.assetAmount
	frame_dig 14 // expectedADepositB64: uint64
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	>
	bz *if10_end

	// *if10_consequent
	// *if11_condition
	// contracts\BiatecClammPool.algo.ts:535
	// expectedBDepositB64 > txAssetBDeposit.assetAmount
	frame_dig 15 // expectedBDepositB64: uint64
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	>
	bz *if11_end

	// *if11_consequent
	// contracts\BiatecClammPool.algo.ts:536
	// assert(false, 'Dominant is asset B')
	int 0

	// Dominant is asset B
	assert

*if11_end:
	// *if12_condition
	// contracts\BiatecClammPool.algo.ts:538
	// txAssetBDeposit.assetAmount - expectedBDepositB64 > 0
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	frame_dig 15 // expectedBDepositB64: uint64
	-
	int 0
	>
	bz *if12_end

	// *if12_consequent
	// contracts\BiatecClammPool.algo.ts:540
	// this.doAxfer(this.txn.sender, assetB, txAssetBDeposit.assetAmount - expectedBDepositB64)
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	frame_dig 15 // expectedBDepositB64: uint64
	-
	frame_dig -6 // assetB: AssetID
	txn Sender
	callsub doAxfer

*if12_end:
	// contracts\BiatecClammPool.algo.ts:542
	// realAssetADeposit = aDepositInBaseScale
	frame_dig 4 // aDepositInBaseScale: unsafe uint256
	frame_bury 16 // realAssetADeposit: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:543
	// realAssetBDeposit = (expectedBDepositB64 as uint256) * assetBDelicmalScale2Scale
	frame_dig 15 // expectedBDepositB64: uint64
	itob
	frame_dig 2 // assetBDelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 17 // realAssetBDeposit: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:544
	// return this.processAddLiqudity(realAssetADeposit, realAssetBDeposit, assetLPDelicmalScale2Scale, assetLP);
	frame_dig -7 // assetLP: AssetID
	frame_dig 3 // assetLPDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 17 // realAssetBDeposit: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 16 // realAssetADeposit: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub processAddLiqudity

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 17
	retsub

*if10_end:
	// *if13_condition
	// contracts\BiatecClammPool.algo.ts:547
	// expectedBDepositB64 > txAssetBDeposit.assetAmount
	frame_dig 15 // expectedBDepositB64: uint64
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	>
	bz *if13_end

	// *if13_consequent
	// *if14_condition
	// contracts\BiatecClammPool.algo.ts:554
	// expectedADepositB64 > txAssetADeposit.assetAmount
	frame_dig 14 // expectedADepositB64: uint64
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	>
	bz *if14_end

	// *if14_consequent
	// contracts\BiatecClammPool.algo.ts:555
	// assert(false, 'Dominant is asset A')
	int 0

	// Dominant is asset A
	assert

*if14_end:
	// *if15_condition
	// contracts\BiatecClammPool.algo.ts:557
	// txAssetADeposit.assetAmount - expectedADepositB64 > 0
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	frame_dig 14 // expectedADepositB64: uint64
	-
	int 0
	>
	bz *if15_end

	// *if15_consequent
	// contracts\BiatecClammPool.algo.ts:559
	// this.doAxfer(this.txn.sender, assetB, txAssetADeposit.assetAmount - expectedADepositB64)
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	frame_dig 14 // expectedADepositB64: uint64
	-
	frame_dig -6 // assetB: AssetID
	txn Sender
	callsub doAxfer

*if15_end:
	// contracts\BiatecClammPool.algo.ts:561
	// realAssetADeposit = (expectedADepositB64 as uint256) * assetADelicmalScale2Scale
	frame_dig 14 // expectedADepositB64: uint64
	itob
	frame_dig 1 // assetADelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 18 // realAssetADeposit: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:562
	// realAssetBDeposit = bDepositInBaseScale
	frame_dig 5 // bDepositInBaseScale: unsafe uint256
	frame_bury 19 // realAssetBDeposit: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:563
	// return this.processAddLiqudity(realAssetADeposit, realAssetBDeposit, assetLPDelicmalScale2Scale, assetLP);
	frame_dig -7 // assetLP: AssetID
	frame_dig 3 // assetLPDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 19 // realAssetBDeposit: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 18 // realAssetADeposit: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub processAddLiqudity

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 19
	retsub

*if13_end:
	// *if16_condition
	// contracts\BiatecClammPool.algo.ts:565
	// expectedADepositB64 === txAssetADeposit.assetAmount && expectedBDepositB64 === txAssetBDeposit.assetAmount
	frame_dig 14 // expectedADepositB64: uint64
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	==
	dup
	bz *skip_and1
	frame_dig 15 // expectedBDepositB64: uint64
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	==
	&&

*skip_and1:
	bz *if16_end

	// *if16_consequent
	// contracts\BiatecClammPool.algo.ts:566
	// realAssetADeposit = aDepositInBaseScale
	frame_dig 4 // aDepositInBaseScale: unsafe uint256
	frame_bury 20 // realAssetADeposit: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:567
	// realAssetBDeposit = bDepositInBaseScale
	frame_dig 5 // bDepositInBaseScale: unsafe uint256
	frame_bury 21 // realAssetBDeposit: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:568
	// return this.processAddLiqudity(realAssetADeposit, realAssetBDeposit, assetLPDelicmalScale2Scale, assetLP);
	frame_dig -7 // assetLP: AssetID
	frame_dig 3 // assetLPDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 21 // realAssetBDeposit: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 20 // realAssetADeposit: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub processAddLiqudity

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 21
	retsub

*if16_end:
	// *if17_condition
	// contracts\BiatecClammPool.algo.ts:571
	// expectedADepositB64 === txAssetADeposit.assetAmount && expectedBDepositB64 === txAssetBDeposit.assetAmount
	frame_dig 14 // expectedADepositB64: uint64
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	==
	dup
	bz *skip_and2
	frame_dig 15 // expectedBDepositB64: uint64
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	==
	&&

*skip_and2:
	bz *if17_end

	// *if17_consequent
	// contracts\BiatecClammPool.algo.ts:572
	// realAssetADeposit = aDepositInBaseScale
	frame_dig 4 // aDepositInBaseScale: unsafe uint256
	frame_bury 22 // realAssetADeposit: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:573
	// realAssetBDeposit = bDepositInBaseScale
	frame_dig 5 // bDepositInBaseScale: unsafe uint256
	frame_bury 23 // realAssetBDeposit: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:574
	// return this.processAddLiqudity(realAssetADeposit, realAssetBDeposit, assetLPDelicmalScale2Scale, assetLP);
	frame_dig -7 // assetLP: AssetID
	frame_dig 3 // assetLPDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 23 // realAssetBDeposit: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 22 // realAssetADeposit: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub processAddLiqudity

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 23
	retsub

*if17_end:
	// *if18_condition
	// contracts\BiatecClammPool.algo.ts:577
	// expectedADepositB64 === 0 && expectedBDepositB64 === 0
	frame_dig 14 // expectedADepositB64: uint64
	int 0
	==
	dup
	bz *skip_and3
	frame_dig 15 // expectedBDepositB64: uint64
	int 0
	==
	&&

*skip_and3:
	bz *if18_end

	// *if18_consequent
	// *if19_condition
	// contracts\BiatecClammPool.algo.ts:579
	// txAssetADeposit.assetAmount > 0
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	int 0
	>
	bz *if19_end

	// *if19_consequent
	// contracts\BiatecClammPool.algo.ts:580
	// this.doAxfer(this.txn.sender, assetA, txAssetADeposit.assetAmount)
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	frame_dig -5 // assetA: AssetID
	txn Sender
	callsub doAxfer

*if19_end:
	// *if20_condition
	// contracts\BiatecClammPool.algo.ts:582
	// txAssetBDeposit.assetAmount > 0
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	int 0
	>
	bz *if20_end

	// *if20_consequent
	// contracts\BiatecClammPool.algo.ts:583
	// this.doAxfer(this.txn.sender, assetB, txAssetBDeposit.assetAmount)
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	frame_dig -6 // assetB: AssetID
	txn Sender
	callsub doAxfer

*if20_end:
	// contracts\BiatecClammPool.algo.ts:585
	// return 0;
	int 0

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 23
	retsub

*if18_end:
	// contracts\BiatecClammPool.algo.ts:587
	// assert(false, 'failed to calculate exact liqudidity')
	int 0

	// failed to calculate exact liqudidity
	assert

	// contracts\BiatecClammPool.algo.ts:588
	// return expectedBDepositB64;
	frame_dig 15 // expectedBDepositB64: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 23
	retsub

// processAddLiqudity(realAssetADeposit: uint256, realAssetBDeposit: uint256, assetLPDelicmalScale2Scale: uint256, assetLP: AssetID): uint64
//
// This method is used in addLiquidity to process the liquidity addition from calculated values
// @param realAssetADeposit Real asset a deposit
// @param realAssetBDeposit Real asset b deposit
// @param assetLPDelicmalScale2Scale LP decimal scale
// @param assetLP LP Asset
// @returns LP Token quantity distributed
processAddLiqudity:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 8

	// contracts\BiatecClammPool.algo.ts:605
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:607
	// this.assetABalance.value = this.assetABalance.value + realAssetADeposit
	byte 0x6162 // "ab"
	dup
	app_global_get
	frame_dig -1 // realAssetADeposit: uint256
	b+
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:608
	// this.assetBBalance.value = this.assetBBalance.value + realAssetBDeposit
	byte 0x6262 // "bb"
	dup
	app_global_get
	frame_dig -2 // realAssetBDeposit: uint256
	b+
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:611
	// x = this.assetABalance.value
	byte 0x6162 // "ab"
	app_global_get
	frame_bury 0 // x: uint256

	// contracts\BiatecClammPool.algo.ts:612
	// y = this.assetBBalance.value
	byte 0x6262 // "bb"
	app_global_get
	frame_bury 1 // y: uint256

	// contracts\BiatecClammPool.algo.ts:613
	// priceMin = this.priceMin.value as uint256
	byte 0x704d696e // "pMin"
	app_global_get
	itob
	frame_bury 2 // priceMin: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:614
	// priceMax = this.priceMax.value as uint256
	byte 0x704d6178 // "pMax"
	app_global_get
	itob
	frame_bury 3 // priceMax: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:615
	// priceMinSqrt = this.priceMinSqrt.value
	byte 0x704d696e53 // "pMinS"
	app_global_get
	frame_bury 4 // priceMinSqrt: uint256

	// contracts\BiatecClammPool.algo.ts:616
	// priceMaxSqrt = this.priceMaxSqrt.value
	byte 0x704d617853 // "pMaxS"
	app_global_get
	frame_bury 5 // priceMaxSqrt: uint256

	// contracts\BiatecClammPool.algo.ts:617
	// newLiqudity = <uint256>0
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 6 // newLiqudity: unsafe uint256

	// *if21_condition
	// contracts\BiatecClammPool.algo.ts:618
	// priceMin === priceMax
	frame_dig 2 // priceMin: unsafe uint256
	frame_dig 3 // priceMax: unsafe uint256
	b==
	bz *if21_else

	// *if21_consequent
	// contracts\BiatecClammPool.algo.ts:619
	// newLiqudity = this.calculateLiquidityFlatPrice(x, y, priceMin)
	frame_dig 2 // priceMin: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 1 // y: uint256
	frame_dig 0 // x: uint256
	callsub calculateLiquidityFlatPrice
	frame_bury 6 // newLiqudity: unsafe uint256
	b *if21_end

*if21_else:
	// contracts\BiatecClammPool.algo.ts:621
	// D_SQRT = this.calculateLiquidityD(x, y, priceMin, priceMax, priceMinSqrt, priceMaxSqrt)
	frame_dig 5 // priceMaxSqrt: uint256
	frame_dig 4 // priceMinSqrt: uint256
	frame_dig 3 // priceMax: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 2 // priceMin: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 1 // y: uint256
	frame_dig 0 // x: uint256
	callsub calculateLiquidityD
	frame_bury 7 // D_SQRT: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:622
	// newLiqudity = this.calculateLiquidityWithD(x, y, priceMinSqrt, priceMaxSqrt, D_SQRT)
	frame_dig 7 // D_SQRT: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 5 // priceMaxSqrt: uint256
	frame_dig 4 // priceMinSqrt: uint256
	frame_dig 1 // y: uint256
	frame_dig 0 // x: uint256
	callsub calculateLiquidityWithD
	frame_bury 6 // newLiqudity: unsafe uint256

*if21_end:
	// contracts\BiatecClammPool.algo.ts:625
	// lpTokensToSend = ((newLiqudity - this.Liqudity.value) / assetLPDelicmalScale2Scale) as uint64
	frame_dig 6 // newLiqudity: unsafe uint256
	byte 0x4c // "L"
	app_global_get
	b-
	frame_dig -3 // assetLPDelicmalScale2Scale: uint256
	b/
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	frame_bury 8 // lpTokensToSend: uint64

	// contracts\BiatecClammPool.algo.ts:627
	// this.Liqudity.value = newLiqudity
	byte 0x4c // "L"
	frame_dig 6 // newLiqudity: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:629
	// this.doAxfer(this.txn.sender, assetLP, lpTokensToSend)
	frame_dig 8 // lpTokensToSend: uint64
	frame_dig -4 // assetLP: AssetID
	txn Sender
	callsub doAxfer

	// contracts\BiatecClammPool.algo.ts:635
	// assert(lpTokensToSend > 0, 'LP-ZERO-ERR')
	frame_dig 8 // lpTokensToSend: uint64
	int 0
	>

	// LP-ZERO-ERR
	assert

	// contracts\BiatecClammPool.algo.ts:636
	// return lpTokensToSend as uint64;
	frame_dig 8 // lpTokensToSend: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 8
	retsub

// removeLiquidity(uint64,uint64,axfer,uint64,uint64,uint64)uint256
*abi_route_removeLiquidity:
	// The ABI return prefix
	byte 0x151f7c75

	// assetLP: uint64
	txna ApplicationArgs 5
	btoi

	// assetB: uint64
	txna ApplicationArgs 4
	btoi

	// assetA: uint64
	txna ApplicationArgs 3
	btoi

	// txLPXfer: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==
	assert

	// appBiatecIdentityProvider: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute removeLiquidity(uint64,uint64,axfer,uint64,uint64,uint64)uint256
	callsub removeLiquidity
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// removeLiquidity(appBiatecConfigProvider: AppID, appBiatecIdentityProvider: AppID, txLPXfer: AssetTransferTxn, assetA: AssetID, assetB: AssetID, assetLP: AssetID): uint256
//
// This method retrieves from the liquidity provider LP token and returns Asset A and Asset B from the Automated Market Maker Concentrated Liqudidity Pool
// @param appBiatecConfigProvider Configuration reference
// @param appBiatecIdentityProvider Identity service reference
// @param txLPXfer Transfer of the LP token
// @param assetLP LP pool asset
// @param assetA Asset A
// @param assetB Asset B
// @returns LP position reduced
removeLiquidity:
	proto 6 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 17

	// well formed mint
	// contracts\BiatecClammPool.algo.ts:658
	// this.checkAssets(assetA, assetB, assetLP)
	frame_dig -6 // assetLP: AssetID
	frame_dig -5 // assetB: AssetID
	frame_dig -4 // assetA: AssetID
	callsub checkAssets

	// contracts\BiatecClammPool.algo.ts:659
	// verifyAssetTransferTxn(txLPXfer, {
	//       assetReceiver: this.app.address,
	//       xferAsset: assetLP,
	//       assetAmount: { greaterThanEqualTo: 0 },
	//     })
	// verify assetReceiver
	frame_dig -3 // txLPXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert

	// verify xferAsset
	frame_dig -3 // txLPXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -6 // assetLP: AssetID
	==
	assert

	// verify assetAmount
	frame_dig -3 // txLPXfer: AssetTransferTxn
	gtxns AssetAmount
	int 0
	>=
	assert

	// contracts\BiatecClammPool.algo.ts:665
	// this.verifyIdentity(appBiatecConfigProvider, appBiatecIdentityProvider)
	frame_dig -2 // appBiatecIdentityProvider: AppID
	frame_dig -1 // appBiatecConfigProvider: AppID
	callsub verifyIdentity

	// contracts\BiatecClammPool.algo.ts:668
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:669
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:671
	// assetADecimals = 6
	int 6
	frame_bury 0 // assetADecimals: uint64

	// *if22_condition
	// contracts\BiatecClammPool.algo.ts:672
	// assetA.id > 0
	frame_dig -4 // assetA: AssetID
	int 0
	>
	bz *if22_end

	// *if22_consequent
	// contracts\BiatecClammPool.algo.ts:672
	// assetADecimals = assetA.decimals
	frame_dig -4 // assetA: AssetID
	asset_params_get AssetDecimals
	pop
	frame_bury 0 // assetADecimals: uint64

*if22_end:
	// contracts\BiatecClammPool.algo.ts:674
	// assetADelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetADecimals)) as uint256
	int 10
	int 9
	frame_dig 0 // assetADecimals: uint64
	-
	exp
	itob
	frame_bury 1 // assetADelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:676
	// assetBDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetB.decimals)) as uint256
	int 10
	int 9
	frame_dig -5 // assetB: AssetID
	asset_params_get AssetDecimals
	pop
	-
	exp
	itob
	frame_bury 2 // assetBDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:678
	// assetLPDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - LP_TOKEN_DECIMALS)) as uint256
	int 10
	int 3
	exp
	itob
	frame_bury 3 // assetLPDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:680
	// lpDelta = txLPXfer.assetAmount as uint256
	frame_dig -3 // txLPXfer: AssetTransferTxn
	gtxns AssetAmount
	itob
	frame_bury 4 // lpDelta: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:681
	// lpDeltaBase = lpDelta * assetLPDelicmalScale2Scale
	frame_dig 4 // lpDelta: unsafe uint256
	frame_dig 3 // assetLPDelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 5 // lpDeltaBase: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:682
	// lpDeltaWithFees = lpDeltaBase
	frame_dig 5 // lpDeltaBase: unsafe uint256
	frame_bury 6 // lpDeltaWithFees: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:683
	// lpWithOthers = this.calculateDistributedLiquidity(assetLP, lpDelta)
	frame_dig 4 // lpDelta: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig -6 // assetLP: AssetID
	callsub calculateDistributedLiquidity
	frame_bury 7 // lpWithOthers: unsafe uint256

	// *if23_condition
	// contracts\BiatecClammPool.algo.ts:684
	// lpWithOthers > <uint256>0
	frame_dig 7 // lpWithOthers: unsafe uint256
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	bz *if23_end

	// *if23_consequent
	// contracts\BiatecClammPool.algo.ts:686
	// myPortion = (lpDeltaBase * s) / lpWithOthers
	frame_dig 5 // lpDeltaBase: unsafe uint256
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 7 // lpWithOthers: unsafe uint256
	b/
	frame_bury 8 // myPortion: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:687
	// myPortionOfFeesCollected = (this.LiqudityUsersFromFees.value * myPortion) / s
	byte 0x4c75 // "Lu"
	app_global_get
	frame_dig 8 // myPortion: unsafe uint256
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 9 // myPortionOfFeesCollected: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:688
	// lpDeltaWithFees = lpDeltaBase + myPortionOfFeesCollected
	frame_dig 5 // lpDeltaBase: unsafe uint256
	frame_dig 9 // myPortionOfFeesCollected: unsafe uint256
	b+
	frame_bury 6 // lpDeltaWithFees: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:689
	// this.LiqudityUsersFromFees.value = this.LiqudityUsersFromFees.value - myPortionOfFeesCollected
	byte 0x4c75 // "Lu"
	dup
	app_global_get
	frame_dig 9 // myPortionOfFeesCollected: unsafe uint256
	b-
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

*if23_end:
	// contracts\BiatecClammPool.algo.ts:691
	// aToSend = this.calculateAssetAWithdrawOnLpDeposit(
	//       lpDeltaWithFees,
	//       this.assetABalance.value,
	//       this.Liqudity.value
	//     )
	byte 0x4c // "L"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	frame_dig 6 // lpDeltaWithFees: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub calculateAssetAWithdrawOnLpDeposit
	frame_bury 10 // aToSend: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:696
	// aToSend64 = (aToSend / assetADelicmalScale2Scale) as uint64
	frame_dig 10 // aToSend: unsafe uint256
	frame_dig 1 // assetADelicmalScale2Scale: unsafe uint256
	b/
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	frame_bury 11 // aToSend64: uint64

	// *if24_condition
	// contracts\BiatecClammPool.algo.ts:697
	// aToSend64 > 0
	frame_dig 11 // aToSend64: uint64
	int 0
	>
	bz *if24_end

	// *if24_consequent
	// contracts\BiatecClammPool.algo.ts:698
	// this.doAxfer(this.txn.sender, assetA, aToSend64)
	frame_dig 11 // aToSend64: uint64
	frame_dig -4 // assetA: AssetID
	txn Sender
	callsub doAxfer

*if24_end:
	// contracts\BiatecClammPool.algo.ts:700
	// bToSend = this.calculateAssetAWithdrawOnLpDeposit(
	//       lpDeltaWithFees,
	//       this.assetBBalance.value,
	//       this.Liqudity.value
	//     )
	byte 0x4c // "L"
	app_global_get
	byte 0x6262 // "bb"
	app_global_get
	frame_dig 6 // lpDeltaWithFees: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub calculateAssetAWithdrawOnLpDeposit
	frame_bury 12 // bToSend: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:705
	// bToSend64 = (bToSend / assetBDelicmalScale2Scale) as uint64
	frame_dig 12 // bToSend: unsafe uint256
	frame_dig 2 // assetBDelicmalScale2Scale: unsafe uint256
	b/
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	frame_bury 13 // bToSend64: uint64

	// *if25_condition
	// contracts\BiatecClammPool.algo.ts:706
	// bToSend64 > 0
	frame_dig 13 // bToSend64: uint64
	int 0
	>
	bz *if25_end

	// *if25_consequent
	// contracts\BiatecClammPool.algo.ts:707
	// this.doAxfer(this.txn.sender, assetB, bToSend64)
	frame_dig 13 // bToSend64: uint64
	frame_dig -5 // assetB: AssetID
	txn Sender
	callsub doAxfer

*if25_end:
	// contracts\BiatecClammPool.algo.ts:711
	// assert(aToSend64 > 0 || bToSend64 > 0, 'ERR-REM-ZERO')
	frame_dig 11 // aToSend64: uint64
	int 0
	>
	dup
	bnz *skip_or0
	frame_dig 13 // bToSend64: uint64
	int 0
	>
	||

*skip_or0:
	// ERR-REM-ZERO
	assert

	// contracts\BiatecClammPool.algo.ts:713
	// newAssetA = this.assetABalance.value - aToSend
	byte 0x6162 // "ab"
	app_global_get
	frame_dig 10 // aToSend: unsafe uint256
	b-
	frame_bury 14 // newAssetA: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:714
	// newAssetB = this.assetBBalance.value - bToSend
	byte 0x6262 // "bb"
	app_global_get
	frame_dig 12 // bToSend: unsafe uint256
	b-
	frame_bury 15 // newAssetB: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:715
	// this.assetABalance.value = newAssetA
	byte 0x6162 // "ab"
	frame_dig 14 // newAssetA: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:716
	// this.assetBBalance.value = newAssetB
	byte 0x6262 // "bb"
	frame_dig 15 // newAssetB: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:720
	// lAfter = <uint256>0
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 16 // lAfter: unsafe uint256

	// *if26_condition
	// contracts\BiatecClammPool.algo.ts:721
	// this.priceMin.value === this.priceMax.value
	byte 0x704d696e // "pMin"
	app_global_get
	byte 0x704d6178 // "pMax"
	app_global_get
	==
	bz *if26_else

	// *if26_consequent
	// contracts\BiatecClammPool.algo.ts:722
	// lAfter = this.calculateLiquidityFlatPrice(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMin.value as uint256
	//       )
	byte 0x704d696e // "pMin"
	app_global_get
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	callsub calculateLiquidityFlatPrice
	frame_bury 16 // lAfter: unsafe uint256
	b *if26_end

*if26_else:
	// contracts\BiatecClammPool.algo.ts:728
	// D_SQRT = this.calculateLiquidityD(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMin.value as uint256, // priceMin: uint256,
	//         this.priceMax.value as uint256, // priceMax: uint256,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value // priceMaxSqrt: uint256,
	//       )
	byte 0x704d617853 // "pMaxS"
	app_global_get
	byte 0x704d696e53 // "pMinS"
	app_global_get
	byte 0x704d6178 // "pMax"
	app_global_get
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	byte 0x704d696e // "pMin"
	app_global_get
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	callsub calculateLiquidityD
	frame_bury 17 // D_SQRT: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:736
	// lAfter = this.calculateLiquidityWithD(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value, // priceMaxSqrt: uint256,
	//         D_SQRT
	//       )
	frame_dig 17 // D_SQRT: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	byte 0x704d617853 // "pMaxS"
	app_global_get
	byte 0x704d696e53 // "pMinS"
	app_global_get
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	callsub calculateLiquidityWithD
	frame_bury 16 // lAfter: unsafe uint256

*if26_end:
	// contracts\BiatecClammPool.algo.ts:744
	// this.Liqudity.value = lAfter
	byte 0x4c // "L"
	frame_dig 16 // lAfter: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:745
	// return lpDeltaWithFees / assetLPDelicmalScale2Scale;
	frame_dig 6 // lpDeltaWithFees: unsafe uint256
	frame_dig 3 // assetLPDelicmalScale2Scale: unsafe uint256
	b/

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 17
	retsub

// removeLiquidityAdmin(uint64,uint64,uint64,uint64,uint256)uint256
*abi_route_removeLiquidityAdmin:
	// The ABI return prefix
	byte 0x151f7c75

	// amount: uint256
	txna ApplicationArgs 5
	dup
	len
	int 32
	==
	assert

	// assetLP: uint64
	txna ApplicationArgs 4
	btoi

	// assetB: uint64
	txna ApplicationArgs 3
	btoi

	// assetA: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute removeLiquidityAdmin(uint64,uint64,uint64,uint64,uint256)uint256
	callsub removeLiquidityAdmin
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// removeLiquidityAdmin(appBiatecConfigProvider: AppID, assetA: AssetID, assetB: AssetID, assetLP: AssetID, amount: uint256): uint256
//
// This method allows biatec admin to reduce the lp position created by lp fees allocation.
//
// Only addressExecutiveFee is allowed to execute this method.
//
// @param appBiatecConfigProvider Biatec config app. Only addressExecutiveFee is allowed to execute this method.
// @param assetA Asset A
// @param assetB Asset B
// @param amount Amount to withdraw. If zero, removes all available lps from fees.
//
// @returns LP position reduced
removeLiquidityAdmin:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 14

	// well formed mint
	// contracts\BiatecClammPool.algo.ts:768
	// this.checkAssets(assetA, assetB, assetLP)
	frame_dig -4 // assetLP: AssetID
	frame_dig -3 // assetB: AssetID
	frame_dig -2 // assetA: AssetID
	callsub checkAssets

	// contracts\BiatecClammPool.algo.ts:770
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value)
	frame_dig -1 // appBiatecConfigProvider: AppID
	byte 0x42 // "B"
	app_global_get
	==
	assert

	// contracts\BiatecClammPool.algo.ts:771
	// addressExecutiveFee = appBiatecConfigProvider.globalState('ef')
	frame_dig -1 // appBiatecConfigProvider: AppID
	byte 0x6566 // "ef"
	app_global_get_ex
	assert
	frame_bury 0 // addressExecutiveFee: any

	// contracts\BiatecClammPool.algo.ts:773
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -1 // appBiatecConfigProvider: AppID
	byte 0x73 // "s"
	app_global_get_ex
	assert
	frame_bury 1 // paused: uint64

	// contracts\BiatecClammPool.algo.ts:774
	// assert(paused === 0, 'ERR_PAUSED')
	frame_dig 1 // paused: uint64
	int 0
	==

	// ERR_PAUSED
	assert

	// contracts\BiatecClammPool.algo.ts:780
	// assert(this.txn.sender === addressExecutiveFee, 'ERR-EXEC-ONLY')
	txn Sender
	frame_dig 0 // addressExecutiveFee: any
	==

	// ERR-EXEC-ONLY
	assert

	// contracts\BiatecClammPool.algo.ts:782
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:783
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:785
	// assetADecimals = 6
	int 6
	frame_bury 2 // assetADecimals: uint64

	// *if27_condition
	// contracts\BiatecClammPool.algo.ts:786
	// assetA.id > 0
	frame_dig -2 // assetA: AssetID
	int 0
	>
	bz *if27_end

	// *if27_consequent
	// contracts\BiatecClammPool.algo.ts:786
	// assetADecimals = assetA.decimals
	frame_dig -2 // assetA: AssetID
	asset_params_get AssetDecimals
	pop
	frame_bury 2 // assetADecimals: uint64

*if27_end:
	// contracts\BiatecClammPool.algo.ts:788
	// assetADelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetADecimals)) as uint256
	int 10
	int 9
	frame_dig 2 // assetADecimals: uint64
	-
	exp
	itob
	frame_bury 3 // assetADelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:790
	// assetBDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetB.decimals)) as uint256
	int 10
	int 9
	frame_dig -3 // assetB: AssetID
	asset_params_get AssetDecimals
	pop
	-
	exp
	itob
	frame_bury 4 // assetBDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:792
	// assetLPDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - LP_TOKEN_DECIMALS)) as uint256
	int 10
	int 3
	exp
	itob
	frame_bury 5 // assetLPDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:794
	// lpDeltaWithFees = amount
	frame_dig -5 // amount: uint256
	frame_bury 6 // lpDeltaWithFees: unsafe uint256

	// *if28_condition
	// contracts\BiatecClammPool.algo.ts:795
	// lpDeltaWithFees === <uint256>0
	frame_dig 6 // lpDeltaWithFees: unsafe uint256
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	b==
	bz *if28_end

	// *if28_consequent
	// contracts\BiatecClammPool.algo.ts:795
	// lpDeltaWithFees = this.LiqudityBiatecFromFees.value
	byte 0x4c62 // "Lb"
	app_global_get
	frame_bury 6 // lpDeltaWithFees: unsafe uint256

*if28_end:
	// contracts\BiatecClammPool.algo.ts:796
	// assert(
	//       lpDeltaWithFees <= this.LiqudityBiatecFromFees.value,
	//       'ERR-TOO-MUCH' // 'Biatec cannot take more lp then is collected in fees'
	//     )
	frame_dig 6 // lpDeltaWithFees: unsafe uint256
	byte 0x4c62 // "Lb"
	app_global_get
	b<=

	// ERR-TOO-MUCH
	assert

	// contracts\BiatecClammPool.algo.ts:800
	// this.LiqudityBiatecFromFees.value = this.LiqudityBiatecFromFees.value - lpDeltaWithFees
	byte 0x4c62 // "Lb"
	dup
	app_global_get
	frame_dig 6 // lpDeltaWithFees: unsafe uint256
	b-
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:801
	// aToSend = this.calculateAssetAWithdrawOnLpDeposit(
	//       lpDeltaWithFees,
	//       this.assetABalance.value,
	//       this.Liqudity.value
	//     )
	byte 0x4c // "L"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	frame_dig 6 // lpDeltaWithFees: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub calculateAssetAWithdrawOnLpDeposit
	frame_bury 7 // aToSend: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:806
	// aToSend64 = (aToSend / assetADelicmalScale2Scale) as uint64
	frame_dig 7 // aToSend: unsafe uint256
	frame_dig 3 // assetADelicmalScale2Scale: unsafe uint256
	b/
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	frame_bury 8 // aToSend64: uint64

	// *if29_condition
	// contracts\BiatecClammPool.algo.ts:807
	// aToSend64 > 0
	frame_dig 8 // aToSend64: uint64
	int 0
	>
	bz *if29_end

	// *if29_consequent
	// contracts\BiatecClammPool.algo.ts:808
	// this.doAxfer(this.txn.sender, assetA, aToSend64)
	frame_dig 8 // aToSend64: uint64
	frame_dig -2 // assetA: AssetID
	txn Sender
	callsub doAxfer

*if29_end:
	// contracts\BiatecClammPool.algo.ts:810
	// bToSend = this.calculateAssetAWithdrawOnLpDeposit(
	//       lpDeltaWithFees,
	//       this.assetBBalance.value,
	//       this.Liqudity.value
	//     )
	byte 0x4c // "L"
	app_global_get
	byte 0x6262 // "bb"
	app_global_get
	frame_dig 6 // lpDeltaWithFees: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub calculateAssetAWithdrawOnLpDeposit
	frame_bury 9 // bToSend: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:815
	// bToSend64 = (bToSend / assetBDelicmalScale2Scale) as uint64
	frame_dig 9 // bToSend: unsafe uint256
	frame_dig 4 // assetBDelicmalScale2Scale: unsafe uint256
	b/
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	frame_bury 10 // bToSend64: uint64

	// *if30_condition
	// contracts\BiatecClammPool.algo.ts:816
	// bToSend64 > 0
	frame_dig 10 // bToSend64: uint64
	int 0
	>
	bz *if30_end

	// *if30_consequent
	// contracts\BiatecClammPool.algo.ts:817
	// this.doAxfer(this.txn.sender, assetB, bToSend64)
	frame_dig 10 // bToSend64: uint64
	frame_dig -3 // assetB: AssetID
	txn Sender
	callsub doAxfer

*if30_end:
	// contracts\BiatecClammPool.algo.ts:820
	// newAssetA = this.assetABalance.value - aToSend
	byte 0x6162 // "ab"
	app_global_get
	frame_dig 7 // aToSend: unsafe uint256
	b-
	frame_bury 11 // newAssetA: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:821
	// newAssetB = this.assetBBalance.value - bToSend
	byte 0x6262 // "bb"
	app_global_get
	frame_dig 9 // bToSend: unsafe uint256
	b-
	frame_bury 12 // newAssetB: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:822
	// this.assetABalance.value = newAssetA
	byte 0x6162 // "ab"
	frame_dig 11 // newAssetA: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:823
	// this.assetBBalance.value = newAssetB
	byte 0x6262 // "bb"
	frame_dig 12 // newAssetB: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:827
	// lAfter = <uint256>0
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 13 // lAfter: unsafe uint256

	// *if31_condition
	// contracts\BiatecClammPool.algo.ts:828
	// this.priceMin.value === this.priceMax.value
	byte 0x704d696e // "pMin"
	app_global_get
	byte 0x704d6178 // "pMax"
	app_global_get
	==
	bz *if31_else

	// *if31_consequent
	// contracts\BiatecClammPool.algo.ts:829
	// lAfter = this.calculateLiquidityFlatPrice(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMin.value as uint256 // priceMin: uint256,
	//       )
	byte 0x704d696e // "pMin"
	app_global_get
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	callsub calculateLiquidityFlatPrice
	frame_bury 13 // lAfter: unsafe uint256
	b *if31_end

*if31_else:
	// contracts\BiatecClammPool.algo.ts:835
	// D_SQRT = this.calculateLiquidityD(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMin.value as uint256, // priceMin: uint256,
	//         this.priceMax.value as uint256, // priceMax: uint256,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value // priceMaxSqrt: uint256,
	//       )
	byte 0x704d617853 // "pMaxS"
	app_global_get
	byte 0x704d696e53 // "pMinS"
	app_global_get
	byte 0x704d6178 // "pMax"
	app_global_get
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	byte 0x704d696e // "pMin"
	app_global_get
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	callsub calculateLiquidityD
	frame_bury 14 // D_SQRT: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:843
	// lAfter = this.calculateLiquidityWithD(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value, // priceMaxSqrt: uint256,
	//         D_SQRT
	//       )
	frame_dig 14 // D_SQRT: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	byte 0x704d617853 // "pMaxS"
	app_global_get
	byte 0x704d696e53 // "pMinS"
	app_global_get
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	callsub calculateLiquidityWithD
	frame_bury 13 // lAfter: unsafe uint256

*if31_end:
	// contracts\BiatecClammPool.algo.ts:851
	// this.Liqudity.value = lAfter
	byte 0x4c // "L"
	frame_dig 13 // lAfter: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:852
	// return lpDeltaWithFees / assetLPDelicmalScale2Scale;
	frame_dig 6 // lpDeltaWithFees: unsafe uint256
	frame_dig 5 // assetLPDelicmalScale2Scale: unsafe uint256
	b/

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 14
	retsub

// verifyIdentity(appBiatecConfigProvider: AppID, appBiatecIdentityProvider: AppID): UserInfoV1
//
// Checks if config matches with the app configuration, identity matches with the config, and user is not banned.
//
// Fetches the user info from the identity app and returns the engagement, verification class,...
//
// @param appBiatecConfigProvider Biatec config provider
// @param appBiatecIdentityProvider Biatec identity provider
// @returns User info object
verifyIdentity:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts\BiatecClammPool.algo.ts:865
	// assert(
	//       appBiatecConfigProvider === this.appBiatecConfigProvider.value,
	//       'ERR-INVALID-CONFIG' // 'Configuration app does not match'
	//     )
	frame_dig -1 // appBiatecConfigProvider: AppID
	byte 0x42 // "B"
	app_global_get
	==

	// ERR-INVALID-CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:869
	// identityFromConfig = appBiatecConfigProvider.globalState('i')
	frame_dig -1 // appBiatecConfigProvider: AppID
	byte 0x69 // "i"
	app_global_get_ex
	assert
	frame_bury 0 // identityFromConfig: any

	// contracts\BiatecClammPool.algo.ts:870
	// assert(
	//       appBiatecIdentityProvider === identityFromConfig,
	//       'ERR-WRONG-IDENT' // appBiatecIdentityProvider must match to the config in appBiatecConfigProvider'
	//     )
	frame_dig -2 // appBiatecIdentityProvider: AppID
	frame_dig 0 // identityFromConfig: any
	==

	// ERR-WRONG-IDENT
	assert

	// contracts\BiatecClammPool.algo.ts:875
	// user = sendMethodCall<[Address, uint8], UserInfoV1>({
	//       name: 'getUser',
	//       methodArgs: [this.txn.sender, <uint8>1],
	//       fee: 0,
	//       applicationID: appBiatecIdentityProvider,
	//     })
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "getUser(address,uint8)(uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint256,uint256,bool,uint64,uint64,bool)"
	itxn_field ApplicationArgs

	// contracts\BiatecClammPool.algo.ts:877
	// methodArgs: [this.txn.sender, <uint8>1]
	txn Sender
	itxn_field ApplicationArgs
	byte 0x01
	itxn_field ApplicationArgs

	// contracts\BiatecClammPool.algo.ts:878
	// fee: 0
	int 0
	itxn_field Fee

	// contracts\BiatecClammPool.algo.ts:879
	// applicationID: appBiatecIdentityProvider
	frame_dig -2 // appBiatecIdentityProvider: AppID
	itxn_field ApplicationID

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 1 // user: (uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint256,uint256,bool,uint64,uint64,bool)

	// contracts\BiatecClammPool.algo.ts:881
	// assert(
	//       !user.isLocked,
	//       'ERR-USER-LOCKED' // 'User must not be locked'
	//     )
	frame_dig 1 // user: (uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint256,uint256,bool,uint64,uint64,bool)
	store 255 // full array
	load 255 // full array
	int 1032
	getbit
	!

	// ERR-USER-LOCKED
	assert

	// contracts\BiatecClammPool.algo.ts:885
	// assert(
	//       user.verificationClass >= this.verificationClass.value, // if(user.verificationClass >= this.verificationClass.value) then ok
	//       'ERR-LOW-VER' // 'User cannot interact with this smart contract as his verification class is lower then required here'
	//     )
	frame_dig 1 // user: (uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint256,uint256,bool,uint64,uint64,bool)
	store 255 // full array
	load 255 // full array
	extract 9 8
	btoi
	byte 0x63 // "c"
	app_global_get
	>=

	// ERR-LOW-VER
	assert

	// contracts\BiatecClammPool.algo.ts:890
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -1 // appBiatecConfigProvider: AppID
	byte 0x73 // "s"
	app_global_get_ex
	assert
	frame_bury 2 // paused: uint64

	// contracts\BiatecClammPool.algo.ts:891
	// assert(paused === 0, 'ERR_PAUSED')
	frame_dig 2 // paused: uint64
	int 0
	==

	// ERR_PAUSED
	assert

	// contracts\BiatecClammPool.algo.ts:893
	// return user;
	frame_dig 1 // user: (uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint256,uint256,bool,uint64,uint64,bool)

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// swap(uint64,uint64,uint64,txn,uint64,uint64,uint64)uint256
*abi_route_swap:
	// The ABI return prefix
	byte 0x151f7c75

	// minimumToReceive: uint64
	txna ApplicationArgs 6
	btoi

	// assetB: uint64
	txna ApplicationArgs 5
	btoi

	// assetA: uint64
	txna ApplicationArgs 4
	btoi

	// txSwap: txn
	txn GroupIndex
	int 1
	-

	// appBiatecPoolProvider: uint64
	txna ApplicationArgs 3
	btoi

	// appBiatecIdentityProvider: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute swap(uint64,uint64,uint64,txn,uint64,uint64,uint64)uint256
	callsub swap
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// swap(appBiatecConfigProvider: AppID, appBiatecIdentityProvider: AppID, appBiatecPoolProvider: AppID, txSwap: Txn, assetA: AssetID, assetB: AssetID, minimumToReceive: uint64): uint256
//
// Swap Asset A to Asset B or Asset B to Asst A
// @param txSwap Transfer of the token to be deposited to the pool. To the owner the other asset will be sent.
// @param assetA Asset A
// @param assetB Asset B
// @param minimumToReceive If number greater then zero, the check is performed for the output of the other asset
swap:
	proto 7 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 33

	// contracts\BiatecClammPool.algo.ts:912
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:913
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:914
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// well formed swap
	// contracts\BiatecClammPool.algo.ts:916
	// this.checkAssetsAB(assetA, assetB)
	frame_dig -6 // assetB: AssetID
	frame_dig -5 // assetA: AssetID
	callsub checkAssetsAB

	// *if32_condition
	// contracts\BiatecClammPool.algo.ts:918
	// txSwap.typeEnum === TransactionType.Payment
	frame_dig -4 // txSwap: Txn
	gtxns TypeEnum
	int pay
	==
	bz *if32_else

	// *if32_consequent
	// contracts\BiatecClammPool.algo.ts:919
	// assert(assetA.id === 0)
	frame_dig -5 // assetA: AssetID
	int 0
	==
	assert

	// contracts\BiatecClammPool.algo.ts:921
	// verifyPayTxn(txSwap, {
	//         amount: { greaterThan: 0 },
	//         receiver: this.app.address,
	//         sender: this.txn.sender,
	//       })
	// verify pay
	frame_dig -4 // txSwap: Txn
	gtxns TypeEnum
	int pay
	==
	assert

	// verify amount
	frame_dig -4 // txSwap: Txn
	gtxns Amount
	int 0
	>
	assert

	// verify receiver
	frame_dig -4 // txSwap: Txn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify sender
	frame_dig -4 // txSwap: Txn
	gtxns Sender
	txn Sender
	==
	assert
	b *if32_end

*if32_else:
	// contracts\BiatecClammPool.algo.ts:927
	// assert(txSwap.typeEnum === TransactionType.AssetTransfer)
	frame_dig -4 // txSwap: Txn
	gtxns TypeEnum
	int axfer
	==
	assert

	// contracts\BiatecClammPool.algo.ts:929
	// verifyAssetTransferTxn(txSwap, {
	//         assetAmount: { greaterThan: 0 },
	//         assetReceiver: this.app.address,
	//         sender: this.txn.sender,
	//         xferAsset: { includedIn: [assetA, assetB] },
	//       })
	// verify axfer
	frame_dig -4 // txSwap: Txn
	gtxns TypeEnum
	int axfer
	==
	assert

	// verify assetAmount
	frame_dig -4 // txSwap: Txn
	gtxns AssetAmount
	int 0
	>
	assert

	// verify assetReceiver
	frame_dig -4 // txSwap: Txn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert

	// verify sender
	frame_dig -4 // txSwap: Txn
	gtxns Sender
	txn Sender
	==
	assert

	// verify xferAsset
	frame_dig -4 // txSwap: Txn
	gtxns XferAsset
	frame_dig -5 // assetA: AssetID
	==
	frame_dig -4 // txSwap: Txn
	gtxns XferAsset
	frame_dig -6 // assetB: AssetID
	==
	||
	assert

*if32_end:
	// contracts\BiatecClammPool.algo.ts:937
	// poolProviderFromConfig = appBiatecConfigProvider.globalState('p')
	frame_dig -1 // appBiatecConfigProvider: AppID
	byte 0x70 // "p"
	app_global_get_ex
	assert
	frame_bury 0 // poolProviderFromConfig: any

	// contracts\BiatecClammPool.algo.ts:938
	// assert(
	//       appBiatecPoolProvider === poolProviderFromConfig,
	//       'ERR-INVALID-PP' // appBiatecPoolProvider must match to the config in appBiatecConfigProvider'
	//     )
	frame_dig -3 // appBiatecPoolProvider: AppID
	frame_dig 0 // poolProviderFromConfig: any
	==

	// ERR-INVALID-PP
	assert

	// contracts\BiatecClammPool.algo.ts:942
	// user = this.verifyIdentity(appBiatecConfigProvider, appBiatecIdentityProvider)
	frame_dig -2 // appBiatecIdentityProvider: AppID
	frame_dig -1 // appBiatecConfigProvider: AppID
	callsub verifyIdentity
	frame_bury 1 // user: (uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint256,uint256,bool,uint64,uint64,bool)

	// contracts\BiatecClammPool.algo.ts:944
	// assetADecimals = 6
	int 6
	frame_bury 2 // assetADecimals: uint64

	// *if33_condition
	// contracts\BiatecClammPool.algo.ts:945
	// assetA.id > 0
	frame_dig -5 // assetA: AssetID
	int 0
	>
	bz *if33_end

	// *if33_consequent
	// contracts\BiatecClammPool.algo.ts:945
	// assetADecimals = assetA.decimals
	frame_dig -5 // assetA: AssetID
	asset_params_get AssetDecimals
	pop
	frame_bury 2 // assetADecimals: uint64

*if33_end:
	// contracts\BiatecClammPool.algo.ts:947
	// assetADelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetADecimals)) as uint256
	int 10
	int 9
	frame_dig 2 // assetADecimals: uint64
	-
	exp
	itob
	frame_bury 3 // assetADelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:949
	// assetBDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetB.decimals)) as uint256
	int 10
	int 9
	frame_dig -6 // assetB: AssetID
	asset_params_get AssetDecimals
	pop
	-
	exp
	itob
	frame_bury 4 // assetBDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:951
	// feesMultiplier = (s - ((this.fee.value as uint256) * user.feeMultiplier) / user.base) as uint256
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	byte 0x66 // "f"
	app_global_get
	itob
	frame_dig 1 // user: (uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint256,uint256,bool,uint64,uint64,bool)
	store 255 // full array
	load 255 // full array
	extract 65 32
	b*
	frame_dig 1 // user: (uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint256,uint256,bool,uint64,uint64,bool)
	store 255 // full array
	load 255 // full array
	extract 97 32
	b/
	b-
	frame_bury 5 // feesMultiplier: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:952
	// ret: uint64 = 0
	int 0
	frame_bury 6 // ret: uint64

	// contracts\BiatecClammPool.algo.ts:953
	// amountAForStats = 0
	int 0
	frame_bury 7 // amountAForStats: uint64

	// contracts\BiatecClammPool.algo.ts:954
	// amountBForStats = 0
	int 0
	frame_bury 8 // amountBForStats: uint64

	// contracts\BiatecClammPool.algo.ts:955
	// feeAmountAForStats = 0
	int 0
	frame_bury 9 // feeAmountAForStats: uint64

	// contracts\BiatecClammPool.algo.ts:956
	// feeAmountBForStats = 0
	int 0
	frame_bury 10 // feeAmountBForStats: uint64

	// contracts\BiatecClammPool.algo.ts:958
	// isAssetA = false
	int 0
	frame_bury 11 // isAssetA: bool

	// *if34_condition
	// contracts\BiatecClammPool.algo.ts:959
	// txSwap.typeEnum === TransactionType.Payment
	frame_dig -4 // txSwap: Txn
	gtxns TypeEnum
	int pay
	==
	bz *if34_else

	// *if34_consequent
	// contracts\BiatecClammPool.algo.ts:960
	// isAssetA = true
	int 1
	frame_bury 11 // isAssetA: bool
	b *if34_end

*if34_else:
	// contracts\BiatecClammPool.algo.ts:962
	// isAssetA = txSwap.xferAsset === assetA
	frame_dig -4 // txSwap: Txn
	gtxns XferAsset
	frame_dig -5 // assetA: AssetID
	==
	frame_bury 11 // isAssetA: bool

*if34_end:
	// contracts\BiatecClammPool.algo.ts:964
	// realSwapBaseDecimals = <uint256>0
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 12 // realSwapBaseDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:965
	// inAsset = <uint256>0
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 13 // inAsset: unsafe uint256

	// *if35_condition
	// contracts\BiatecClammPool.algo.ts:966
	// isAssetA
	frame_dig 11 // isAssetA: bool
	bz *if35_end

	// *if35_consequent
	// contracts\BiatecClammPool.algo.ts:967
	// assetInAssetDecimals = <uint256>0
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 14 // assetInAssetDecimals: unsafe uint256

	// *if36_condition
	// contracts\BiatecClammPool.algo.ts:968
	// txSwap.typeEnum === TransactionType.Payment
	frame_dig -4 // txSwap: Txn
	gtxns TypeEnum
	int pay
	==
	bz *if36_else

	// *if36_consequent
	// contracts\BiatecClammPool.algo.ts:969
	// assetInAssetDecimals = txSwap.amount as uint256
	frame_dig -4 // txSwap: Txn
	gtxns Amount
	itob
	frame_bury 14 // assetInAssetDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:970
	// amountAForStats = txSwap.amount
	frame_dig -4 // txSwap: Txn
	gtxns Amount
	frame_bury 7 // amountAForStats: uint64
	b *if36_end

*if36_else:
	// contracts\BiatecClammPool.algo.ts:972
	// assetInAssetDecimals = txSwap.assetAmount as uint256
	frame_dig -4 // txSwap: Txn
	gtxns AssetAmount
	itob
	frame_bury 14 // assetInAssetDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:973
	// amountAForStats = txSwap.assetAmount
	frame_dig -4 // txSwap: Txn
	gtxns AssetAmount
	frame_bury 7 // amountAForStats: uint64

*if36_end:
	// contracts\BiatecClammPool.algo.ts:975
	// inAsset = (assetInAssetDecimals * assetADelicmalScale2Scale) as uint256
	frame_dig 14 // assetInAssetDecimals: unsafe uint256
	frame_dig 3 // assetADelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 13 // inAsset: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:976
	// inAssetAfterFee = (inAsset * feesMultiplier) / s
	frame_dig 13 // inAsset: unsafe uint256
	frame_dig 5 // feesMultiplier: unsafe uint256
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 15 // inAssetAfterFee: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:978
	// toSwap = this.calculateAssetBWithdrawOnAssetADeposit(
	//         inAssetAfterFee,
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMinSqrt.value,
	//         this.priceMaxSqrt.value,
	//         this.Liqudity.value
	//       )
	byte 0x4c // "L"
	app_global_get
	byte 0x704d617853 // "pMaxS"
	app_global_get
	byte 0x704d696e53 // "pMinS"
	app_global_get
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	frame_dig 15 // inAssetAfterFee: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub calculateAssetBWithdrawOnAssetADeposit
	frame_bury 16 // toSwap: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:986
	// realSwapBaseDecimals = toSwap
	frame_dig 16 // toSwap: unsafe uint256
	frame_bury 12 // realSwapBaseDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:987
	// realSwapBDecimals = (toSwap / assetBDelicmalScale2Scale) as uint256
	frame_dig 16 // toSwap: unsafe uint256
	frame_dig 4 // assetBDelicmalScale2Scale: unsafe uint256
	b/
	frame_bury 17 // realSwapBDecimals: unsafe uint256

	// *if37_condition
	// contracts\BiatecClammPool.algo.ts:989
	// realSwapBDecimals * assetBDelicmalScale2Scale !== toSwap
	frame_dig 17 // realSwapBDecimals: unsafe uint256
	frame_dig 4 // assetBDelicmalScale2Scale: unsafe uint256
	b*
	frame_dig 16 // toSwap: unsafe uint256
	b!=
	bz *if37_end

	// *if37_consequent
	// contracts\BiatecClammPool.algo.ts:990
	// realSwapBDecimals = realSwapBDecimals - <uint256>1
	frame_dig 17 // realSwapBDecimals: unsafe uint256
	byte 0x0000000000000000000000000000000000000000000000000000000000000001
	b-
	frame_bury 17 // realSwapBDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:991
	// realSwapBaseDecimals = realSwapBDecimals * assetBDelicmalScale2Scale
	frame_dig 17 // realSwapBDecimals: unsafe uint256
	frame_dig 4 // assetBDelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 12 // realSwapBaseDecimals: unsafe uint256

*if37_end:
	// contracts\BiatecClammPool.algo.ts:993
	// toSwapBDecimals = realSwapBDecimals as uint64
	frame_dig 17 // realSwapBDecimals: unsafe uint256
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	frame_bury 18 // toSwapBDecimals: uint64

	// contracts\BiatecClammPool.algo.ts:994
	// ret = toSwapBDecimals
	frame_dig 18 // toSwapBDecimals: uint64
	frame_bury 6 // ret: uint64

	// *if38_condition
	// contracts\BiatecClammPool.algo.ts:995
	// minimumToReceive > 0
	frame_dig -7 // minimumToReceive: uint64
	int 0
	>
	bz *if38_end

	// *if38_consequent
	// contracts\BiatecClammPool.algo.ts:997
	// assert(minimumToReceive >= toSwapBDecimals)
	frame_dig -7 // minimumToReceive: uint64
	frame_dig 18 // toSwapBDecimals: uint64
	>=
	assert

*if38_end:
	// contracts\BiatecClammPool.algo.ts:999
	// amountBForStats = toSwapBDecimals
	frame_dig 18 // toSwapBDecimals: uint64
	frame_bury 8 // amountBForStats: uint64

	// contracts\BiatecClammPool.algo.ts:1000
	// this.doAxfer(this.txn.sender, assetB, toSwapBDecimals)
	frame_dig 18 // toSwapBDecimals: uint64
	frame_dig -6 // assetB: AssetID
	txn Sender
	callsub doAxfer

	// contracts\BiatecClammPool.algo.ts:1002
	// this.assetABalance.value = this.assetABalance.value + inAsset
	byte 0x6162 // "ab"
	dup
	app_global_get
	frame_dig 13 // inAsset: unsafe uint256
	b+
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:1003
	// this.assetBBalance.value = this.assetBBalance.value - realSwapBaseDecimals
	byte 0x6262 // "bb"
	dup
	app_global_get
	frame_dig 12 // realSwapBaseDecimals: unsafe uint256
	b-
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

*if35_end:
	// *if39_condition
	// contracts\BiatecClammPool.algo.ts:1006
	// !isAssetA
	frame_dig 11 // isAssetA: bool
	!
	bz *if39_end

	// *if39_consequent
	// contracts\BiatecClammPool.algo.ts:1007
	// assetInAssetDecimals = txSwap.assetAmount as uint256
	frame_dig -4 // txSwap: Txn
	gtxns AssetAmount
	itob
	frame_bury 19 // assetInAssetDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1008
	// amountBForStats = txSwap.assetAmount
	frame_dig -4 // txSwap: Txn
	gtxns AssetAmount
	frame_bury 8 // amountBForStats: uint64

	// contracts\BiatecClammPool.algo.ts:1009
	// inAsset = (assetInAssetDecimals * assetBDelicmalScale2Scale) as uint256
	frame_dig 19 // assetInAssetDecimals: unsafe uint256
	frame_dig 4 // assetBDelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 13 // inAsset: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1010
	// inAssetAfterFee = (inAsset * feesMultiplier) / s
	frame_dig 13 // inAsset: unsafe uint256
	frame_dig 5 // feesMultiplier: unsafe uint256
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 20 // inAssetAfterFee: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1011
	// toSwap = this.calculateAssetAWithdrawOnAssetBDeposit(
	//         inAssetAfterFee,
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMinSqrt.value,
	//         this.priceMaxSqrt.value,
	//         this.Liqudity.value
	//       )
	byte 0x4c // "L"
	app_global_get
	byte 0x704d617853 // "pMaxS"
	app_global_get
	byte 0x704d696e53 // "pMinS"
	app_global_get
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	frame_dig 20 // inAssetAfterFee: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub calculateAssetAWithdrawOnAssetBDeposit
	frame_bury 21 // toSwap: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1019
	// realSwapBaseDecimals = toSwap
	frame_dig 21 // toSwap: unsafe uint256
	frame_bury 12 // realSwapBaseDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1020
	// realSwapADecimals = toSwap / assetADelicmalScale2Scale
	frame_dig 21 // toSwap: unsafe uint256
	frame_dig 3 // assetADelicmalScale2Scale: unsafe uint256
	b/
	frame_bury 22 // realSwapADecimals: unsafe uint256

	// *if40_condition
	// contracts\BiatecClammPool.algo.ts:1022
	// realSwapADecimals * assetADelicmalScale2Scale !== toSwap
	frame_dig 22 // realSwapADecimals: unsafe uint256
	frame_dig 3 // assetADelicmalScale2Scale: unsafe uint256
	b*
	frame_dig 21 // toSwap: unsafe uint256
	b!=
	bz *if40_end

	// *if40_consequent
	// contracts\BiatecClammPool.algo.ts:1023
	// realSwapADecimals = realSwapADecimals - <uint256>1
	frame_dig 22 // realSwapADecimals: unsafe uint256
	byte 0x0000000000000000000000000000000000000000000000000000000000000001
	b-
	frame_bury 22 // realSwapADecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1024
	// realSwapBaseDecimals = realSwapADecimals * assetADelicmalScale2Scale
	frame_dig 22 // realSwapADecimals: unsafe uint256
	frame_dig 3 // assetADelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 12 // realSwapBaseDecimals: unsafe uint256

*if40_end:
	// contracts\BiatecClammPool.algo.ts:1026
	// toSwapADecimals = realSwapADecimals as uint64
	frame_dig 22 // realSwapADecimals: unsafe uint256
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	frame_bury 23 // toSwapADecimals: uint64

	// contracts\BiatecClammPool.algo.ts:1027
	// ret = toSwapADecimals
	frame_dig 23 // toSwapADecimals: uint64
	frame_bury 6 // ret: uint64

	// *if41_condition
	// contracts\BiatecClammPool.algo.ts:1028
	// minimumToReceive > 0
	frame_dig -7 // minimumToReceive: uint64
	int 0
	>
	bz *if41_end

	// *if41_consequent
	// contracts\BiatecClammPool.algo.ts:1030
	// assert(minimumToReceive >= toSwapADecimals)
	frame_dig -7 // minimumToReceive: uint64
	frame_dig 23 // toSwapADecimals: uint64
	>=
	assert

*if41_end:
	// contracts\BiatecClammPool.algo.ts:1032
	// amountAForStats = toSwapADecimals
	frame_dig 23 // toSwapADecimals: uint64
	frame_bury 7 // amountAForStats: uint64

	// contracts\BiatecClammPool.algo.ts:1033
	// this.doAxfer(this.txn.sender, assetA, toSwapADecimals)
	frame_dig 23 // toSwapADecimals: uint64
	frame_dig -5 // assetA: AssetID
	txn Sender
	callsub doAxfer

	// contracts\BiatecClammPool.algo.ts:1035
	// this.assetBBalance.value = this.assetBBalance.value + inAsset
	byte 0x6262 // "bb"
	dup
	app_global_get
	frame_dig 13 // inAsset: unsafe uint256
	b+
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:1036
	// this.assetABalance.value = this.assetABalance.value - realSwapBaseDecimals
	byte 0x6162 // "ab"
	dup
	app_global_get
	frame_dig 12 // realSwapBaseDecimals: unsafe uint256
	b-
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

*if39_end:
	// contracts\BiatecClammPool.algo.ts:1038
	// newL = <uint256>0
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 24 // newL: unsafe uint256

	// *if42_condition
	// contracts\BiatecClammPool.algo.ts:1039
	// this.priceMin.value === this.priceMax.value
	byte 0x704d696e // "pMin"
	app_global_get
	byte 0x704d6178 // "pMax"
	app_global_get
	==
	bz *if42_else

	// *if42_consequent
	// contracts\BiatecClammPool.algo.ts:1040
	// newL = this.calculateLiquidityFlatPrice(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMin.value as uint256 // priceMin: uint256,
	//       )
	byte 0x704d696e // "pMin"
	app_global_get
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	callsub calculateLiquidityFlatPrice
	frame_bury 24 // newL: unsafe uint256
	b *if42_end

*if42_else:
	// contracts\BiatecClammPool.algo.ts:1046
	// D_SQRT = this.calculateLiquidityD(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMin.value as uint256, // priceMin: uint256,
	//         this.priceMax.value as uint256, // priceMax: uint256,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value // priceMaxSqrt: uint256,
	//       )
	byte 0x704d617853 // "pMaxS"
	app_global_get
	byte 0x704d696e53 // "pMinS"
	app_global_get
	byte 0x704d6178 // "pMax"
	app_global_get
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	byte 0x704d696e // "pMin"
	app_global_get
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	callsub calculateLiquidityD
	frame_bury 25 // D_SQRT: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1054
	// newL = this.calculateLiquidityWithD(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value, // priceMaxSqrt: uint256,
	//         D_SQRT
	//       )
	frame_dig 25 // D_SQRT: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	byte 0x704d617853 // "pMaxS"
	app_global_get
	byte 0x704d696e53 // "pMinS"
	app_global_get
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	callsub calculateLiquidityWithD
	frame_bury 24 // newL: unsafe uint256

*if42_end:
	// *if43_condition
	// contracts\BiatecClammPool.algo.ts:1063
	// newL !== this.Liqudity.value
	frame_dig 24 // newL: unsafe uint256
	byte 0x4c // "L"
	app_global_get
	b!=
	bz *if43_end

	// *if43_consequent
	// contracts\BiatecClammPool.algo.ts:1066
	// diff = (newL - this.Liqudity.value) as uint256
	frame_dig 24 // newL: unsafe uint256
	byte 0x4c // "L"
	app_global_get
	b-
	frame_bury 26 // diff: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1067
	// this.Liqudity.value = newL
	byte 0x4c // "L"
	frame_dig 24 // newL: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// *if44_condition
	// contracts\BiatecClammPool.algo.ts:1069
	// isAssetA
	frame_dig 11 // isAssetA: bool
	bz *if44_else

	// *if44_consequent
	// contracts\BiatecClammPool.algo.ts:1071
	// feeB256 = (this.assetABalance.value * diff) / newL
	byte 0x6162 // "ab"
	app_global_get
	frame_dig 26 // diff: unsafe uint256
	b*
	frame_dig 24 // newL: unsafe uint256
	b/
	frame_bury 27 // feeB256: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1072
	// feeAmountAForStats = feeB256 as uint64
	frame_dig 27 // feeB256: unsafe uint256
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	frame_bury 9 // feeAmountAForStats: uint64

	// contracts\BiatecClammPool.algo.ts:1073
	// feeAmountBForStats = 0
	int 0
	frame_bury 10 // feeAmountBForStats: uint64
	b *if44_end

*if44_else:
	// contracts\BiatecClammPool.algo.ts:1076
	// feeB256 = (this.assetBBalance.value * diff) / newL
	byte 0x6262 // "bb"
	app_global_get
	frame_dig 26 // diff: unsafe uint256
	b*
	frame_dig 24 // newL: unsafe uint256
	b/
	frame_bury 28 // feeB256: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1077
	// feeAmountAForStats = 0
	int 0
	frame_bury 9 // feeAmountAForStats: uint64

	// contracts\BiatecClammPool.algo.ts:1078
	// feeAmountBForStats = feeB256 as uint64
	frame_dig 28 // feeB256: unsafe uint256
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	frame_bury 10 // feeAmountBForStats: uint64

*if44_end:
	// contracts\BiatecClammPool.algo.ts:1081
	// biatecFee = this.appBiatecConfigProvider.value.globalState('f') as uint256
	byte 0x42 // "B"
	app_global_get
	byte 0x66 // "f"
	app_global_get_ex
	assert
	frame_bury 29 // biatecFee: uint256

	// *if45_condition
	// contracts\BiatecClammPool.algo.ts:1082
	// biatecFee === <uint256>0
	frame_dig 29 // biatecFee: uint256
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	b==
	bz *if45_else

	// *if45_consequent
	// contracts\BiatecClammPool.algo.ts:1083
	// usersLiquidityFromFeeIncrement = diff
	frame_dig 26 // diff: unsafe uint256
	frame_bury 30 // usersLiquidityFromFeeIncrement: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1084
	// this.LiqudityUsersFromFees.value = this.LiqudityUsersFromFees.value + usersLiquidityFromFeeIncrement
	byte 0x4c75 // "Lu"
	dup
	app_global_get
	frame_dig 30 // usersLiquidityFromFeeIncrement: unsafe uint256
	b+
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put
	b *if45_end

*if45_else:
	// contracts\BiatecClammPool.algo.ts:1086
	// usersLiquidityFromFeeIncrement = (diff * (s - biatecFee)) / s
	frame_dig 26 // diff: unsafe uint256
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	frame_dig 29 // biatecFee: uint256
	b-
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 31 // usersLiquidityFromFeeIncrement: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1087
	// biatecLiquidityFromFeeIncrement = diff - usersLiquidityFromFeeIncrement
	frame_dig 26 // diff: unsafe uint256
	frame_dig 31 // usersLiquidityFromFeeIncrement: unsafe uint256
	b-
	frame_bury 32 // biatecLiquidityFromFeeIncrement: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1088
	// this.LiqudityUsersFromFees.value = this.LiqudityUsersFromFees.value + usersLiquidityFromFeeIncrement
	byte 0x4c75 // "Lu"
	dup
	app_global_get
	frame_dig 31 // usersLiquidityFromFeeIncrement: unsafe uint256
	b+
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:1089
	// this.LiqudityBiatecFromFees.value = this.LiqudityBiatecFromFees.value + biatecLiquidityFromFeeIncrement
	byte 0x4c62 // "Lb"
	dup
	app_global_get
	frame_dig 32 // biatecLiquidityFromFeeIncrement: unsafe uint256
	b+
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

*if45_end:

*if43_end:
	// contracts\BiatecClammPool.algo.ts:1092
	// newPrice = this.calculatePrice(
	//       this.assetABalance.value, // assetAQuantity: uint256,
	//       this.assetBBalance.value, // assetBQuantity: uint256,
	//       this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//       this.priceMaxSqrt.value, // priceMaxSqrt: uint256,
	//       this.Liqudity.value // liquidity: uint256
	//     )
	byte 0x4c // "L"
	app_global_get
	byte 0x704d617853 // "pMaxS"
	app_global_get
	byte 0x704d696e53 // "pMinS"
	app_global_get
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	callsub calculatePrice
	frame_bury 33 // newPrice: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1099
	// assert(amountAForStats > 0 && amountBForStats > 0, 'Stats to register must not be empty')
	frame_dig 7 // amountAForStats: uint64
	int 0
	>
	dup
	bz *skip_and4
	frame_dig 8 // amountBForStats: uint64
	int 0
	>
	&&

*skip_and4:
	// Stats to register must not be empty
	assert

	// contracts\BiatecClammPool.algo.ts:1100
	// sendMethodCall<[AppID, AssetID, AssetID, uint64, uint64, uint64, uint64, uint64, uint64, uint64], void>({
	//       name: 'registerTrade',
	//       methodArgs: [
	//         globals.currentApplicationID,
	//         assetA,
	//         assetB,
	//         this.currentPrice.value as uint64,
	//         newPrice as uint64,
	//         amountAForStats * (assetADelicmalScale2Scale as uint64),
	//         amountBForStats * (assetBDelicmalScale2Scale as uint64),
	//         feeAmountAForStats,
	//         feeAmountBForStats,
	//         SCALE,
	//       ],
	//       fee: 0,
	//       applicationID: appBiatecPoolProvider,
	//     })
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "registerTrade(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)void"
	itxn_field ApplicationArgs

	// contracts\BiatecClammPool.algo.ts:1102
	// methodArgs: [
	//         globals.currentApplicationID,
	//         assetA,
	//         assetB,
	//         this.currentPrice.value as uint64,
	//         newPrice as uint64,
	//         amountAForStats * (assetADelicmalScale2Scale as uint64),
	//         amountBForStats * (assetBDelicmalScale2Scale as uint64),
	//         feeAmountAForStats,
	//         feeAmountBForStats,
	//         SCALE,
	//       ]
	global CurrentApplicationID
	itob
	itxn_field ApplicationArgs
	frame_dig -5 // assetA: AssetID
	itob
	itxn_field ApplicationArgs
	frame_dig -6 // assetB: AssetID
	itob
	itxn_field ApplicationArgs
	byte 0x7072696365 // "price"
	app_global_get
	itob
	itxn_field ApplicationArgs
	frame_dig 33 // newPrice: unsafe uint256
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	itob
	itxn_field ApplicationArgs
	frame_dig 7 // amountAForStats: uint64
	frame_dig 3 // assetADelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	*
	itob
	itxn_field ApplicationArgs
	frame_dig 8 // amountBForStats: uint64
	frame_dig 4 // assetBDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	*
	itob
	itxn_field ApplicationArgs
	frame_dig 9 // feeAmountAForStats: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig 10 // feeAmountBForStats: uint64
	itob
	itxn_field ApplicationArgs
	byte 0x000000003b9aca00
	itxn_field ApplicationArgs

	// contracts\BiatecClammPool.algo.ts:1114
	// fee: 0
	int 0
	itxn_field Fee

	// contracts\BiatecClammPool.algo.ts:1115
	// applicationID: appBiatecPoolProvider
	frame_dig -3 // appBiatecPoolProvider: AppID
	itxn_field ApplicationID

	// Submit inner transaction
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:1118
	// this.currentPrice.value = newPrice as uint64
	byte 0x7072696365 // "price"
	frame_dig 33 // newPrice: unsafe uint256
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	app_global_put

	// contracts\BiatecClammPool.algo.ts:1140
	// return ret as uint256;
	frame_dig 6 // ret: uint64
	itob

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 33
	retsub

// distributeExcessAssets(uint64,uint64,uint64,uint256,uint256)uint256
*abi_route_distributeExcessAssets:
	// The ABI return prefix
	byte 0x151f7c75

	// amountB: uint256
	txna ApplicationArgs 5
	dup
	len
	int 32
	==
	assert

	// amountA: uint256
	txna ApplicationArgs 4
	dup
	len
	int 32
	==
	assert

	// assetB: uint64
	txna ApplicationArgs 3
	btoi

	// assetA: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute distributeExcessAssets(uint64,uint64,uint64,uint256,uint256)uint256
	callsub distributeExcessAssets
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// distributeExcessAssets(appBiatecConfigProvider: AppID, assetA: AssetID, assetB: AssetID, amountA: uint256, amountB: uint256): uint256
//
// If someone deposits excess assets to the LP pool, addressExecutiveFee can either distribute them to the lp tokens or withdraw it, depending on the use case.
// If someone sent there assets in fault, the withrawing can be use to return them back. If the pool received assets for example for having its algo stake online and recieved rewards it is prefered to distribute them to the current LP holders.
//
// This method is used to distribute amount a and amount b of asset a and asset b to holders as the fee income.
//
// Only addressExecutiveFee is allowed to execute this method.
//
// @param appBiatecConfigProvider Biatec config app. Only addressExecutiveFee is allowed to execute this method.
// @param assetA Asset A
// @param assetB Asset B
// @param amountA Amount of asset A to be deposited to the liquidity. In base decimals (9)
// @param amountB Amount of asset B to be deposited to the liquidity. In base decimals (9)
distributeExcessAssets:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 12

	// contracts\BiatecClammPool.algo.ts:1164
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:1165
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:1166
	// this.checkAssetsAB(assetA, assetB)
	frame_dig -3 // assetB: AssetID
	frame_dig -2 // assetA: AssetID
	callsub checkAssetsAB

	// contracts\BiatecClammPool.algo.ts:1168
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value, 'ERR_CONFIG')
	frame_dig -1 // appBiatecConfigProvider: AppID
	byte 0x42 // "B"
	app_global_get
	==

	// ERR_CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:1169
	// addressExecutiveFee = appBiatecConfigProvider.globalState('ef')
	frame_dig -1 // appBiatecConfigProvider: AppID
	byte 0x6566 // "ef"
	app_global_get_ex
	assert
	frame_bury 0 // addressExecutiveFee: any

	// contracts\BiatecClammPool.algo.ts:1171
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -1 // appBiatecConfigProvider: AppID
	byte 0x73 // "s"
	app_global_get_ex
	assert
	frame_bury 1 // paused: uint64

	// contracts\BiatecClammPool.algo.ts:1172
	// assert(paused === 0, 'ERR_PAUSED')
	frame_dig 1 // paused: uint64
	int 0
	==

	// ERR_PAUSED
	assert

	// contracts\BiatecClammPool.algo.ts:1174
	// assert(
	//       this.txn.sender === addressExecutiveFee,
	//       'ERR_SENDER' // 'Only fee executor setup in the config can take the collected fees'
	//     )
	txn Sender
	frame_dig 0 // addressExecutiveFee: any
	==

	// ERR_SENDER
	assert

	// contracts\BiatecClammPool.algo.ts:1179
	// assetADecimals = 6
	int 6
	frame_bury 2 // assetADecimals: uint64

	// *if46_condition
	// contracts\BiatecClammPool.algo.ts:1180
	// assetA.id > 0
	frame_dig -2 // assetA: AssetID
	int 0
	>
	bz *if46_end

	// *if46_consequent
	// contracts\BiatecClammPool.algo.ts:1180
	// assetADecimals = assetA.decimals
	frame_dig -2 // assetA: AssetID
	asset_params_get AssetDecimals
	pop
	frame_bury 2 // assetADecimals: uint64

*if46_end:
	// contracts\BiatecClammPool.algo.ts:1182
	// assetADelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetADecimals)) as uint256
	int 10
	int 9
	frame_dig 2 // assetADecimals: uint64
	-
	exp
	itob
	frame_bury 3 // assetADelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1184
	// assetBDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetB.decimals)) as uint256
	int 10
	int 9
	frame_dig -3 // assetB: AssetID
	asset_params_get AssetDecimals
	pop
	-
	exp
	itob
	frame_bury 4 // assetBDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1186
	// this.assetABalance.value = this.assetABalance.value + amountA
	byte 0x6162 // "ab"
	dup
	app_global_get
	frame_dig -4 // amountA: uint256
	b+
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:1187
	// this.assetBBalance.value = this.assetBBalance.value + amountB
	byte 0x6262 // "bb"
	dup
	app_global_get
	frame_dig -5 // amountB: uint256
	b+
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// *if47_condition
	// contracts\BiatecClammPool.algo.ts:1188
	// assetA.id === 0
	frame_dig -2 // assetA: AssetID
	int 0
	==
	bz *if47_else

	// *if47_consequent
	// contracts\BiatecClammPool.algo.ts:1189
	// assert(
	//         ((this.app.address.balance - 1_000_000) as uint256) * assetADelicmalScale2Scale >= this.assetABalance.value,
	//         'ERR_A0_B' // 'It is not possible to set higher assetABalance in algos then is in the app balance'
	//       )
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	int 1_000_000
	-
	itob
	frame_dig 3 // assetADelicmalScale2Scale: unsafe uint256
	b*
	byte 0x6162 // "ab"
	app_global_get
	b>=

	// ERR_A0_B
	assert
	b *if47_end

*if47_else:
	// contracts\BiatecClammPool.algo.ts:1194
	// assert(
	//         (this.app.address.assetBalance(assetA) as uint256) * assetADelicmalScale2Scale >= this.assetABalance.value,
	//         'ERR_A_B' // 'It is not possible to set higher assetABalance then is in the app balance'
	//       )
	global CurrentApplicationAddress
	frame_dig -2 // assetA: AssetID
	asset_holding_get AssetBalance
	pop
	itob
	frame_dig 3 // assetADelicmalScale2Scale: unsafe uint256
	b*
	byte 0x6162 // "ab"
	app_global_get
	b>=

	// ERR_A_B
	assert

*if47_end:
	// contracts\BiatecClammPool.algo.ts:1199
	// assert(
	//       (this.app.address.assetBalance(assetB) as uint256) * assetBDelicmalScale2Scale >= this.assetBBalance.value,
	//       'ERR_B_B' // 'It is not possible to set higher assetBBalance then is in the app balance'
	//     )
	global CurrentApplicationAddress
	frame_dig -3 // assetB: AssetID
	asset_holding_get AssetBalance
	pop
	itob
	frame_dig 4 // assetBDelicmalScale2Scale: unsafe uint256
	b*
	byte 0x6262 // "bb"
	app_global_get
	b>=

	// ERR_B_B
	assert

	// contracts\BiatecClammPool.algo.ts:1203
	// newL = <uint256>0
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 5 // newL: unsafe uint256

	// *if48_condition
	// contracts\BiatecClammPool.algo.ts:1204
	// this.priceMin.value === this.priceMax.value
	byte 0x704d696e // "pMin"
	app_global_get
	byte 0x704d6178 // "pMax"
	app_global_get
	==
	bz *if48_else

	// *if48_consequent
	// contracts\BiatecClammPool.algo.ts:1205
	// newL = this.calculateLiquidityFlatPrice(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMin.value as uint256 // priceMin: uint256,
	//       )
	byte 0x704d696e // "pMin"
	app_global_get
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	callsub calculateLiquidityFlatPrice
	frame_bury 5 // newL: unsafe uint256
	b *if48_end

*if48_else:
	// contracts\BiatecClammPool.algo.ts:1211
	// D_SQRT = this.calculateLiquidityD(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMin.value as uint256, // priceMin: uint256,
	//         this.priceMax.value as uint256, // priceMax: uint256,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value // priceMaxSqrt: uint256,
	//       )
	byte 0x704d617853 // "pMaxS"
	app_global_get
	byte 0x704d696e53 // "pMinS"
	app_global_get
	byte 0x704d6178 // "pMax"
	app_global_get
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	byte 0x704d696e // "pMin"
	app_global_get
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	callsub calculateLiquidityD
	frame_bury 6 // D_SQRT: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1219
	// newL = this.calculateLiquidityWithD(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value, // priceMaxSqrt: uint256,
	//         D_SQRT
	//       )
	frame_dig 6 // D_SQRT: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	byte 0x704d617853 // "pMaxS"
	app_global_get
	byte 0x704d696e53 // "pMinS"
	app_global_get
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	callsub calculateLiquidityWithD
	frame_bury 5 // newL: unsafe uint256

*if48_end:
	// contracts\BiatecClammPool.algo.ts:1228
	// diff = (newL - this.Liqudity.value) as uint256
	frame_dig 5 // newL: unsafe uint256
	byte 0x4c // "L"
	app_global_get
	b-
	frame_bury 7 // diff: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1229
	// this.Liqudity.value = newL
	byte 0x4c // "L"
	frame_dig 5 // newL: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:1231
	// biatecFee = this.appBiatecConfigProvider.value.globalState('f') as uint256
	byte 0x42 // "B"
	app_global_get
	byte 0x66 // "f"
	app_global_get_ex
	assert
	frame_bury 8 // biatecFee: uint256

	// *if49_condition
	// contracts\BiatecClammPool.algo.ts:1232
	// biatecFee === <uint256>0
	frame_dig 8 // biatecFee: uint256
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	b==
	bz *if49_else

	// *if49_consequent
	// contracts\BiatecClammPool.algo.ts:1233
	// usersLiquidityFromFeeIncrement = diff
	frame_dig 7 // diff: unsafe uint256
	frame_bury 9 // usersLiquidityFromFeeIncrement: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1234
	// this.LiqudityUsersFromFees.value = this.LiqudityUsersFromFees.value + usersLiquidityFromFeeIncrement
	byte 0x4c75 // "Lu"
	dup
	app_global_get
	frame_dig 9 // usersLiquidityFromFeeIncrement: unsafe uint256
	b+
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put
	b *if49_end

*if49_else:
	// contracts\BiatecClammPool.algo.ts:1236
	// usersLiquidityFromFeeIncrement = (diff * (s - biatecFee)) / s
	frame_dig 7 // diff: unsafe uint256
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	frame_dig 8 // biatecFee: uint256
	b-
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 10 // usersLiquidityFromFeeIncrement: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1237
	// biatecLiquidityFromFeeIncrement = diff - usersLiquidityFromFeeIncrement
	frame_dig 7 // diff: unsafe uint256
	frame_dig 10 // usersLiquidityFromFeeIncrement: unsafe uint256
	b-
	frame_bury 11 // biatecLiquidityFromFeeIncrement: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1238
	// this.LiqudityUsersFromFees.value = this.LiqudityUsersFromFees.value + usersLiquidityFromFeeIncrement
	byte 0x4c75 // "Lu"
	dup
	app_global_get
	frame_dig 10 // usersLiquidityFromFeeIncrement: unsafe uint256
	b+
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:1239
	// this.LiqudityBiatecFromFees.value = this.LiqudityBiatecFromFees.value + biatecLiquidityFromFeeIncrement
	byte 0x4c62 // "Lb"
	dup
	app_global_get
	frame_dig 11 // biatecLiquidityFromFeeIncrement: unsafe uint256
	b+
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

*if49_end:
	// contracts\BiatecClammPool.algo.ts:1242
	// newPrice = this.calculatePrice(
	//       this.assetABalance.value, // assetAQuantity: uint256,
	//       this.assetBBalance.value, // assetBQuantity: uint256,
	//       this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//       this.priceMaxSqrt.value, // priceMaxSqrt: uint256,
	//       this.Liqudity.value // liquidity: uint256
	//     )
	byte 0x4c // "L"
	app_global_get
	byte 0x704d617853 // "pMaxS"
	app_global_get
	byte 0x704d696e53 // "pMinS"
	app_global_get
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	callsub calculatePrice
	frame_bury 12 // newPrice: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1249
	// this.currentPrice.value = newPrice as uint64
	byte 0x7072696365 // "price"
	frame_dig 12 // newPrice: unsafe uint256
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	app_global_put

	// contracts\BiatecClammPool.algo.ts:1250
	// return diff;
	frame_dig 7 // diff: unsafe uint256

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 12
	retsub

// withdrawExcessAssets(uint64,uint64,uint64,uint64,uint64)uint64
*abi_route_withdrawExcessAssets:
	// The ABI return prefix
	byte 0x151f7c75

	// amountB: uint64
	txna ApplicationArgs 5
	btoi

	// amountA: uint64
	txna ApplicationArgs 4
	btoi

	// assetB: uint64
	txna ApplicationArgs 3
	btoi

	// assetA: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute withdrawExcessAssets(uint64,uint64,uint64,uint64,uint64)uint64
	callsub withdrawExcessAssets
	itob
	concat
	log
	int 1
	return

// withdrawExcessAssets(appBiatecConfigProvider: AppID, assetA: AssetID, assetB: AssetID, amountA: uint64, amountB: uint64): uint64
//
// If someone deposits excess assets to the LP pool, addressExecutiveFee can either distribute them to the lp tokens or withdraw it, depending on the use case.
// If someone sent there assets in fault, the withrawing can be use to return them back. If the pool received assets for example for having its algo stake online and recieved rewards it is prefered to distribute them to the current LP holders.
//
// This method is used to distribute amount a and amount b of asset a and asset b to addressExecutiveFee account.
//
// Only addressExecutiveFee is allowed to execute this method.
//
// @param appBiatecConfigProvider Biatec config app. Only addressExecutiveFee is allowed to execute this method.
// @param assetA Asset A
// @param assetB Asset B
// @param amountA Amount of asset A to be deposited to the liquidity. In asset a decimals
// @param amountB Amount of asset B to be deposited to the liquidity. In asset b decimals
withdrawExcessAssets:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 4

	// contracts\BiatecClammPool.algo.ts:1274
	// this.checkAssetsAB(assetA, assetB)
	frame_dig -3 // assetB: AssetID
	frame_dig -2 // assetA: AssetID
	callsub checkAssetsAB

	// contracts\BiatecClammPool.algo.ts:1276
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value, 'ERR_CONFIG')
	frame_dig -1 // appBiatecConfigProvider: AppID
	byte 0x42 // "B"
	app_global_get
	==

	// ERR_CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:1277
	// addressExecutiveFee = appBiatecConfigProvider.globalState('ef')
	frame_dig -1 // appBiatecConfigProvider: AppID
	byte 0x6566 // "ef"
	app_global_get_ex
	assert
	frame_bury 0 // addressExecutiveFee: any

	// contracts\BiatecClammPool.algo.ts:1279
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -1 // appBiatecConfigProvider: AppID
	byte 0x73 // "s"
	app_global_get_ex
	assert
	frame_bury 1 // paused: uint64

	// contracts\BiatecClammPool.algo.ts:1280
	// assert(paused === 0, 'ERR_PAUSED')
	frame_dig 1 // paused: uint64
	int 0
	==

	// ERR_PAUSED
	assert

	// contracts\BiatecClammPool.algo.ts:1282
	// assert(
	//       this.txn.sender === addressExecutiveFee,
	//       'ERR_SENDER' // 'Only fee executor setup in the config can take the collected fees'
	//     )
	txn Sender
	frame_dig 0 // addressExecutiveFee: any
	==

	// ERR_SENDER
	assert

	// contracts\BiatecClammPool.algo.ts:1286
	// assetADecimals = 6
	int 6
	frame_bury 2 // assetADecimals: uint64

	// *if50_condition
	// contracts\BiatecClammPool.algo.ts:1287
	// assetA.id > 0
	frame_dig -2 // assetA: AssetID
	int 0
	>
	bz *if50_end

	// *if50_consequent
	// contracts\BiatecClammPool.algo.ts:1287
	// assetADecimals = assetA.decimals
	frame_dig -2 // assetA: AssetID
	asset_params_get AssetDecimals
	pop
	frame_bury 2 // assetADecimals: uint64

*if50_end:
	// contracts\BiatecClammPool.algo.ts:1289
	// assetADelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetADecimals)) as uint256
	int 10
	int 9
	frame_dig 2 // assetADecimals: uint64
	-
	exp
	itob
	frame_bury 3 // assetADelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1291
	// assetBDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetB.decimals)) as uint256
	int 10
	int 9
	frame_dig -3 // assetB: AssetID
	asset_params_get AssetDecimals
	pop
	-
	exp
	itob
	frame_bury 4 // assetBDelicmalScale2Scale: unsafe uint256

	// *if51_condition
	// contracts\BiatecClammPool.algo.ts:1293
	// amountA > 0
	frame_dig -4 // amountA: uint64
	int 0
	>
	bz *if51_end

	// *if51_consequent
	// contracts\BiatecClammPool.algo.ts:1294
	// this.doAxfer(this.txn.sender, assetA, amountA)
	frame_dig -4 // amountA: uint64
	frame_dig -2 // assetA: AssetID
	txn Sender
	callsub doAxfer

*if51_end:
	// *if52_condition
	// contracts\BiatecClammPool.algo.ts:1296
	// amountB > 0
	frame_dig -5 // amountB: uint64
	int 0
	>
	bz *if52_end

	// *if52_consequent
	// contracts\BiatecClammPool.algo.ts:1297
	// this.doAxfer(this.txn.sender, assetB, amountB)
	frame_dig -5 // amountB: uint64
	frame_dig -3 // assetB: AssetID
	txn Sender
	callsub doAxfer

*if52_end:
	// *if53_condition
	// contracts\BiatecClammPool.algo.ts:1300
	// assetA.id === 0
	frame_dig -2 // assetA: AssetID
	int 0
	==
	bz *if53_else

	// *if53_consequent
	// contracts\BiatecClammPool.algo.ts:1301
	// assert(
	//         ((this.app.address.balance - 1_000_000) as uint256) * assetADelicmalScale2Scale >= this.assetABalance.value,
	//         'ERR_A0_B' // 'It is not possible to set higher assetABalance in algos then is in the app balance'
	//       )
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	int 1_000_000
	-
	itob
	frame_dig 3 // assetADelicmalScale2Scale: unsafe uint256
	b*
	byte 0x6162 // "ab"
	app_global_get
	b>=

	// ERR_A0_B
	assert
	b *if53_end

*if53_else:
	// contracts\BiatecClammPool.algo.ts:1306
	// assert(
	//         (this.app.address.assetBalance(assetA) as uint256) * assetADelicmalScale2Scale >= this.assetABalance.value,
	//         'ERR_A_B' // 'It is not possible to set higher assetABalance then is in the app balance'
	//       )
	global CurrentApplicationAddress
	frame_dig -2 // assetA: AssetID
	asset_holding_get AssetBalance
	pop
	itob
	frame_dig 3 // assetADelicmalScale2Scale: unsafe uint256
	b*
	byte 0x6162 // "ab"
	app_global_get
	b>=

	// ERR_A_B
	assert

*if53_end:
	// contracts\BiatecClammPool.algo.ts:1311
	// assert(
	//       (this.app.address.assetBalance(assetB) as uint256) * assetBDelicmalScale2Scale >= this.assetBBalance.value,
	//       'ERR_B_B' // 'It is not possible to set higher assetBBalance then is in the app balance'
	//     )
	global CurrentApplicationAddress
	frame_dig -3 // assetB: AssetID
	asset_holding_get AssetBalance
	pop
	itob
	frame_dig 4 // assetBDelicmalScale2Scale: unsafe uint256
	b*
	byte 0x6262 // "bb"
	app_global_get
	b>=

	// ERR_B_B
	assert

	// contracts\BiatecClammPool.algo.ts:1316
	// return amountA + amountB;
	frame_dig -4 // amountA: uint64
	frame_dig -5 // amountB: uint64
	+

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 4
	retsub

// sendOnlineKeyRegistration(uint64,byte[],byte[],byte[],uint64,uint64,uint64)void
*abi_route_sendOnlineKeyRegistration:
	// voteKeyDilution: uint64
	txna ApplicationArgs 7
	btoi

	// voteLast: uint64
	txna ApplicationArgs 6
	btoi

	// voteFirst: uint64
	txna ApplicationArgs 5
	btoi

	// stateProofPK: byte[]
	txna ApplicationArgs 4
	extract 2 0

	// selectionPK: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// votePK: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute sendOnlineKeyRegistration(uint64,byte[],byte[],byte[],uint64,uint64,uint64)void
	callsub sendOnlineKeyRegistration
	int 1
	return

// sendOnlineKeyRegistration(appBiatecConfigProvider: AppID, votePK: bytes, selectionPK: bytes, stateProofPK: bytes, voteFirst: uint64, voteLast: uint64, voteKeyDilution: uint64): void
//
// addressExecutiveFee can perfom key registration for this LP pool
//
// Only addressExecutiveFee is allowed to execute this method.
sendOnlineKeyRegistration:
	proto 7 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts\BiatecClammPool.algo.ts:1333
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value, 'ERR_CONFIG')
	frame_dig -1 // appBiatecConfigProvider: AppID
	byte 0x42 // "B"
	app_global_get
	==

	// ERR_CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:1334
	// addressExecutiveFee = appBiatecConfigProvider.globalState('ef')
	frame_dig -1 // appBiatecConfigProvider: AppID
	byte 0x6566 // "ef"
	app_global_get_ex
	assert
	frame_bury 0 // addressExecutiveFee: any

	// contracts\BiatecClammPool.algo.ts:1335
	// assert(
	//       this.txn.sender === addressExecutiveFee,
	//       'ERR_SENDER' // 'Only fee executor setup in the config can take the collected fees'
	//     )
	txn Sender
	frame_dig 0 // addressExecutiveFee: any
	==

	// ERR_SENDER
	assert

	// contracts\BiatecClammPool.algo.ts:1339
	// sendOnlineKeyRegistration({
	//       selectionPK: selectionPK,
	//       stateProofPK: stateProofPK,
	//       voteFirst: voteFirst,
	//       voteKeyDilution: voteKeyDilution,
	//       voteLast: voteLast,
	//       votePK: votePK,
	//       fee: 0,
	//     })
	itxn_begin
	int keyreg
	itxn_field TypeEnum

	// contracts\BiatecClammPool.algo.ts:1340
	// selectionPK: selectionPK
	frame_dig -3 // selectionPK: bytes
	itxn_field SelectionPK

	// contracts\BiatecClammPool.algo.ts:1341
	// stateProofPK: stateProofPK
	frame_dig -4 // stateProofPK: bytes
	itxn_field StateProofPK

	// contracts\BiatecClammPool.algo.ts:1342
	// voteFirst: voteFirst
	frame_dig -5 // voteFirst: uint64
	itxn_field VoteFirst

	// contracts\BiatecClammPool.algo.ts:1343
	// voteKeyDilution: voteKeyDilution
	frame_dig -7 // voteKeyDilution: uint64
	itxn_field VoteKeyDilution

	// contracts\BiatecClammPool.algo.ts:1344
	// voteLast: voteLast
	frame_dig -6 // voteLast: uint64
	itxn_field VoteLast

	// contracts\BiatecClammPool.algo.ts:1345
	// votePK: votePK
	frame_dig -2 // votePK: bytes
	itxn_field VotePK

	// contracts\BiatecClammPool.algo.ts:1346
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// sendOfflineKeyRegistration(uint64)void
*abi_route_sendOfflineKeyRegistration:
	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute sendOfflineKeyRegistration(uint64)void
	callsub sendOfflineKeyRegistration
	int 1
	return

// sendOfflineKeyRegistration(appBiatecConfigProvider: AppID): void
//
// addressExecutiveFee can perfom key unregistration for this LP pool
//
// Only addressExecutiveFee is allowed to execute this method.
sendOfflineKeyRegistration:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts\BiatecClammPool.algo.ts:1356
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value, 'ERR_CONFIG')
	frame_dig -1 // appBiatecConfigProvider: AppID
	byte 0x42 // "B"
	app_global_get
	==

	// ERR_CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:1357
	// addressExecutiveFee = appBiatecConfigProvider.globalState('ef')
	frame_dig -1 // appBiatecConfigProvider: AppID
	byte 0x6566 // "ef"
	app_global_get_ex
	assert
	frame_bury 0 // addressExecutiveFee: any

	// contracts\BiatecClammPool.algo.ts:1359
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -1 // appBiatecConfigProvider: AppID
	byte 0x73 // "s"
	app_global_get_ex
	assert
	frame_bury 1 // paused: uint64

	// contracts\BiatecClammPool.algo.ts:1360
	// assert(paused === 0, 'ERR_PAUSED')
	frame_dig 1 // paused: uint64
	int 0
	==

	// ERR_PAUSED
	assert

	// contracts\BiatecClammPool.algo.ts:1362
	// assert(
	//       this.txn.sender === addressExecutiveFee,
	//       'ERR_SENDER' // 'Only fee executor setup in the config can take the collected fees'
	//     )
	txn Sender
	frame_dig 0 // addressExecutiveFee: any
	==

	// ERR_SENDER
	assert

	// contracts\BiatecClammPool.algo.ts:1366
	// sendOfflineKeyRegistration({ fee: 0 })
	itxn_begin
	int keyreg
	itxn_field TypeEnum

	// contracts\BiatecClammPool.algo.ts:1366
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// calculateDistributedLiquidity(uint64,uint256)uint256
*abi_route_calculateDistributedLiquidity:
	// The ABI return prefix
	byte 0x151f7c75

	// currentDeposit: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// assetLP: uint64
	txna ApplicationArgs 1
	btoi

	// execute calculateDistributedLiquidity(uint64,uint256)uint256
	callsub calculateDistributedLiquidity
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// calculateDistributedLiquidity(assetLP: AssetID, currentDeposit: uint256): uint256
//
// Calculates the number of LP tokens issued to users
calculateDistributedLiquidity:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 4

	// contracts\BiatecClammPool.algo.ts:1374
	// current = (this.app.address.assetBalance(assetLP) as uint256) - currentDeposit
	global CurrentApplicationAddress
	frame_dig -1 // assetLP: AssetID
	asset_holding_get AssetBalance
	pop
	itob
	frame_dig -2 // currentDeposit: uint256
	b-
	frame_bury 0 // current: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1375
	// minted = TOTAL_SUPPLY as uint256
	byte 0x000000000000000000000000000000000000000000000000002386f26fc10000
	frame_bury 1 // minted: uint256

	// contracts\BiatecClammPool.algo.ts:1376
	// distributedLPTokens = minted - current
	byte 0x000000000000000000000000000000000000000000000000002386f26fc10000 // minted: uint256
	frame_dig 0 // current: unsafe uint256
	b-
	frame_bury 2 // distributedLPTokens: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1378
	// assetLPDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - LP_TOKEN_DECIMALS)) as uint256
	int 10
	int 3
	exp
	itob
	frame_bury 3 // assetLPDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1379
	// ret = distributedLPTokens * assetLPDelicmalScale2Scale
	frame_dig 2 // distributedLPTokens: unsafe uint256
	frame_dig 3 // assetLPDelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 4 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1380
	// return ret;
	frame_dig 4 // ret: unsafe uint256

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 4
	retsub

// calculateLiquidityFlatPrice(uint256,uint256,uint256)uint256
*abi_route_calculateLiquidityFlatPrice:
	// The ABI return prefix
	byte 0x151f7c75

	// price: uint256
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// y: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// x: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute calculateLiquidityFlatPrice(uint256,uint256,uint256)uint256
	callsub calculateLiquidityFlatPrice
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// calculateLiquidityFlatPrice(x: uint256, y: uint256, price: uint256): uint256
calculateLiquidityFlatPrice:
	proto 3 1

	// contracts\BiatecClammPool.algo.ts:1399
	// return (x * price) / s + y;
	frame_dig -1 // x: uint256
	frame_dig -3 // price: uint256
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_dig -2 // y: uint256
	b+
	retsub

// calculateLiquidityD(uint256,uint256,uint256,uint256,uint256,uint256)uint256
*abi_route_calculateLiquidityD:
	// The ABI return prefix
	byte 0x151f7c75

	// priceMaxSqrt: uint256
	txna ApplicationArgs 6
	dup
	len
	int 32
	==
	assert

	// priceMinSqrt: uint256
	txna ApplicationArgs 5
	dup
	len
	int 32
	==
	assert

	// priceMax: uint256
	txna ApplicationArgs 4
	dup
	len
	int 32
	==
	assert

	// priceMin: uint256
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// y: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// x: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute calculateLiquidityD(uint256,uint256,uint256,uint256,uint256,uint256)uint256
	callsub calculateLiquidityD
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// calculateLiquidityD(x: uint256, y: uint256, priceMin: uint256, priceMax: uint256, priceMinSqrt: uint256, priceMaxSqrt: uint256): uint256
//
// Calculates the liquidity  from the x - Asset A position and y - Asset B position
// This method calculates discriminant - first part of the calculation.
// It is divided so that the readonly method does not need to charge fees
//
// @param x Asset A position balanced on the curve
// @param y Asset B position balanced on the curve
// @param priceMin Minimum price variable in base scale decimals (pa)
// @param priceMax Maximum price variable in base scale decimals (pb)
// @param priceMinSqrt sqrt(priceMin) in base scale decimals Variable pas
// @param priceMaxSqrt sqrt(priceMax) in base scale decimals Variable pbs
// @returns Liquidity is constant in swapping each direction. On deposit the diff between the liquidity is number of LP tokens received by user.
calculateLiquidityD:
	proto 6 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 8

	// contracts\BiatecClammPool.algo.ts:1453
	// D1 = (x * x * priceMin) / s / s
	frame_dig -1 // x: uint256
	frame_dig -1 // x: uint256
	b*
	frame_dig -3 // priceMin: uint256
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 0 // D1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1455
	// D2 = (y * y) / priceMax
	frame_dig -2 // y: uint256
	frame_dig -2 // y: uint256
	b*
	frame_dig -4 // priceMax: uint256
	b/
	frame_bury 1 // D2: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1457
	// D3_1 = <uint256>2 * x * y * priceMinSqrt
	byte 0x0000000000000000000000000000000000000000000000000000000000000002
	frame_dig -1 // x: uint256
	b*
	frame_dig -2 // y: uint256
	b*
	frame_dig -5 // priceMinSqrt: uint256
	b*
	frame_bury 2 // D3_1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1458
	// D3 = D3_1 / priceMaxSqrt / s
	frame_dig 2 // D3_1: unsafe uint256
	frame_dig -6 // priceMaxSqrt: uint256
	b/
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 3 // D3: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1461
	// D4 = (<uint256>4 * x * y) / s
	byte 0x0000000000000000000000000000000000000000000000000000000000000004
	frame_dig -1 // x: uint256
	b*
	frame_dig -2 // y: uint256
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 4 // D4: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1463
	// D5_1 = <uint256>4 * x * y * priceMinSqrt
	byte 0x0000000000000000000000000000000000000000000000000000000000000004
	frame_dig -1 // x: uint256
	b*
	frame_dig -2 // y: uint256
	b*
	frame_dig -5 // priceMinSqrt: uint256
	b*
	frame_bury 5 // D5_1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1464
	// D5 = D5_1 / priceMaxSqrt / s
	frame_dig 5 // D5_1: unsafe uint256
	frame_dig -6 // priceMaxSqrt: uint256
	b/
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 6 // D5: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1465
	// D = D1 + D2 + D3 + D4 - D5
	frame_dig 0 // D1: unsafe uint256
	frame_dig 1 // D2: unsafe uint256
	b+
	frame_dig 3 // D3: unsafe uint256
	b+
	frame_dig 4 // D4: unsafe uint256
	b+
	frame_dig 6 // D5: unsafe uint256
	b-
	frame_bury 7 // D: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1466
	// D_SQRT = sqrt(s * D)
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	frame_dig 7 // D: unsafe uint256
	b*
	bsqrt
	frame_bury 8 // D_SQRT: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1467
	// return D_SQRT;
	frame_dig 8 // D_SQRT: unsafe uint256

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 8
	retsub

// calculateLiquidityWithD(uint256,uint256,uint256,uint256,uint256)uint256
*abi_route_calculateLiquidityWithD:
	// The ABI return prefix
	byte 0x151f7c75

	// D_SQRT: uint256
	txna ApplicationArgs 5
	dup
	len
	int 32
	==
	assert

	// priceMaxSqrt: uint256
	txna ApplicationArgs 4
	dup
	len
	int 32
	==
	assert

	// priceMinSqrt: uint256
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// y: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// x: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute calculateLiquidityWithD(uint256,uint256,uint256,uint256,uint256)uint256
	callsub calculateLiquidityWithD
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// calculateLiquidityWithD(x: uint256, y: uint256, priceMinSqrt: uint256, priceMaxSqrt: uint256, D_SQRT: uint256): uint256
//
// Calculates the liquidity  from the x - Asset A position and y - Asset B position
//
// @param x Asset A position balanced on the curve
// @param y Asset B position balanced on the curve
// @param priceMinSqrt sqrt(priceMin) in base scale decimals Variable pas
// @param priceMaxSqrt sqrt(priceMax) in base scale decimals Variable pbs
// @returns Liquidity is constant in swapping each direction. On deposit the diff between the liquidity is number of LP tokens received by user.
calculateLiquidityWithD:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 11

	// contracts\BiatecClammPool.algo.ts:1517
	// L1 = (x * priceMinSqrt) / s
	frame_dig -1 // x: uint256
	frame_dig -3 // priceMinSqrt: uint256
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 0 // L1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1520
	// L2 = (y * s) / priceMaxSqrt
	frame_dig -2 // y: uint256
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig -4 // priceMaxSqrt: uint256
	b/
	frame_bury 1 // L2: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1525
	// L3_0 = <uint256>2
	byte 0x0000000000000000000000000000000000000000000000000000000000000002
	frame_bury 2 // L3_0: uint256

	// contracts\BiatecClammPool.algo.ts:1526
	// L3_1 = L3_0 * priceMinSqrt
	byte 0x0000000000000000000000000000000000000000000000000000000000000002 // L3_0: uint256
	frame_dig -3 // priceMinSqrt: uint256
	b*
	frame_bury 3 // L3_1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1527
	// L3_2 = L3_1 * s
	frame_dig 3 // L3_1: unsafe uint256
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_bury 4 // L3_2: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1528
	// L3 = L3_2 / priceMaxSqrt
	frame_dig 4 // L3_2: unsafe uint256
	frame_dig -4 // priceMaxSqrt: uint256
	b/
	frame_bury 5 // L3: unsafe uint256

	// *if54_condition
	// contracts\BiatecClammPool.algo.ts:1529
	// <uint256>2 * s > L3
	byte 0x0000000000000000000000000000000000000000000000000000000000000002
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 5 // L3: unsafe uint256
	b>
	bz *if54_end

	// *if54_consequent
	// contracts\BiatecClammPool.algo.ts:1530
	// nom = L1 + L2 + D_SQRT
	frame_dig 0 // L1: unsafe uint256
	frame_dig 1 // L2: unsafe uint256
	b+
	frame_dig -5 // D_SQRT: uint256
	b+
	frame_bury 6 // nom: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1531
	// den = <uint256>2 * s - L3
	byte 0x0000000000000000000000000000000000000000000000000000000000000002
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 5 // L3: unsafe uint256
	b-
	frame_bury 7 // den: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1532
	// ret = (s * nom) / den
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	frame_dig 6 // nom: unsafe uint256
	b*
	frame_dig 7 // den: unsafe uint256
	b/
	frame_bury 8 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1533
	// return ret;
	frame_dig 8 // ret: unsafe uint256

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 8
	retsub

*if54_end:
	// contracts\BiatecClammPool.algo.ts:1535
	// nom = L1 + L2 - D_SQRT
	frame_dig 0 // L1: unsafe uint256
	frame_dig 1 // L2: unsafe uint256
	b+
	frame_dig -5 // D_SQRT: uint256
	b-
	frame_bury 9 // nom: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1536
	// den = L3 - <uint256>2 * s
	frame_dig 5 // L3: unsafe uint256
	byte 0x0000000000000000000000000000000000000000000000000000000000000002
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	b-
	frame_bury 10 // den: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1537
	// ret = (s * nom) / den
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	frame_dig 9 // nom: unsafe uint256
	b*
	frame_dig 10 // den: unsafe uint256
	b/
	frame_bury 11 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1538
	// return ret;
	frame_dig 11 // ret: unsafe uint256

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 11
	retsub

// calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256
*abi_route_calculatePrice:
	// The ABI return prefix
	byte 0x151f7c75

	// liquidity: uint256
	txna ApplicationArgs 5
	dup
	len
	int 32
	==
	assert

	// priceMaxSqrt: uint256
	txna ApplicationArgs 4
	dup
	len
	int 32
	==
	assert

	// priceMinSqrt: uint256
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// assetBQuantity: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// assetAQuantity: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256
	callsub calculatePrice
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// calculatePrice(assetAQuantity: uint256, assetBQuantity: uint256, priceMinSqrt: uint256, priceMaxSqrt: uint256, liquidity: uint256): uint256
//
// Get the current price when asset a has x
// @param assetAQuantity x
// @param assetBQuantity y
// @param priceMinSqrt sqrt(priceMin)
// @param priceMaxSqrt sqrt(priceMax)
// @param liquidity Current pool liquidity - L variable
// @returns the price with specified quantity with the price range set in the contract
calculatePrice:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 7

	// *if55_condition
	// contracts\BiatecClammPool.algo.ts:1562
	// priceMinSqrt === priceMaxSqrt
	frame_dig -3 // priceMinSqrt: uint256
	frame_dig -4 // priceMaxSqrt: uint256
	b==
	bz *if55_end

	// *if55_consequent
	// contracts\BiatecClammPool.algo.ts:1563
	// ret = (priceMinSqrt * priceMinSqrt) / s
	frame_dig -3 // priceMinSqrt: uint256
	frame_dig -3 // priceMinSqrt: uint256
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 0 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1564
	// return ret;
	frame_dig 0 // ret: unsafe uint256

	// set the subroutine return value
	frame_bury 0
	retsub

*if55_end:
	// contracts\BiatecClammPool.algo.ts:1567
	// a = priceMinSqrt
	frame_dig -3 // priceMinSqrt: uint256
	frame_bury 1 // a: uint256

	// contracts\BiatecClammPool.algo.ts:1568
	// b = priceMaxSqrt
	frame_dig -4 // priceMaxSqrt: uint256
	frame_bury 2 // b: uint256

	// contracts\BiatecClammPool.algo.ts:1569
	// P1 = (liquidity * a) / s
	frame_dig -5 // liquidity: uint256
	frame_dig 1 // a: uint256
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 3 // P1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1570
	// P2 = (liquidity * s) / b
	frame_dig -5 // liquidity: uint256
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 2 // b: uint256
	b/
	frame_bury 4 // P2: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1571
	// Nom = assetBQuantity + P1
	frame_dig -2 // assetBQuantity: uint256
	frame_dig 3 // P1: unsafe uint256
	b+
	frame_bury 5 // Nom: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1572
	// Denom = assetAQuantity + P2
	frame_dig -1 // assetAQuantity: uint256
	frame_dig 4 // P2: unsafe uint256
	b+
	frame_bury 6 // Denom: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1573
	// ret = (Nom * s) / Denom
	frame_dig 5 // Nom: unsafe uint256
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 6 // Denom: unsafe uint256
	b/
	frame_bury 7 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1574
	// return ret;
	frame_dig 7 // ret: unsafe uint256

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 7
	retsub

// calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256
*abi_route_calculateAssetBWithdrawOnAssetADeposit:
	// The ABI return prefix
	byte 0x151f7c75

	// liqudity: uint256
	txna ApplicationArgs 6
	dup
	len
	int 32
	==
	assert

	// priceMaxSqrt: uint256
	txna ApplicationArgs 5
	dup
	len
	int 32
	==
	assert

	// priceMinSqrt: uint256
	txna ApplicationArgs 4
	dup
	len
	int 32
	==
	assert

	// assetBBalance: uint256
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// assetABalance: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// inAmount: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256
	callsub calculateAssetBWithdrawOnAssetADeposit
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// calculateAssetBWithdrawOnAssetADeposit(inAmount: uint256, assetABalance: uint256, assetBBalance: uint256, priceMinSqrt: uint256, priceMaxSqrt: uint256, liqudity: uint256): uint256
//
// Calculates how much asset B will be taken from the smart contract on asset A deposit
// @param inAmount Asset A amount in Base decimal representation.. If asset has 6 decimals, 1 is represented as 1000000000
// @param assetABalance Asset A balance. Variable ab, in base scale
// @param assetBBalance Asset B balance. Variable bb, in base scale
// @param priceMinSqrt sqrt(Min price). Variable pMinS, in base scale
// @param priceMaxSqrt sqrt(Max price). Variable pMaxS, in base scale
// @param liqudity sqrt(Max price). Variable L, in base scale
// @returns Amount of asset B to be given to the caller before fees. The result is in Base decimals (9)
calculateAssetBWithdrawOnAssetADeposit:
	proto 6 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 12

	// *if56_condition
	// contracts\BiatecClammPool.algo.ts:1597
	// priceMinSqrt === priceMaxSqrt
	frame_dig -4 // priceMinSqrt: uint256
	frame_dig -5 // priceMaxSqrt: uint256
	b==
	bz *if56_end

	// *if56_consequent
	// contracts\BiatecClammPool.algo.ts:1598
	// ret = (inAmount * priceMinSqrt * priceMinSqrt) / s / s
	frame_dig -1 // inAmount: uint256
	frame_dig -4 // priceMinSqrt: uint256
	b*
	frame_dig -4 // priceMinSqrt: uint256
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 0 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1599
	// return ret;
	frame_dig 0 // ret: unsafe uint256

	// set the subroutine return value
	frame_bury 0
	retsub

*if56_end:
	// contracts\BiatecClammPool.algo.ts:1617
	// x = assetABalance
	frame_dig -2 // assetABalance: uint256
	frame_bury 1 // x: uint256

	// contracts\BiatecClammPool.algo.ts:1618
	// y = assetBBalance
	frame_dig -3 // assetBBalance: uint256
	frame_bury 2 // y: uint256

	// contracts\BiatecClammPool.algo.ts:1619
	// a = priceMinSqrt
	frame_dig -4 // priceMinSqrt: uint256
	frame_bury 3 // a: uint256

	// contracts\BiatecClammPool.algo.ts:1620
	// b = priceMaxSqrt
	frame_dig -5 // priceMaxSqrt: uint256
	frame_bury 4 // b: uint256

	// contracts\BiatecClammPool.algo.ts:1621
	// L = liqudity
	frame_dig -6 // liqudity: uint256
	frame_bury 5 // L: uint256

	// contracts\BiatecClammPool.algo.ts:1623
	// P1 = (((((a /* 10D */ * b) /* 10D */ / s) * inAmount) /* AD */ / s) * L) /* 10D */ / s
	frame_dig 3 // a: uint256
	frame_dig 4 // b: uint256
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_dig -1 // inAmount: uint256
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_dig 5 // L: uint256
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 6 // P1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1625
	// P2 = (((b /* 10D */ * inAmount) /* AD */ / s) * y) /* BD */ / s
	frame_dig 4 // b: uint256
	frame_dig -1 // inAmount: uint256
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_dig 2 // y: uint256
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 7 // P2: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1627
	// P3 = (b /* 10D */ * inAmount) /* AD */ / s
	frame_dig 4 // b: uint256
	frame_dig -1 // inAmount: uint256
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 8 // P3: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1629
	// P4 = (b /* 10D */ * x) /* 10D */ / s
	frame_dig 4 // b: uint256
	frame_dig 1 // x: uint256
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 9 // P4: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1631
	// P12 = P1 + P2
	frame_dig 6 // P1: unsafe uint256
	frame_dig 7 // P2: unsafe uint256
	b+
	frame_bury 10 // P12: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1633
	// P345 = P3 + P4 + L
	frame_dig 8 // P3: unsafe uint256
	frame_dig 9 // P4: unsafe uint256
	b+
	frame_dig 5 // L: uint256
	b+
	frame_bury 11 // P345: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1635
	// ret = (P12 * s) / P345
	frame_dig 10 // P12: unsafe uint256
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 11 // P345: unsafe uint256
	b/
	frame_bury 12 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1636
	// return ret;
	frame_dig 12 // ret: unsafe uint256

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 12
	retsub

// calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256
*abi_route_calculateAssetAWithdrawOnAssetBDeposit:
	// The ABI return prefix
	byte 0x151f7c75

	// liqudity: uint256
	txna ApplicationArgs 6
	dup
	len
	int 32
	==
	assert

	// priceMaxSqrt: uint256
	txna ApplicationArgs 5
	dup
	len
	int 32
	==
	assert

	// priceMinSqrt: uint256
	txna ApplicationArgs 4
	dup
	len
	int 32
	==
	assert

	// assetBBalance: uint256
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// assetABalance: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// inAmount: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256
	callsub calculateAssetAWithdrawOnAssetBDeposit
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// calculateAssetAWithdrawOnAssetBDeposit(inAmount: uint256, assetABalance: uint256, assetBBalance: uint256, priceMinSqrt: uint256, priceMaxSqrt: uint256, liqudity: uint256): uint256
//
// Calculates how much asset A will be taken from the smart contract on asset B deposit
// @param inAmount Asset B amount in Base decimal representation.. If asset has 6 decimals, 1 is represented as 1000000000
// @param assetABalance Asset A balance. Variable ab, in base scale
// @param assetBBalance Asset B balance. Variable bb, in base scale
// @param priceMinSqrt sqrt(Min price). Variable pMinS, in base scale
// @param priceMaxSqrt sqrt(Max price). Variable pMaxS, in base scale
// @param liqudity sqrt(Max price). Variable L, in base scale
//
// @returns Amount of asset A to be given to the caller before fees. The result is in Base decimals (9)
calculateAssetAWithdrawOnAssetBDeposit:
	proto 6 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 13

	// *if57_condition
	// contracts\BiatecClammPool.algo.ts:1659
	// priceMinSqrt === priceMaxSqrt
	frame_dig -4 // priceMinSqrt: uint256
	frame_dig -5 // priceMaxSqrt: uint256
	b==
	bz *if57_end

	// *if57_consequent
	// contracts\BiatecClammPool.algo.ts:1660
	// ret = (inAmount * s * s) / priceMinSqrt / priceMinSqrt
	frame_dig -1 // inAmount: uint256
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig -4 // priceMinSqrt: uint256
	b/
	frame_dig -4 // priceMinSqrt: uint256
	b/
	frame_bury 0 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1661
	// return ret;
	frame_dig 0 // ret: unsafe uint256

	// set the subroutine return value
	frame_bury 0
	retsub

*if57_end:
	// contracts\BiatecClammPool.algo.ts:1676
	// x = assetABalance
	frame_dig -2 // assetABalance: uint256
	frame_bury 1 // x: uint256

	// contracts\BiatecClammPool.algo.ts:1677
	// y = assetBBalance
	frame_dig -3 // assetBBalance: uint256
	frame_bury 2 // y: uint256

	// contracts\BiatecClammPool.algo.ts:1678
	// a = priceMinSqrt
	frame_dig -4 // priceMinSqrt: uint256
	frame_bury 3 // a: uint256

	// contracts\BiatecClammPool.algo.ts:1679
	// b = priceMaxSqrt
	frame_dig -5 // priceMaxSqrt: uint256
	frame_bury 4 // b: uint256

	// contracts\BiatecClammPool.algo.ts:1680
	// L = liqudity
	frame_dig -6 // liqudity: uint256
	frame_bury 5 // L: uint256

	// contracts\BiatecClammPool.algo.ts:1683
	// P1 = (inAmount * L) / s
	frame_dig -1 // inAmount: uint256
	frame_dig 5 // L: uint256
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 6 // P1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1685
	// P2 = (((b * inAmount) / s) * x) / s
	frame_dig 4 // b: uint256
	frame_dig -1 // inAmount: uint256
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_dig 1 // x: uint256
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 7 // P2: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1687
	// nom = P1 + P2
	frame_dig 6 // P1: unsafe uint256
	frame_dig 7 // P2: unsafe uint256
	b+
	frame_bury 8 // nom: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1689
	// P3 = (((a * b) / s) * L) / s
	frame_dig 3 // a: uint256
	frame_dig 4 // b: uint256
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_dig 5 // L: uint256
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 9 // P3: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1691
	// P4 = (b * inAmount) / s
	frame_dig 4 // b: uint256
	frame_dig -1 // inAmount: uint256
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 10 // P4: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1693
	// P5 = (b * y) / s
	frame_dig 4 // b: uint256
	frame_dig 2 // y: uint256
	b*
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 11 // P5: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1695
	// denom = P3 + P4 + P5
	frame_dig 9 // P3: unsafe uint256
	frame_dig 10 // P4: unsafe uint256
	b+
	frame_dig 11 // P5: unsafe uint256
	b+
	frame_bury 12 // denom: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1697
	// ret = (nom * s) / denom
	frame_dig 8 // nom: unsafe uint256
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 12 // denom: unsafe uint256
	b/
	frame_bury 13 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1698
	// return ret;
	frame_dig 13 // ret: unsafe uint256

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 13
	retsub

// calculateAssetAWithdrawOnLpDeposit(uint256,uint256,uint256)uint256
*abi_route_calculateAssetAWithdrawOnLpDeposit:
	// The ABI return prefix
	byte 0x151f7c75

	// liqudity: uint256
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// assetABalance: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// inAmount: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute calculateAssetAWithdrawOnLpDeposit(uint256,uint256,uint256)uint256
	callsub calculateAssetAWithdrawOnLpDeposit
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// calculateAssetAWithdrawOnLpDeposit(inAmount: uint256, assetABalance: uint256, liqudity: uint256): uint256
//
// Calculates how much asset A will be taken from the smart contract on LP asset deposit
// @param inAmount LP Asset amount in Base decimal representation..
// @param assetABalance Asset A balance. Variable ab, in base scale
// @param liqudity Current liqudity. Variable L, in base scale
//
// @returns Amount of asset A to be given to the caller before fees. The result is in Base decimals (9)
calculateAssetAWithdrawOnLpDeposit:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts\BiatecClammPool.algo.ts:1714
	// ret = (assetABalance * inAmount) / liqudity
	frame_dig -2 // assetABalance: uint256
	frame_dig -1 // inAmount: uint256
	b*
	frame_dig -3 // liqudity: uint256
	b/
	frame_bury 0 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1715
	// return ret;
	frame_dig 0 // ret: unsafe uint256

	// set the subroutine return value
	frame_bury 0
	retsub

// calculateAssetBWithdrawOnLpDeposit(uint256,uint256,uint256)uint256
*abi_route_calculateAssetBWithdrawOnLpDeposit:
	// The ABI return prefix
	byte 0x151f7c75

	// liqudity: uint256
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// assetBBalance: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// inAmount: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute calculateAssetBWithdrawOnLpDeposit(uint256,uint256,uint256)uint256
	callsub calculateAssetBWithdrawOnLpDeposit
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// calculateAssetBWithdrawOnLpDeposit(inAmount: uint256, assetBBalance: uint256, liqudity: uint256): uint256
//
// Calculates how much asset B will be taken from the smart contract on LP asset deposit
// @param inAmount LP Asset amount in Base decimal representation..
// @param assetBBalance Asset B balance. Variable ab, in base scale
// @param liqudity Current liqudity. Variable L, in base scale
//
// @returns Amount of asset B to be given to the caller before fees. The result is in Base decimals (9)
calculateAssetBWithdrawOnLpDeposit:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts\BiatecClammPool.algo.ts:1731
	// ret = (assetBBalance * inAmount) / liqudity
	frame_dig -2 // assetBBalance: uint256
	frame_dig -1 // inAmount: uint256
	b*
	frame_dig -3 // liqudity: uint256
	b/
	frame_bury 0 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1732
	// return ret;
	frame_dig 0 // ret: unsafe uint256

	// set the subroutine return value
	frame_bury 0
	retsub

// calculateAssetBDepositOnAssetADeposit(uint256,uint256,uint256,uint256)uint256
*abi_route_calculateAssetBDepositOnAssetADeposit:
	// The ABI return prefix
	byte 0x151f7c75

	// assetBBalance: uint256
	txna ApplicationArgs 4
	dup
	len
	int 32
	==
	assert

	// assetABalance: uint256
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// inAmountB: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// inAmountA: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute calculateAssetBDepositOnAssetADeposit(uint256,uint256,uint256,uint256)uint256
	callsub calculateAssetBDepositOnAssetADeposit
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// calculateAssetBDepositOnAssetADeposit(inAmountA: uint256, inAmountB: uint256, assetABalance: uint256, assetBBalance: uint256): uint256
//
// Calculates how much asset B should be deposited when user deposit asset a and b.
//
// On deposit min(calculateAssetBDepositOnAssetADeposit, calculateAssetADepositOnAssetBDeposit) should be considered for the real deposit and rest should be swapped or returned back to user
//
// @param inAmountA Asset A amount in Base decimal representation
// @param inAmountB Asset B amount in Base decimal representation
// @param assetABalance Asset A balance. Variable ab, in base scale
// @param assetBBalance Asset B balance. Variable bb, in base scale
//
// @returns Amount of asset B to be given to the caller before fees. The result is in Base decimals (9)
calculateAssetBDepositOnAssetADeposit:
	proto 4 1

	// *if58_condition
	// contracts\BiatecClammPool.algo.ts:1754
	// assetABalance > <uint256>0
	frame_dig -3 // assetABalance: uint256
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	bz *if58_end

	// *if58_consequent
	// contracts\BiatecClammPool.algo.ts:1755
	// return (inAmountA * assetBBalance) / assetABalance;
	frame_dig -1 // inAmountA: uint256
	frame_dig -4 // assetBBalance: uint256
	b*
	frame_dig -3 // assetABalance: uint256
	b/
	retsub

*if58_end:
	// contracts\BiatecClammPool.algo.ts:1758
	// return inAmountB;
	frame_dig -2 // inAmountB: uint256
	retsub

// calculateAssetADepositOnAssetBDeposit(uint256,uint256,uint256,uint256)uint256
*abi_route_calculateAssetADepositOnAssetBDeposit:
	// The ABI return prefix
	byte 0x151f7c75

	// assetBBalance: uint256
	txna ApplicationArgs 4
	dup
	len
	int 32
	==
	assert

	// assetABalance: uint256
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// inAmountB: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// inAmountA: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute calculateAssetADepositOnAssetBDeposit(uint256,uint256,uint256,uint256)uint256
	callsub calculateAssetADepositOnAssetBDeposit
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// calculateAssetADepositOnAssetBDeposit(inAmountA: uint256, inAmountB: uint256, assetABalance: uint256, assetBBalance: uint256): uint256
//
// Calculates how much asset A should be deposited when user deposit asset a and b
//
// On deposit min(calculateAssetBDepositOnAssetADeposit, calculateAssetADepositOnAssetBDeposit) should be considered for the real deposit and rest should be swapped or returned back to user
//
// @param inAmountA Asset A amount in Base decimal representation
// @param inAmountB Asset B amount in Base decimal representation
// @param assetABalance Asset A balance. Variable ab, in base scale
// @param assetBBalance Asset B balance. Variable bb, in base scale
//
// @returns Amount of asset A to be deposited. The result is in Base decimals (9)
calculateAssetADepositOnAssetBDeposit:
	proto 4 1

	// *if59_condition
	// contracts\BiatecClammPool.algo.ts:1780
	// assetBBalance > <uint256>0
	frame_dig -4 // assetBBalance: uint256
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	bz *if59_end

	// *if59_consequent
	// contracts\BiatecClammPool.algo.ts:1781
	// return (inAmountB * assetABalance) / assetBBalance;
	frame_dig -2 // inAmountB: uint256
	frame_dig -3 // assetABalance: uint256
	b*
	frame_dig -4 // assetBBalance: uint256
	b/
	retsub

*if59_end:
	// contracts\BiatecClammPool.algo.ts:1784
	// return inAmountA;
	frame_dig -1 // inAmountA: uint256
	retsub

// status(uint64,uint64,uint64,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
*abi_route_status:
	// The ABI return prefix
	byte 0x151f7c75

	// assetLP: uint64
	txna ApplicationArgs 4
	btoi

	// assetB: uint64
	txna ApplicationArgs 3
	btoi

	// assetA: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute status(uint64,uint64,uint64,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	callsub status
	concat
	log
	int 1
	return

// status(appBiatecConfigProvider: AppID, assetA: AssetID, assetB: AssetID, assetLP: AssetID): AmmStatus
status:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts\BiatecClammPool.algo.ts:1789
	// assert(
	//       appBiatecConfigProvider === this.appBiatecConfigProvider.value,
	//       'ERR_CONFIG' // 'appBiatecConfigProvider must match to the global variable app id'
	//     )
	frame_dig -1 // appBiatecConfigProvider: AppID
	byte 0x42 // "B"
	app_global_get
	==

	// ERR_CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:1793
	// assert(assetA.id === this.assetA.value)
	frame_dig -2 // assetA: AssetID
	byte 0x61 // "a"
	app_global_get
	==
	assert

	// contracts\BiatecClammPool.algo.ts:1794
	// assert(assetB.id === this.assetB.value)
	frame_dig -3 // assetB: AssetID
	byte 0x62 // "b"
	app_global_get
	==
	assert

	// contracts\BiatecClammPool.algo.ts:1795
	// assert(this.assetLP.value === assetLP.id, 'ERR_LP')
	byte 0x6c70 // "lp"
	app_global_get
	frame_dig -4 // assetLP: AssetID
	==

	// ERR_LP
	assert

	// contracts\BiatecClammPool.algo.ts:1796
	// biatecFee = this.appBiatecConfigProvider.value.globalState('f') as uint256
	byte 0x42 // "B"
	app_global_get
	byte 0x66 // "f"
	app_global_get_ex
	assert
	frame_bury 0 // biatecFee: uint256

	// contracts\BiatecClammPool.algo.ts:1797
	// realBalanceA =
	//       assetA.id === 0
	//         ? globals.currentApplicationAddress.balance
	//         : globals.currentApplicationAddress.assetBalance(assetA)
	frame_dig -2 // assetA: AssetID
	int 0
	==
	bz *ternary1_false
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	b *ternary1_end

*ternary1_false:
	global CurrentApplicationAddress
	frame_dig -2 // assetA: AssetID
	asset_holding_get AssetBalance
	pop

*ternary1_end:
	frame_bury 1 // realBalanceA: uint64

	// contracts\BiatecClammPool.algo.ts:1801
	// realBalanceB = globals.currentApplicationAddress.assetBalance(assetB)
	global CurrentApplicationAddress
	frame_dig -3 // assetB: AssetID
	asset_holding_get AssetBalance
	pop
	frame_bury 2 // realBalanceB: uint64

	// contracts\BiatecClammPool.algo.ts:1802
	// return {
	//       assetA: this.assetA.value,
	//       assetB: this.assetB.value,
	//       poolToken: this.assetLP.value,
	//       assetABalance: this.assetABalance.value as uint64,
	//       assetBBalance: this.assetBBalance.value as uint64,
	//       realABalance: realBalanceA,
	//       realBBalance: realBalanceB,
	//       fee: this.fee.value,
	//       biatecFee: biatecFee as uint64,
	//       currentLiqudity: this.Liqudity.value as uint64,
	//       liqudityBiatecFromFees: this.LiqudityBiatecFromFees.value as uint64,
	//       liqudityUsersFromFees: this.LiqudityUsersFromFees.value as uint64,
	//       price: this.currentPrice.value as uint64,
	//       priceMaxSqrt: this.priceMaxSqrt.value as uint64,
	//       priceMinSqrt: this.priceMinSqrt.value as uint64,
	//       releasedLiqudity: this.calculateDistributedLiquidity(assetLP, <uint256>0) as uint64,
	//       scale: SCALE,
	//       verificationClass: this.verificationClass.value,
	//     };
	byte 0x000000003b9aca00
	byte 0x6162 // "ab"
	app_global_get
	dup
	bitlen
	int 64
	<=
	assert
	extract 24 8
	btoi
	itob
	concat
	byte 0x6262 // "bb"
	app_global_get
	dup
	bitlen
	int 64
	<=
	assert
	extract 24 8
	btoi
	itob
	concat
	frame_dig 1 // realBalanceA: uint64
	itob
	concat
	frame_dig 2 // realBalanceB: uint64
	itob
	concat
	byte 0x704d696e53 // "pMinS"
	app_global_get
	dup
	bitlen
	int 64
	<=
	assert
	extract 24 8
	btoi
	itob
	concat
	byte 0x704d617853 // "pMaxS"
	app_global_get
	dup
	bitlen
	int 64
	<=
	assert
	extract 24 8
	btoi
	itob
	concat
	byte 0x4c // "L"
	app_global_get
	dup
	bitlen
	int 64
	<=
	assert
	extract 24 8
	btoi
	itob
	concat
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_dig -4 // assetLP: AssetID
	callsub calculateDistributedLiquidity
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	itob
	concat
	byte 0x4c75 // "Lu"
	app_global_get
	dup
	bitlen
	int 64
	<=
	assert
	extract 24 8
	btoi
	itob
	concat
	byte 0x4c62 // "Lb"
	app_global_get
	dup
	bitlen
	int 64
	<=
	assert
	extract 24 8
	btoi
	itob
	concat
	byte 0x61 // "a"
	app_global_get
	itob
	concat
	byte 0x62 // "b"
	app_global_get
	itob
	concat
	byte 0x6c70 // "lp"
	app_global_get
	itob
	concat
	byte 0x7072696365 // "price"
	app_global_get
	itob
	concat
	byte 0x66 // "f"
	app_global_get
	itob
	concat
	frame_dig 0 // biatecFee: uint256
	dup
	bitlen
	int 64
	<=
	assert
	extract 24 8
	btoi
	itob
	concat
	byte 0x63 // "c"
	app_global_get
	itob
	concat

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

*create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication
	err

*call_NoOp:
	method "getCurrentPrice()uint64"
	method "getPriceDivider()uint64"
	method "getLPTokenId()uint64"
	method "bootstrap(uint64,uint64,uint64,uint64,pay,uint64,uint64,uint64,uint64,uint8)uint64"
	method "addLiquidity(uint64,uint64,txn,txn,uint64,uint64,uint64)uint64"
	method "removeLiquidity(uint64,uint64,axfer,uint64,uint64,uint64)uint256"
	method "removeLiquidityAdmin(uint64,uint64,uint64,uint64,uint256)uint256"
	method "swap(uint64,uint64,uint64,txn,uint64,uint64,uint64)uint256"
	method "distributeExcessAssets(uint64,uint64,uint64,uint256,uint256)uint256"
	method "withdrawExcessAssets(uint64,uint64,uint64,uint64,uint64)uint64"
	method "sendOnlineKeyRegistration(uint64,byte[],byte[],byte[],uint64,uint64,uint64)void"
	method "sendOfflineKeyRegistration(uint64)void"
	method "calculateDistributedLiquidity(uint64,uint256)uint256"
	method "calculateLiquidityFlatPrice(uint256,uint256,uint256)uint256"
	method "calculateLiquidityD(uint256,uint256,uint256,uint256,uint256,uint256)uint256"
	method "calculateLiquidityWithD(uint256,uint256,uint256,uint256,uint256)uint256"
	method "calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256"
	method "calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256"
	method "calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256"
	method "calculateAssetAWithdrawOnLpDeposit(uint256,uint256,uint256)uint256"
	method "calculateAssetBWithdrawOnLpDeposit(uint256,uint256,uint256)uint256"
	method "calculateAssetBDepositOnAssetADeposit(uint256,uint256,uint256,uint256)uint256"
	method "calculateAssetADepositOnAssetBDeposit(uint256,uint256,uint256,uint256)uint256"
	method "status(uint64,uint64,uint64,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)"
	txna ApplicationArgs 0
	match *abi_route_getCurrentPrice *abi_route_getPriceDivider *abi_route_getLPTokenId *abi_route_bootstrap *abi_route_addLiquidity *abi_route_removeLiquidity *abi_route_removeLiquidityAdmin *abi_route_swap *abi_route_distributeExcessAssets *abi_route_withdrawExcessAssets *abi_route_sendOnlineKeyRegistration *abi_route_sendOfflineKeyRegistration *abi_route_calculateDistributedLiquidity *abi_route_calculateLiquidityFlatPrice *abi_route_calculateLiquidityD *abi_route_calculateLiquidityWithD *abi_route_calculatePrice *abi_route_calculateAssetBWithdrawOnAssetADeposit *abi_route_calculateAssetAWithdrawOnAssetBDeposit *abi_route_calculateAssetAWithdrawOnLpDeposit *abi_route_calculateAssetBWithdrawOnLpDeposit *abi_route_calculateAssetBDepositOnAssetADeposit *abi_route_calculateAssetADepositOnAssetBDeposit *abi_route_status
	err

*call_UpdateApplication:
	method "updateApplication(uint64,byte[])void"
	txna ApplicationArgs 0
	match *abi_route_updateApplication
	err
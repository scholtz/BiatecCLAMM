#pragma version 10
intcblock 32 256 0 1 64 6 8 10 9 4 5 3 2 1_000_000
bytecblock 0x 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 0x000000000000000000000000000000000000000000000000000000003b9aca00 0x6162 0x6262 0x0a8101 0x0000000000000000000000000000000000000000000000000000000000000000 0x151f7c75 0x4c 0xFFFFFFFFFFFFFFFF 0x704d696e53 0x704d617853 0x704d696e 0x4c75 0x704d6178 0x6263 0x4c62 0x66 0x7072696365 0x0000000000000000000000000000000000000000000000000000000000000002 0x6c70 0x73 0x6566 0x61 0x62 0x63 0x2d 0x0000000000000000000000000000000000000000000000000000000000000001 0x000000000000000000000000000000000000000000000000f9ccd8a1c5080000 0x0000000000000000000000000000000000000000000000000000000000000004 "BIATEC-CLAMM-01-01-01" 0x000000003b9aca00 0x7363616c65 0x7363766572 0x70

// This TEAL was generated by TEALScript v0.105.3
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 5 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_UpdateApplication *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	intc 3 // 1
	return

// createApplication(): void
createApplication:
	proto 0 0

	// contracts\BiatecClammPool.algo.ts:100
	// log(version)
	bytec 30 // "BIATEC-CLAMM-01-01-01"
	log

	// contracts\BiatecClammPool.algo.ts:101
	// this.scale.value = SCALE
	bytec 32 //  "scale"
	pushint 1000000000
	app_global_put

	// contracts\BiatecClammPool.algo.ts:102
	// this.fee.value = <uint64>0
	bytec 17 //  "f"
	intc 2 // 0
	app_global_put

	// contracts\BiatecClammPool.algo.ts:103
	// this.Liqudity.value = <uint256>0
	bytec 8 //  "L"
	bytec 6 // 0x0000000000000000000000000000000000000000000000000000000000000000
	app_global_put

	// contracts\BiatecClammPool.algo.ts:104
	// this.LiqudityBiatecFromFees.value = <uint256>0
	bytec 16 //  "Lb"
	bytec 6 // 0x0000000000000000000000000000000000000000000000000000000000000000
	app_global_put

	// contracts\BiatecClammPool.algo.ts:105
	// this.LiqudityUsersFromFees.value = <uint256>0
	bytec 13 //  "Lu"
	bytec 6 // 0x0000000000000000000000000000000000000000000000000000000000000000
	app_global_put

	// contracts\BiatecClammPool.algo.ts:106
	// this.priceMax.value = 0
	bytec 14 //  "pMax"
	intc 2 // 0
	app_global_put

	// contracts\BiatecClammPool.algo.ts:107
	// this.version.value = version
	bytec 33 //  "scver"
	bytec 30 // "BIATEC-CLAMM-01-01-01"
	app_global_put
	retsub

// updateApplication(uint64,byte[])void
*abi_route_updateApplication:
	// newVersion: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateApplication(uint64,byte[])void
	callsub updateApplication
	intc 3 // 1
	return

// updateApplication(appBiatecConfigProvider: AppID, newVersion: bytes): void
updateApplication:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts\BiatecClammPool.algo.ts:111
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value, 'ERR_CONFIG')
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 15 //  "bc"
	app_global_get
	==

	// ERR_CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:112
	// addressUdpater = appBiatecConfigProvider.globalState('u') as Address
	frame_dig -1 // appBiatecConfigProvider: AppID
	pushbytes 0x75 // "u"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('u')
	assert
	frame_bury 0 // addressUdpater: address

	// contracts\BiatecClammPool.algo.ts:113
	// assert(this.txn.sender === addressUdpater, 'ERR_UPDATER')
	txn Sender
	frame_dig 0 // addressUdpater: address
	==

	// ERR_UPDATER
	assert

	// contracts\BiatecClammPool.algo.ts:114
	// this.version.value = newVersion
	bytec 33 //  "scver"
	frame_dig -2 // newVersion: bytes
	app_global_put
	retsub

// getCurrentPrice()uint64
*abi_route_getCurrentPrice:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// execute getCurrentPrice()uint64
	callsub getCurrentPrice
	itob
	concat
	log
	intc 3 // 1
	return

// getCurrentPrice(): uint64
getCurrentPrice:
	proto 0 1

	// contracts\BiatecClammPool.algo.ts:119
	// return this.currentPrice.value;
	bytec 18 //  "price"
	app_global_get
	retsub

// getPriceDivider()uint64
*abi_route_getPriceDivider:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// execute getPriceDivider()uint64
	callsub getPriceDivider
	itob
	concat
	log
	intc 3 // 1
	return

// getPriceDivider(): uint64
getPriceDivider:
	proto 0 1

	// contracts\BiatecClammPool.algo.ts:124
	// return this.scale.value;
	bytec 32 //  "scale"
	app_global_get
	retsub

// getLPTokenId()uint64
*abi_route_getLPTokenId:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// execute getLPTokenId()uint64
	callsub getLPTokenId
	itob
	concat
	log
	intc 3 // 1
	return

// getLPTokenId(): uint64
getLPTokenId:
	proto 0 1

	// contracts\BiatecClammPool.algo.ts:129
	// return this.assetLp.value;
	bytec 20 //  "lp"
	app_global_get
	retsub

// bootstrap(uint64,uint64,uint64,uint64,pay,uint64,uint64,uint64,uint64,uint8)uint64
*abi_route_bootstrap:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// verificationClass: uint8
	txna ApplicationArgs 9
	dup
	len
	intc 3 // 1
	==

	// argument 0 (verificationClass) for bootstrap must be a uint8
	assert
	btoi

	// currentPrice: uint64
	txna ApplicationArgs 8
	btoi

	// priceMax: uint64
	txna ApplicationArgs 7
	btoi

	// priceMin: uint64
	txna ApplicationArgs 6
	btoi

	// fee: uint64
	txna ApplicationArgs 5
	btoi

	// txSeed: pay
	txn GroupIndex
	intc 3 // 1
	-
	dup
	gtxns TypeEnum
	intc 3 //  pay
	==

	// argument 5 (txSeed) for bootstrap must be a pay transaction
	assert

	// appBiatecPoolProvider: uint64
	txna ApplicationArgs 4
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 3
	btoi

	// assetB: uint64
	txna ApplicationArgs 2
	btoi

	// assetA: uint64
	txna ApplicationArgs 1
	btoi

	// execute bootstrap(uint64,uint64,uint64,uint64,pay,uint64,uint64,uint64,uint64,uint8)uint64
	callsub bootstrap
	itob
	concat
	log
	intc 3 // 1
	return

// bootstrap(assetA: AssetID, assetB: AssetID, appBiatecConfigProvider: AppID, appBiatecPoolProvider: AppID, txSeed: PayTxn, fee: uint64, priceMin: uint64, priceMax: uint64, currentPrice: uint64, verificationClass: uint8): uint64
bootstrap:
	proto 10 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts\BiatecClammPool.algo.ts:144
	// verifyPayTxn(txSeed, { receiver: this.app.address, amount: { greaterThanEqualTo: 300_000 } })
	// verify receiver
	frame_dig -5 // txSeed: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"txSeed","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -5 // txSeed: PayTxn
	gtxns Amount
	pushint 300_000
	>=

	// transaction verification failed: {"txn":"txSeed","field":"amount","condition":"greaterThanEqualTo","expected":">=300_000"}
	assert

	// contracts\BiatecClammPool.algo.ts:145
	// assert(this.priceMax.value === 0, 'ERR_PRICE_MAX')
	bytec 14 //  "pMax"
	app_global_get
	intc 2 // 0
	==

	// ERR_PRICE_MAX
	assert

	// contracts\BiatecClammPool.algo.ts:146
	// assert(this.txn.sender === this.app.creator, 'ERR_SENDER')
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==

	// ERR_SENDER
	assert

	// contracts\BiatecClammPool.algo.ts:147
	// assert(priceMax > 0, 'ERR_PRICE')
	frame_dig -8 // priceMax: uint64
	intc 2 // 0
	>

	// ERR_PRICE
	assert

	// contracts\BiatecClammPool.algo.ts:148
	// assert(assetA < assetB)
	frame_dig -1 // assetA: AssetID
	frame_dig -2 // assetB: AssetID
	<
	assert

	// contracts\BiatecClammPool.algo.ts:149
	// assert(fee <= SCALE / 10)
	frame_dig -6 // fee: uint64
	pushint 100000000
	<=
	assert

	// contracts\BiatecClammPool.algo.ts:150
	// assert(verificationClass <= 4)
	frame_dig -10 // verificationClass: uint8
	intc 9 // 4
	<=
	assert

	// contracts\BiatecClammPool.algo.ts:151
	// assert(!this.currentPrice.exists)
	txna Applications 0
	bytec 18 //  "price"
	app_global_get_ex
	swap
	pop
	!
	assert

	// *if0_condition
	// contracts\BiatecClammPool.algo.ts:152
	// assetA.id > 0
	frame_dig -1 // assetA: AssetID
	intc 2 // 0
	>
	bz *if0_end

	// *if0_consequent
	// contracts\BiatecClammPool.algo.ts:153
	// assert(assetA.decimals <= SCALE_DECIMALS)
	frame_dig -1 // assetA: AssetID
	asset_params_get AssetDecimals
	pop
	intc 8 // 9
	<=
	assert

*if0_end:
	// contracts\BiatecClammPool.algo.ts:155
	// assert(assetB.decimals <= SCALE_DECIMALS)
	frame_dig -2 // assetB: AssetID
	asset_params_get AssetDecimals
	pop
	intc 8 // 9
	<=
	assert

	// contracts\BiatecClammPool.algo.ts:157
	// assert(this.fee.value <= 0, 'ERR_FEE')
	bytec 17 //  "f"
	app_global_get
	intc 2 // 0
	<=

	// ERR_FEE
	assert

	// contracts\BiatecClammPool.algo.ts:159
	// poolProviderFromConfig = appBiatecConfigProvider.globalState('p') as AppID
	frame_dig -3 // appBiatecConfigProvider: AppID
	bytec 34 //  "p"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('p')
	assert
	frame_bury 0 // poolProviderFromConfig: uint64

	// contracts\BiatecClammPool.algo.ts:160
	// assert(
	//       appBiatecPoolProvider === poolProviderFromConfig,
	//       'ERR_CONFIG' // 'appBiatecPoolProvider must match to the config in appBiatecConfigProvider'
	//     )
	frame_dig -4 // appBiatecPoolProvider: AppID
	frame_dig 0 // poolProviderFromConfig: uint64
	==

	// ERR_CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:164
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -3 // appBiatecConfigProvider: AppID
	bytec 21 //  "s"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('s')
	assert
	frame_bury 1 // paused: uint64

	// contracts\BiatecClammPool.algo.ts:165
	// assert(paused === 0, 'ERR_PAUSED')
	frame_dig 1 // paused: uint64
	intc 2 // 0
	==

	// ERR_PAUSED
	assert

	// contracts\BiatecClammPool.algo.ts:167
	// this.appBiatecConfigProvider.value = appBiatecConfigProvider
	bytec 15 //  "bc"
	frame_dig -3 // appBiatecConfigProvider: AppID
	app_global_put

	// contracts\BiatecClammPool.algo.ts:169
	// this.priceMin.value = priceMin
	bytec 12 //  "pMin"
	frame_dig -7 // priceMin: uint64
	app_global_put

	// contracts\BiatecClammPool.algo.ts:170
	// this.priceMax.value = priceMax
	bytec 14 //  "pMax"
	frame_dig -8 // priceMax: uint64
	app_global_put

	// contracts\BiatecClammPool.algo.ts:171
	// this.priceMinSqrt.value = sqrt((priceMin as uint256) * s)
	bytec 10 //  "pMinS"
	frame_dig -7 // priceMin: uint64
	itob
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	bsqrt
	dup
	bitlen
	intc 1 // 256
	<=

	// sqrt((priceMin as uint256) * s) overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:172
	// this.priceMaxSqrt.value = sqrt((priceMax as uint256) * s)
	bytec 11 //  "pMaxS"
	frame_dig -8 // priceMax: uint64
	itob
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	bsqrt
	dup
	bitlen
	intc 1 // 256
	<=

	// sqrt((priceMax as uint256) * s) overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:173
	// this.assetABalance.value = <uint256>0
	bytec 3 //  "ab"
	bytec 6 // 0x0000000000000000000000000000000000000000000000000000000000000000
	app_global_put

	// contracts\BiatecClammPool.algo.ts:174
	// this.assetBBalance.value = <uint256>0
	bytec 4 //  "bb"
	bytec 6 // 0x0000000000000000000000000000000000000000000000000000000000000000
	app_global_put

	// contracts\BiatecClammPool.algo.ts:175
	// this.currentPrice.value = currentPrice
	bytec 18 //  "price"
	frame_dig -9 // currentPrice: uint64
	app_global_put

	// contracts\BiatecClammPool.algo.ts:177
	// this.assetA.value = assetA.id
	bytec 23 //  "a"
	frame_dig -1 // assetA: AssetID
	app_global_put

	// contracts\BiatecClammPool.algo.ts:178
	// this.assetB.value = assetB.id
	bytec 24 //  "b"
	frame_dig -2 // assetB: AssetID
	app_global_put

	// contracts\BiatecClammPool.algo.ts:179
	// this.assetLp.value = this.doCreatePoolToken(assetA, assetB).id
	bytec 20 //  "lp"
	frame_dig -2 // assetB: AssetID
	frame_dig -1 // assetA: AssetID
	callsub doCreatePoolToken
	app_global_put

	// contracts\BiatecClammPool.algo.ts:180
	// this.fee.value = fee
	bytec 17 //  "f"
	frame_dig -6 // fee: uint64
	app_global_put

	// contracts\BiatecClammPool.algo.ts:181
	// this.doOptIn(assetA)
	frame_dig -1 // assetA: AssetID
	callsub doOptIn

	// contracts\BiatecClammPool.algo.ts:182
	// this.doOptIn(assetB)
	frame_dig -2 // assetB: AssetID
	callsub doOptIn

	// contracts\BiatecClammPool.algo.ts:184
	// sendMethodCall<[AppID, AssetID, AssetID, uint8], void>({
	//       name: 'registerPool',
	//       methodArgs: [globals.currentApplicationID, assetA, assetB, verificationClass],
	//       fee: 0,
	//       applicationID: appBiatecPoolProvider,
	//     })
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	pushbytes 0xd14ca904 // method "registerPool(uint64,uint64,uint64,uint8)void"
	itxn_field ApplicationArgs

	// contracts\BiatecClammPool.algo.ts:186
	// methodArgs: [globals.currentApplicationID, assetA, assetB, verificationClass]
	global CurrentApplicationID
	itob
	itxn_field ApplicationArgs
	frame_dig -1 // assetA: AssetID
	itob
	itxn_field ApplicationArgs
	frame_dig -2 // assetB: AssetID
	itob
	itxn_field ApplicationArgs
	frame_dig -10 // verificationClass: uint8
	itob
	extract 7 1
	itxn_field ApplicationArgs

	// contracts\BiatecClammPool.algo.ts:187
	// fee: 0
	intc 2 // 0
	itxn_field Fee

	// contracts\BiatecClammPool.algo.ts:188
	// applicationID: appBiatecPoolProvider
	frame_dig -4 // appBiatecPoolProvider: AppID
	itxn_field ApplicationID

	// Submit inner transaction
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:191
	// return this.assetLp.value;
	bytec 20 //  "lp"
	app_global_get

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// doAxfer(receiver: Address, asset: AssetID, amount: uint64): void
doAxfer:
	proto 3 0

	// *if1_condition
	// contracts\BiatecClammPool.algo.ts:195
	// asset.id === 0
	frame_dig -2 // asset: AssetID
	intc 2 // 0
	==
	bz *if1_else

	// *if1_consequent
	// contracts\BiatecClammPool.algo.ts:196
	// sendPayment({
	//         receiver: receiver,
	//         amount: amount,
	//         fee: 0,
	//       })
	itxn_begin
	intc 3 //  pay
	itxn_field TypeEnum

	// contracts\BiatecClammPool.algo.ts:197
	// receiver: receiver
	frame_dig -1 // receiver: Address
	itxn_field Receiver

	// contracts\BiatecClammPool.algo.ts:198
	// amount: amount
	frame_dig -3 // amount: uint64
	itxn_field Amount

	// contracts\BiatecClammPool.algo.ts:199
	// fee: 0
	intc 2 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if1_end

*if1_else:
	// contracts\BiatecClammPool.algo.ts:202
	// sendAssetTransfer({
	//         assetReceiver: receiver,
	//         xferAsset: asset,
	//         assetAmount: amount,
	//         fee: 0,
	//       })
	itxn_begin
	intc 9 //  axfer
	itxn_field TypeEnum

	// contracts\BiatecClammPool.algo.ts:203
	// assetReceiver: receiver
	frame_dig -1 // receiver: Address
	itxn_field AssetReceiver

	// contracts\BiatecClammPool.algo.ts:204
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// contracts\BiatecClammPool.algo.ts:205
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// contracts\BiatecClammPool.algo.ts:206
	// fee: 0
	intc 2 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if1_end:
	retsub

// doOptIn(asset: AssetID): void
doOptIn:
	proto 1 0

	// *if2_condition
	// contracts\BiatecClammPool.algo.ts:212
	// asset.id > 0
	frame_dig -1 // asset: AssetID
	intc 2 // 0
	>
	bz *if2_end

	// *if2_consequent
	// contracts\BiatecClammPool.algo.ts:214
	// this.doAxfer(this.app.address, asset, 0)
	intc 2 // 0
	frame_dig -1 // asset: AssetID
	global CurrentApplicationAddress
	callsub doAxfer

*if2_end:
	retsub

// doCreatePoolToken(assetA: AssetID, assetB: AssetID): AssetID
doCreatePoolToken:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts\BiatecClammPool.algo.ts:219
	// nameAssetA = 'ALGO'
	pushbytes 0x414c474f // "ALGO"
	frame_bury 0 // nameAssetA: byte[]

	// *if3_condition
	// contracts\BiatecClammPool.algo.ts:220
	// assetA.id > 0
	frame_dig -1 // assetA: AssetID
	intc 2 // 0
	>
	bz *if3_end

	// *if3_consequent
	// contracts\BiatecClammPool.algo.ts:221
	// nameAssetA = assetA.unitName
	frame_dig -1 // assetA: AssetID
	asset_params_get AssetUnitName
	pop
	frame_bury 0 // nameAssetA: byte[]

*if3_end:
	// contracts\BiatecClammPool.algo.ts:224
	// name =
	//       'B-' + itob(this.verificationClass.value) + '-' + nameAssetA + '-' + assetB.unitName + '-' + itob(this.fee.value)
	pushbytes 0x422d // "B-"
	bytec 25 //  "c"
	app_global_get
	itob
	concat
	bytec 26 //  "-"
	concat
	frame_dig 0 // nameAssetA: byte[]
	concat
	bytec 26 //  "-"
	concat
	frame_dig -2 // assetB: AssetID
	asset_params_get AssetUnitName
	pop
	concat
	bytec 26 //  "-"
	concat
	bytec 17 //  "f"
	app_global_get
	itob
	concat
	frame_bury 1 // name: byte[]

	// contracts\BiatecClammPool.algo.ts:227
	// return sendAssetCreation({
	//       configAssetName: name,
	//       configAssetUnitName: 'BLP', // Biatec LP token
	//       // eslint-disable-next-line no-loss-of-precision
	//       configAssetTotal: Uint<64>(TOTAL_SUPPLY),
	//       configAssetDecimals: LP_TOKEN_DECIMALS,
	//       configAssetManager: this.app.address,
	//       configAssetReserve: this.app.address,
	//     });
	itxn_begin
	intc 11 //  acfg
	itxn_field TypeEnum

	// contracts\BiatecClammPool.algo.ts:228
	// configAssetName: name
	frame_dig 1 // name: byte[]
	itxn_field ConfigAssetName

	// contracts\BiatecClammPool.algo.ts:229
	// configAssetUnitName: 'BLP'
	pushbytes 0x424c50 // "BLP"
	itxn_field ConfigAssetUnitName

	// contracts\BiatecClammPool.algo.ts:231
	// configAssetTotal: Uint<64>(TOTAL_SUPPLY)
	pushint 18000000000000000000
	itxn_field ConfigAssetTotal

	// contracts\BiatecClammPool.algo.ts:232
	// configAssetDecimals: LP_TOKEN_DECIMALS
	intc 5 // 6
	itxn_field ConfigAssetDecimals

	// contracts\BiatecClammPool.algo.ts:233
	// configAssetManager: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetManager

	// contracts\BiatecClammPool.algo.ts:234
	// configAssetReserve: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetReserve

	// Fee field not set, defaulting to 0
	intc 2 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn CreatedAssetID

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// checkAssetsAB(assetA: AssetID, assetB: AssetID): void
checkAssetsAB:
	proto 2 0

	// contracts\BiatecClammPool.algo.ts:239
	// assert(assetA.id === this.assetA.value, 'assetA does not match')
	frame_dig -1 // assetA: AssetID
	bytec 23 //  "a"
	app_global_get
	==

	// assetA does not match
	assert

	// contracts\BiatecClammPool.algo.ts:240
	// assert(assetB.id === this.assetB.value, 'assetB does not match')
	frame_dig -2 // assetB: AssetID
	bytec 24 //  "b"
	app_global_get
	==

	// assetB does not match
	assert
	retsub

// checkAssets(assetA: AssetID, assetB: AssetID, assetLp: AssetID): void
checkAssets:
	proto 3 0

	// contracts\BiatecClammPool.algo.ts:244
	// this.checkAssetsAB(assetA, assetB)
	frame_dig -2 // assetB: AssetID
	frame_dig -1 // assetA: AssetID
	callsub checkAssetsAB

	// contracts\BiatecClammPool.algo.ts:245
	// assert(assetLp.id === this.assetLp.value, 'assetLp does not match')
	frame_dig -3 // assetLp: AssetID
	bytec 20 //  "lp"
	app_global_get
	==

	// assetLp does not match
	assert
	retsub

// addLiquidity(uint64,uint64,txn,txn,uint64,uint64,uint64)uint64
*abi_route_addLiquidity:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// assetLp: uint64
	txna ApplicationArgs 5
	btoi

	// assetB: uint64
	txna ApplicationArgs 4
	btoi

	// assetA: uint64
	txna ApplicationArgs 3
	btoi

	// txAssetBDeposit: txn
	txn GroupIndex
	intc 3 // 1
	-

	// txAssetADeposit: txn
	txn GroupIndex
	intc 12 // 2
	-

	// appBiatecIdentityProvider: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute addLiquidity(uint64,uint64,txn,txn,uint64,uint64,uint64)uint64
	callsub addLiquidity
	itob
	concat
	log
	intc 3 // 1
	return

// addLiquidity(appBiatecConfigProvider: AppID, appBiatecIdentityProvider: AppID, txAssetADeposit: Txn, txAssetBDeposit: Txn, assetA: AssetID, assetB: AssetID, assetLp: AssetID): uint64
addLiquidity:
	proto 7 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 23

	// contracts\BiatecClammPool.algo.ts:257
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 2 // 0
	itxn_field Fee
	bytec 5 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 10 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:258
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 2 // 0
	itxn_field Fee
	bytec 5 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 10 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// well formed mint
	// contracts\BiatecClammPool.algo.ts:260
	// this.checkAssets(assetA, assetB, assetLp)
	frame_dig -7 // assetLp: AssetID
	frame_dig -6 // assetB: AssetID
	frame_dig -5 // assetA: AssetID
	callsub checkAssets

	// contracts\BiatecClammPool.algo.ts:262
	// this.verifyIdentity(appBiatecConfigProvider, appBiatecIdentityProvider)
	frame_dig -2 // appBiatecIdentityProvider: AppID
	frame_dig -1 // appBiatecConfigProvider: AppID
	callsub verifyIdentity

	// contracts\BiatecClammPool.algo.ts:264
	// assetADecimals = 6
	intc 5 // 6
	frame_bury 0 // assetADecimals: uint64

	// *if4_condition
	// contracts\BiatecClammPool.algo.ts:265
	// assetA.id > 0
	frame_dig -5 // assetA: AssetID
	intc 2 // 0
	>
	bz *if4_end

	// *if4_consequent
	// contracts\BiatecClammPool.algo.ts:265
	// assetADecimals = assetA.decimals
	frame_dig -5 // assetA: AssetID
	asset_params_get AssetDecimals
	pop
	frame_bury 0 // assetADecimals: uint64

*if4_end:
	// contracts\BiatecClammPool.algo.ts:267
	// assetADelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetADecimals)) as uint256
	intc 7 // 10
	intc 8 // 9
	frame_dig 0 // assetADecimals: uint64
	-
	exp
	itob
	frame_bury 1 // assetADelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:269
	// assetBDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetB.decimals)) as uint256
	intc 7 // 10
	intc 8 // 9
	frame_dig -6 // assetB: AssetID
	asset_params_get AssetDecimals
	pop
	-
	exp
	itob
	frame_bury 2 // assetBDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:271
	// assetLpDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - LP_TOKEN_DECIMALS)) as uint256
	intc 7 // 10
	intc 11 // 3
	exp
	itob
	frame_bury 3 // assetLpDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:273
	// aDepositInBaseScale = (txAssetADeposit.assetAmount as uint256) * assetADelicmalScale2Scale
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	itob
	frame_dig 1 // assetADelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 4 // aDepositInBaseScale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:274
	// bDepositInBaseScale = (txAssetBDeposit.assetAmount as uint256) * assetBDelicmalScale2Scale
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	itob
	frame_dig 2 // assetBDelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 5 // bDepositInBaseScale: unsafe uint256

	// *if5_condition
	// contracts\BiatecClammPool.algo.ts:276
	// assetA.id > 0
	frame_dig -5 // assetA: AssetID
	intc 2 // 0
	>
	bz *if5_else

	// *if5_consequent
	// contracts\BiatecClammPool.algo.ts:277
	// assert(txAssetADeposit.typeEnum === TransactionType.AssetTransfer)
	frame_dig -3 // txAssetADeposit: Txn
	gtxns TypeEnum
	intc 9 //  axfer
	==
	assert
	b *if5_end

*if5_else:
	// contracts\BiatecClammPool.algo.ts:279
	// assert(txAssetADeposit.typeEnum === TransactionType.Payment)
	frame_dig -3 // txAssetADeposit: Txn
	gtxns TypeEnum
	intc 3 //  pay
	==
	assert

*if5_end:
	// *if6_condition
	// contracts\BiatecClammPool.algo.ts:282
	// txAssetADeposit.typeEnum === TransactionType.AssetTransfer
	frame_dig -3 // txAssetADeposit: Txn
	gtxns TypeEnum
	intc 9 //  axfer
	==
	bz *if6_elseif1_condition

	// *if6_consequent
	// contracts\BiatecClammPool.algo.ts:283
	// xfer = txAssetADeposit as AssetTransferTxn
	frame_dig -3 // txAssetADeposit: Txn
	dup
	gtxns TypeEnum
	intc 9 //  axfer
	==

	// failed to cast txAssetADeposit to axfer
	assert
	frame_bury 6 // xfer: axfer

	// contracts\BiatecClammPool.algo.ts:284
	// verifyAssetTransferTxn(xfer, {
	//         assetReceiver: this.app.address,
	//         xferAsset: assetA,
	//         assetAmount: { greaterThanEqualTo: 0 },
	//       })
	// verify axfer
	frame_dig 6 // xfer: axfer
	gtxns TypeEnum
	intc 9 //  axfer
	==

	// transaction verification failed: {"txn":"xfer","field":"typeEnum","expected":"axfer"}
	assert

	// verify assetReceiver
	frame_dig 6 // xfer: axfer
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"xfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig 6 // xfer: axfer
	gtxns XferAsset
	frame_dig -5 // assetA: AssetID
	==

	// transaction verification failed: {"txn":"xfer","field":"xferAsset","expected":"assetA"}
	assert

	// verify assetAmount
	frame_dig 6 // xfer: axfer
	gtxns AssetAmount
	intc 2 // 0
	>=

	// transaction verification failed: {"txn":"xfer","field":"assetAmount","condition":"greaterThanEqualTo","expected":">=0"}
	assert
	b *if6_end

*if6_elseif1_condition:
	// contracts\BiatecClammPool.algo.ts:289
	// txAssetADeposit.typeEnum === TransactionType.Payment
	frame_dig -3 // txAssetADeposit: Txn
	gtxns TypeEnum
	intc 3 //  pay
	==
	bz *if6_else

	// *if6_elseif1_consequent
	// contracts\BiatecClammPool.algo.ts:290
	// payTx = txAssetADeposit as PayTxn
	frame_dig -3 // txAssetADeposit: Txn
	dup
	gtxns TypeEnum
	intc 3 //  pay
	==

	// failed to cast txAssetADeposit to pay
	assert
	frame_bury 7 // payTx: pay

	// contracts\BiatecClammPool.algo.ts:291
	// verifyPayTxn(payTx, {
	//         receiver: this.app.address,
	//         amount: { greaterThanEqualTo: 0 },
	//       })
	// verify pay
	frame_dig 7 // payTx: pay
	gtxns TypeEnum
	intc 3 //  pay
	==

	// transaction verification failed: {"txn":"payTx","field":"typeEnum","expected":"pay"}
	assert

	// verify receiver
	frame_dig 7 // payTx: pay
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payTx","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig 7 // payTx: pay
	gtxns Amount
	intc 2 // 0
	>=

	// transaction verification failed: {"txn":"payTx","field":"amount","condition":"greaterThanEqualTo","expected":">=0"}
	assert
	b *if6_end

*if6_else:
	// contracts\BiatecClammPool.algo.ts:296
	// assert(false, 'Unsupported tx type of the asset A')
	intc 2 // 0

	// Unsupported tx type of the asset A
	assert

*if6_end:
	// *if7_condition
	// contracts\BiatecClammPool.algo.ts:299
	// txAssetBDeposit.typeEnum === TransactionType.AssetTransfer
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns TypeEnum
	intc 9 //  axfer
	==
	bz *if7_elseif1_condition

	// *if7_consequent
	// contracts\BiatecClammPool.algo.ts:300
	// xfer = txAssetBDeposit as AssetTransferTxn
	frame_dig -4 // txAssetBDeposit: Txn
	dup
	gtxns TypeEnum
	intc 9 //  axfer
	==

	// failed to cast txAssetBDeposit to axfer
	assert
	frame_bury 8 // xfer: axfer

	// contracts\BiatecClammPool.algo.ts:301
	// verifyAssetTransferTxn(xfer, {
	//         assetReceiver: this.app.address,
	//         xferAsset: assetB,
	//         assetAmount: { greaterThanEqualTo: 0 },
	//       })
	// verify axfer
	frame_dig 8 // xfer: axfer
	gtxns TypeEnum
	intc 9 //  axfer
	==

	// transaction verification failed: {"txn":"xfer","field":"typeEnum","expected":"axfer"}
	assert

	// verify assetReceiver
	frame_dig 8 // xfer: axfer
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"xfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig 8 // xfer: axfer
	gtxns XferAsset
	frame_dig -6 // assetB: AssetID
	==

	// transaction verification failed: {"txn":"xfer","field":"xferAsset","expected":"assetB"}
	assert

	// verify assetAmount
	frame_dig 8 // xfer: axfer
	gtxns AssetAmount
	intc 2 // 0
	>=

	// transaction verification failed: {"txn":"xfer","field":"assetAmount","condition":"greaterThanEqualTo","expected":">=0"}
	assert
	b *if7_end

*if7_elseif1_condition:
	// contracts\BiatecClammPool.algo.ts:306
	// txAssetBDeposit.typeEnum === TransactionType.Payment
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns TypeEnum
	intc 3 //  pay
	==
	bz *if7_else

	// *if7_elseif1_consequent
	// contracts\BiatecClammPool.algo.ts:307
	// payTx = txAssetBDeposit as PayTxn
	frame_dig -4 // txAssetBDeposit: Txn
	dup
	gtxns TypeEnum
	intc 3 //  pay
	==

	// failed to cast txAssetBDeposit to pay
	assert
	frame_bury 9 // payTx: pay

	// contracts\BiatecClammPool.algo.ts:308
	// verifyPayTxn(payTx, {
	//         receiver: this.app.address,
	//         amount: { greaterThanEqualTo: 0 },
	//       })
	// verify pay
	frame_dig 9 // payTx: pay
	gtxns TypeEnum
	intc 3 //  pay
	==

	// transaction verification failed: {"txn":"payTx","field":"typeEnum","expected":"pay"}
	assert

	// verify receiver
	frame_dig 9 // payTx: pay
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payTx","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig 9 // payTx: pay
	gtxns Amount
	intc 2 // 0
	>=

	// transaction verification failed: {"txn":"payTx","field":"amount","condition":"greaterThanEqualTo","expected":">=0"}
	assert
	b *if7_end

*if7_else:
	// contracts\BiatecClammPool.algo.ts:313
	// assert(false, 'Unsupported tx type of the asset B')
	intc 2 // 0

	// Unsupported tx type of the asset B
	assert

*if7_end:
	// *if8_condition
	// contracts\BiatecClammPool.algo.ts:318
	// this.priceMinSqrt.value === this.priceMaxSqrt.value
	bytec 10 //  "pMinS"
	app_global_get
	bytec 11 //  "pMaxS"
	app_global_get
	b==
	bz *if8_end

	// *if8_consequent
	// contracts\BiatecClammPool.algo.ts:319
	// return this.processAddLiqudity(aDepositInBaseScale, bDepositInBaseScale, assetLpDelicmalScale2Scale, assetLp);
	frame_dig -7 // assetLp: AssetID
	frame_dig 3 // assetLpDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// assetLpDelicmalScale2Scale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 5 // bDepositInBaseScale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// bDepositInBaseScale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 4 // aDepositInBaseScale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// aDepositInBaseScale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub processAddLiqudity
	b *addLiquidity*return

*if8_end:
	// *if9_condition
	// contracts\BiatecClammPool.algo.ts:324
	// this.assetABalance.value === <uint256>0 && this.assetBBalance.value === <uint256>0
	bytec 3 //  "ab"
	app_global_get
	bytec 6 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b==
	dup
	bz *skip_and0
	bytec 4 //  "bb"
	app_global_get
	bytec 6 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b==
	&&

*skip_and0:
	bz *if9_end

	// *if9_consequent
	// contracts\BiatecClammPool.algo.ts:329
	// ret = this.processAddLiqudity(
	//         aDepositInBaseScale,
	//         bDepositInBaseScale,
	//         assetLpDelicmalScale2Scale,
	//         assetLp
	//       )
	frame_dig -7 // assetLp: AssetID
	frame_dig 3 // assetLpDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// assetLpDelicmalScale2Scale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 5 // bDepositInBaseScale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// bDepositInBaseScale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 4 // aDepositInBaseScale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// aDepositInBaseScale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub processAddLiqudity
	frame_bury 10 // ret: uint64

	// contracts\BiatecClammPool.algo.ts:336
	// newPrice = this.calculatePrice(
	//         this.assetABalance.value, // assetAQuantity: uint256,
	//         this.assetBBalance.value, // assetBQuantity: uint256,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value, // priceMaxSqrt: uint256,
	//         this.Liqudity.value // liquidity: uint256
	//       )
	bytec 8 //  "L"
	app_global_get
	bytec 11 //  "pMaxS"
	app_global_get
	bytec 10 //  "pMinS"
	app_global_get
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculatePrice
	frame_bury 11 // newPrice: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:344
	// this.currentPrice.value = newPrice as uint64
	bytec 18 //  "price"
	frame_dig 11 // newPrice: unsafe uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// newPrice as uint64 overflowed 64 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	app_global_put

	// contracts\BiatecClammPool.algo.ts:345
	// return ret;
	frame_dig 10 // ret: uint64
	b *addLiquidity*return

*if9_end:
	// contracts\BiatecClammPool.algo.ts:352
	// a = this.calculateAssetADepositOnAssetBDeposit(
	//       aDepositInBaseScale,
	//       bDepositInBaseScale,
	//       this.assetABalance.value,
	//       this.assetBBalance.value
	//     )
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	frame_dig 5 // bDepositInBaseScale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// bDepositInBaseScale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 4 // aDepositInBaseScale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// aDepositInBaseScale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub calculateAssetADepositOnAssetBDeposit
	frame_bury 12 // a: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:359
	// b = this.calculateAssetBDepositOnAssetADeposit(
	//       aDepositInBaseScale,
	//       bDepositInBaseScale,
	//       this.assetABalance.value,
	//       this.assetBBalance.value
	//     )
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	frame_dig 5 // bDepositInBaseScale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// bDepositInBaseScale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 4 // aDepositInBaseScale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// aDepositInBaseScale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub calculateAssetBDepositOnAssetADeposit
	frame_bury 13 // b: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:365
	// expectedADepositB64 = (a / assetADelicmalScale2Scale) as uint64
	frame_dig 12 // a: unsafe uint256
	frame_dig 1 // assetADelicmalScale2Scale: unsafe uint256
	b/
	dup
	bitlen
	intc 4 // 64
	<=

	// (a / assetADelicmalScale2Scale) as uint64 overflowed 64 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 14 // expectedADepositB64: uint64

	// contracts\BiatecClammPool.algo.ts:366
	// expectedBDepositB64 = (b / assetBDelicmalScale2Scale) as uint64
	frame_dig 13 // b: unsafe uint256
	frame_dig 2 // assetBDelicmalScale2Scale: unsafe uint256
	b/
	dup
	bitlen
	intc 4 // 64
	<=

	// (b / assetBDelicmalScale2Scale) as uint64 overflowed 64 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 15 // expectedBDepositB64: uint64

	// *if10_condition
	// contracts\BiatecClammPool.algo.ts:368
	// expectedADepositB64 > txAssetADeposit.assetAmount
	frame_dig 14 // expectedADepositB64: uint64
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	>
	bz *if10_end

	// *if10_consequent
	// *if11_condition
	// contracts\BiatecClammPool.algo.ts:369
	// expectedBDepositB64 > txAssetBDeposit.assetAmount
	frame_dig 15 // expectedBDepositB64: uint64
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	>
	bz *if11_end

	// *if11_consequent
	// contracts\BiatecClammPool.algo.ts:370
	// assert(false, 'Dominant is asset B')
	intc 2 // 0

	// Dominant is asset B
	assert

*if11_end:
	// *if12_condition
	// contracts\BiatecClammPool.algo.ts:372
	// txAssetBDeposit.assetAmount - expectedBDepositB64 > 0
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	frame_dig 15 // expectedBDepositB64: uint64
	-
	intc 2 // 0
	>
	bz *if12_end

	// *if12_consequent
	// contracts\BiatecClammPool.algo.ts:374
	// this.doAxfer(this.txn.sender, assetB, txAssetBDeposit.assetAmount - expectedBDepositB64)
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	frame_dig 15 // expectedBDepositB64: uint64
	-
	frame_dig -6 // assetB: AssetID
	txn Sender
	callsub doAxfer

*if12_end:
	// contracts\BiatecClammPool.algo.ts:376
	// realAssetADeposit = aDepositInBaseScale
	frame_dig 4 // aDepositInBaseScale: unsafe uint256
	frame_bury 16 // realAssetADeposit: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:377
	// realAssetBDeposit = (expectedBDepositB64 as uint256) * assetBDelicmalScale2Scale
	frame_dig 15 // expectedBDepositB64: uint64
	itob
	frame_dig 2 // assetBDelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 17 // realAssetBDeposit: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:378
	// return this.processAddLiqudity(realAssetADeposit, realAssetBDeposit, assetLpDelicmalScale2Scale, assetLp);
	frame_dig -7 // assetLp: AssetID
	frame_dig 3 // assetLpDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// assetLpDelicmalScale2Scale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 17 // realAssetBDeposit: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// realAssetBDeposit overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 16 // realAssetADeposit: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// realAssetADeposit overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub processAddLiqudity
	b *addLiquidity*return

*if10_end:
	// *if13_condition
	// contracts\BiatecClammPool.algo.ts:381
	// expectedBDepositB64 > txAssetBDeposit.assetAmount
	frame_dig 15 // expectedBDepositB64: uint64
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	>
	bz *if13_end

	// *if13_consequent
	// *if14_condition
	// contracts\BiatecClammPool.algo.ts:382
	// expectedADepositB64 > txAssetADeposit.assetAmount
	frame_dig 14 // expectedADepositB64: uint64
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	>
	bz *if14_end

	// *if14_consequent
	// contracts\BiatecClammPool.algo.ts:383
	// assert(false, 'Dominant is asset A')
	intc 2 // 0

	// Dominant is asset A
	assert

*if14_end:
	// *if15_condition
	// contracts\BiatecClammPool.algo.ts:385
	// txAssetADeposit.assetAmount - expectedADepositB64 > 0
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	frame_dig 14 // expectedADepositB64: uint64
	-
	intc 2 // 0
	>
	bz *if15_end

	// *if15_consequent
	// contracts\BiatecClammPool.algo.ts:387
	// this.doAxfer(this.txn.sender, assetB, txAssetADeposit.assetAmount - expectedADepositB64)
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	frame_dig 14 // expectedADepositB64: uint64
	-
	frame_dig -6 // assetB: AssetID
	txn Sender
	callsub doAxfer

*if15_end:
	// contracts\BiatecClammPool.algo.ts:389
	// realAssetADeposit = (expectedADepositB64 as uint256) * assetADelicmalScale2Scale
	frame_dig 14 // expectedADepositB64: uint64
	itob
	frame_dig 1 // assetADelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 18 // realAssetADeposit: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:390
	// realAssetBDeposit = bDepositInBaseScale
	frame_dig 5 // bDepositInBaseScale: unsafe uint256
	frame_bury 19 // realAssetBDeposit: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:391
	// return this.processAddLiqudity(realAssetADeposit, realAssetBDeposit, assetLpDelicmalScale2Scale, assetLp);
	frame_dig -7 // assetLp: AssetID
	frame_dig 3 // assetLpDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// assetLpDelicmalScale2Scale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 19 // realAssetBDeposit: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// realAssetBDeposit overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 18 // realAssetADeposit: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// realAssetADeposit overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub processAddLiqudity
	b *addLiquidity*return

*if13_end:
	// *if16_condition
	// contracts\BiatecClammPool.algo.ts:393
	// expectedADepositB64 === txAssetADeposit.assetAmount && expectedBDepositB64 === txAssetBDeposit.assetAmount
	frame_dig 14 // expectedADepositB64: uint64
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	==
	dup
	bz *skip_and1
	frame_dig 15 // expectedBDepositB64: uint64
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	==
	&&

*skip_and1:
	bz *if16_end

	// *if16_consequent
	// contracts\BiatecClammPool.algo.ts:394
	// realAssetADeposit = aDepositInBaseScale
	frame_dig 4 // aDepositInBaseScale: unsafe uint256
	frame_bury 20 // realAssetADeposit: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:395
	// realAssetBDeposit = bDepositInBaseScale
	frame_dig 5 // bDepositInBaseScale: unsafe uint256
	frame_bury 21 // realAssetBDeposit: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:396
	// return this.processAddLiqudity(realAssetADeposit, realAssetBDeposit, assetLpDelicmalScale2Scale, assetLp);
	frame_dig -7 // assetLp: AssetID
	frame_dig 3 // assetLpDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// assetLpDelicmalScale2Scale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 21 // realAssetBDeposit: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// realAssetBDeposit overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 20 // realAssetADeposit: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// realAssetADeposit overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub processAddLiqudity
	b *addLiquidity*return

*if16_end:
	// *if17_condition
	// contracts\BiatecClammPool.algo.ts:399
	// expectedADepositB64 === txAssetADeposit.assetAmount && expectedBDepositB64 === txAssetBDeposit.assetAmount
	frame_dig 14 // expectedADepositB64: uint64
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	==
	dup
	bz *skip_and2
	frame_dig 15 // expectedBDepositB64: uint64
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	==
	&&

*skip_and2:
	bz *if17_end

	// *if17_consequent
	// contracts\BiatecClammPool.algo.ts:400
	// realAssetADeposit = aDepositInBaseScale
	frame_dig 4 // aDepositInBaseScale: unsafe uint256
	frame_bury 22 // realAssetADeposit: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:401
	// realAssetBDeposit = bDepositInBaseScale
	frame_dig 5 // bDepositInBaseScale: unsafe uint256
	frame_bury 23 // realAssetBDeposit: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:402
	// return this.processAddLiqudity(realAssetADeposit, realAssetBDeposit, assetLpDelicmalScale2Scale, assetLp);
	frame_dig -7 // assetLp: AssetID
	frame_dig 3 // assetLpDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// assetLpDelicmalScale2Scale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 23 // realAssetBDeposit: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// realAssetBDeposit overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 22 // realAssetADeposit: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// realAssetADeposit overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub processAddLiqudity
	b *addLiquidity*return

*if17_end:
	// *if18_condition
	// contracts\BiatecClammPool.algo.ts:405
	// expectedADepositB64 === 0 && expectedBDepositB64 === 0
	frame_dig 14 // expectedADepositB64: uint64
	intc 2 // 0
	==
	dup
	bz *skip_and3
	frame_dig 15 // expectedBDepositB64: uint64
	intc 2 // 0
	==
	&&

*skip_and3:
	bz *if18_end

	// *if18_consequent
	// *if19_condition
	// contracts\BiatecClammPool.algo.ts:407
	// txAssetADeposit.assetAmount > 0
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	intc 2 // 0
	>
	bz *if19_end

	// *if19_consequent
	// contracts\BiatecClammPool.algo.ts:408
	// this.doAxfer(this.txn.sender, assetA, txAssetADeposit.assetAmount)
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	frame_dig -5 // assetA: AssetID
	txn Sender
	callsub doAxfer

*if19_end:
	// *if20_condition
	// contracts\BiatecClammPool.algo.ts:410
	// txAssetBDeposit.assetAmount > 0
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	intc 2 // 0
	>
	bz *if20_end

	// *if20_consequent
	// contracts\BiatecClammPool.algo.ts:411
	// this.doAxfer(this.txn.sender, assetB, txAssetBDeposit.assetAmount)
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	frame_dig -6 // assetB: AssetID
	txn Sender
	callsub doAxfer

*if20_end:
	// contracts\BiatecClammPool.algo.ts:413
	// return 0;
	intc 2 // 0
	b *addLiquidity*return

*if18_end:
	// contracts\BiatecClammPool.algo.ts:415
	// assert(false, 'failed to calculate exact liqudidity')
	intc 2 // 0

	// failed to calculate exact liqudidity
	assert

	// contracts\BiatecClammPool.algo.ts:416
	// return expectedBDepositB64;
	frame_dig 15 // expectedBDepositB64: uint64

*addLiquidity*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 23
	retsub

// processAddLiqudity(realAssetADeposit: uint256, realAssetBDeposit: uint256, assetLpDelicmalScale2Scale: uint256, assetLp: AssetID): uint64
//
// This method is used in addLiquidity to process the liquidity addition from calculated values
// @param realAssetADeposit Real asset a deposit
// @param realAssetBDeposit Real asset b deposit
// @param assetLpDelicmalScale2Scale LP decimal scale
// @param assetLp LP Asset
// @returns LP Token quantity distributed
processAddLiqudity:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 8

	// contracts\BiatecClammPool.algo.ts:433
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 2 // 0
	itxn_field Fee
	bytec 5 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 10 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:435
	// this.assetABalance.value = this.assetABalance.value + realAssetADeposit
	bytec 3 //  "ab"
	dup
	app_global_get
	frame_dig -1 // realAssetADeposit: uint256
	b+
	dup
	bitlen
	intc 1 // 256
	<=

	// this.assetABalance.value + realAssetADeposit overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:436
	// this.assetBBalance.value = this.assetBBalance.value + realAssetBDeposit
	bytec 4 //  "bb"
	dup
	app_global_get
	frame_dig -2 // realAssetBDeposit: uint256
	b+
	dup
	bitlen
	intc 1 // 256
	<=

	// this.assetBBalance.value + realAssetBDeposit overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:439
	// x = this.assetABalance.value
	bytec 3 //  "ab"
	app_global_get
	frame_bury 0 // x: uint256

	// contracts\BiatecClammPool.algo.ts:440
	// y = this.assetBBalance.value
	bytec 4 //  "bb"
	app_global_get
	frame_bury 1 // y: uint256

	// contracts\BiatecClammPool.algo.ts:441
	// priceMin = this.priceMin.value as uint256
	bytec 12 //  "pMin"
	app_global_get
	itob
	frame_bury 2 // priceMin: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:442
	// priceMax = this.priceMax.value as uint256
	bytec 14 //  "pMax"
	app_global_get
	itob
	frame_bury 3 // priceMax: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:443
	// priceMinSqrt = this.priceMinSqrt.value
	bytec 10 //  "pMinS"
	app_global_get
	frame_bury 4 // priceMinSqrt: uint256

	// contracts\BiatecClammPool.algo.ts:444
	// priceMaxSqrt = this.priceMaxSqrt.value
	bytec 11 //  "pMaxS"
	app_global_get
	frame_bury 5 // priceMaxSqrt: uint256

	// contracts\BiatecClammPool.algo.ts:445
	// newLiqudity = <uint256>0
	bytec 6 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 6 // newLiqudity: unsafe uint256

	// *if21_condition
	// contracts\BiatecClammPool.algo.ts:446
	// priceMin === priceMax
	frame_dig 2 // priceMin: unsafe uint256
	frame_dig 3 // priceMax: unsafe uint256
	b==
	bz *if21_else

	// *if21_consequent
	// contracts\BiatecClammPool.algo.ts:447
	// newLiqudity = this.calculateLiquidityFlatPrice(x, y, priceMin)
	frame_dig 2 // priceMin: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// priceMin overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 1 // y: uint256
	frame_dig 0 // x: uint256
	callsub calculateLiquidityFlatPrice
	frame_bury 6 // newLiqudity: unsafe uint256
	b *if21_end

*if21_else:
	// contracts\BiatecClammPool.algo.ts:449
	// D_SQRT = this.calculateLiquidityD(x, y, priceMin, priceMax, priceMinSqrt, priceMaxSqrt)
	frame_dig 5 // priceMaxSqrt: uint256
	frame_dig 4 // priceMinSqrt: uint256
	frame_dig 3 // priceMax: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// priceMax overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 2 // priceMin: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// priceMin overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 1 // y: uint256
	frame_dig 0 // x: uint256
	callsub calculateLiquidityD
	frame_bury 7 // D_SQRT: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:450
	// newLiqudity = this.calculateLiquidityWithD(x, y, priceMinSqrt, priceMaxSqrt, D_SQRT)
	frame_dig 7 // D_SQRT: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// D_SQRT overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 5 // priceMaxSqrt: uint256
	frame_dig 4 // priceMinSqrt: uint256
	frame_dig 1 // y: uint256
	frame_dig 0 // x: uint256
	callsub calculateLiquidityWithD
	frame_bury 6 // newLiqudity: unsafe uint256

*if21_end:
	// contracts\BiatecClammPool.algo.ts:453
	// lpTokensToSend = ((newLiqudity - this.Liqudity.value) / assetLpDelicmalScale2Scale) as uint64
	frame_dig 6 // newLiqudity: unsafe uint256
	bytec 8 //  "L"
	app_global_get
	b-
	frame_dig -3 // assetLpDelicmalScale2Scale: uint256
	b/
	dup
	bitlen
	intc 4 // 64
	<=

	// ((newLiqudity - this.Liqudity.value) / assetLpDelicmalScale2Scale) as uint64 overflowed 64 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 8 // lpTokensToSend: uint64

	// contracts\BiatecClammPool.algo.ts:455
	// this.Liqudity.value = newLiqudity
	bytec 8 //  "L"
	frame_dig 6 // newLiqudity: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// newLiqudity overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:457
	// this.doAxfer(this.txn.sender, assetLp, lpTokensToSend)
	frame_dig 8 // lpTokensToSend: uint64
	frame_dig -4 // assetLp: AssetID
	txn Sender
	callsub doAxfer

	// contracts\BiatecClammPool.algo.ts:463
	// assert(lpTokensToSend > 0, 'LP-ZERO-ERR')
	frame_dig 8 // lpTokensToSend: uint64
	intc 2 // 0
	>

	// LP-ZERO-ERR
	assert

	// contracts\BiatecClammPool.algo.ts:464
	// return lpTokensToSend as uint64;
	frame_dig 8 // lpTokensToSend: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 8
	retsub

// removeLiquidity(uint64,uint64,axfer,uint64,uint64,uint64)uint256
*abi_route_removeLiquidity:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// assetLp: uint64
	txna ApplicationArgs 5
	btoi

	// assetB: uint64
	txna ApplicationArgs 4
	btoi

	// assetA: uint64
	txna ApplicationArgs 3
	btoi

	// txLpXfer: axfer
	txn GroupIndex
	intc 3 // 1
	-
	dup
	gtxns TypeEnum
	intc 9 //  axfer
	==

	// argument 3 (txLpXfer) for removeLiquidity must be a axfer transaction
	assert

	// appBiatecIdentityProvider: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute removeLiquidity(uint64,uint64,axfer,uint64,uint64,uint64)uint256
	callsub removeLiquidity
	dup
	bitlen
	intc 1 // 256
	<=

	// removeLiquidity return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// removeLiquidity(appBiatecConfigProvider: AppID, appBiatecIdentityProvider: AppID, txLpXfer: AssetTransferTxn, assetA: AssetID, assetB: AssetID, assetLp: AssetID): uint256
//
// This method retrieves from the liquidity provider LP token and returns Asset A and Asset B from the Automated Market Maker Concentrated Liqudidity Pool
// @param appBiatecConfigProvider Configuration reference
// @param appBiatecIdentityProvider Identity service reference
// @param txLpXfer Transfer of the LP token
// @param assetLp LP pool asset
// @param assetA Asset A
// @param assetB Asset B
// @returns LP position reduced
removeLiquidity:
	proto 6 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 17

	// well formed mint
	// contracts\BiatecClammPool.algo.ts:486
	// this.checkAssets(assetA, assetB, assetLp)
	frame_dig -6 // assetLp: AssetID
	frame_dig -5 // assetB: AssetID
	frame_dig -4 // assetA: AssetID
	callsub checkAssets

	// contracts\BiatecClammPool.algo.ts:487
	// verifyAssetTransferTxn(txLpXfer, {
	//       assetReceiver: this.app.address,
	//       xferAsset: assetLp,
	//       assetAmount: { greaterThanEqualTo: 0 },
	//     })
	// verify assetReceiver
	frame_dig -3 // txLpXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"txLpXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -3 // txLpXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -6 // assetLp: AssetID
	==

	// transaction verification failed: {"txn":"txLpXfer","field":"xferAsset","expected":"assetLp"}
	assert

	// verify assetAmount
	frame_dig -3 // txLpXfer: AssetTransferTxn
	gtxns AssetAmount
	intc 2 // 0
	>=

	// transaction verification failed: {"txn":"txLpXfer","field":"assetAmount","condition":"greaterThanEqualTo","expected":">=0"}
	assert

	// contracts\BiatecClammPool.algo.ts:493
	// this.verifyIdentity(appBiatecConfigProvider, appBiatecIdentityProvider)
	frame_dig -2 // appBiatecIdentityProvider: AppID
	frame_dig -1 // appBiatecConfigProvider: AppID
	callsub verifyIdentity

	// contracts\BiatecClammPool.algo.ts:496
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 2 // 0
	itxn_field Fee
	bytec 5 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 10 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:497
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 2 // 0
	itxn_field Fee
	bytec 5 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 10 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:499
	// assetADecimals = 6
	intc 5 // 6
	frame_bury 0 // assetADecimals: uint64

	// *if22_condition
	// contracts\BiatecClammPool.algo.ts:500
	// assetA.id > 0
	frame_dig -4 // assetA: AssetID
	intc 2 // 0
	>
	bz *if22_end

	// *if22_consequent
	// contracts\BiatecClammPool.algo.ts:500
	// assetADecimals = assetA.decimals
	frame_dig -4 // assetA: AssetID
	asset_params_get AssetDecimals
	pop
	frame_bury 0 // assetADecimals: uint64

*if22_end:
	// contracts\BiatecClammPool.algo.ts:502
	// assetADelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetADecimals)) as uint256
	intc 7 // 10
	intc 8 // 9
	frame_dig 0 // assetADecimals: uint64
	-
	exp
	itob
	frame_bury 1 // assetADelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:504
	// assetBDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetB.decimals)) as uint256
	intc 7 // 10
	intc 8 // 9
	frame_dig -5 // assetB: AssetID
	asset_params_get AssetDecimals
	pop
	-
	exp
	itob
	frame_bury 2 // assetBDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:506
	// assetLpDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - LP_TOKEN_DECIMALS)) as uint256
	intc 7 // 10
	intc 11 // 3
	exp
	itob
	frame_bury 3 // assetLpDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:508
	// lpDelta = txLpXfer.assetAmount as uint256
	frame_dig -3 // txLpXfer: AssetTransferTxn
	gtxns AssetAmount
	itob
	frame_bury 4 // lpDelta: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:509
	// lpDeltaBase = lpDelta * assetLpDelicmalScale2Scale
	frame_dig 4 // lpDelta: unsafe uint256
	frame_dig 3 // assetLpDelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 5 // lpDeltaBase: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:510
	// lpDeltaWithFees = lpDeltaBase
	frame_dig 5 // lpDeltaBase: unsafe uint256
	frame_bury 6 // lpDeltaWithFees: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:511
	// lpWithOthers = this.calculateDistributedLiquidity(assetLp, lpDelta)
	frame_dig 4 // lpDelta: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// lpDelta overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig -6 // assetLp: AssetID
	callsub calculateDistributedLiquidity
	frame_bury 7 // lpWithOthers: unsafe uint256

	// *if23_condition
	// contracts\BiatecClammPool.algo.ts:512
	// lpWithOthers > <uint256>0
	frame_dig 7 // lpWithOthers: unsafe uint256
	bytec 6 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	bz *if23_end

	// *if23_consequent
	// contracts\BiatecClammPool.algo.ts:514
	// myPortion = (lpDeltaBase * s) / lpWithOthers
	frame_dig 5 // lpDeltaBase: unsafe uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 7 // lpWithOthers: unsafe uint256
	b/
	frame_bury 8 // myPortion: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:515
	// myPortionOfFeesCollected = (this.LiqudityUsersFromFees.value * myPortion) / s
	bytec 13 //  "Lu"
	app_global_get
	frame_dig 8 // myPortion: unsafe uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 9 // myPortionOfFeesCollected: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:516
	// lpDeltaWithFees = lpDeltaBase + myPortionOfFeesCollected
	frame_dig 5 // lpDeltaBase: unsafe uint256
	frame_dig 9 // myPortionOfFeesCollected: unsafe uint256
	b+
	frame_bury 6 // lpDeltaWithFees: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:517
	// this.LiqudityUsersFromFees.value = this.LiqudityUsersFromFees.value - myPortionOfFeesCollected
	bytec 13 //  "Lu"
	dup
	app_global_get
	frame_dig 9 // myPortionOfFeesCollected: unsafe uint256
	b-
	dup
	bitlen
	intc 1 // 256
	<=

	// this.LiqudityUsersFromFees.value - myPortionOfFeesCollected overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

*if23_end:
	// contracts\BiatecClammPool.algo.ts:519
	// aToSend = this.calculateAssetAWithdrawOnLpDeposit(
	//       lpDeltaWithFees,
	//       this.assetABalance.value,
	//       this.Liqudity.value
	//     )
	bytec 8 //  "L"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	frame_dig 6 // lpDeltaWithFees: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// lpDeltaWithFees overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub calculateAssetAWithdrawOnLpDeposit
	frame_bury 10 // aToSend: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:524
	// aToSend64 = (aToSend / assetADelicmalScale2Scale) as uint64
	frame_dig 10 // aToSend: unsafe uint256
	frame_dig 1 // assetADelicmalScale2Scale: unsafe uint256
	b/
	dup
	bitlen
	intc 4 // 64
	<=

	// (aToSend / assetADelicmalScale2Scale) as uint64 overflowed 64 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 11 // aToSend64: uint64

	// *if24_condition
	// contracts\BiatecClammPool.algo.ts:525
	// aToSend64 > 0
	frame_dig 11 // aToSend64: uint64
	intc 2 // 0
	>
	bz *if24_end

	// *if24_consequent
	// contracts\BiatecClammPool.algo.ts:526
	// this.doAxfer(this.txn.sender, assetA, aToSend64)
	frame_dig 11 // aToSend64: uint64
	frame_dig -4 // assetA: AssetID
	txn Sender
	callsub doAxfer

*if24_end:
	// contracts\BiatecClammPool.algo.ts:528
	// bToSend = this.calculateAssetAWithdrawOnLpDeposit(
	//       lpDeltaWithFees,
	//       this.assetBBalance.value,
	//       this.Liqudity.value
	//     )
	bytec 8 //  "L"
	app_global_get
	bytec 4 //  "bb"
	app_global_get
	frame_dig 6 // lpDeltaWithFees: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// lpDeltaWithFees overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub calculateAssetAWithdrawOnLpDeposit
	frame_bury 12 // bToSend: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:533
	// bToSend64 = (bToSend / assetBDelicmalScale2Scale) as uint64
	frame_dig 12 // bToSend: unsafe uint256
	frame_dig 2 // assetBDelicmalScale2Scale: unsafe uint256
	b/
	dup
	bitlen
	intc 4 // 64
	<=

	// (bToSend / assetBDelicmalScale2Scale) as uint64 overflowed 64 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 13 // bToSend64: uint64

	// *if25_condition
	// contracts\BiatecClammPool.algo.ts:534
	// bToSend64 > 0
	frame_dig 13 // bToSend64: uint64
	intc 2 // 0
	>
	bz *if25_end

	// *if25_consequent
	// contracts\BiatecClammPool.algo.ts:535
	// this.doAxfer(this.txn.sender, assetB, bToSend64)
	frame_dig 13 // bToSend64: uint64
	frame_dig -5 // assetB: AssetID
	txn Sender
	callsub doAxfer

*if25_end:
	// contracts\BiatecClammPool.algo.ts:539
	// assert(aToSend64 > 0 || bToSend64 > 0, 'ERR-REM-ZERO')
	frame_dig 11 // aToSend64: uint64
	intc 2 // 0
	>
	dup
	bnz *skip_or0
	frame_dig 13 // bToSend64: uint64
	intc 2 // 0
	>
	||

*skip_or0:
	// ERR-REM-ZERO
	assert

	// contracts\BiatecClammPool.algo.ts:541
	// newAssetA = this.assetABalance.value - aToSend
	bytec 3 //  "ab"
	app_global_get
	frame_dig 10 // aToSend: unsafe uint256
	b-
	frame_bury 14 // newAssetA: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:542
	// newAssetB = this.assetBBalance.value - bToSend
	bytec 4 //  "bb"
	app_global_get
	frame_dig 12 // bToSend: unsafe uint256
	b-
	frame_bury 15 // newAssetB: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:543
	// this.assetABalance.value = newAssetA
	bytec 3 //  "ab"
	frame_dig 14 // newAssetA: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// newAssetA overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:544
	// this.assetBBalance.value = newAssetB
	bytec 4 //  "bb"
	frame_dig 15 // newAssetB: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// newAssetB overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:548
	// lAfter = <uint256>0
	bytec 6 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 16 // lAfter: unsafe uint256

	// *if26_condition
	// contracts\BiatecClammPool.algo.ts:549
	// this.priceMin.value === this.priceMax.value
	bytec 12 //  "pMin"
	app_global_get
	bytec 14 //  "pMax"
	app_global_get
	==
	bz *if26_else

	// *if26_consequent
	// contracts\BiatecClammPool.algo.ts:550
	// lAfter = this.calculateLiquidityFlatPrice(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMin.value as uint256
	//       )
	bytec 12 //  "pMin"
	app_global_get
	itob
	dup
	bitlen
	intc 1 // 256
	<=

	// this.priceMin.value as uint256 overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculateLiquidityFlatPrice
	frame_bury 16 // lAfter: unsafe uint256
	b *if26_end

*if26_else:
	// contracts\BiatecClammPool.algo.ts:556
	// D_SQRT = this.calculateLiquidityD(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMin.value as uint256, // priceMin: uint256,
	//         this.priceMax.value as uint256, // priceMax: uint256,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value // priceMaxSqrt: uint256,
	//       )
	bytec 11 //  "pMaxS"
	app_global_get
	bytec 10 //  "pMinS"
	app_global_get
	bytec 14 //  "pMax"
	app_global_get
	itob
	dup
	bitlen
	intc 1 // 256
	<=

	// this.priceMax.value as uint256 overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 12 //  "pMin"
	app_global_get
	itob
	dup
	bitlen
	intc 1 // 256
	<=

	// this.priceMin.value as uint256 overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculateLiquidityD
	frame_bury 17 // D_SQRT: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:564
	// lAfter = this.calculateLiquidityWithD(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value, // priceMaxSqrt: uint256,
	//         D_SQRT
	//       )
	frame_dig 17 // D_SQRT: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// D_SQRT overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 11 //  "pMaxS"
	app_global_get
	bytec 10 //  "pMinS"
	app_global_get
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculateLiquidityWithD
	frame_bury 16 // lAfter: unsafe uint256

*if26_end:
	// contracts\BiatecClammPool.algo.ts:572
	// this.Liqudity.value = lAfter
	bytec 8 //  "L"
	frame_dig 16 // lAfter: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// lAfter overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:573
	// return lpDeltaWithFees / assetLpDelicmalScale2Scale;
	frame_dig 6 // lpDeltaWithFees: unsafe uint256
	frame_dig 3 // assetLpDelicmalScale2Scale: unsafe uint256
	b/

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 17
	retsub

// removeLiquidityAdmin(uint64,uint64,uint64,uint64,uint256)uint256
*abi_route_removeLiquidityAdmin:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// amount: uint256
	txna ApplicationArgs 5
	dup
	len
	intc 0 // 32
	==

	// argument 0 (amount) for removeLiquidityAdmin must be a uint256
	assert

	// assetLp: uint64
	txna ApplicationArgs 4
	btoi

	// assetB: uint64
	txna ApplicationArgs 3
	btoi

	// assetA: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute removeLiquidityAdmin(uint64,uint64,uint64,uint64,uint256)uint256
	callsub removeLiquidityAdmin
	dup
	bitlen
	intc 1 // 256
	<=

	// removeLiquidityAdmin return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// removeLiquidityAdmin(appBiatecConfigProvider: AppID, assetA: AssetID, assetB: AssetID, assetLp: AssetID, amount: uint256): uint256
removeLiquidityAdmin:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 14

	// well formed mint
	// contracts\BiatecClammPool.algo.ts:584
	// this.checkAssets(assetA, assetB, assetLp)
	frame_dig -4 // assetLp: AssetID
	frame_dig -3 // assetB: AssetID
	frame_dig -2 // assetA: AssetID
	callsub checkAssets

	// contracts\BiatecClammPool.algo.ts:586
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value)
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 15 //  "bc"
	app_global_get
	==
	assert

	// contracts\BiatecClammPool.algo.ts:587
	// addressExecutiveFee = appBiatecConfigProvider.globalState('ef') as Address
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 22 //  "ef"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('ef')
	assert
	frame_bury 0 // addressExecutiveFee: address

	// contracts\BiatecClammPool.algo.ts:589
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 21 //  "s"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('s')
	assert
	frame_bury 1 // paused: uint64

	// contracts\BiatecClammPool.algo.ts:590
	// assert(paused === 0, 'ERR_PAUSED')
	frame_dig 1 // paused: uint64
	intc 2 // 0
	==

	// ERR_PAUSED
	assert

	// contracts\BiatecClammPool.algo.ts:596
	// assert(this.txn.sender === addressExecutiveFee, 'ERR-EXEC-ONLY')
	txn Sender
	frame_dig 0 // addressExecutiveFee: address
	==

	// ERR-EXEC-ONLY
	assert

	// contracts\BiatecClammPool.algo.ts:598
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 2 // 0
	itxn_field Fee
	bytec 5 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 10 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:599
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 2 // 0
	itxn_field Fee
	bytec 5 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 10 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:601
	// assetADecimals = 6
	intc 5 // 6
	frame_bury 2 // assetADecimals: uint64

	// *if27_condition
	// contracts\BiatecClammPool.algo.ts:602
	// assetA.id > 0
	frame_dig -2 // assetA: AssetID
	intc 2 // 0
	>
	bz *if27_end

	// *if27_consequent
	// contracts\BiatecClammPool.algo.ts:602
	// assetADecimals = assetA.decimals
	frame_dig -2 // assetA: AssetID
	asset_params_get AssetDecimals
	pop
	frame_bury 2 // assetADecimals: uint64

*if27_end:
	// contracts\BiatecClammPool.algo.ts:604
	// assetADelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetADecimals)) as uint256
	intc 7 // 10
	intc 8 // 9
	frame_dig 2 // assetADecimals: uint64
	-
	exp
	itob
	frame_bury 3 // assetADelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:606
	// assetBDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetB.decimals)) as uint256
	intc 7 // 10
	intc 8 // 9
	frame_dig -3 // assetB: AssetID
	asset_params_get AssetDecimals
	pop
	-
	exp
	itob
	frame_bury 4 // assetBDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:608
	// assetLpDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - LP_TOKEN_DECIMALS)) as uint256
	intc 7 // 10
	intc 11 // 3
	exp
	itob
	frame_bury 5 // assetLpDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:610
	// lpDeltaWithFees = amount
	frame_dig -5 // amount: uint256
	frame_bury 6 // lpDeltaWithFees: unsafe uint256

	// *if28_condition
	// contracts\BiatecClammPool.algo.ts:611
	// lpDeltaWithFees === <uint256>0
	frame_dig 6 // lpDeltaWithFees: unsafe uint256
	bytec 6 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b==
	bz *if28_end

	// *if28_consequent
	// contracts\BiatecClammPool.algo.ts:611
	// lpDeltaWithFees = this.LiqudityBiatecFromFees.value
	bytec 16 //  "Lb"
	app_global_get
	frame_bury 6 // lpDeltaWithFees: unsafe uint256

*if28_end:
	// contracts\BiatecClammPool.algo.ts:612
	// assert(
	//       lpDeltaWithFees <= this.LiqudityBiatecFromFees.value,
	//       'ERR-TOO-MUCH' // 'Biatec cannot take more lp then is collected in fees'
	//     )
	frame_dig 6 // lpDeltaWithFees: unsafe uint256
	bytec 16 //  "Lb"
	app_global_get
	b<=

	// ERR-TOO-MUCH
	assert

	// contracts\BiatecClammPool.algo.ts:616
	// this.LiqudityBiatecFromFees.value = this.LiqudityBiatecFromFees.value - lpDeltaWithFees
	bytec 16 //  "Lb"
	dup
	app_global_get
	frame_dig 6 // lpDeltaWithFees: unsafe uint256
	b-
	dup
	bitlen
	intc 1 // 256
	<=

	// this.LiqudityBiatecFromFees.value - lpDeltaWithFees overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:617
	// aToSend = this.calculateAssetAWithdrawOnLpDeposit(
	//       lpDeltaWithFees,
	//       this.assetABalance.value,
	//       this.Liqudity.value
	//     )
	bytec 8 //  "L"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	frame_dig 6 // lpDeltaWithFees: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// lpDeltaWithFees overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub calculateAssetAWithdrawOnLpDeposit
	frame_bury 7 // aToSend: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:622
	// aToSend64 = (aToSend / assetADelicmalScale2Scale) as uint64
	frame_dig 7 // aToSend: unsafe uint256
	frame_dig 3 // assetADelicmalScale2Scale: unsafe uint256
	b/
	dup
	bitlen
	intc 4 // 64
	<=

	// (aToSend / assetADelicmalScale2Scale) as uint64 overflowed 64 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 8 // aToSend64: uint64

	// *if29_condition
	// contracts\BiatecClammPool.algo.ts:623
	// aToSend64 > 0
	frame_dig 8 // aToSend64: uint64
	intc 2 // 0
	>
	bz *if29_end

	// *if29_consequent
	// contracts\BiatecClammPool.algo.ts:624
	// this.doAxfer(this.txn.sender, assetA, aToSend64)
	frame_dig 8 // aToSend64: uint64
	frame_dig -2 // assetA: AssetID
	txn Sender
	callsub doAxfer

*if29_end:
	// contracts\BiatecClammPool.algo.ts:626
	// bToSend = this.calculateAssetAWithdrawOnLpDeposit(
	//       lpDeltaWithFees,
	//       this.assetBBalance.value,
	//       this.Liqudity.value
	//     )
	bytec 8 //  "L"
	app_global_get
	bytec 4 //  "bb"
	app_global_get
	frame_dig 6 // lpDeltaWithFees: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// lpDeltaWithFees overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub calculateAssetAWithdrawOnLpDeposit
	frame_bury 9 // bToSend: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:631
	// bToSend64 = (bToSend / assetBDelicmalScale2Scale) as uint64
	frame_dig 9 // bToSend: unsafe uint256
	frame_dig 4 // assetBDelicmalScale2Scale: unsafe uint256
	b/
	dup
	bitlen
	intc 4 // 64
	<=

	// (bToSend / assetBDelicmalScale2Scale) as uint64 overflowed 64 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 10 // bToSend64: uint64

	// *if30_condition
	// contracts\BiatecClammPool.algo.ts:632
	// bToSend64 > 0
	frame_dig 10 // bToSend64: uint64
	intc 2 // 0
	>
	bz *if30_end

	// *if30_consequent
	// contracts\BiatecClammPool.algo.ts:633
	// this.doAxfer(this.txn.sender, assetB, bToSend64)
	frame_dig 10 // bToSend64: uint64
	frame_dig -3 // assetB: AssetID
	txn Sender
	callsub doAxfer

*if30_end:
	// contracts\BiatecClammPool.algo.ts:636
	// newAssetA = this.assetABalance.value - aToSend
	bytec 3 //  "ab"
	app_global_get
	frame_dig 7 // aToSend: unsafe uint256
	b-
	frame_bury 11 // newAssetA: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:637
	// newAssetB = this.assetBBalance.value - bToSend
	bytec 4 //  "bb"
	app_global_get
	frame_dig 9 // bToSend: unsafe uint256
	b-
	frame_bury 12 // newAssetB: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:638
	// this.assetABalance.value = newAssetA
	bytec 3 //  "ab"
	frame_dig 11 // newAssetA: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// newAssetA overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:639
	// this.assetBBalance.value = newAssetB
	bytec 4 //  "bb"
	frame_dig 12 // newAssetB: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// newAssetB overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:641
	// lAfter = <uint256>0
	bytec 6 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 13 // lAfter: unsafe uint256

	// *if31_condition
	// contracts\BiatecClammPool.algo.ts:642
	// this.priceMin.value === this.priceMax.value
	bytec 12 //  "pMin"
	app_global_get
	bytec 14 //  "pMax"
	app_global_get
	==
	bz *if31_else

	// *if31_consequent
	// contracts\BiatecClammPool.algo.ts:643
	// lAfter = this.calculateLiquidityFlatPrice(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMin.value as uint256 // priceMin: uint256,
	//       )
	bytec 12 //  "pMin"
	app_global_get
	itob
	dup
	bitlen
	intc 1 // 256
	<=

	// this.priceMin.value as uint256 overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculateLiquidityFlatPrice
	frame_bury 13 // lAfter: unsafe uint256
	b *if31_end

*if31_else:
	// contracts\BiatecClammPool.algo.ts:649
	// D_SQRT = this.calculateLiquidityD(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMin.value as uint256, // priceMin: uint256,
	//         this.priceMax.value as uint256, // priceMax: uint256,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value // priceMaxSqrt: uint256,
	//       )
	bytec 11 //  "pMaxS"
	app_global_get
	bytec 10 //  "pMinS"
	app_global_get
	bytec 14 //  "pMax"
	app_global_get
	itob
	dup
	bitlen
	intc 1 // 256
	<=

	// this.priceMax.value as uint256 overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 12 //  "pMin"
	app_global_get
	itob
	dup
	bitlen
	intc 1 // 256
	<=

	// this.priceMin.value as uint256 overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculateLiquidityD
	frame_bury 14 // D_SQRT: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:657
	// lAfter = this.calculateLiquidityWithD(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value, // priceMaxSqrt: uint256,
	//         D_SQRT
	//       )
	frame_dig 14 // D_SQRT: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// D_SQRT overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 11 //  "pMaxS"
	app_global_get
	bytec 10 //  "pMinS"
	app_global_get
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculateLiquidityWithD
	frame_bury 13 // lAfter: unsafe uint256

*if31_end:
	// contracts\BiatecClammPool.algo.ts:665
	// this.Liqudity.value = lAfter
	bytec 8 //  "L"
	frame_dig 13 // lAfter: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// lAfter overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:666
	// return lpDeltaWithFees / assetLpDelicmalScale2Scale;
	frame_dig 6 // lpDeltaWithFees: unsafe uint256
	frame_dig 5 // assetLpDelicmalScale2Scale: unsafe uint256
	b/

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 14
	retsub

// verifyIdentity(appBiatecConfigProvider: AppID, appBiatecIdentityProvider: AppID): UserInfoV1
verifyIdentity:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts\BiatecClammPool.algo.ts:670
	// assert(
	//       appBiatecConfigProvider === this.appBiatecConfigProvider.value,
	//       'ERR-INVALID-CONFIG' // 'Configuration app does not match'
	//     )
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 15 //  "bc"
	app_global_get
	==

	// ERR-INVALID-CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:674
	// identityFromConfig = appBiatecConfigProvider.globalState('i') as AppID
	frame_dig -1 // appBiatecConfigProvider: AppID
	pushbytes 0x69 // "i"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('i')
	assert
	frame_bury 0 // identityFromConfig: uint64

	// contracts\BiatecClammPool.algo.ts:675
	// assert(
	//       appBiatecIdentityProvider === identityFromConfig,
	//       'ERR-WRONG-IDENT' // appBiatecIdentityProvider must match to the config in appBiatecConfigProvider'
	//     )
	frame_dig -2 // appBiatecIdentityProvider: AppID
	frame_dig 0 // identityFromConfig: uint64
	==

	// ERR-WRONG-IDENT
	assert

	// contracts\BiatecClammPool.algo.ts:680
	// user = sendMethodCall<[Address, uint8], UserInfoV1>({
	//       name: 'getUser',
	//       methodArgs: [this.txn.sender, <uint8>1],
	//       fee: 0,
	//       applicationID: appBiatecIdentityProvider,
	//     })
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	pushbytes 0x9936a16d // method "getUser(address,uint8)(uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint256,uint256,bool,uint64,uint64,bool)"
	itxn_field ApplicationArgs

	// contracts\BiatecClammPool.algo.ts:682
	// methodArgs: [this.txn.sender, <uint8>1]
	txn Sender
	itxn_field ApplicationArgs
	pushbytes 0x01
	itxn_field ApplicationArgs

	// contracts\BiatecClammPool.algo.ts:683
	// fee: 0
	intc 2 // 0
	itxn_field Fee

	// contracts\BiatecClammPool.algo.ts:684
	// applicationID: appBiatecIdentityProvider
	frame_dig -2 // appBiatecIdentityProvider: AppID
	itxn_field ApplicationID

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 3 // 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 1 // user: (uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint256,uint256,bool,uint64,uint64,bool)

	// contracts\BiatecClammPool.algo.ts:686
	// assert(
	//       !user.isLocked,
	//       'ERR-USER-LOCKED' // 'User must not be locked'
	//     )
	frame_dig 1 // user: (uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint256,uint256,bool,uint64,uint64,bool)
	store 255 // full array
	load 255 // full array
	pushint 1032
	getbit
	!

	// ERR-USER-LOCKED
	assert

	// contracts\BiatecClammPool.algo.ts:690
	// assert(
	//       user.verificationClass >= this.verificationClass.value, // if(user.verificationClass >= this.verificationClass.value) then ok
	//       'ERR-LOW-VER' // 'User cannot interact with this smart contract as his verification class is lower then required here'
	//     )
	frame_dig 1 // user: (uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint256,uint256,bool,uint64,uint64,bool)
	store 255 // full array
	load 255 // full array
	extract 9 8
	btoi
	bytec 25 //  "c"
	app_global_get
	>=

	// ERR-LOW-VER
	assert

	// contracts\BiatecClammPool.algo.ts:695
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 21 //  "s"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('s')
	assert
	frame_bury 2 // paused: uint64

	// contracts\BiatecClammPool.algo.ts:696
	// assert(paused === 0, 'ERR_PAUSED')
	frame_dig 2 // paused: uint64
	intc 2 // 0
	==

	// ERR_PAUSED
	assert

	// contracts\BiatecClammPool.algo.ts:698
	// return user;
	frame_dig 1 // user: (uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint256,uint256,bool,uint64,uint64,bool)

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// swap(uint64,uint64,uint64,txn,uint64,uint64,uint64)uint256
*abi_route_swap:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// minimumToReceive: uint64
	txna ApplicationArgs 6
	btoi

	// assetB: uint64
	txna ApplicationArgs 5
	btoi

	// assetA: uint64
	txna ApplicationArgs 4
	btoi

	// txSwap: txn
	txn GroupIndex
	intc 3 // 1
	-

	// appBiatecPoolProvider: uint64
	txna ApplicationArgs 3
	btoi

	// appBiatecIdentityProvider: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute swap(uint64,uint64,uint64,txn,uint64,uint64,uint64)uint256
	callsub swap
	dup
	bitlen
	intc 1 // 256
	<=

	// swap return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// swap(appBiatecConfigProvider: AppID, appBiatecIdentityProvider: AppID, appBiatecPoolProvider: AppID, txSwap: Txn, assetA: AssetID, assetB: AssetID, minimumToReceive: uint64): uint256
swap:
	proto 7 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 33

	// contracts\BiatecClammPool.algo.ts:710
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 2 // 0
	itxn_field Fee
	bytec 5 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 10 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:711
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 2 // 0
	itxn_field Fee
	bytec 5 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 10 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:712
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 2 // 0
	itxn_field Fee
	bytec 5 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 10 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// well formed swap
	// contracts\BiatecClammPool.algo.ts:714
	// this.checkAssetsAB(assetA, assetB)
	frame_dig -6 // assetB: AssetID
	frame_dig -5 // assetA: AssetID
	callsub checkAssetsAB

	// *if32_condition
	// contracts\BiatecClammPool.algo.ts:716
	// txSwap.typeEnum === TransactionType.Payment
	frame_dig -4 // txSwap: Txn
	gtxns TypeEnum
	intc 3 //  pay
	==
	bz *if32_else

	// *if32_consequent
	// contracts\BiatecClammPool.algo.ts:717
	// assert(assetA.id === 0)
	frame_dig -5 // assetA: AssetID
	intc 2 // 0
	==
	assert

	// contracts\BiatecClammPool.algo.ts:719
	// verifyPayTxn(txSwap, {
	//         amount: { greaterThan: 0 },
	//         receiver: this.app.address,
	//         sender: this.txn.sender,
	//       })
	// verify pay
	frame_dig -4 // txSwap: Txn
	gtxns TypeEnum
	intc 3 //  pay
	==

	// transaction verification failed: {"txn":"txSwap","field":"typeEnum","expected":"pay"}
	assert

	// verify amount
	frame_dig -4 // txSwap: Txn
	gtxns Amount
	intc 2 // 0
	>

	// transaction verification failed: {"txn":"txSwap","field":"amount","condition":"greaterThan","expected":">0"}
	assert

	// verify receiver
	frame_dig -4 // txSwap: Txn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"txSwap","field":"receiver","expected":"this.app.address"}
	assert

	// verify sender
	frame_dig -4 // txSwap: Txn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"txSwap","field":"sender","expected":"this.txn.sender"}
	assert
	b *if32_end

*if32_else:
	// contracts\BiatecClammPool.algo.ts:725
	// assert(txSwap.typeEnum === TransactionType.AssetTransfer)
	frame_dig -4 // txSwap: Txn
	gtxns TypeEnum
	intc 9 //  axfer
	==
	assert

	// contracts\BiatecClammPool.algo.ts:727
	// verifyAssetTransferTxn(txSwap, {
	//         assetAmount: { greaterThan: 0 },
	//         assetReceiver: this.app.address,
	//         sender: this.txn.sender,
	//         xferAsset: { includedIn: [assetA, assetB] },
	//       })
	// verify axfer
	frame_dig -4 // txSwap: Txn
	gtxns TypeEnum
	intc 9 //  axfer
	==

	// transaction verification failed: {"txn":"txSwap","field":"typeEnum","expected":"axfer"}
	assert

	// verify assetAmount
	frame_dig -4 // txSwap: Txn
	gtxns AssetAmount
	intc 2 // 0
	>

	// transaction verification failed: {"txn":"txSwap","field":"assetAmount","condition":"greaterThan","expected":">0"}
	assert

	// verify assetReceiver
	frame_dig -4 // txSwap: Txn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"txSwap","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify sender
	frame_dig -4 // txSwap: Txn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"txSwap","field":"sender","expected":"this.txn.sender"}
	assert

	// verify xferAsset
	frame_dig -4 // txSwap: Txn
	gtxns XferAsset
	frame_dig -5 // assetA: AssetID
	==
	frame_dig -4 // txSwap: Txn
	gtxns XferAsset
	frame_dig -6 // assetB: AssetID
	==
	||

	// transaction verification failed: {"txn":{"txnText":"txSwap"},"field":"xferAsset","condition":"includedIn","expected":"[assetA, assetB]"}
	assert

*if32_end:
	// contracts\BiatecClammPool.algo.ts:735
	// poolProviderFromConfig = appBiatecConfigProvider.globalState('p') as AppID
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 34 //  "p"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('p')
	assert
	frame_bury 0 // poolProviderFromConfig: uint64

	// contracts\BiatecClammPool.algo.ts:736
	// assert(
	//       appBiatecPoolProvider === poolProviderFromConfig,
	//       'ERR-INVALID-PP' // appBiatecPoolProvider must match to the config in appBiatecConfigProvider'
	//     )
	frame_dig -3 // appBiatecPoolProvider: AppID
	frame_dig 0 // poolProviderFromConfig: uint64
	==

	// ERR-INVALID-PP
	assert

	// contracts\BiatecClammPool.algo.ts:740
	// user = this.verifyIdentity(appBiatecConfigProvider, appBiatecIdentityProvider)
	frame_dig -2 // appBiatecIdentityProvider: AppID
	frame_dig -1 // appBiatecConfigProvider: AppID
	callsub verifyIdentity
	frame_bury 1 // user: (uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint256,uint256,bool,uint64,uint64,bool)

	// contracts\BiatecClammPool.algo.ts:742
	// assetADecimals = 6
	intc 5 // 6
	frame_bury 2 // assetADecimals: uint64

	// *if33_condition
	// contracts\BiatecClammPool.algo.ts:743
	// assetA.id > 0
	frame_dig -5 // assetA: AssetID
	intc 2 // 0
	>
	bz *if33_end

	// *if33_consequent
	// contracts\BiatecClammPool.algo.ts:743
	// assetADecimals = assetA.decimals
	frame_dig -5 // assetA: AssetID
	asset_params_get AssetDecimals
	pop
	frame_bury 2 // assetADecimals: uint64

*if33_end:
	// contracts\BiatecClammPool.algo.ts:745
	// assetADelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetADecimals)) as uint256
	intc 7 // 10
	intc 8 // 9
	frame_dig 2 // assetADecimals: uint64
	-
	exp
	itob
	frame_bury 3 // assetADelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:747
	// assetBDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetB.decimals)) as uint256
	intc 7 // 10
	intc 8 // 9
	frame_dig -6 // assetB: AssetID
	asset_params_get AssetDecimals
	pop
	-
	exp
	itob
	frame_bury 4 // assetBDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:749
	// feesMultiplier = (s - ((this.fee.value as uint256) * user.feeMultiplier) / user.base) as uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	bytec 17 //  "f"
	app_global_get
	itob
	frame_dig 1 // user: (uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint256,uint256,bool,uint64,uint64,bool)
	store 255 // full array
	load 255 // full array
	extract 65 32
	b*
	frame_dig 1 // user: (uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint256,uint256,bool,uint64,uint64,bool)
	store 255 // full array
	load 255 // full array
	extract 97 32
	b/
	b-
	frame_bury 5 // feesMultiplier: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:750
	// ret: uint64 = 0
	intc 2 // 0
	frame_bury 6 // ret: uint64

	// contracts\BiatecClammPool.algo.ts:751
	// amountAForStats = 0
	intc 2 // 0
	frame_bury 7 // amountAForStats: uint64

	// contracts\BiatecClammPool.algo.ts:752
	// amountBForStats = 0
	intc 2 // 0
	frame_bury 8 // amountBForStats: uint64

	// contracts\BiatecClammPool.algo.ts:753
	// feeAmountAForStats = 0
	intc 2 // 0
	frame_bury 9 // feeAmountAForStats: uint64

	// contracts\BiatecClammPool.algo.ts:754
	// feeAmountBForStats = 0
	intc 2 // 0
	frame_bury 10 // feeAmountBForStats: uint64

	// contracts\BiatecClammPool.algo.ts:756
	// isAssetA = false
	intc 2 // 0
	frame_bury 11 // isAssetA: bool

	// *if34_condition
	// contracts\BiatecClammPool.algo.ts:757
	// txSwap.typeEnum === TransactionType.Payment
	frame_dig -4 // txSwap: Txn
	gtxns TypeEnum
	intc 3 //  pay
	==
	bz *if34_else

	// *if34_consequent
	// contracts\BiatecClammPool.algo.ts:758
	// isAssetA = true
	intc 3 // 1
	frame_bury 11 // isAssetA: bool
	b *if34_end

*if34_else:
	// contracts\BiatecClammPool.algo.ts:760
	// isAssetA = txSwap.xferAsset === assetA
	frame_dig -4 // txSwap: Txn
	gtxns XferAsset
	frame_dig -5 // assetA: AssetID
	==
	frame_bury 11 // isAssetA: bool

*if34_end:
	// contracts\BiatecClammPool.algo.ts:762
	// realSwapBaseDecimals = <uint256>0
	bytec 6 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 12 // realSwapBaseDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:763
	// inAsset = <uint256>0
	bytec 6 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 13 // inAsset: unsafe uint256

	// *if35_condition
	// contracts\BiatecClammPool.algo.ts:764
	// isAssetA
	frame_dig 11 // isAssetA: bool
	bz *if35_end

	// *if35_consequent
	// contracts\BiatecClammPool.algo.ts:765
	// assetInAssetDecimals = <uint256>0
	bytec 6 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 14 // assetInAssetDecimals: unsafe uint256

	// *if36_condition
	// contracts\BiatecClammPool.algo.ts:766
	// txSwap.typeEnum === TransactionType.Payment
	frame_dig -4 // txSwap: Txn
	gtxns TypeEnum
	intc 3 //  pay
	==
	bz *if36_else

	// *if36_consequent
	// contracts\BiatecClammPool.algo.ts:767
	// assetInAssetDecimals = txSwap.amount as uint256
	frame_dig -4 // txSwap: Txn
	gtxns Amount
	itob
	frame_bury 14 // assetInAssetDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:768
	// amountAForStats = txSwap.amount
	frame_dig -4 // txSwap: Txn
	gtxns Amount
	frame_bury 7 // amountAForStats: uint64
	b *if36_end

*if36_else:
	// contracts\BiatecClammPool.algo.ts:770
	// assetInAssetDecimals = txSwap.assetAmount as uint256
	frame_dig -4 // txSwap: Txn
	gtxns AssetAmount
	itob
	frame_bury 14 // assetInAssetDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:771
	// amountAForStats = txSwap.assetAmount
	frame_dig -4 // txSwap: Txn
	gtxns AssetAmount
	frame_bury 7 // amountAForStats: uint64

*if36_end:
	// contracts\BiatecClammPool.algo.ts:773
	// inAsset = (assetInAssetDecimals * assetADelicmalScale2Scale) as uint256
	frame_dig 14 // assetInAssetDecimals: unsafe uint256
	frame_dig 3 // assetADelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 13 // inAsset: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:774
	// inAssetAfterFee = (inAsset * feesMultiplier) / s
	frame_dig 13 // inAsset: unsafe uint256
	frame_dig 5 // feesMultiplier: unsafe uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 15 // inAssetAfterFee: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:776
	// toSwap = this.calculateAssetBWithdrawOnAssetADeposit(
	//         inAssetAfterFee,
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMinSqrt.value,
	//         this.priceMaxSqrt.value,
	//         this.Liqudity.value
	//       )
	bytec 8 //  "L"
	app_global_get
	bytec 11 //  "pMaxS"
	app_global_get
	bytec 10 //  "pMinS"
	app_global_get
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	frame_dig 15 // inAssetAfterFee: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// inAssetAfterFee overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub calculateAssetBWithdrawOnAssetADeposit
	frame_bury 16 // toSwap: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:784
	// realSwapBaseDecimals = toSwap
	frame_dig 16 // toSwap: unsafe uint256
	frame_bury 12 // realSwapBaseDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:785
	// realSwapBDecimals = (toSwap / assetBDelicmalScale2Scale) as uint256
	frame_dig 16 // toSwap: unsafe uint256
	frame_dig 4 // assetBDelicmalScale2Scale: unsafe uint256
	b/
	frame_bury 17 // realSwapBDecimals: unsafe uint256

	// *if37_condition
	// contracts\BiatecClammPool.algo.ts:787
	// realSwapBDecimals * assetBDelicmalScale2Scale !== toSwap
	frame_dig 17 // realSwapBDecimals: unsafe uint256
	frame_dig 4 // assetBDelicmalScale2Scale: unsafe uint256
	b*
	frame_dig 16 // toSwap: unsafe uint256
	b!=
	bz *if37_end

	// *if37_consequent
	// contracts\BiatecClammPool.algo.ts:788
	// realSwapBDecimals = realSwapBDecimals - <uint256>1
	frame_dig 17 // realSwapBDecimals: unsafe uint256
	bytec 27 // 0x0000000000000000000000000000000000000000000000000000000000000001
	b-
	frame_bury 17 // realSwapBDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:789
	// realSwapBaseDecimals = realSwapBDecimals * assetBDelicmalScale2Scale
	frame_dig 17 // realSwapBDecimals: unsafe uint256
	frame_dig 4 // assetBDelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 12 // realSwapBaseDecimals: unsafe uint256

*if37_end:
	// contracts\BiatecClammPool.algo.ts:791
	// toSwapBDecimals = realSwapBDecimals as uint64
	frame_dig 17 // realSwapBDecimals: unsafe uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// realSwapBDecimals as uint64 overflowed 64 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 18 // toSwapBDecimals: uint64

	// contracts\BiatecClammPool.algo.ts:792
	// ret = toSwapBDecimals
	frame_dig 18 // toSwapBDecimals: uint64
	frame_bury 6 // ret: uint64

	// *if38_condition
	// contracts\BiatecClammPool.algo.ts:793
	// minimumToReceive > 0
	frame_dig -7 // minimumToReceive: uint64
	intc 2 // 0
	>
	bz *if38_end

	// *if38_consequent
	// contracts\BiatecClammPool.algo.ts:795
	// assert(minimumToReceive >= toSwapBDecimals)
	frame_dig -7 // minimumToReceive: uint64
	frame_dig 18 // toSwapBDecimals: uint64
	>=
	assert

*if38_end:
	// contracts\BiatecClammPool.algo.ts:797
	// amountBForStats = toSwapBDecimals
	frame_dig 18 // toSwapBDecimals: uint64
	frame_bury 8 // amountBForStats: uint64

	// contracts\BiatecClammPool.algo.ts:798
	// this.doAxfer(this.txn.sender, assetB, toSwapBDecimals)
	frame_dig 18 // toSwapBDecimals: uint64
	frame_dig -6 // assetB: AssetID
	txn Sender
	callsub doAxfer

	// contracts\BiatecClammPool.algo.ts:800
	// this.assetABalance.value = this.assetABalance.value + inAsset
	bytec 3 //  "ab"
	dup
	app_global_get
	frame_dig 13 // inAsset: unsafe uint256
	b+
	dup
	bitlen
	intc 1 // 256
	<=

	// this.assetABalance.value + inAsset overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:801
	// this.assetBBalance.value = this.assetBBalance.value - realSwapBaseDecimals
	bytec 4 //  "bb"
	dup
	app_global_get
	frame_dig 12 // realSwapBaseDecimals: unsafe uint256
	b-
	dup
	bitlen
	intc 1 // 256
	<=

	// this.assetBBalance.value - realSwapBaseDecimals overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

*if35_end:
	// *if39_condition
	// contracts\BiatecClammPool.algo.ts:804
	// !isAssetA
	frame_dig 11 // isAssetA: bool
	!
	bz *if39_end

	// *if39_consequent
	// contracts\BiatecClammPool.algo.ts:805
	// assetInAssetDecimals = txSwap.assetAmount as uint256
	frame_dig -4 // txSwap: Txn
	gtxns AssetAmount
	itob
	frame_bury 19 // assetInAssetDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:806
	// amountBForStats = txSwap.assetAmount
	frame_dig -4 // txSwap: Txn
	gtxns AssetAmount
	frame_bury 8 // amountBForStats: uint64

	// contracts\BiatecClammPool.algo.ts:807
	// inAsset = (assetInAssetDecimals * assetBDelicmalScale2Scale) as uint256
	frame_dig 19 // assetInAssetDecimals: unsafe uint256
	frame_dig 4 // assetBDelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 13 // inAsset: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:808
	// inAssetAfterFee = (inAsset * feesMultiplier) / s
	frame_dig 13 // inAsset: unsafe uint256
	frame_dig 5 // feesMultiplier: unsafe uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 20 // inAssetAfterFee: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:809
	// toSwap = this.calculateAssetAWithdrawOnAssetBDeposit(
	//         inAssetAfterFee,
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMinSqrt.value,
	//         this.priceMaxSqrt.value,
	//         this.Liqudity.value
	//       )
	bytec 8 //  "L"
	app_global_get
	bytec 11 //  "pMaxS"
	app_global_get
	bytec 10 //  "pMinS"
	app_global_get
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	frame_dig 20 // inAssetAfterFee: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// inAssetAfterFee overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub calculateAssetAWithdrawOnAssetBDeposit
	frame_bury 21 // toSwap: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:817
	// realSwapBaseDecimals = toSwap
	frame_dig 21 // toSwap: unsafe uint256
	frame_bury 12 // realSwapBaseDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:818
	// realSwapADecimals = toSwap / assetADelicmalScale2Scale
	frame_dig 21 // toSwap: unsafe uint256
	frame_dig 3 // assetADelicmalScale2Scale: unsafe uint256
	b/
	frame_bury 22 // realSwapADecimals: unsafe uint256

	// *if40_condition
	// contracts\BiatecClammPool.algo.ts:820
	// realSwapADecimals * assetADelicmalScale2Scale !== toSwap
	frame_dig 22 // realSwapADecimals: unsafe uint256
	frame_dig 3 // assetADelicmalScale2Scale: unsafe uint256
	b*
	frame_dig 21 // toSwap: unsafe uint256
	b!=
	bz *if40_end

	// *if40_consequent
	// contracts\BiatecClammPool.algo.ts:821
	// realSwapADecimals = realSwapADecimals - <uint256>1
	frame_dig 22 // realSwapADecimals: unsafe uint256
	bytec 27 // 0x0000000000000000000000000000000000000000000000000000000000000001
	b-
	frame_bury 22 // realSwapADecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:822
	// realSwapBaseDecimals = realSwapADecimals * assetADelicmalScale2Scale
	frame_dig 22 // realSwapADecimals: unsafe uint256
	frame_dig 3 // assetADelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 12 // realSwapBaseDecimals: unsafe uint256

*if40_end:
	// contracts\BiatecClammPool.algo.ts:824
	// toSwapADecimals = realSwapADecimals as uint64
	frame_dig 22 // realSwapADecimals: unsafe uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// realSwapADecimals as uint64 overflowed 64 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 23 // toSwapADecimals: uint64

	// contracts\BiatecClammPool.algo.ts:825
	// ret = toSwapADecimals
	frame_dig 23 // toSwapADecimals: uint64
	frame_bury 6 // ret: uint64

	// *if41_condition
	// contracts\BiatecClammPool.algo.ts:826
	// minimumToReceive > 0
	frame_dig -7 // minimumToReceive: uint64
	intc 2 // 0
	>
	bz *if41_end

	// *if41_consequent
	// contracts\BiatecClammPool.algo.ts:828
	// assert(minimumToReceive >= toSwapADecimals)
	frame_dig -7 // minimumToReceive: uint64
	frame_dig 23 // toSwapADecimals: uint64
	>=
	assert

*if41_end:
	// contracts\BiatecClammPool.algo.ts:830
	// amountAForStats = toSwapADecimals
	frame_dig 23 // toSwapADecimals: uint64
	frame_bury 7 // amountAForStats: uint64

	// contracts\BiatecClammPool.algo.ts:831
	// this.doAxfer(this.txn.sender, assetA, toSwapADecimals)
	frame_dig 23 // toSwapADecimals: uint64
	frame_dig -5 // assetA: AssetID
	txn Sender
	callsub doAxfer

	// contracts\BiatecClammPool.algo.ts:833
	// this.assetBBalance.value = this.assetBBalance.value + inAsset
	bytec 4 //  "bb"
	dup
	app_global_get
	frame_dig 13 // inAsset: unsafe uint256
	b+
	dup
	bitlen
	intc 1 // 256
	<=

	// this.assetBBalance.value + inAsset overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:834
	// this.assetABalance.value = this.assetABalance.value - realSwapBaseDecimals
	bytec 3 //  "ab"
	dup
	app_global_get
	frame_dig 12 // realSwapBaseDecimals: unsafe uint256
	b-
	dup
	bitlen
	intc 1 // 256
	<=

	// this.assetABalance.value - realSwapBaseDecimals overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

*if39_end:
	// contracts\BiatecClammPool.algo.ts:836
	// newL = <uint256>0
	bytec 6 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 24 // newL: unsafe uint256

	// *if42_condition
	// contracts\BiatecClammPool.algo.ts:837
	// this.priceMin.value === this.priceMax.value
	bytec 12 //  "pMin"
	app_global_get
	bytec 14 //  "pMax"
	app_global_get
	==
	bz *if42_else

	// *if42_consequent
	// contracts\BiatecClammPool.algo.ts:838
	// newL = this.calculateLiquidityFlatPrice(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMin.value as uint256 // priceMin: uint256,
	//       )
	bytec 12 //  "pMin"
	app_global_get
	itob
	dup
	bitlen
	intc 1 // 256
	<=

	// this.priceMin.value as uint256 overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculateLiquidityFlatPrice
	frame_bury 24 // newL: unsafe uint256
	b *if42_end

*if42_else:
	// contracts\BiatecClammPool.algo.ts:844
	// D_SQRT = this.calculateLiquidityD(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMin.value as uint256, // priceMin: uint256,
	//         this.priceMax.value as uint256, // priceMax: uint256,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value // priceMaxSqrt: uint256,
	//       )
	bytec 11 //  "pMaxS"
	app_global_get
	bytec 10 //  "pMinS"
	app_global_get
	bytec 14 //  "pMax"
	app_global_get
	itob
	dup
	bitlen
	intc 1 // 256
	<=

	// this.priceMax.value as uint256 overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 12 //  "pMin"
	app_global_get
	itob
	dup
	bitlen
	intc 1 // 256
	<=

	// this.priceMin.value as uint256 overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculateLiquidityD
	frame_bury 25 // D_SQRT: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:852
	// newL = this.calculateLiquidityWithD(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value, // priceMaxSqrt: uint256,
	//         D_SQRT
	//       )
	frame_dig 25 // D_SQRT: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// D_SQRT overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 11 //  "pMaxS"
	app_global_get
	bytec 10 //  "pMinS"
	app_global_get
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculateLiquidityWithD
	frame_bury 24 // newL: unsafe uint256

*if42_end:
	// *if43_condition
	// contracts\BiatecClammPool.algo.ts:861
	// newL > this.Liqudity.value
	frame_dig 24 // newL: unsafe uint256
	bytec 8 //  "L"
	app_global_get
	b>
	bz *if43_end

	// *if43_consequent
	// contracts\BiatecClammPool.algo.ts:864
	// diff = (newL - this.Liqudity.value) as uint256
	frame_dig 24 // newL: unsafe uint256
	bytec 8 //  "L"
	app_global_get
	b-
	frame_bury 26 // diff: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:865
	// this.Liqudity.value = newL
	bytec 8 //  "L"
	frame_dig 24 // newL: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// newL overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// *if44_condition
	// contracts\BiatecClammPool.algo.ts:867
	// isAssetA
	frame_dig 11 // isAssetA: bool
	bz *if44_else

	// *if44_consequent
	// contracts\BiatecClammPool.algo.ts:869
	// feeB256 = (this.assetABalance.value * diff) / newL
	bytec 3 //  "ab"
	app_global_get
	frame_dig 26 // diff: unsafe uint256
	b*
	frame_dig 24 // newL: unsafe uint256
	b/
	frame_bury 27 // feeB256: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:870
	// feeAmountAForStats = feeB256 as uint64
	frame_dig 27 // feeB256: unsafe uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// feeB256 as uint64 overflowed 64 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 9 // feeAmountAForStats: uint64

	// contracts\BiatecClammPool.algo.ts:871
	// feeAmountBForStats = 0
	intc 2 // 0
	frame_bury 10 // feeAmountBForStats: uint64
	b *if44_end

*if44_else:
	// contracts\BiatecClammPool.algo.ts:874
	// feeB256 = (this.assetBBalance.value * diff) / newL
	bytec 4 //  "bb"
	app_global_get
	frame_dig 26 // diff: unsafe uint256
	b*
	frame_dig 24 // newL: unsafe uint256
	b/
	frame_bury 28 // feeB256: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:875
	// feeAmountAForStats = 0
	intc 2 // 0
	frame_bury 9 // feeAmountAForStats: uint64

	// contracts\BiatecClammPool.algo.ts:876
	// feeAmountBForStats = feeB256 as uint64
	frame_dig 28 // feeB256: unsafe uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// feeB256 as uint64 overflowed 64 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 10 // feeAmountBForStats: uint64

*if44_end:
	// contracts\BiatecClammPool.algo.ts:879
	// biatecFee = this.appBiatecConfigProvider.value.globalState('f') as uint256
	bytec 15 //  "bc"
	app_global_get
	bytec 17 //  "f"
	app_global_get_ex

	// global state value does not exist: this.appBiatecConfigProvider.value.globalState('f')
	assert
	frame_bury 29 // biatecFee: uint256

	// *if45_condition
	// contracts\BiatecClammPool.algo.ts:880
	// biatecFee === <uint256>0
	frame_dig 29 // biatecFee: uint256
	bytec 6 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b==
	bz *if45_else

	// *if45_consequent
	// contracts\BiatecClammPool.algo.ts:881
	// usersLiquidityFromFeeIncrement = diff
	frame_dig 26 // diff: unsafe uint256
	frame_bury 30 // usersLiquidityFromFeeIncrement: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:882
	// this.LiqudityUsersFromFees.value = this.LiqudityUsersFromFees.value + usersLiquidityFromFeeIncrement
	bytec 13 //  "Lu"
	dup
	app_global_get
	frame_dig 30 // usersLiquidityFromFeeIncrement: unsafe uint256
	b+
	dup
	bitlen
	intc 1 // 256
	<=

	// this.LiqudityUsersFromFees.value + usersLiquidityFromFeeIncrement overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put
	b *if45_end

*if45_else:
	// contracts\BiatecClammPool.algo.ts:884
	// usersLiquidityFromFeeIncrement = (diff * (s - biatecFee)) / s
	frame_dig 26 // diff: unsafe uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	frame_dig 29 // biatecFee: uint256
	b-
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 31 // usersLiquidityFromFeeIncrement: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:885
	// biatecLiquidityFromFeeIncrement = diff - usersLiquidityFromFeeIncrement
	frame_dig 26 // diff: unsafe uint256
	frame_dig 31 // usersLiquidityFromFeeIncrement: unsafe uint256
	b-
	frame_bury 32 // biatecLiquidityFromFeeIncrement: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:886
	// this.LiqudityUsersFromFees.value = this.LiqudityUsersFromFees.value + usersLiquidityFromFeeIncrement
	bytec 13 //  "Lu"
	dup
	app_global_get
	frame_dig 31 // usersLiquidityFromFeeIncrement: unsafe uint256
	b+
	dup
	bitlen
	intc 1 // 256
	<=

	// this.LiqudityUsersFromFees.value + usersLiquidityFromFeeIncrement overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:887
	// this.LiqudityBiatecFromFees.value = this.LiqudityBiatecFromFees.value + biatecLiquidityFromFeeIncrement
	bytec 16 //  "Lb"
	dup
	app_global_get
	frame_dig 32 // biatecLiquidityFromFeeIncrement: unsafe uint256
	b+
	dup
	bitlen
	intc 1 // 256
	<=

	// this.LiqudityBiatecFromFees.value + biatecLiquidityFromFeeIncrement overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

*if45_end:

*if43_end:
	// contracts\BiatecClammPool.algo.ts:890
	// newPrice = this.calculatePrice(
	//       this.assetABalance.value, // assetAQuantity: uint256,
	//       this.assetBBalance.value, // assetBQuantity: uint256,
	//       this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//       this.priceMaxSqrt.value, // priceMaxSqrt: uint256,
	//       this.Liqudity.value // liquidity: uint256
	//     )
	bytec 8 //  "L"
	app_global_get
	bytec 11 //  "pMaxS"
	app_global_get
	bytec 10 //  "pMinS"
	app_global_get
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculatePrice
	frame_bury 33 // newPrice: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:897
	// assert(amountAForStats > 0 && amountBForStats > 0, 'Stats to register must not be empty')
	frame_dig 7 // amountAForStats: uint64
	intc 2 // 0
	>
	dup
	bz *skip_and4
	frame_dig 8 // amountBForStats: uint64
	intc 2 // 0
	>
	&&

*skip_and4:
	// Stats to register must not be empty
	assert

	// contracts\BiatecClammPool.algo.ts:898
	// sendMethodCall<[AppID, AssetID, AssetID, uint64, uint64, uint64, uint64, uint64, uint64, uint64], void>({
	//       name: 'registerTrade',
	//       methodArgs: [
	//         globals.currentApplicationID,
	//         assetA,
	//         assetB,
	//         this.currentPrice.value as uint64,
	//         newPrice as uint64,
	//         amountAForStats * (assetADelicmalScale2Scale as uint64),
	//         amountBForStats * (assetBDelicmalScale2Scale as uint64),
	//         feeAmountAForStats,
	//         feeAmountBForStats,
	//         SCALE,
	//       ],
	//       fee: 0,
	//       applicationID: appBiatecPoolProvider,
	//     })
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	pushbytes 0xe13e4f5a // method "registerTrade(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)void"
	itxn_field ApplicationArgs

	// contracts\BiatecClammPool.algo.ts:900
	// methodArgs: [
	//         globals.currentApplicationID,
	//         assetA,
	//         assetB,
	//         this.currentPrice.value as uint64,
	//         newPrice as uint64,
	//         amountAForStats * (assetADelicmalScale2Scale as uint64),
	//         amountBForStats * (assetBDelicmalScale2Scale as uint64),
	//         feeAmountAForStats,
	//         feeAmountBForStats,
	//         SCALE,
	//       ]
	global CurrentApplicationID
	itob
	itxn_field ApplicationArgs
	frame_dig -5 // assetA: AssetID
	itob
	itxn_field ApplicationArgs
	frame_dig -6 // assetB: AssetID
	itob
	itxn_field ApplicationArgs
	bytec 18 //  "price"
	app_global_get
	itob
	itxn_field ApplicationArgs
	frame_dig 33 // newPrice: unsafe uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// newPrice as uint64 overflowed 64 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	itob
	itxn_field ApplicationArgs
	frame_dig 7 // amountAForStats: uint64
	frame_dig 3 // assetADelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// assetADelicmalScale2Scale as uint64 overflowed 64 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	*
	itob
	itxn_field ApplicationArgs
	frame_dig 8 // amountBForStats: uint64
	frame_dig 4 // assetBDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// assetBDelicmalScale2Scale as uint64 overflowed 64 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	*
	itob
	itxn_field ApplicationArgs
	frame_dig 9 // feeAmountAForStats: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig 10 // feeAmountBForStats: uint64
	itob
	itxn_field ApplicationArgs
	bytec 31 // 0x000000003b9aca00
	itxn_field ApplicationArgs

	// contracts\BiatecClammPool.algo.ts:912
	// fee: 0
	intc 2 // 0
	itxn_field Fee

	// contracts\BiatecClammPool.algo.ts:913
	// applicationID: appBiatecPoolProvider
	frame_dig -3 // appBiatecPoolProvider: AppID
	itxn_field ApplicationID

	// Submit inner transaction
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:916
	// this.currentPrice.value = newPrice as uint64
	bytec 18 //  "price"
	frame_dig 33 // newPrice: unsafe uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// newPrice as uint64 overflowed 64 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	app_global_put

	// contracts\BiatecClammPool.algo.ts:938
	// return ret as uint256;
	frame_dig 6 // ret: uint64
	itob

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 33
	retsub

// distributeExcessAssets(uint64,uint64,uint64,uint256,uint256)uint256
*abi_route_distributeExcessAssets:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// amountB: uint256
	txna ApplicationArgs 5
	dup
	len
	intc 0 // 32
	==

	// argument 0 (amountB) for distributeExcessAssets must be a uint256
	assert

	// amountA: uint256
	txna ApplicationArgs 4
	dup
	len
	intc 0 // 32
	==

	// argument 1 (amountA) for distributeExcessAssets must be a uint256
	assert

	// assetB: uint64
	txna ApplicationArgs 3
	btoi

	// assetA: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute distributeExcessAssets(uint64,uint64,uint64,uint256,uint256)uint256
	callsub distributeExcessAssets
	dup
	bitlen
	intc 1 // 256
	<=

	// distributeExcessAssets return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// distributeExcessAssets(appBiatecConfigProvider: AppID, assetA: AssetID, assetB: AssetID, amountA: uint256, amountB: uint256): uint256
distributeExcessAssets:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 12

	// contracts\BiatecClammPool.algo.ts:948
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 2 // 0
	itxn_field Fee
	bytec 5 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 10 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:949
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 2 // 0
	itxn_field Fee
	bytec 5 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 10 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:950
	// this.checkAssetsAB(assetA, assetB)
	frame_dig -3 // assetB: AssetID
	frame_dig -2 // assetA: AssetID
	callsub checkAssetsAB

	// contracts\BiatecClammPool.algo.ts:952
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value, 'ERR_CONFIG')
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 15 //  "bc"
	app_global_get
	==

	// ERR_CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:953
	// addressExecutiveFee = appBiatecConfigProvider.globalState('ef') as Address
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 22 //  "ef"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('ef')
	assert
	frame_bury 0 // addressExecutiveFee: address

	// contracts\BiatecClammPool.algo.ts:955
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 21 //  "s"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('s')
	assert
	frame_bury 1 // paused: uint64

	// contracts\BiatecClammPool.algo.ts:956
	// assert(paused === 0, 'ERR_PAUSED')
	frame_dig 1 // paused: uint64
	intc 2 // 0
	==

	// ERR_PAUSED
	assert

	// contracts\BiatecClammPool.algo.ts:958
	// assert(
	//       this.txn.sender === addressExecutiveFee,
	//       'ERR_SENDER' // 'Only fee executor setup in the config can take the collected fees'
	//     )
	txn Sender
	frame_dig 0 // addressExecutiveFee: address
	==

	// ERR_SENDER
	assert

	// contracts\BiatecClammPool.algo.ts:963
	// assetADecimals = 6
	intc 5 // 6
	frame_bury 2 // assetADecimals: uint64

	// *if46_condition
	// contracts\BiatecClammPool.algo.ts:964
	// assetA.id > 0
	frame_dig -2 // assetA: AssetID
	intc 2 // 0
	>
	bz *if46_end

	// *if46_consequent
	// contracts\BiatecClammPool.algo.ts:964
	// assetADecimals = assetA.decimals
	frame_dig -2 // assetA: AssetID
	asset_params_get AssetDecimals
	pop
	frame_bury 2 // assetADecimals: uint64

*if46_end:
	// contracts\BiatecClammPool.algo.ts:966
	// assetADelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetADecimals)) as uint256
	intc 7 // 10
	intc 8 // 9
	frame_dig 2 // assetADecimals: uint64
	-
	exp
	itob
	frame_bury 3 // assetADelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:968
	// assetBDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetB.decimals)) as uint256
	intc 7 // 10
	intc 8 // 9
	frame_dig -3 // assetB: AssetID
	asset_params_get AssetDecimals
	pop
	-
	exp
	itob
	frame_bury 4 // assetBDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:970
	// this.assetABalance.value = this.assetABalance.value + amountA
	bytec 3 //  "ab"
	dup
	app_global_get
	frame_dig -4 // amountA: uint256
	b+
	dup
	bitlen
	intc 1 // 256
	<=

	// this.assetABalance.value + amountA overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:971
	// this.assetBBalance.value = this.assetBBalance.value + amountB
	bytec 4 //  "bb"
	dup
	app_global_get
	frame_dig -5 // amountB: uint256
	b+
	dup
	bitlen
	intc 1 // 256
	<=

	// this.assetBBalance.value + amountB overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// *if47_condition
	// contracts\BiatecClammPool.algo.ts:972
	// assetA.id === 0
	frame_dig -2 // assetA: AssetID
	intc 2 // 0
	==
	bz *if47_else

	// *if47_consequent
	// contracts\BiatecClammPool.algo.ts:973
	// assert(
	//         ((this.app.address.balance - 1_000_000) as uint256) * assetADelicmalScale2Scale >= this.assetABalance.value,
	//         'ERR_A0_B' // 'It is not possible to set higher assetABalance in algos then is in the app balance'
	//       )
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	intc 13 // 1_000_000
	-
	itob
	frame_dig 3 // assetADelicmalScale2Scale: unsafe uint256
	b*
	bytec 3 //  "ab"
	app_global_get
	b>=

	// ERR_A0_B
	assert
	b *if47_end

*if47_else:
	// contracts\BiatecClammPool.algo.ts:978
	// assert(
	//         (this.app.address.assetBalance(assetA) as uint256) * assetADelicmalScale2Scale >= this.assetABalance.value,
	//         'ERR_A_B' // 'It is not possible to set higher assetABalance then is in the app balance'
	//       )
	global CurrentApplicationAddress
	frame_dig -2 // assetA: AssetID
	asset_holding_get AssetBalance
	pop
	itob
	frame_dig 3 // assetADelicmalScale2Scale: unsafe uint256
	b*
	bytec 3 //  "ab"
	app_global_get
	b>=

	// ERR_A_B
	assert

*if47_end:
	// contracts\BiatecClammPool.algo.ts:983
	// assert(
	//       (this.app.address.assetBalance(assetB) as uint256) * assetBDelicmalScale2Scale >= this.assetBBalance.value,
	//       'ERR_B_B' // 'It is not possible to set higher assetBBalance then is in the app balance'
	//     )
	global CurrentApplicationAddress
	frame_dig -3 // assetB: AssetID
	asset_holding_get AssetBalance
	pop
	itob
	frame_dig 4 // assetBDelicmalScale2Scale: unsafe uint256
	b*
	bytec 4 //  "bb"
	app_global_get
	b>=

	// ERR_B_B
	assert

	// contracts\BiatecClammPool.algo.ts:987
	// newL = <uint256>0
	bytec 6 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 5 // newL: unsafe uint256

	// *if48_condition
	// contracts\BiatecClammPool.algo.ts:988
	// this.priceMin.value === this.priceMax.value
	bytec 12 //  "pMin"
	app_global_get
	bytec 14 //  "pMax"
	app_global_get
	==
	bz *if48_else

	// *if48_consequent
	// contracts\BiatecClammPool.algo.ts:989
	// newL = this.calculateLiquidityFlatPrice(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMin.value as uint256 // priceMin: uint256,
	//       )
	bytec 12 //  "pMin"
	app_global_get
	itob
	dup
	bitlen
	intc 1 // 256
	<=

	// this.priceMin.value as uint256 overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculateLiquidityFlatPrice
	frame_bury 5 // newL: unsafe uint256
	b *if48_end

*if48_else:
	// contracts\BiatecClammPool.algo.ts:995
	// D_SQRT = this.calculateLiquidityD(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMin.value as uint256, // priceMin: uint256,
	//         this.priceMax.value as uint256, // priceMax: uint256,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value // priceMaxSqrt: uint256,
	//       )
	bytec 11 //  "pMaxS"
	app_global_get
	bytec 10 //  "pMinS"
	app_global_get
	bytec 14 //  "pMax"
	app_global_get
	itob
	dup
	bitlen
	intc 1 // 256
	<=

	// this.priceMax.value as uint256 overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 12 //  "pMin"
	app_global_get
	itob
	dup
	bitlen
	intc 1 // 256
	<=

	// this.priceMin.value as uint256 overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculateLiquidityD
	frame_bury 6 // D_SQRT: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1003
	// newL = this.calculateLiquidityWithD(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value, // priceMaxSqrt: uint256,
	//         D_SQRT
	//       )
	frame_dig 6 // D_SQRT: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// D_SQRT overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 11 //  "pMaxS"
	app_global_get
	bytec 10 //  "pMinS"
	app_global_get
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculateLiquidityWithD
	frame_bury 5 // newL: unsafe uint256

*if48_end:
	// contracts\BiatecClammPool.algo.ts:1012
	// diff = (newL - this.Liqudity.value) as uint256
	frame_dig 5 // newL: unsafe uint256
	bytec 8 //  "L"
	app_global_get
	b-
	frame_bury 7 // diff: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1013
	// this.Liqudity.value = newL
	bytec 8 //  "L"
	frame_dig 5 // newL: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// newL overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:1015
	// biatecFee = this.appBiatecConfigProvider.value.globalState('f') as uint256
	bytec 15 //  "bc"
	app_global_get
	bytec 17 //  "f"
	app_global_get_ex

	// global state value does not exist: this.appBiatecConfigProvider.value.globalState('f')
	assert
	frame_bury 8 // biatecFee: uint256

	// *if49_condition
	// contracts\BiatecClammPool.algo.ts:1016
	// biatecFee === <uint256>0
	frame_dig 8 // biatecFee: uint256
	bytec 6 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b==
	bz *if49_else

	// *if49_consequent
	// contracts\BiatecClammPool.algo.ts:1017
	// usersLiquidityFromFeeIncrement = diff
	frame_dig 7 // diff: unsafe uint256
	frame_bury 9 // usersLiquidityFromFeeIncrement: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1018
	// this.LiqudityUsersFromFees.value = this.LiqudityUsersFromFees.value + usersLiquidityFromFeeIncrement
	bytec 13 //  "Lu"
	dup
	app_global_get
	frame_dig 9 // usersLiquidityFromFeeIncrement: unsafe uint256
	b+
	dup
	bitlen
	intc 1 // 256
	<=

	// this.LiqudityUsersFromFees.value + usersLiquidityFromFeeIncrement overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put
	b *if49_end

*if49_else:
	// contracts\BiatecClammPool.algo.ts:1020
	// usersLiquidityFromFeeIncrement = (diff * (s - biatecFee)) / s
	frame_dig 7 // diff: unsafe uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	frame_dig 8 // biatecFee: uint256
	b-
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 10 // usersLiquidityFromFeeIncrement: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1021
	// biatecLiquidityFromFeeIncrement = diff - usersLiquidityFromFeeIncrement
	frame_dig 7 // diff: unsafe uint256
	frame_dig 10 // usersLiquidityFromFeeIncrement: unsafe uint256
	b-
	frame_bury 11 // biatecLiquidityFromFeeIncrement: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1022
	// this.LiqudityUsersFromFees.value = this.LiqudityUsersFromFees.value + usersLiquidityFromFeeIncrement
	bytec 13 //  "Lu"
	dup
	app_global_get
	frame_dig 10 // usersLiquidityFromFeeIncrement: unsafe uint256
	b+
	dup
	bitlen
	intc 1 // 256
	<=

	// this.LiqudityUsersFromFees.value + usersLiquidityFromFeeIncrement overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:1023
	// this.LiqudityBiatecFromFees.value = this.LiqudityBiatecFromFees.value + biatecLiquidityFromFeeIncrement
	bytec 16 //  "Lb"
	dup
	app_global_get
	frame_dig 11 // biatecLiquidityFromFeeIncrement: unsafe uint256
	b+
	dup
	bitlen
	intc 1 // 256
	<=

	// this.LiqudityBiatecFromFees.value + biatecLiquidityFromFeeIncrement overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

*if49_end:
	// contracts\BiatecClammPool.algo.ts:1026
	// newPrice = this.calculatePrice(
	//       this.assetABalance.value, // assetAQuantity: uint256,
	//       this.assetBBalance.value, // assetBQuantity: uint256,
	//       this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//       this.priceMaxSqrt.value, // priceMaxSqrt: uint256,
	//       this.Liqudity.value // liquidity: uint256
	//     )
	bytec 8 //  "L"
	app_global_get
	bytec 11 //  "pMaxS"
	app_global_get
	bytec 10 //  "pMinS"
	app_global_get
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculatePrice
	frame_bury 12 // newPrice: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1033
	// this.currentPrice.value = newPrice as uint64
	bytec 18 //  "price"
	frame_dig 12 // newPrice: unsafe uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// newPrice as uint64 overflowed 64 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	app_global_put

	// contracts\BiatecClammPool.algo.ts:1034
	// return diff;
	frame_dig 7 // diff: unsafe uint256

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 12
	retsub

// withdrawExcessAssets(uint64,uint64,uint64,uint64,uint64)uint64
*abi_route_withdrawExcessAssets:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// amountB: uint64
	txna ApplicationArgs 5
	btoi

	// amountA: uint64
	txna ApplicationArgs 4
	btoi

	// assetB: uint64
	txna ApplicationArgs 3
	btoi

	// assetA: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute withdrawExcessAssets(uint64,uint64,uint64,uint64,uint64)uint64
	callsub withdrawExcessAssets
	itob
	concat
	log
	intc 3 // 1
	return

// withdrawExcessAssets(appBiatecConfigProvider: AppID, assetA: AssetID, assetB: AssetID, amountA: uint64, amountB: uint64): uint64
withdrawExcessAssets:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 4

	// contracts\BiatecClammPool.algo.ts:1044
	// this.checkAssetsAB(assetA, assetB)
	frame_dig -3 // assetB: AssetID
	frame_dig -2 // assetA: AssetID
	callsub checkAssetsAB

	// contracts\BiatecClammPool.algo.ts:1046
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value, 'ERR_CONFIG')
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 15 //  "bc"
	app_global_get
	==

	// ERR_CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:1047
	// addressExecutiveFee = appBiatecConfigProvider.globalState('ef') as Address
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 22 //  "ef"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('ef')
	assert
	frame_bury 0 // addressExecutiveFee: address

	// contracts\BiatecClammPool.algo.ts:1049
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 21 //  "s"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('s')
	assert
	frame_bury 1 // paused: uint64

	// contracts\BiatecClammPool.algo.ts:1050
	// assert(paused === 0, 'ERR_PAUSED')
	frame_dig 1 // paused: uint64
	intc 2 // 0
	==

	// ERR_PAUSED
	assert

	// contracts\BiatecClammPool.algo.ts:1052
	// assert(
	//       this.txn.sender === addressExecutiveFee,
	//       'ERR_SENDER' // 'Only fee executor setup in the config can take the collected fees'
	//     )
	txn Sender
	frame_dig 0 // addressExecutiveFee: address
	==

	// ERR_SENDER
	assert

	// contracts\BiatecClammPool.algo.ts:1056
	// assetADecimals = 6
	intc 5 // 6
	frame_bury 2 // assetADecimals: uint64

	// *if50_condition
	// contracts\BiatecClammPool.algo.ts:1057
	// assetA.id > 0
	frame_dig -2 // assetA: AssetID
	intc 2 // 0
	>
	bz *if50_end

	// *if50_consequent
	// contracts\BiatecClammPool.algo.ts:1057
	// assetADecimals = assetA.decimals
	frame_dig -2 // assetA: AssetID
	asset_params_get AssetDecimals
	pop
	frame_bury 2 // assetADecimals: uint64

*if50_end:
	// contracts\BiatecClammPool.algo.ts:1059
	// assetADelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetADecimals)) as uint256
	intc 7 // 10
	intc 8 // 9
	frame_dig 2 // assetADecimals: uint64
	-
	exp
	itob
	frame_bury 3 // assetADelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1061
	// assetBDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetB.decimals)) as uint256
	intc 7 // 10
	intc 8 // 9
	frame_dig -3 // assetB: AssetID
	asset_params_get AssetDecimals
	pop
	-
	exp
	itob
	frame_bury 4 // assetBDelicmalScale2Scale: unsafe uint256

	// *if51_condition
	// contracts\BiatecClammPool.algo.ts:1063
	// amountA > 0
	frame_dig -4 // amountA: uint64
	intc 2 // 0
	>
	bz *if51_end

	// *if51_consequent
	// contracts\BiatecClammPool.algo.ts:1064
	// this.doAxfer(this.txn.sender, assetA, amountA)
	frame_dig -4 // amountA: uint64
	frame_dig -2 // assetA: AssetID
	txn Sender
	callsub doAxfer

*if51_end:
	// *if52_condition
	// contracts\BiatecClammPool.algo.ts:1066
	// amountB > 0
	frame_dig -5 // amountB: uint64
	intc 2 // 0
	>
	bz *if52_end

	// *if52_consequent
	// contracts\BiatecClammPool.algo.ts:1067
	// this.doAxfer(this.txn.sender, assetB, amountB)
	frame_dig -5 // amountB: uint64
	frame_dig -3 // assetB: AssetID
	txn Sender
	callsub doAxfer

*if52_end:
	// *if53_condition
	// contracts\BiatecClammPool.algo.ts:1070
	// assetA.id === 0
	frame_dig -2 // assetA: AssetID
	intc 2 // 0
	==
	bz *if53_else

	// *if53_consequent
	// contracts\BiatecClammPool.algo.ts:1071
	// assert(
	//         ((this.app.address.balance - 1_000_000) as uint256) * assetADelicmalScale2Scale >= this.assetABalance.value,
	//         'ERR_A0_B' // 'It is not possible to set higher assetABalance in algos then is in the app balance'
	//       )
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	intc 13 // 1_000_000
	-
	itob
	frame_dig 3 // assetADelicmalScale2Scale: unsafe uint256
	b*
	bytec 3 //  "ab"
	app_global_get
	b>=

	// ERR_A0_B
	assert
	b *if53_end

*if53_else:
	// contracts\BiatecClammPool.algo.ts:1076
	// assert(
	//         (this.app.address.assetBalance(assetA) as uint256) * assetADelicmalScale2Scale >= this.assetABalance.value,
	//         'ERR_A_B' // 'It is not possible to set higher assetABalance then is in the app balance'
	//       )
	global CurrentApplicationAddress
	frame_dig -2 // assetA: AssetID
	asset_holding_get AssetBalance
	pop
	itob
	frame_dig 3 // assetADelicmalScale2Scale: unsafe uint256
	b*
	bytec 3 //  "ab"
	app_global_get
	b>=

	// ERR_A_B
	assert

*if53_end:
	// contracts\BiatecClammPool.algo.ts:1081
	// assert(
	//       (this.app.address.assetBalance(assetB) as uint256) * assetBDelicmalScale2Scale >= this.assetBBalance.value,
	//       'ERR_B_B' // 'It is not possible to set higher assetBBalance then is in the app balance'
	//     )
	global CurrentApplicationAddress
	frame_dig -3 // assetB: AssetID
	asset_holding_get AssetBalance
	pop
	itob
	frame_dig 4 // assetBDelicmalScale2Scale: unsafe uint256
	b*
	bytec 4 //  "bb"
	app_global_get
	b>=

	// ERR_B_B
	assert

	// contracts\BiatecClammPool.algo.ts:1086
	// return amountA + amountB;
	frame_dig -4 // amountA: uint64
	frame_dig -5 // amountB: uint64
	+

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 4
	retsub

// sendOnlineKeyRegistration(uint64,byte[],byte[],byte[],uint64,uint64,uint64)void
*abi_route_sendOnlineKeyRegistration:
	// voteKeyDilution: uint64
	txna ApplicationArgs 7
	btoi

	// voteLast: uint64
	txna ApplicationArgs 6
	btoi

	// voteFirst: uint64
	txna ApplicationArgs 5
	btoi

	// stateProofPk: byte[]
	txna ApplicationArgs 4
	extract 2 0

	// selectionPk: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// votePk: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute sendOnlineKeyRegistration(uint64,byte[],byte[],byte[],uint64,uint64,uint64)void
	callsub sendOnlineKeyRegistration
	intc 3 // 1
	return

// sendOnlineKeyRegistration(appBiatecConfigProvider: AppID, votePk: bytes, selectionPk: bytes, stateProofPk: bytes, voteFirst: uint64, voteLast: uint64, voteKeyDilution: uint64): void
sendOnlineKeyRegistration:
	proto 7 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts\BiatecClammPool.algo.ts:1098
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value, 'ERR_CONFIG')
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 15 //  "bc"
	app_global_get
	==

	// ERR_CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:1099
	// addressExecutiveFee = appBiatecConfigProvider.globalState('ef') as Address
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 22 //  "ef"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('ef')
	assert
	frame_bury 0 // addressExecutiveFee: address

	// contracts\BiatecClammPool.algo.ts:1100
	// assert(
	//       this.txn.sender === addressExecutiveFee,
	//       'ERR_SENDER' // 'Only fee executor setup in the config can take the collected fees'
	//     )
	txn Sender
	frame_dig 0 // addressExecutiveFee: address
	==

	// ERR_SENDER
	assert

	// contracts\BiatecClammPool.algo.ts:1104
	// sendOnlineKeyRegistration({
	//       selectionPK: selectionPk,
	//       stateProofPK: stateProofPk,
	//       voteFirst: voteFirst,
	//       voteKeyDilution: voteKeyDilution,
	//       voteLast: voteLast,
	//       votePK: votePk,
	//       fee: 0,
	//     })
	itxn_begin
	intc 12 //  keyreg
	itxn_field TypeEnum

	// contracts\BiatecClammPool.algo.ts:1105
	// selectionPK: selectionPk
	frame_dig -3 // selectionPk: bytes
	itxn_field SelectionPK

	// contracts\BiatecClammPool.algo.ts:1106
	// stateProofPK: stateProofPk
	frame_dig -4 // stateProofPk: bytes
	itxn_field StateProofPK

	// contracts\BiatecClammPool.algo.ts:1107
	// voteFirst: voteFirst
	frame_dig -5 // voteFirst: uint64
	itxn_field VoteFirst

	// contracts\BiatecClammPool.algo.ts:1108
	// voteKeyDilution: voteKeyDilution
	frame_dig -7 // voteKeyDilution: uint64
	itxn_field VoteKeyDilution

	// contracts\BiatecClammPool.algo.ts:1109
	// voteLast: voteLast
	frame_dig -6 // voteLast: uint64
	itxn_field VoteLast

	// contracts\BiatecClammPool.algo.ts:1110
	// votePK: votePk
	frame_dig -2 // votePk: bytes
	itxn_field VotePK

	// contracts\BiatecClammPool.algo.ts:1111
	// fee: 0
	intc 2 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// sendOfflineKeyRegistration(uint64)void
*abi_route_sendOfflineKeyRegistration:
	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute sendOfflineKeyRegistration(uint64)void
	callsub sendOfflineKeyRegistration
	intc 3 // 1
	return

// sendOfflineKeyRegistration(appBiatecConfigProvider: AppID): void
sendOfflineKeyRegistration:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts\BiatecClammPool.algo.ts:1116
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value, 'ERR_CONFIG')
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 15 //  "bc"
	app_global_get
	==

	// ERR_CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:1117
	// addressExecutiveFee = appBiatecConfigProvider.globalState('ef') as Address
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 22 //  "ef"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('ef')
	assert
	frame_bury 0 // addressExecutiveFee: address

	// contracts\BiatecClammPool.algo.ts:1119
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 21 //  "s"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('s')
	assert
	frame_bury 1 // paused: uint64

	// contracts\BiatecClammPool.algo.ts:1120
	// assert(paused === 0, 'ERR_PAUSED')
	frame_dig 1 // paused: uint64
	intc 2 // 0
	==

	// ERR_PAUSED
	assert

	// contracts\BiatecClammPool.algo.ts:1122
	// assert(
	//       this.txn.sender === addressExecutiveFee,
	//       'ERR_SENDER' // 'Only fee executor setup in the config can take the collected fees'
	//     )
	txn Sender
	frame_dig 0 // addressExecutiveFee: address
	==

	// ERR_SENDER
	assert

	// contracts\BiatecClammPool.algo.ts:1126
	// sendOfflineKeyRegistration({ fee: 0 })
	itxn_begin
	intc 12 //  keyreg
	itxn_field TypeEnum

	// contracts\BiatecClammPool.algo.ts:1126
	// fee: 0
	intc 2 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// calculateDistributedLiquidity(uint64,uint256)uint256
*abi_route_calculateDistributedLiquidity:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// currentDeposit: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 0 (currentDeposit) for calculateDistributedLiquidity must be a uint256
	assert

	// assetLp: uint64
	txna ApplicationArgs 1
	btoi

	// execute calculateDistributedLiquidity(uint64,uint256)uint256
	callsub calculateDistributedLiquidity
	dup
	bitlen
	intc 1 // 256
	<=

	// calculateDistributedLiquidity return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateDistributedLiquidity(assetLp: AssetID, currentDeposit: uint256): uint256
calculateDistributedLiquidity:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 4

	// contracts\BiatecClammPool.algo.ts:1131
	// current = (this.app.address.assetBalance(assetLp) as uint256) - currentDeposit
	global CurrentApplicationAddress
	frame_dig -1 // assetLp: AssetID
	asset_holding_get AssetBalance
	pop
	itob
	frame_dig -2 // currentDeposit: uint256
	b-
	frame_bury 0 // current: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1132
	// minted = Uint<256>(TOTAL_SUPPLY) as uint256
	bytec 28 // 0x000000000000000000000000000000000000000000000000f9ccd8a1c5080000
	frame_bury 1 // minted: uint256

	// contracts\BiatecClammPool.algo.ts:1133
	// distributedLPTokens = minted - current
	bytec 28 //  minted: uint256
	frame_dig 0 // current: unsafe uint256
	b-
	frame_bury 2 // distributedLPTokens: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1135
	// assetLpDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - LP_TOKEN_DECIMALS)) as uint256
	intc 7 // 10
	intc 11 // 3
	exp
	itob
	frame_bury 3 // assetLpDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1136
	// ret = distributedLPTokens * assetLpDelicmalScale2Scale
	frame_dig 2 // distributedLPTokens: unsafe uint256
	frame_dig 3 // assetLpDelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 4 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1137
	// return ret;
	frame_dig 4 // ret: unsafe uint256

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 4
	retsub

// calculateLiquidityFlatPrice(uint256,uint256,uint256)uint256
*abi_route_calculateLiquidityFlatPrice:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// price: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 0 (price) for calculateLiquidityFlatPrice must be a uint256
	assert

	// y: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 1 (y) for calculateLiquidityFlatPrice must be a uint256
	assert

	// x: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 2 (x) for calculateLiquidityFlatPrice must be a uint256
	assert

	// execute calculateLiquidityFlatPrice(uint256,uint256,uint256)uint256
	callsub calculateLiquidityFlatPrice
	dup
	bitlen
	intc 1 // 256
	<=

	// calculateLiquidityFlatPrice return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateLiquidityFlatPrice(x: uint256, y: uint256, price: uint256): uint256
calculateLiquidityFlatPrice:
	proto 3 1

	// contracts\BiatecClammPool.algo.ts:1142
	// return (x * price) / s + y;
	frame_dig -1 // x: uint256
	frame_dig -3 // price: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_dig -2 // y: uint256
	b+
	retsub

// calculateLiquidityD(uint256,uint256,uint256,uint256,uint256,uint256)uint256
*abi_route_calculateLiquidityD:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// priceMaxSqrt: uint256
	txna ApplicationArgs 6
	dup
	len
	intc 0 // 32
	==

	// argument 0 (priceMaxSqrt) for calculateLiquidityD must be a uint256
	assert

	// priceMinSqrt: uint256
	txna ApplicationArgs 5
	dup
	len
	intc 0 // 32
	==

	// argument 1 (priceMinSqrt) for calculateLiquidityD must be a uint256
	assert

	// priceMax: uint256
	txna ApplicationArgs 4
	dup
	len
	intc 0 // 32
	==

	// argument 2 (priceMax) for calculateLiquidityD must be a uint256
	assert

	// priceMin: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 3 (priceMin) for calculateLiquidityD must be a uint256
	assert

	// y: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 4 (y) for calculateLiquidityD must be a uint256
	assert

	// x: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 5 (x) for calculateLiquidityD must be a uint256
	assert

	// execute calculateLiquidityD(uint256,uint256,uint256,uint256,uint256,uint256)uint256
	callsub calculateLiquidityD
	dup
	bitlen
	intc 1 // 256
	<=

	// calculateLiquidityD return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateLiquidityD(x: uint256, y: uint256, priceMin: uint256, priceMax: uint256, priceMinSqrt: uint256, priceMaxSqrt: uint256): uint256
calculateLiquidityD:
	proto 6 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 8

	// contracts\BiatecClammPool.algo.ts:1154
	// D1 = (x * x * priceMin) / s / s
	frame_dig -1 // x: uint256
	frame_dig -1 // x: uint256
	b*
	frame_dig -3 // priceMin: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 0 // D1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1156
	// D2 = (y * y) / priceMax
	frame_dig -2 // y: uint256
	frame_dig -2 // y: uint256
	b*
	frame_dig -4 // priceMax: uint256
	b/
	frame_bury 1 // D2: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1158
	// D3_1 = <uint256>2 * x * y * priceMinSqrt
	bytec 19 // 0x0000000000000000000000000000000000000000000000000000000000000002
	frame_dig -1 // x: uint256
	b*
	frame_dig -2 // y: uint256
	b*
	frame_dig -5 // priceMinSqrt: uint256
	b*
	frame_bury 2 // D3_1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1159
	// D3 = D3_1 / priceMaxSqrt / s
	frame_dig 2 // D3_1: unsafe uint256
	frame_dig -6 // priceMaxSqrt: uint256
	b/
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 3 // D3: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1162
	// D4 = (<uint256>4 * x * y) / s
	bytec 29 // 0x0000000000000000000000000000000000000000000000000000000000000004
	frame_dig -1 // x: uint256
	b*
	frame_dig -2 // y: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 4 // D4: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1164
	// D5_1 = <uint256>4 * x * y * priceMinSqrt
	bytec 29 // 0x0000000000000000000000000000000000000000000000000000000000000004
	frame_dig -1 // x: uint256
	b*
	frame_dig -2 // y: uint256
	b*
	frame_dig -5 // priceMinSqrt: uint256
	b*
	frame_bury 5 // D5_1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1165
	// D5 = D5_1 / priceMaxSqrt / s
	frame_dig 5 // D5_1: unsafe uint256
	frame_dig -6 // priceMaxSqrt: uint256
	b/
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 6 // D5: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1166
	// D = D1 + D2 + D3 + D4 - D5
	frame_dig 0 // D1: unsafe uint256
	frame_dig 1 // D2: unsafe uint256
	b+
	frame_dig 3 // D3: unsafe uint256
	b+
	frame_dig 4 // D4: unsafe uint256
	b+
	frame_dig 6 // D5: unsafe uint256
	b-
	frame_bury 7 // D: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1167
	// D_SQRT = sqrt(s * D)
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	frame_dig 7 // D: unsafe uint256
	b*
	bsqrt
	frame_bury 8 // D_SQRT: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1168
	// return D_SQRT;
	frame_dig 8 // D_SQRT: unsafe uint256

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 8
	retsub

// calculateLiquidityWithD(uint256,uint256,uint256,uint256,uint256)uint256
*abi_route_calculateLiquidityWithD:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// dSqrt: uint256
	txna ApplicationArgs 5
	dup
	len
	intc 0 // 32
	==

	// argument 0 (dSqrt) for calculateLiquidityWithD must be a uint256
	assert

	// priceMaxSqrt: uint256
	txna ApplicationArgs 4
	dup
	len
	intc 0 // 32
	==

	// argument 1 (priceMaxSqrt) for calculateLiquidityWithD must be a uint256
	assert

	// priceMinSqrt: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 2 (priceMinSqrt) for calculateLiquidityWithD must be a uint256
	assert

	// y: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 3 (y) for calculateLiquidityWithD must be a uint256
	assert

	// x: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 4 (x) for calculateLiquidityWithD must be a uint256
	assert

	// execute calculateLiquidityWithD(uint256,uint256,uint256,uint256,uint256)uint256
	callsub calculateLiquidityWithD
	dup
	bitlen
	intc 1 // 256
	<=

	// calculateLiquidityWithD return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateLiquidityWithD(x: uint256, y: uint256, priceMinSqrt: uint256, priceMaxSqrt: uint256, dSqrt: uint256): uint256
calculateLiquidityWithD:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 11

	// contracts\BiatecClammPool.algo.ts:1179
	// L1 = (x * priceMinSqrt) / s
	frame_dig -1 // x: uint256
	frame_dig -3 // priceMinSqrt: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 0 // L1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1182
	// L2 = (y * s) / priceMaxSqrt
	frame_dig -2 // y: uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig -4 // priceMaxSqrt: uint256
	b/
	frame_bury 1 // L2: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1187
	// L3_0 = <uint256>2
	bytec 19 // 0x0000000000000000000000000000000000000000000000000000000000000002
	frame_bury 2 // L3_0: uint256

	// contracts\BiatecClammPool.algo.ts:1188
	// L3_1 = L3_0 * priceMinSqrt
	bytec 19 //  L3_0: uint256
	frame_dig -3 // priceMinSqrt: uint256
	b*
	frame_bury 3 // L3_1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1189
	// L3_2 = L3_1 * s
	frame_dig 3 // L3_1: unsafe uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_bury 4 // L3_2: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1190
	// L3 = L3_2 / priceMaxSqrt
	frame_dig 4 // L3_2: unsafe uint256
	frame_dig -4 // priceMaxSqrt: uint256
	b/
	frame_bury 5 // L3: unsafe uint256

	// *if54_condition
	// contracts\BiatecClammPool.algo.ts:1191
	// <uint256>2 * s > L3
	bytec 19 // 0x0000000000000000000000000000000000000000000000000000000000000002
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 5 // L3: unsafe uint256
	b>
	bz *if54_end

	// *if54_consequent
	// contracts\BiatecClammPool.algo.ts:1192
	// nom = L1 + L2 + dSqrt
	frame_dig 0 // L1: unsafe uint256
	frame_dig 1 // L2: unsafe uint256
	b+
	frame_dig -5 // dSqrt: uint256
	b+
	frame_bury 6 // nom: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1193
	// den = <uint256>2 * s - L3
	bytec 19 // 0x0000000000000000000000000000000000000000000000000000000000000002
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 5 // L3: unsafe uint256
	b-
	frame_bury 7 // den: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1194
	// ret = (s * nom) / den
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	frame_dig 6 // nom: unsafe uint256
	b*
	frame_dig 7 // den: unsafe uint256
	b/
	frame_bury 8 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1195
	// return ret;
	frame_dig 8 // ret: unsafe uint256
	b *calculateLiquidityWithD*return

*if54_end:
	// contracts\BiatecClammPool.algo.ts:1197
	// nom = L1 + L2 - dSqrt
	frame_dig 0 // L1: unsafe uint256
	frame_dig 1 // L2: unsafe uint256
	b+
	frame_dig -5 // dSqrt: uint256
	b-
	frame_bury 9 // nom: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1198
	// den = L3 - <uint256>2 * s
	frame_dig 5 // L3: unsafe uint256
	bytec 19 // 0x0000000000000000000000000000000000000000000000000000000000000002
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	b-
	frame_bury 10 // den: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1199
	// ret = (s * nom) / den
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	frame_dig 9 // nom: unsafe uint256
	b*
	frame_dig 10 // den: unsafe uint256
	b/
	frame_bury 11 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1200
	// return ret;
	frame_dig 11 // ret: unsafe uint256

*calculateLiquidityWithD*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 11
	retsub

// calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256
*abi_route_calculatePrice:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// liquidity: uint256
	txna ApplicationArgs 5
	dup
	len
	intc 0 // 32
	==

	// argument 0 (liquidity) for calculatePrice must be a uint256
	assert

	// priceMaxSqrt: uint256
	txna ApplicationArgs 4
	dup
	len
	intc 0 // 32
	==

	// argument 1 (priceMaxSqrt) for calculatePrice must be a uint256
	assert

	// priceMinSqrt: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 2 (priceMinSqrt) for calculatePrice must be a uint256
	assert

	// assetBQuantity: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 3 (assetBQuantity) for calculatePrice must be a uint256
	assert

	// assetAQuantity: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 4 (assetAQuantity) for calculatePrice must be a uint256
	assert

	// execute calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256
	callsub calculatePrice
	dup
	bitlen
	intc 1 // 256
	<=

	// calculatePrice return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculatePrice(assetAQuantity: uint256, assetBQuantity: uint256, priceMinSqrt: uint256, priceMaxSqrt: uint256, liquidity: uint256): uint256
calculatePrice:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 7

	// *if55_condition
	// contracts\BiatecClammPool.algo.ts:1215
	// priceMinSqrt === priceMaxSqrt
	frame_dig -3 // priceMinSqrt: uint256
	frame_dig -4 // priceMaxSqrt: uint256
	b==
	bz *if55_end

	// *if55_consequent
	// contracts\BiatecClammPool.algo.ts:1216
	// ret = (priceMinSqrt * priceMinSqrt) / s
	frame_dig -3 // priceMinSqrt: uint256
	frame_dig -3 // priceMinSqrt: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 0 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1217
	// return ret;
	frame_dig 0 // ret: unsafe uint256
	b *calculatePrice*return

*if55_end:
	// contracts\BiatecClammPool.algo.ts:1220
	// a = priceMinSqrt
	frame_dig -3 // priceMinSqrt: uint256
	frame_bury 1 // a: uint256

	// contracts\BiatecClammPool.algo.ts:1221
	// b = priceMaxSqrt
	frame_dig -4 // priceMaxSqrt: uint256
	frame_bury 2 // b: uint256

	// contracts\BiatecClammPool.algo.ts:1222
	// P1 = (liquidity * a) / s
	frame_dig -5 // liquidity: uint256
	frame_dig 1 // a: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 3 // P1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1223
	// P2 = (liquidity * s) / b
	frame_dig -5 // liquidity: uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 2 // b: uint256
	b/
	frame_bury 4 // P2: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1224
	// Nom = assetBQuantity + P1
	frame_dig -2 // assetBQuantity: uint256
	frame_dig 3 // P1: unsafe uint256
	b+
	frame_bury 5 // Nom: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1225
	// Denom = assetAQuantity + P2
	frame_dig -1 // assetAQuantity: uint256
	frame_dig 4 // P2: unsafe uint256
	b+
	frame_bury 6 // Denom: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1226
	// ret = (Nom * s) / Denom
	frame_dig 5 // Nom: unsafe uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 6 // Denom: unsafe uint256
	b/
	frame_bury 7 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1227
	// return ret;
	frame_dig 7 // ret: unsafe uint256

*calculatePrice*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 7
	retsub

// calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256
*abi_route_calculateAssetBWithdrawOnAssetADeposit:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// liqudity: uint256
	txna ApplicationArgs 6
	dup
	len
	intc 0 // 32
	==

	// argument 0 (liqudity) for calculateAssetBWithdrawOnAssetADeposit must be a uint256
	assert

	// priceMaxSqrt: uint256
	txna ApplicationArgs 5
	dup
	len
	intc 0 // 32
	==

	// argument 1 (priceMaxSqrt) for calculateAssetBWithdrawOnAssetADeposit must be a uint256
	assert

	// priceMinSqrt: uint256
	txna ApplicationArgs 4
	dup
	len
	intc 0 // 32
	==

	// argument 2 (priceMinSqrt) for calculateAssetBWithdrawOnAssetADeposit must be a uint256
	assert

	// assetBBalance: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 3 (assetBBalance) for calculateAssetBWithdrawOnAssetADeposit must be a uint256
	assert

	// assetABalance: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 4 (assetABalance) for calculateAssetBWithdrawOnAssetADeposit must be a uint256
	assert

	// inAmount: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 5 (inAmount) for calculateAssetBWithdrawOnAssetADeposit must be a uint256
	assert

	// execute calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256
	callsub calculateAssetBWithdrawOnAssetADeposit
	dup
	bitlen
	intc 1 // 256
	<=

	// calculateAssetBWithdrawOnAssetADeposit return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateAssetBWithdrawOnAssetADeposit(inAmount: uint256, assetABalance: uint256, assetBBalance: uint256, priceMinSqrt: uint256, priceMaxSqrt: uint256, liqudity: uint256): uint256
calculateAssetBWithdrawOnAssetADeposit:
	proto 6 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 12

	// *if56_condition
	// contracts\BiatecClammPool.algo.ts:1240
	// priceMinSqrt === priceMaxSqrt
	frame_dig -4 // priceMinSqrt: uint256
	frame_dig -5 // priceMaxSqrt: uint256
	b==
	bz *if56_end

	// *if56_consequent
	// contracts\BiatecClammPool.algo.ts:1241
	// ret = (inAmount * priceMinSqrt * priceMinSqrt) / s / s
	frame_dig -1 // inAmount: uint256
	frame_dig -4 // priceMinSqrt: uint256
	b*
	frame_dig -4 // priceMinSqrt: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 0 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1242
	// return ret;
	frame_dig 0 // ret: unsafe uint256
	b *calculateAssetBWithdrawOnAssetADeposit*return

*if56_end:
	// contracts\BiatecClammPool.algo.ts:1245
	// x = assetABalance
	frame_dig -2 // assetABalance: uint256
	frame_bury 1 // x: uint256

	// contracts\BiatecClammPool.algo.ts:1246
	// y = assetBBalance
	frame_dig -3 // assetBBalance: uint256
	frame_bury 2 // y: uint256

	// contracts\BiatecClammPool.algo.ts:1247
	// a = priceMinSqrt
	frame_dig -4 // priceMinSqrt: uint256
	frame_bury 3 // a: uint256

	// contracts\BiatecClammPool.algo.ts:1248
	// b = priceMaxSqrt
	frame_dig -5 // priceMaxSqrt: uint256
	frame_bury 4 // b: uint256

	// contracts\BiatecClammPool.algo.ts:1249
	// L = liqudity
	frame_dig -6 // liqudity: uint256
	frame_bury 5 // L: uint256

	// contracts\BiatecClammPool.algo.ts:1251
	// P1 = (((((a /* 10D */ * b) /* 10D */ / s) * inAmount) /* AD */ / s) * L) /* 10D */ / s
	frame_dig 3 // a: uint256
	frame_dig 4 // b: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_dig -1 // inAmount: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_dig 5 // L: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 6 // P1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1253
	// P2 = (((b /* 10D */ * inAmount) /* AD */ / s) * y) /* BD */ / s
	frame_dig 4 // b: uint256
	frame_dig -1 // inAmount: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_dig 2 // y: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 7 // P2: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1255
	// P3 = (b /* 10D */ * inAmount) /* AD */ / s
	frame_dig 4 // b: uint256
	frame_dig -1 // inAmount: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 8 // P3: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1257
	// P4 = (b /* 10D */ * x) /* 10D */ / s
	frame_dig 4 // b: uint256
	frame_dig 1 // x: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 9 // P4: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1259
	// P12 = P1 + P2
	frame_dig 6 // P1: unsafe uint256
	frame_dig 7 // P2: unsafe uint256
	b+
	frame_bury 10 // P12: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1261
	// P345 = P3 + P4 + L
	frame_dig 8 // P3: unsafe uint256
	frame_dig 9 // P4: unsafe uint256
	b+
	frame_dig 5 // L: uint256
	b+
	frame_bury 11 // P345: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1263
	// ret = (P12 * s) / P345
	frame_dig 10 // P12: unsafe uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 11 // P345: unsafe uint256
	b/
	frame_bury 12 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1264
	// return ret;
	frame_dig 12 // ret: unsafe uint256

*calculateAssetBWithdrawOnAssetADeposit*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 12
	retsub

// calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256
*abi_route_calculateAssetAWithdrawOnAssetBDeposit:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// liqudity: uint256
	txna ApplicationArgs 6
	dup
	len
	intc 0 // 32
	==

	// argument 0 (liqudity) for calculateAssetAWithdrawOnAssetBDeposit must be a uint256
	assert

	// priceMaxSqrt: uint256
	txna ApplicationArgs 5
	dup
	len
	intc 0 // 32
	==

	// argument 1 (priceMaxSqrt) for calculateAssetAWithdrawOnAssetBDeposit must be a uint256
	assert

	// priceMinSqrt: uint256
	txna ApplicationArgs 4
	dup
	len
	intc 0 // 32
	==

	// argument 2 (priceMinSqrt) for calculateAssetAWithdrawOnAssetBDeposit must be a uint256
	assert

	// assetBBalance: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 3 (assetBBalance) for calculateAssetAWithdrawOnAssetBDeposit must be a uint256
	assert

	// assetABalance: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 4 (assetABalance) for calculateAssetAWithdrawOnAssetBDeposit must be a uint256
	assert

	// inAmount: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 5 (inAmount) for calculateAssetAWithdrawOnAssetBDeposit must be a uint256
	assert

	// execute calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256
	callsub calculateAssetAWithdrawOnAssetBDeposit
	dup
	bitlen
	intc 1 // 256
	<=

	// calculateAssetAWithdrawOnAssetBDeposit return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateAssetAWithdrawOnAssetBDeposit(inAmount: uint256, assetABalance: uint256, assetBBalance: uint256, priceMinSqrt: uint256, priceMaxSqrt: uint256, liqudity: uint256): uint256
calculateAssetAWithdrawOnAssetBDeposit:
	proto 6 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 13

	// *if57_condition
	// contracts\BiatecClammPool.algo.ts:1276
	// priceMinSqrt === priceMaxSqrt
	frame_dig -4 // priceMinSqrt: uint256
	frame_dig -5 // priceMaxSqrt: uint256
	b==
	bz *if57_end

	// *if57_consequent
	// contracts\BiatecClammPool.algo.ts:1277
	// ret = (inAmount * s * s) / priceMinSqrt / priceMinSqrt
	frame_dig -1 // inAmount: uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig -4 // priceMinSqrt: uint256
	b/
	frame_dig -4 // priceMinSqrt: uint256
	b/
	frame_bury 0 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1278
	// return ret;
	frame_dig 0 // ret: unsafe uint256
	b *calculateAssetAWithdrawOnAssetBDeposit*return

*if57_end:
	// contracts\BiatecClammPool.algo.ts:1280
	// x = assetABalance
	frame_dig -2 // assetABalance: uint256
	frame_bury 1 // x: uint256

	// contracts\BiatecClammPool.algo.ts:1281
	// y = assetBBalance
	frame_dig -3 // assetBBalance: uint256
	frame_bury 2 // y: uint256

	// contracts\BiatecClammPool.algo.ts:1282
	// a = priceMinSqrt
	frame_dig -4 // priceMinSqrt: uint256
	frame_bury 3 // a: uint256

	// contracts\BiatecClammPool.algo.ts:1283
	// b = priceMaxSqrt
	frame_dig -5 // priceMaxSqrt: uint256
	frame_bury 4 // b: uint256

	// contracts\BiatecClammPool.algo.ts:1284
	// L = liqudity
	frame_dig -6 // liqudity: uint256
	frame_bury 5 // L: uint256

	// contracts\BiatecClammPool.algo.ts:1287
	// P1 = (inAmount * L) / s
	frame_dig -1 // inAmount: uint256
	frame_dig 5 // L: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 6 // P1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1289
	// P2 = (((b * inAmount) / s) * x) / s
	frame_dig 4 // b: uint256
	frame_dig -1 // inAmount: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_dig 1 // x: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 7 // P2: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1291
	// nom = P1 + P2
	frame_dig 6 // P1: unsafe uint256
	frame_dig 7 // P2: unsafe uint256
	b+
	frame_bury 8 // nom: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1293
	// P3 = (((a * b) / s) * L) / s
	frame_dig 3 // a: uint256
	frame_dig 4 // b: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_dig 5 // L: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 9 // P3: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1295
	// P4 = (b * inAmount) / s
	frame_dig 4 // b: uint256
	frame_dig -1 // inAmount: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 10 // P4: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1297
	// P5 = (b * y) / s
	frame_dig 4 // b: uint256
	frame_dig 2 // y: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 11 // P5: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1299
	// denom = P3 + P4 + P5
	frame_dig 9 // P3: unsafe uint256
	frame_dig 10 // P4: unsafe uint256
	b+
	frame_dig 11 // P5: unsafe uint256
	b+
	frame_bury 12 // denom: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1301
	// ret = (nom * s) / denom
	frame_dig 8 // nom: unsafe uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 12 // denom: unsafe uint256
	b/
	frame_bury 13 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1302
	// return ret;
	frame_dig 13 // ret: unsafe uint256

*calculateAssetAWithdrawOnAssetBDeposit*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 13
	retsub

// calculateAssetAWithdrawOnLpDeposit(uint256,uint256,uint256)uint256
*abi_route_calculateAssetAWithdrawOnLpDeposit:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// liqudity: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 0 (liqudity) for calculateAssetAWithdrawOnLpDeposit must be a uint256
	assert

	// assetABalance: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 1 (assetABalance) for calculateAssetAWithdrawOnLpDeposit must be a uint256
	assert

	// inAmount: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 2 (inAmount) for calculateAssetAWithdrawOnLpDeposit must be a uint256
	assert

	// execute calculateAssetAWithdrawOnLpDeposit(uint256,uint256,uint256)uint256
	callsub calculateAssetAWithdrawOnLpDeposit
	dup
	bitlen
	intc 1 // 256
	<=

	// calculateAssetAWithdrawOnLpDeposit return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateAssetAWithdrawOnLpDeposit(inAmount: uint256, assetABalance: uint256, liqudity: uint256): uint256
calculateAssetAWithdrawOnLpDeposit:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts\BiatecClammPool.algo.ts:1310
	// ret = (assetABalance * inAmount) / liqudity
	frame_dig -2 // assetABalance: uint256
	frame_dig -1 // inAmount: uint256
	b*
	frame_dig -3 // liqudity: uint256
	b/
	frame_bury 0 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1311
	// return ret;
	frame_dig 0 // ret: unsafe uint256

	// set the subroutine return value
	frame_bury 0
	retsub

// calculateAssetBWithdrawOnLpDeposit(uint256,uint256,uint256)uint256
*abi_route_calculateAssetBWithdrawOnLpDeposit:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// liqudity: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 0 (liqudity) for calculateAssetBWithdrawOnLpDeposit must be a uint256
	assert

	// assetBBalance: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 1 (assetBBalance) for calculateAssetBWithdrawOnLpDeposit must be a uint256
	assert

	// inAmount: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 2 (inAmount) for calculateAssetBWithdrawOnLpDeposit must be a uint256
	assert

	// execute calculateAssetBWithdrawOnLpDeposit(uint256,uint256,uint256)uint256
	callsub calculateAssetBWithdrawOnLpDeposit
	dup
	bitlen
	intc 1 // 256
	<=

	// calculateAssetBWithdrawOnLpDeposit return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateAssetBWithdrawOnLpDeposit(inAmount: uint256, assetBBalance: uint256, liqudity: uint256): uint256
calculateAssetBWithdrawOnLpDeposit:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts\BiatecClammPool.algo.ts:1319
	// ret = (assetBBalance * inAmount) / liqudity
	frame_dig -2 // assetBBalance: uint256
	frame_dig -1 // inAmount: uint256
	b*
	frame_dig -3 // liqudity: uint256
	b/
	frame_bury 0 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1320
	// return ret;
	frame_dig 0 // ret: unsafe uint256

	// set the subroutine return value
	frame_bury 0
	retsub

// calculateAssetBDepositOnAssetADeposit(uint256,uint256,uint256,uint256)uint256
*abi_route_calculateAssetBDepositOnAssetADeposit:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// assetBBalance: uint256
	txna ApplicationArgs 4
	dup
	len
	intc 0 // 32
	==

	// argument 0 (assetBBalance) for calculateAssetBDepositOnAssetADeposit must be a uint256
	assert

	// assetABalance: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 1 (assetABalance) for calculateAssetBDepositOnAssetADeposit must be a uint256
	assert

	// inAmountB: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 2 (inAmountB) for calculateAssetBDepositOnAssetADeposit must be a uint256
	assert

	// inAmountA: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 3 (inAmountA) for calculateAssetBDepositOnAssetADeposit must be a uint256
	assert

	// execute calculateAssetBDepositOnAssetADeposit(uint256,uint256,uint256,uint256)uint256
	callsub calculateAssetBDepositOnAssetADeposit
	dup
	bitlen
	intc 1 // 256
	<=

	// calculateAssetBDepositOnAssetADeposit return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateAssetBDepositOnAssetADeposit(inAmountA: uint256, inAmountB: uint256, assetABalance: uint256, assetBBalance: uint256): uint256
calculateAssetBDepositOnAssetADeposit:
	proto 4 1

	// *if58_condition
	// contracts\BiatecClammPool.algo.ts:1330
	// assetABalance > <uint256>0
	frame_dig -3 // assetABalance: uint256
	bytec 6 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	bz *if58_end

	// *if58_consequent
	// contracts\BiatecClammPool.algo.ts:1331
	// return (inAmountA * assetBBalance) / assetABalance;
	frame_dig -1 // inAmountA: uint256
	frame_dig -4 // assetBBalance: uint256
	b*
	frame_dig -3 // assetABalance: uint256
	b/
	retsub

*if58_end:
	// contracts\BiatecClammPool.algo.ts:1334
	// return inAmountB;
	frame_dig -2 // inAmountB: uint256
	retsub

// calculateAssetADepositOnAssetBDeposit(uint256,uint256,uint256,uint256)uint256
*abi_route_calculateAssetADepositOnAssetBDeposit:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// assetBBalance: uint256
	txna ApplicationArgs 4
	dup
	len
	intc 0 // 32
	==

	// argument 0 (assetBBalance) for calculateAssetADepositOnAssetBDeposit must be a uint256
	assert

	// assetABalance: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 1 (assetABalance) for calculateAssetADepositOnAssetBDeposit must be a uint256
	assert

	// inAmountB: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 2 (inAmountB) for calculateAssetADepositOnAssetBDeposit must be a uint256
	assert

	// inAmountA: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 3 (inAmountA) for calculateAssetADepositOnAssetBDeposit must be a uint256
	assert

	// execute calculateAssetADepositOnAssetBDeposit(uint256,uint256,uint256,uint256)uint256
	callsub calculateAssetADepositOnAssetBDeposit
	dup
	bitlen
	intc 1 // 256
	<=

	// calculateAssetADepositOnAssetBDeposit return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateAssetADepositOnAssetBDeposit(inAmountA: uint256, inAmountB: uint256, assetABalance: uint256, assetBBalance: uint256): uint256
calculateAssetADepositOnAssetBDeposit:
	proto 4 1

	// *if59_condition
	// contracts\BiatecClammPool.algo.ts:1344
	// assetBBalance > <uint256>0
	frame_dig -4 // assetBBalance: uint256
	bytec 6 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	bz *if59_end

	// *if59_consequent
	// contracts\BiatecClammPool.algo.ts:1345
	// return (inAmountB * assetABalance) / assetBBalance;
	frame_dig -2 // inAmountB: uint256
	frame_dig -3 // assetABalance: uint256
	b*
	frame_dig -4 // assetBBalance: uint256
	b/
	retsub

*if59_end:
	// contracts\BiatecClammPool.algo.ts:1348
	// return inAmountA;
	frame_dig -1 // inAmountA: uint256
	retsub

// status(uint64,uint64,uint64,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
*abi_route_status:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// assetLp: uint64
	txna ApplicationArgs 4
	btoi

	// assetB: uint64
	txna ApplicationArgs 3
	btoi

	// assetA: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute status(uint64,uint64,uint64,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	callsub status
	concat
	log
	intc 3 // 1
	return

// status(appBiatecConfigProvider: AppID, assetA: AssetID, assetB: AssetID, assetLp: AssetID): AmmStatus
status:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts\BiatecClammPool.algo.ts:1353
	// assert(
	//       appBiatecConfigProvider === this.appBiatecConfigProvider.value,
	//       'ERR_CONFIG' // 'appBiatecConfigProvider must match to the global variable app id'
	//     )
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 15 //  "bc"
	app_global_get
	==

	// ERR_CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:1357
	// assert(assetA.id === this.assetA.value)
	frame_dig -2 // assetA: AssetID
	bytec 23 //  "a"
	app_global_get
	==
	assert

	// contracts\BiatecClammPool.algo.ts:1358
	// assert(assetB.id === this.assetB.value)
	frame_dig -3 // assetB: AssetID
	bytec 24 //  "b"
	app_global_get
	==
	assert

	// contracts\BiatecClammPool.algo.ts:1359
	// assert(this.assetLp.value === assetLp.id, 'ERR_LP')
	bytec 20 //  "lp"
	app_global_get
	frame_dig -4 // assetLp: AssetID
	==

	// ERR_LP
	assert

	// contracts\BiatecClammPool.algo.ts:1360
	// biatecFee = this.appBiatecConfigProvider.value.globalState('f') as uint256
	bytec 15 //  "bc"
	app_global_get
	bytec 17 //  "f"
	app_global_get_ex

	// global state value does not exist: this.appBiatecConfigProvider.value.globalState('f')
	assert
	frame_bury 0 // biatecFee: uint256

	// contracts\BiatecClammPool.algo.ts:1361
	// realBalanceA =
	//       assetA.id === 0
	//         ? globals.currentApplicationAddress.balance
	//         : globals.currentApplicationAddress.assetBalance(assetA)
	frame_dig -2 // assetA: AssetID
	intc 2 // 0
	==
	bz *ternary0_false
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	b *ternary0_end

*ternary0_false:
	global CurrentApplicationAddress
	frame_dig -2 // assetA: AssetID
	asset_holding_get AssetBalance
	pop

*ternary0_end:
	frame_bury 1 // realBalanceA: uint64

	// contracts\BiatecClammPool.algo.ts:1365
	// realBalanceB = globals.currentApplicationAddress.assetBalance(assetB)
	global CurrentApplicationAddress
	frame_dig -3 // assetB: AssetID
	asset_holding_get AssetBalance
	pop
	frame_bury 2 // realBalanceB: uint64

	// contracts\BiatecClammPool.algo.ts:1366
	// return {
	//       assetA: this.assetA.value,
	//       assetB: this.assetB.value,
	//       poolToken: this.assetLp.value,
	//       assetABalance: this.assetABalance.value as uint64,
	//       assetBBalance: this.assetBBalance.value as uint64,
	//       realABalance: realBalanceA,
	//       realBBalance: realBalanceB,
	//       fee: this.fee.value,
	//       biatecFee: biatecFee as uint64,
	//       currentLiqudity: this.Liqudity.value as uint64,
	//       liqudityBiatecFromFees: this.LiqudityBiatecFromFees.value as uint64,
	//       liqudityUsersFromFees: this.LiqudityUsersFromFees.value as uint64,
	//       price: this.currentPrice.value as uint64,
	//       priceMaxSqrt: this.priceMaxSqrt.value as uint64,
	//       priceMinSqrt: this.priceMinSqrt.value as uint64,
	//       releasedLiqudity: this.calculateDistributedLiquidity(assetLp, <uint256>0) as uint64,
	//       scale: SCALE,
	//       verificationClass: this.verificationClass.value,
	//     };
	bytec 31 // 0x000000003b9aca00
	bytec 3 //  "ab"
	app_global_get
	dup
	bitlen
	intc 4 // 64
	<=

	// this.assetABalance.value as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	concat
	bytec 4 //  "bb"
	app_global_get
	dup
	bitlen
	intc 4 // 64
	<=

	// this.assetBBalance.value as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	concat
	frame_dig 1 // realBalanceA: uint64
	itob
	concat
	frame_dig 2 // realBalanceB: uint64
	itob
	concat
	bytec 10 //  "pMinS"
	app_global_get
	dup
	bitlen
	intc 4 // 64
	<=

	// this.priceMinSqrt.value as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	concat
	bytec 11 //  "pMaxS"
	app_global_get
	dup
	bitlen
	intc 4 // 64
	<=

	// this.priceMaxSqrt.value as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	concat
	bytec 8 //  "L"
	app_global_get
	dup
	bitlen
	intc 4 // 64
	<=

	// this.Liqudity.value as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	concat
	bytec 6 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_dig -4 // assetLp: AssetID
	callsub calculateDistributedLiquidity
	dup
	bitlen
	intc 4 // 64
	<=

	// this.calculateDistributedLiquidity(assetLp, <uint256>0) as uint64 overflowed 64 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	itob
	concat
	bytec 13 //  "Lu"
	app_global_get
	dup
	bitlen
	intc 4 // 64
	<=

	// this.LiqudityUsersFromFees.value as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	concat
	bytec 16 //  "Lb"
	app_global_get
	dup
	bitlen
	intc 4 // 64
	<=

	// this.LiqudityBiatecFromFees.value as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	concat
	bytec 23 //  "a"
	app_global_get
	itob
	concat
	bytec 24 //  "b"
	app_global_get
	itob
	concat
	bytec 20 //  "lp"
	app_global_get
	itob
	concat
	bytec 18 //  "price"
	app_global_get
	itob
	concat
	bytec 17 //  "f"
	app_global_get
	itob
	concat
	frame_dig 0 // biatecFee: uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// biatecFee as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	concat
	bytec 25 //  "c"
	app_global_get
	itob
	concat

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0xd1717fe5 // method "getCurrentPrice()uint64"
	pushbytes 0xe3a43a4a // method "getPriceDivider()uint64"
	pushbytes 0x1d764a9e // method "getLPTokenId()uint64"
	pushbytes 0xb313012e // method "bootstrap(uint64,uint64,uint64,uint64,pay,uint64,uint64,uint64,uint64,uint8)uint64"
	pushbytes 0x0440fa8f // method "addLiquidity(uint64,uint64,txn,txn,uint64,uint64,uint64)uint64"
	pushbytes 0x549a90a4 // method "removeLiquidity(uint64,uint64,axfer,uint64,uint64,uint64)uint256"
	pushbytes 0x894a934f // method "removeLiquidityAdmin(uint64,uint64,uint64,uint64,uint256)uint256"
	pushbytes 0x2013349e // method "swap(uint64,uint64,uint64,txn,uint64,uint64,uint64)uint256"
	pushbytes 0xce564412 // method "distributeExcessAssets(uint64,uint64,uint64,uint256,uint256)uint256"
	pushbytes 0x22b746c8 // method "withdrawExcessAssets(uint64,uint64,uint64,uint64,uint64)uint64"
	pushbytes 0x83925c17 // method "sendOnlineKeyRegistration(uint64,byte[],byte[],byte[],uint64,uint64,uint64)void"
	pushbytes 0x0955c25a // method "sendOfflineKeyRegistration(uint64)void"
	pushbytes 0x39eca854 // method "calculateDistributedLiquidity(uint64,uint256)uint256"
	pushbytes 0xff695816 // method "calculateLiquidityFlatPrice(uint256,uint256,uint256)uint256"
	pushbytes 0xdca3d4d6 // method "calculateLiquidityD(uint256,uint256,uint256,uint256,uint256,uint256)uint256"
	pushbytes 0x69d623b1 // method "calculateLiquidityWithD(uint256,uint256,uint256,uint256,uint256)uint256"
	pushbytes 0x3c2c7e4a // method "calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256"
	pushbytes 0x4bf571b6 // method "calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256"
	pushbytes 0x52f7923f // method "calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256"
	pushbytes 0x6c25b3f3 // method "calculateAssetAWithdrawOnLpDeposit(uint256,uint256,uint256)uint256"
	pushbytes 0x05fc238c // method "calculateAssetBWithdrawOnLpDeposit(uint256,uint256,uint256)uint256"
	pushbytes 0xe64ddd82 // method "calculateAssetBDepositOnAssetADeposit(uint256,uint256,uint256,uint256)uint256"
	pushbytes 0x49f68370 // method "calculateAssetADepositOnAssetBDeposit(uint256,uint256,uint256,uint256)uint256"
	pushbytes 0x4feca359 // method "status(uint64,uint64,uint64,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)"
	txna ApplicationArgs 0
	match *abi_route_getCurrentPrice *abi_route_getPriceDivider *abi_route_getLPTokenId *abi_route_bootstrap *abi_route_addLiquidity *abi_route_removeLiquidity *abi_route_removeLiquidityAdmin *abi_route_swap *abi_route_distributeExcessAssets *abi_route_withdrawExcessAssets *abi_route_sendOnlineKeyRegistration *abi_route_sendOfflineKeyRegistration *abi_route_calculateDistributedLiquidity *abi_route_calculateLiquidityFlatPrice *abi_route_calculateLiquidityD *abi_route_calculateLiquidityWithD *abi_route_calculatePrice *abi_route_calculateAssetBWithdrawOnAssetADeposit *abi_route_calculateAssetAWithdrawOnAssetBDeposit *abi_route_calculateAssetAWithdrawOnLpDeposit *abi_route_calculateAssetBWithdrawOnLpDeposit *abi_route_calculateAssetBDepositOnAssetADeposit *abi_route_calculateAssetADepositOnAssetBDeposit *abi_route_status

	// this contract does not implement the given ABI method for call NoOp
	err

*call_UpdateApplication:
	pushbytes 0x5fc885a0 // method "updateApplication(uint64,byte[])void"
	txna ApplicationArgs 0
	match *abi_route_updateApplication

	// this contract does not implement the given ABI method for call UpdateApplication
	err
#pragma version 10
intcblock 32 0 256 1 64 6 8 4 5 10 3 1_000_000 2 9
bytecblock 0x 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 0x000000000000000000000000000000000000000000000000000000003b9aca00 0x0000000000000000000000000000000000000000000000000000000000000000 0x6162 0x6262 0x0a8101 0x151f7c75 0x4c 0x6164 0x6264 0xFFFFFFFFFFFFFFFF 0x4c75 0x6263 0x4c62 0x704d696e53 0x704d617853 0x7072696365 0x66 0x73 0x0000000000000000000000000000000000000000000000000000000000000002 0x6c70 "BIATEC-CLAMM-01-05-05" 0x704d6178 0x6566 0x61 0x62 0x000000000000000000000000000000000000000000000000f9ccd8a1c5080000 0x0000000000000000000000000000000000000000000000000000000000000004 0x70 0x63 0x0000000000000000000000000000000000000000000000000000000000000001 0x000000003b9aca00 0x7363616c65 0x7363766572 0x704d696e 0x422d 0x00

// This TEAL was generated by TEALScript v0.107.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 5 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_UpdateApplication *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	intc 3 // 1
	return

// createApplication(): void
//
// Initial setup
createApplication:
	proto 0 0

	// contracts\BiatecClammPool.algo.ts:118
	// log(version)
	bytec 22 // "BIATEC-CLAMM-01-05-05"
	log

	// contracts\BiatecClammPool.algo.ts:119
	// this.scale.value = SCALE
	bytec 33 //  "scale"
	pushint 1000000000
	app_global_put

	// contracts\BiatecClammPool.algo.ts:120
	// this.fee.value = <uint64>0
	bytec 18 //  "f"
	intc 1 // 0
	app_global_put

	// contracts\BiatecClammPool.algo.ts:121
	// this.Liquidity.value = <uint256>0
	bytec 8 //  "L"
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	app_global_put

	// contracts\BiatecClammPool.algo.ts:122
	// this.LiquidityBiatecFromFees.value = <uint256>0
	bytec 14 //  "Lb"
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	app_global_put

	// contracts\BiatecClammPool.algo.ts:123
	// this.LiquidityUsersFromFees.value = <uint256>0
	bytec 12 //  "Lu"
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	app_global_put

	// contracts\BiatecClammPool.algo.ts:124
	// this.priceMax.value = 0
	bytec 23 //  "pMax"
	intc 1 // 0
	app_global_put

	// contracts\BiatecClammPool.algo.ts:125
	// this.version.value = version
	bytec 34 //  "scver"
	bytec 22 // "BIATEC-CLAMM-01-05-05"
	app_global_put

	// contracts\BiatecClammPool.algo.ts:126
	// this.setupFinished.value = false
	bytec 19 //  "s"
	intc 1 // 0
	bytec 37 // 0x00
	intc 1 // 0
	uncover 2
	setbit
	app_global_put
	retsub

// updateApplication(uint64,byte[])void
*abi_route_updateApplication:
	// newVersion: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateApplication(uint64,byte[])void
	callsub updateApplication
	intc 3 // 1
	return

// updateApplication(appBiatecConfigProvider: AppID, newVersion: bytes): void
//
// addressUdpater from global biatec configuration is allowed to update application
updateApplication:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts\BiatecClammPool.algo.ts:133
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value, 'E_CONFIG')
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 13 //  "bc"
	app_global_get
	==

	// E_CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:134
	// addressUdpater = appBiatecConfigProvider.globalState('u') as Address
	frame_dig -1 // appBiatecConfigProvider: AppID
	pushbytes 0x75 // "u"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('u')
	assert
	frame_bury 0 // addressUdpater: address

	// contracts\BiatecClammPool.algo.ts:135
	// assert(this.txn.sender === addressUdpater, 'E_UPDATER')
	txn Sender
	frame_dig 0 // addressUdpater: address
	==

	// E_UPDATER
	assert

	// contracts\BiatecClammPool.algo.ts:136
	// log(version)
	bytec 22 // "BIATEC-CLAMM-01-05-05"
	log

	// contracts\BiatecClammPool.algo.ts:137
	// log(newVersion)
	frame_dig -2 // newVersion: bytes
	log

	// contracts\BiatecClammPool.algo.ts:138
	// this.version.value = version
	bytec 34 //  "scver"
	bytec 22 // "BIATEC-CLAMM-01-05-05"
	app_global_put
	retsub

// getCurrentPrice()uint64
*abi_route_getCurrentPrice:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// execute getCurrentPrice()uint64
	callsub getCurrentPrice
	itob
	concat
	log
	intc 3 // 1
	return

// getCurrentPrice(): uint64
getCurrentPrice:
	proto 0 1

	// contracts\BiatecClammPool.algo.ts:143
	// return this.currentPrice.value;
	bytec 17 //  "price"
	app_global_get
	retsub

// getPriceDivider()uint64
*abi_route_getPriceDivider:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// execute getPriceDivider()uint64
	callsub getPriceDivider
	itob
	concat
	log
	intc 3 // 1
	return

// getPriceDivider(): uint64
getPriceDivider:
	proto 0 1

	// contracts\BiatecClammPool.algo.ts:148
	// return this.scale.value;
	bytec 33 //  "scale"
	app_global_get
	retsub

// getLPTokenId()uint64
*abi_route_getLPTokenId:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// execute getLPTokenId()uint64
	callsub getLPTokenId
	itob
	concat
	log
	intc 3 // 1
	return

// getLPTokenId(): uint64
getLPTokenId:
	proto 0 1

	// contracts\BiatecClammPool.algo.ts:153
	// return this.assetLp.value;
	bytec 21 //  "lp"
	app_global_get
	retsub

// bootstrap(uint64,uint64,uint64,uint64,pay,uint64,uint64,uint64,uint64,uint64,byte[])uint64
*abi_route_bootstrap:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// nativeTokenName: byte[]
	txna ApplicationArgs 10
	extract 2 0

	// verificationClass: uint64
	txna ApplicationArgs 9
	btoi

	// currentPrice: uint64
	txna ApplicationArgs 8
	btoi

	// priceMax: uint64
	txna ApplicationArgs 7
	btoi

	// priceMin: uint64
	txna ApplicationArgs 6
	btoi

	// fee: uint64
	txna ApplicationArgs 5
	btoi

	// txSeed: pay
	txn GroupIndex
	intc 3 // 1
	-
	dup
	gtxns TypeEnum
	intc 3 //  pay
	==

	// argument 6 (txSeed) for bootstrap must be a pay transaction
	assert

	// appBiatecPoolProvider: uint64
	txna ApplicationArgs 4
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 3
	btoi

	// assetB: uint64
	txna ApplicationArgs 2
	btoi

	// assetA: uint64
	txna ApplicationArgs 1
	btoi

	// execute bootstrap(uint64,uint64,uint64,uint64,pay,uint64,uint64,uint64,uint64,uint64,byte[])uint64
	callsub bootstrap
	itob
	concat
	log
	intc 3 // 1
	return

// bootstrap(assetA: AssetID, assetB: AssetID, appBiatecConfigProvider: AppID, appBiatecPoolProvider: AppID, txSeed: PayTxn, fee: uint64, priceMin: uint64, priceMax: uint64, currentPrice: uint64, verificationClass: uint64, nativeTokenName: bytes): uint64
//
// Only Biatec Pool Provider can deploy and bootsrap this smart contract
// @param assetA Asset A ID must be lower then Asset B ID, or can be equal to Asset B ID for staking pools
// @param assetB Asset B
// @param appBiatecConfigProvider Biatec amm provider
// @param appBiatecPoolProvider Pool provider
// @param txSeed Seed transaction so that smart contract can opt in to the assets
// @param fee Fee in base level (9 decimals). value 1_000_000_000 = 1 = 100%. 10_000_000 = 1%. 1_000_000 = 0.1%
// @param priceMin Min price range. At this point all assets are in asset A.
// @param priceMax Max price range. At this point all assets are in asset B.
// @param currentPrice Deployer can specify the current price for easier deployemnt.
// @param verificationClass Minimum verification level from the biatec identity. Level 0 means no kyc.
// @param nativeTokenName Name of the native token (e.g., 'ALGO', 'VOI', 'ARAMID') when assetA.id = 0
// @returns LP token ID
bootstrap:
	proto 11 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 5

	// contracts\BiatecClammPool.algo.ts:184
	// assert(globals.callerApplicationID == appBiatecPoolProvider, 'Only the pool provider can init this contract')
	global CallerApplicationID
	frame_dig -4 // appBiatecPoolProvider: AppID
	==

	// Only the pool provider can init this contract
	assert

	// contracts\BiatecClammPool.algo.ts:185
	// verifyPayTxn(txSeed, { receiver: this.app.address, amount: { greaterThanEqualTo: 400_000 } })
	// verify receiver
	frame_dig -5 // txSeed: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"txSeed","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -5 // txSeed: PayTxn
	gtxns Amount
	pushint 400_000
	>=

	// transaction verification failed: {"txn":"txSeed","field":"amount","condition":"greaterThanEqualTo","expected":">=400_000"}
	assert

	// contracts\BiatecClammPool.algo.ts:186
	// assert(this.priceMax.value === 0, 'E_PRICE_MAX')
	bytec 23 //  "pMax"
	app_global_get
	intc 1 // 0
	==

	// E_PRICE_MAX
	assert

	// contracts\BiatecClammPool.algo.ts:187
	// assert(this.txn.sender === this.app.creator, 'E_SENDER')
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==

	// E_SENDER
	assert

	// contracts\BiatecClammPool.algo.ts:188
	// assert(priceMax > 0, 'E_PRICE')
	frame_dig -8 // priceMax: uint64
	intc 1 // 0
	>

	// E_PRICE
	assert

	// contracts\BiatecClammPool.algo.ts:191
	// assert(fee <= SCALE / 10)
	frame_dig -6 // fee: uint64
	pushint 100000000
	<=
	assert

	// contracts\BiatecClammPool.algo.ts:193
	// assert(!this.currentPrice.exists)
	txna Applications 0
	bytec 17 //  "price"
	app_global_get_ex
	swap
	pop
	!
	assert

	// *if0_condition
	// contracts\BiatecClammPool.algo.ts:194
	// assetA.id > 0
	frame_dig -1 // assetA: AssetID
	intc 1 // 0
	>
	bz *if0_end

	// *if0_consequent
	// contracts\BiatecClammPool.algo.ts:195
	// assert(assetA.decimals <= SCALE_DECIMALS)
	frame_dig -1 // assetA: AssetID
	asset_params_get AssetDecimals
	pop
	intc 13 // 9
	<=
	assert

*if0_end:
	// *if1_condition
	// contracts\BiatecClammPool.algo.ts:197
	// assetB.id > 0
	frame_dig -2 // assetB: AssetID
	intc 1 // 0
	>
	bz *if1_end

	// *if1_consequent
	// contracts\BiatecClammPool.algo.ts:198
	// assert(assetB.decimals <= SCALE_DECIMALS)
	frame_dig -2 // assetB: AssetID
	asset_params_get AssetDecimals
	pop
	intc 13 // 9
	<=
	assert

*if1_end:
	// contracts\BiatecClammPool.algo.ts:201
	// assert(this.fee.value <= 0, 'E_FEE')
	bytec 18 //  "f"
	app_global_get
	intc 1 // 0
	<=

	// E_FEE
	assert

	// contracts\BiatecClammPool.algo.ts:203
	// poolProviderFromConfig = appBiatecConfigProvider.globalState('p') as AppID
	frame_dig -3 // appBiatecConfigProvider: AppID
	bytec 29 //  "p"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('p')
	assert
	frame_bury 0 // poolProviderFromConfig: uint64

	// contracts\BiatecClammPool.algo.ts:204
	// assert(
	//       appBiatecPoolProvider === poolProviderFromConfig,
	//       'E_CONFIG' // 'appBiatecPoolProvider must match to the config in appBiatecConfigProvider'
	//     )
	frame_dig -4 // appBiatecPoolProvider: AppID
	frame_dig 0 // poolProviderFromConfig: uint64
	==

	// E_CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:208
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -3 // appBiatecConfigProvider: AppID
	bytec 19 //  "s"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('s')
	assert
	frame_bury 1 // paused: uint64

	// contracts\BiatecClammPool.algo.ts:209
	// assert(paused === 0, 'E_PAUSED')
	frame_dig 1 // paused: uint64
	intc 1 // 0
	==

	// E_PAUSED
	assert

	// contracts\BiatecClammPool.algo.ts:211
	// this.appBiatecConfigProvider.value = appBiatecConfigProvider
	bytec 13 //  "bc"
	frame_dig -3 // appBiatecConfigProvider: AppID
	app_global_put

	// contracts\BiatecClammPool.algo.ts:213
	// this.priceMin.value = priceMin
	bytec 35 //  "pMin"
	frame_dig -7 // priceMin: uint64
	app_global_put

	// contracts\BiatecClammPool.algo.ts:214
	// this.priceMax.value = priceMax
	bytec 23 //  "pMax"
	frame_dig -8 // priceMax: uint64
	app_global_put

	// contracts\BiatecClammPool.algo.ts:215
	// this.priceMinSqrt.value = sqrt((priceMin as uint256) * s)
	bytec 15 //  "pMinS"
	frame_dig -7 // priceMin: uint64
	itob
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	bsqrt
	dup
	bitlen
	intc 2 // 256
	<=

	// sqrt((priceMin as uint256) * s) overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:216
	// this.priceMaxSqrt.value = sqrt((priceMax as uint256) * s)
	bytec 16 //  "pMaxS"
	frame_dig -8 // priceMax: uint64
	itob
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	bsqrt
	dup
	bitlen
	intc 2 // 256
	<=

	// sqrt((priceMax as uint256) * s) overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:217
	// this.assetABalanceBaseScale.value = <uint256>0
	bytec 4 //  "ab"
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	app_global_put

	// contracts\BiatecClammPool.algo.ts:218
	// this.assetBBalanceBaseScale.value = <uint256>0
	bytec 5 //  "bb"
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	app_global_put

	// contracts\BiatecClammPool.algo.ts:219
	// this.currentPrice.value = currentPrice
	bytec 17 //  "price"
	frame_dig -9 // currentPrice: uint64
	app_global_put

	// contracts\BiatecClammPool.algo.ts:221
	// this.assetA.value = assetA.id
	bytec 25 //  "a"
	frame_dig -1 // assetA: AssetID
	app_global_put

	// contracts\BiatecClammPool.algo.ts:222
	// this.assetB.value = assetB.id
	bytec 26 //  "b"
	frame_dig -2 // assetB: AssetID
	app_global_put

	// contracts\BiatecClammPool.algo.ts:223
	// this.assetLp.value = this.doCreatePoolToken(assetA, assetB, nativeTokenName).id
	bytec 21 //  "lp"
	frame_dig -11 // nativeTokenName: bytes
	frame_dig -2 // assetB: AssetID
	frame_dig -1 // assetA: AssetID
	callsub doCreatePoolToken
	app_global_put

	// contracts\BiatecClammPool.algo.ts:224
	// this.fee.value = fee
	bytec 18 //  "f"
	frame_dig -6 // fee: uint64
	app_global_put

	// contracts\BiatecClammPool.algo.ts:225
	// this.doOptIn(assetA)
	frame_dig -1 // assetA: AssetID
	callsub doOptIn

	// *if2_condition
	// contracts\BiatecClammPool.algo.ts:226
	// assetA.id !== assetB.id
	frame_dig -1 // assetA: AssetID
	frame_dig -2 // assetB: AssetID
	!=
	bz *if2_end

	// *if2_consequent
	// contracts\BiatecClammPool.algo.ts:227
	// this.doOptIn(assetB)
	frame_dig -2 // assetB: AssetID
	callsub doOptIn

*if2_end:
	// contracts\BiatecClammPool.algo.ts:229
	// this.verificationClass.value = verificationClass
	bytec 30 //  "c"
	frame_dig -10 // verificationClass: uint64
	app_global_put

	// contracts\BiatecClammPool.algo.ts:231
	// assetADecimals = 6
	intc 5 // 6
	frame_bury 2 // assetADecimals: uint64

	// *if3_condition
	// contracts\BiatecClammPool.algo.ts:232
	// assetA.id > 0
	frame_dig -1 // assetA: AssetID
	intc 1 // 0
	>
	bz *if3_end

	// *if3_consequent
	// contracts\BiatecClammPool.algo.ts:232
	// assetADecimals = assetA.decimals
	frame_dig -1 // assetA: AssetID
	asset_params_get AssetDecimals
	pop
	frame_bury 2 // assetADecimals: uint64

*if3_end:
	// contracts\BiatecClammPool.algo.ts:233
	// assetBDecimals = 6
	intc 5 // 6
	frame_bury 3 // assetBDecimals: uint64

	// *if4_condition
	// contracts\BiatecClammPool.algo.ts:234
	// assetB.id > 0
	frame_dig -2 // assetB: AssetID
	intc 1 // 0
	>
	bz *if4_end

	// *if4_consequent
	// contracts\BiatecClammPool.algo.ts:234
	// assetBDecimals = assetB.decimals
	frame_dig -2 // assetB: AssetID
	asset_params_get AssetDecimals
	pop
	frame_bury 3 // assetBDecimals: uint64

*if4_end:
	// contracts\BiatecClammPool.algo.ts:236
	// assetADelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetADecimals)) as uint256
	intc 9 // 10
	intc 13 // 9
	frame_dig 2 // assetADecimals: uint64
	-
	exp
	itob
	frame_bury 4 // assetADelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:238
	// assetBDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetBDecimals)) as uint256
	intc 9 // 10
	intc 13 // 9
	frame_dig 3 // assetBDecimals: uint64
	-
	exp
	itob
	frame_bury 5 // assetBDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:239
	// this.assetADecimalsScaleFromBase.value = assetADelicmalScale2Scale
	bytec 9 //  "ad"
	frame_dig 4 // assetADelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	intc 2 // 256
	<=

	// assetADelicmalScale2Scale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:240
	// this.assetBDecimalsScaleFromBase.value = assetBDelicmalScale2Scale
	bytec 10 //  "bd"
	frame_dig 5 // assetBDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	intc 2 // 256
	<=

	// assetBDelicmalScale2Scale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:241
	// return this.assetLp.value;
	bytec 21 //  "lp"
	app_global_get

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 5
	retsub

// bootstrapStep2()void
*abi_route_bootstrapStep2:
	// execute bootstrapStep2()void
	callsub bootstrapStep2
	intc 3 // 1
	return

// bootstrapStep2(): void
//
// When we know the app id of this pool, we can register it properly at the pool provider
bootstrapStep2:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts\BiatecClammPool.algo.ts:248
	// assert(!this.setupFinished.value)
	bytec 19 //  "s"
	app_global_get
	intc 1 // 0
	getbit
	!
	assert

	// contracts\BiatecClammPool.algo.ts:249
	// appBiatecConfigProvider = this.appBiatecConfigProvider.value as AppID
	bytec 13 //  "bc"
	app_global_get
	frame_bury 0 // appBiatecConfigProvider: uint64

	// contracts\BiatecClammPool.algo.ts:250
	// appBiatecPoolProvider = appBiatecConfigProvider.globalState('p') as AppID
	frame_dig 0 // appBiatecConfigProvider: uint64
	bytec 29 //  "p"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('p')
	assert
	frame_bury 1 // appBiatecPoolProvider: uint64

	// contracts\BiatecClammPool.algo.ts:251
	// sendMethodCall<[], void>({
	//       name: 'registerPool',
	//       methodArgs: [],
	//       fee: 0,
	//       applicationID: appBiatecPoolProvider,
	//     })
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	pushbytes 0x40540ee6 // method "registerPool()void"
	itxn_field ApplicationArgs

	// contracts\BiatecClammPool.algo.ts:253
	// methodArgs: []
	// contracts\BiatecClammPool.algo.ts:254
	// fee: 0
	intc 1 // 0
	itxn_field Fee

	// contracts\BiatecClammPool.algo.ts:255
	// applicationID: appBiatecPoolProvider
	frame_dig 1 // appBiatecPoolProvider: uint64
	itxn_field ApplicationID

	// Submit inner transaction
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:257
	// this.setupFinished.value = true
	bytec 19 //  "s"
	intc 3 // 1
	bytec 37 // 0x00
	intc 1 // 0
	uncover 2
	setbit
	app_global_put
	retsub

// doAxfer(receiver: Address, asset: AssetID, amount: uint64): void
//
// Executes xfer of pay payment methods to specified receiver from smart contract aggregated account with specified asset and amount in tokens decimals
// @param receiver Receiver
// @param asset Asset. Zero for algo
// @param amount Amount to transfer
doAxfer:
	proto 3 0

	// *if5_condition
	// contracts\BiatecClammPool.algo.ts:267
	// asset.id === 0
	frame_dig -2 // asset: AssetID
	intc 1 // 0
	==
	bz *if5_else

	// *if5_consequent
	// contracts\BiatecClammPool.algo.ts:268
	// sendPayment({
	//         receiver: receiver,
	//         amount: amount,
	//         fee: 0,
	//       })
	itxn_begin
	intc 3 //  pay
	itxn_field TypeEnum

	// contracts\BiatecClammPool.algo.ts:269
	// receiver: receiver
	frame_dig -1 // receiver: Address
	itxn_field Receiver

	// contracts\BiatecClammPool.algo.ts:270
	// amount: amount
	frame_dig -3 // amount: uint64
	itxn_field Amount

	// contracts\BiatecClammPool.algo.ts:271
	// fee: 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if5_end

*if5_else:
	// contracts\BiatecClammPool.algo.ts:274
	// sendAssetTransfer({
	//         assetReceiver: receiver,
	//         xferAsset: asset,
	//         assetAmount: amount,
	//         fee: 0,
	//       })
	itxn_begin
	intc 7 //  axfer
	itxn_field TypeEnum

	// contracts\BiatecClammPool.algo.ts:275
	// assetReceiver: receiver
	frame_dig -1 // receiver: Address
	itxn_field AssetReceiver

	// contracts\BiatecClammPool.algo.ts:276
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// contracts\BiatecClammPool.algo.ts:277
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// contracts\BiatecClammPool.algo.ts:278
	// fee: 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if5_end:
	retsub

// doOptIn(asset: AssetID): void
//
// Performs opt in to the asset. If native token is provided (0) it does not perform any action
// @param asset Asset to opt in to
doOptIn:
	proto 1 0

	// *if6_condition
	// contracts\BiatecClammPool.algo.ts:288
	// asset.id > 0
	frame_dig -1 // asset: AssetID
	intc 1 // 0
	>
	bz *if6_end

	// *if6_consequent
	// contracts\BiatecClammPool.algo.ts:290
	// this.doAxfer(this.app.address, asset, 0)
	intc 1 // 0
	frame_dig -1 // asset: AssetID
	global CurrentApplicationAddress
	callsub doAxfer

*if6_end:
	retsub

// doCreatePoolToken(assetA: AssetID, assetB: AssetID, nativeTokenName: bytes): AssetID
//
// Creates LP token
// @param assetA Asset A
// @param assetB Asset B
// @param nativeTokenName Name of the native token (e.g., 'ALGO', 'VOI', 'ARAMID') when assetA.id = 0
// @returns id of the token
doCreatePoolToken:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 4

	// contracts\BiatecClammPool.algo.ts:303
	// defaultNativeTokenName = nativeTokenName
	frame_dig -3 // nativeTokenName: bytes
	frame_bury 0 // defaultNativeTokenName: byte[]

	// *if7_condition
	// contracts\BiatecClammPool.algo.ts:304
	// defaultNativeTokenName.length >= 2
	frame_dig 0 // defaultNativeTokenName: byte[]
	len
	intc 12 // 2
	>=
	bz *if7_end

	// *if7_consequent
	// contracts\BiatecClammPool.algo.ts:305
	// defaultNativeTokenName = substring3(nativeTokenName, 2, nativeTokenName.length)
	frame_dig -3 // nativeTokenName: bytes
	intc 12 // 2
	frame_dig -3 // nativeTokenName: bytes
	len
	substring3
	frame_bury 0 // defaultNativeTokenName: byte[]

*if7_end:
	// *if8_condition
	// contracts\BiatecClammPool.algo.ts:307
	// defaultNativeTokenName.length === 0
	frame_dig 0 // defaultNativeTokenName: byte[]
	len
	intc 1 // 0
	==
	bz *if8_end

	// *if8_consequent
	// contracts\BiatecClammPool.algo.ts:308
	// defaultNativeTokenName = 'ALGO'
	pushbytes 0x414c474f // "ALGO"
	frame_bury 0 // defaultNativeTokenName: byte[]

*if8_end:
	// contracts\BiatecClammPool.algo.ts:311
	// nameAssetABytes = assetA.id > 0 ? assetA.unitName : defaultNativeTokenName
	frame_dig -1 // assetA: AssetID
	intc 1 // 0
	>
	bz *ternary0_false
	frame_dig -1 // assetA: AssetID
	asset_params_get AssetUnitName
	pop
	b *ternary0_end

*ternary0_false:
	frame_dig 0 // defaultNativeTokenName: byte[]

*ternary0_end:
	frame_bury 1 // nameAssetABytes: byte[]

	// contracts\BiatecClammPool.algo.ts:312
	// nameAssetBBytes = assetB.id > 0 ? assetB.unitName : defaultNativeTokenName
	frame_dig -2 // assetB: AssetID
	intc 1 // 0
	>
	bz *ternary1_false
	frame_dig -2 // assetB: AssetID
	asset_params_get AssetUnitName
	pop
	b *ternary1_end

*ternary1_false:
	frame_dig 0 // defaultNativeTokenName: byte[]

*ternary1_end:
	frame_bury 2 // nameAssetBBytes: byte[]

	// contracts\BiatecClammPool.algo.ts:314
	// nameBytes: bytes = ''
	bytec 0 //  ""
	frame_bury 3 // nameBytes: bytes

	// contracts\BiatecClammPool.algo.ts:315
	// unitNameBytes: bytes = 'BLP'
	pushbytes 0x424c50 // "BLP"
	frame_bury 4 // unitNameBytes: bytes

	// *if9_condition
	// contracts\BiatecClammPool.algo.ts:318
	// assetA.id === assetB.id
	frame_dig -1 // assetA: AssetID
	frame_dig -2 // assetB: AssetID
	==
	bz *if9_else

	// *if9_consequent
	// contracts\BiatecClammPool.algo.ts:319
	// nameBytes = 'B-' + nameAssetABytes
	bytec 36 //  "B-"
	frame_dig 1 // nameAssetABytes: byte[]
	concat
	frame_bury 3 // nameBytes: bytes

	// contracts\BiatecClammPool.algo.ts:321
	// unitNameBytes = assetA.id > 0 ? assetA.unitName : defaultNativeTokenName
	frame_dig -1 // assetA: AssetID
	intc 1 // 0
	>
	bz *ternary2_false
	frame_dig -1 // assetA: AssetID
	asset_params_get AssetUnitName
	pop
	b *ternary2_end

*ternary2_false:
	frame_dig 0 // defaultNativeTokenName: byte[]

*ternary2_end:
	frame_bury 4 // unitNameBytes: bytes
	b *if9_end

*if9_else:
	// contracts\BiatecClammPool.algo.ts:324
	// nameBytes = 'B-' + nameAssetABytes + '-' + nameAssetBBytes
	bytec 36 //  "B-"
	frame_dig 1 // nameAssetABytes: byte[]
	concat
	pushbytes 0x2d // "-"
	concat
	frame_dig 2 // nameAssetBBytes: byte[]
	concat
	frame_bury 3 // nameBytes: bytes

*if9_end:
	// contracts\BiatecClammPool.algo.ts:327
	// return sendAssetCreation({
	//       configAssetName: nameBytes,
	//       configAssetUnitName: unitNameBytes,
	//       // eslint-disable-next-line no-loss-of-precision
	//       configAssetTotal: Uint<64>(TOTAL_SUPPLY),
	//       configAssetDecimals: LP_TOKEN_DECIMALS,
	//       configAssetManager: this.app.address,
	//       configAssetReserve: this.app.address,
	//     });
	itxn_begin
	intc 10 //  acfg
	itxn_field TypeEnum

	// contracts\BiatecClammPool.algo.ts:328
	// configAssetName: nameBytes
	frame_dig 3 // nameBytes: bytes
	itxn_field ConfigAssetName

	// contracts\BiatecClammPool.algo.ts:329
	// configAssetUnitName: unitNameBytes
	frame_dig 4 // unitNameBytes: bytes
	itxn_field ConfigAssetUnitName

	// contracts\BiatecClammPool.algo.ts:331
	// configAssetTotal: Uint<64>(TOTAL_SUPPLY)
	pushint 18000000000000000000
	itxn_field ConfigAssetTotal

	// contracts\BiatecClammPool.algo.ts:332
	// configAssetDecimals: LP_TOKEN_DECIMALS
	intc 5 // 6
	itxn_field ConfigAssetDecimals

	// contracts\BiatecClammPool.algo.ts:333
	// configAssetManager: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetManager

	// contracts\BiatecClammPool.algo.ts:334
	// configAssetReserve: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetReserve

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn CreatedAssetID

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 4
	retsub

// checkAssetsAB(assetA: AssetID, assetB: AssetID): void
checkAssetsAB:
	proto 2 0

	// contracts\BiatecClammPool.algo.ts:339
	// assert(assetA.id === this.assetA.value, 'assetA does not match')
	frame_dig -1 // assetA: AssetID
	bytec 25 //  "a"
	app_global_get
	==

	// assetA does not match
	assert

	// contracts\BiatecClammPool.algo.ts:340
	// assert(assetB.id === this.assetB.value, 'assetB does not match')
	frame_dig -2 // assetB: AssetID
	bytec 26 //  "b"
	app_global_get
	==

	// assetB does not match
	assert
	retsub

// checkAssets(assetA: AssetID, assetB: AssetID, assetLp: AssetID): void
checkAssets:
	proto 3 0

	// contracts\BiatecClammPool.algo.ts:344
	// this.checkAssetsAB(assetA, assetB)
	frame_dig -2 // assetB: AssetID
	frame_dig -1 // assetA: AssetID
	callsub checkAssetsAB

	// contracts\BiatecClammPool.algo.ts:345
	// assert(assetLp.id === this.assetLp.value, 'assetLp does not match')
	frame_dig -3 // assetLp: AssetID
	bytec 21 //  "lp"
	app_global_get
	==

	// assetLp does not match
	assert
	retsub

// addLiquidity(uint64,uint64,txn,txn,uint64,uint64,uint64)uint64
*abi_route_addLiquidity:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// assetLp: uint64
	txna ApplicationArgs 5
	btoi

	// assetB: uint64
	txna ApplicationArgs 4
	btoi

	// assetA: uint64
	txna ApplicationArgs 3
	btoi

	// txAssetBDeposit: txn
	txn GroupIndex
	intc 3 // 1
	-

	// txAssetADeposit: txn
	txn GroupIndex
	intc 12 // 2
	-

	// appBiatecIdentityProvider: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute addLiquidity(uint64,uint64,txn,txn,uint64,uint64,uint64)uint64
	callsub addLiquidity
	itob
	concat
	log
	intc 3 // 1
	return

// addLiquidity(appBiatecConfigProvider: AppID, appBiatecIdentityProvider: AppID, txAssetADeposit: Txn, txAssetBDeposit: Txn, assetA: AssetID, assetB: AssetID, assetLp: AssetID): uint64
//
// This method adds Asset A and Asset B to the Automated Market Maker Concentrated Liqudidity Pool and send to the liqudidty provider the liquidity token
// @param appBiatecConfigProvider Configuration reference
// @param appBiatecIdentityProvider Identity service reference
// @param txAssetADeposit Transfer of asset A to the LP pool
// @param txAssetBDeposit Transfer of asset B to the LP pool
// @param assetLp Liquidity pool asset
// @param assetA Asset A
// @param assetB Asset B
// @returns LP Token quantity distributed
addLiquidity:
	proto 7 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 9

	// contracts\BiatecClammPool.algo.ts:360
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 1 // 0
	itxn_field Fee
	bytec 6 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:361
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 1 // 0
	itxn_field Fee
	bytec 6 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// well formed mint
	// contracts\BiatecClammPool.algo.ts:363
	// this.checkAssets(assetA, assetB, assetLp)
	frame_dig -7 // assetLp: AssetID
	frame_dig -6 // assetB: AssetID
	frame_dig -5 // assetA: AssetID
	callsub checkAssets

	// contracts\BiatecClammPool.algo.ts:365
	// this.verifyIdentity(appBiatecConfigProvider, appBiatecIdentityProvider)
	frame_dig -2 // appBiatecIdentityProvider: AppID
	frame_dig -1 // appBiatecConfigProvider: AppID
	callsub verifyIdentity

	// contracts\BiatecClammPool.algo.ts:367
	// assetLpDelicmalScale2Scale = <uint256>LP_SCALE_DECIMALS
	intc 9 // 10
	intc 10 // 3
	exp
	itob
	frame_bury 0 // assetLpDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:369
	// zeroUint256 = <uint256>0
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 1 // zeroUint256: uint256

	// contracts\BiatecClammPool.algo.ts:370
	// aDepositInBaseScale = <uint256>0
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 2 // aDepositInBaseScale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:371
	// bDepositInBaseScale = <uint256>0
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 3 // bDepositInBaseScale: unsafe uint256

	// *if10_condition
	// contracts\BiatecClammPool.algo.ts:372
	// assetA.id > 0
	frame_dig -5 // assetA: AssetID
	intc 1 // 0
	>
	bz *if10_else

	// *if10_consequent
	// contracts\BiatecClammPool.algo.ts:373
	// assert(txAssetADeposit.typeEnum === TransactionType.AssetTransfer)
	frame_dig -3 // txAssetADeposit: Txn
	gtxns TypeEnum
	intc 7 //  axfer
	==
	assert

	// contracts\BiatecClammPool.algo.ts:374
	// aDepositInBaseScale = (txAssetADeposit.assetAmount as uint256) * this.assetADecimalsScaleFromBase.value
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	itob
	bytec 9 //  "ad"
	app_global_get
	b*
	frame_bury 2 // aDepositInBaseScale: unsafe uint256
	b *if10_end

*if10_else:
	// contracts\BiatecClammPool.algo.ts:376
	// assert(txAssetADeposit.typeEnum === TransactionType.Payment)
	frame_dig -3 // txAssetADeposit: Txn
	gtxns TypeEnum
	intc 3 //  pay
	==
	assert

	// contracts\BiatecClammPool.algo.ts:377
	// aDepositInBaseScale = (txAssetADeposit.amount as uint256) * this.assetADecimalsScaleFromBase.value
	frame_dig -3 // txAssetADeposit: Txn
	gtxns Amount
	itob
	bytec 9 //  "ad"
	app_global_get
	b*
	frame_bury 2 // aDepositInBaseScale: unsafe uint256

*if10_end:
	// *if11_condition
	// contracts\BiatecClammPool.algo.ts:380
	// txAssetADeposit.typeEnum === TransactionType.AssetTransfer
	frame_dig -3 // txAssetADeposit: Txn
	gtxns TypeEnum
	intc 7 //  axfer
	==
	bz *if11_elseif1_condition

	// *if11_consequent
	// contracts\BiatecClammPool.algo.ts:381
	// xfer = txAssetADeposit as AssetTransferTxn
	frame_dig -3 // txAssetADeposit: Txn
	dup
	gtxns TypeEnum
	intc 7 //  axfer
	==

	// failed to cast txAssetADeposit to axfer
	assert
	frame_bury 4 // xfer: axfer

	// contracts\BiatecClammPool.algo.ts:382
	// verifyAssetTransferTxn(xfer, {
	//         assetReceiver: this.app.address,
	//         xferAsset: assetA,
	//         assetAmount: { greaterThanEqualTo: 0 },
	//       })
	// verify axfer
	frame_dig 4 // xfer: axfer
	gtxns TypeEnum
	intc 7 //  axfer
	==

	// transaction verification failed: {"txn":"xfer","field":"typeEnum","expected":"axfer"}
	assert

	// verify assetReceiver
	frame_dig 4 // xfer: axfer
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"xfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig 4 // xfer: axfer
	gtxns XferAsset
	frame_dig -5 // assetA: AssetID
	==

	// transaction verification failed: {"txn":"xfer","field":"xferAsset","expected":"assetA"}
	assert

	// verify assetAmount
	frame_dig 4 // xfer: axfer
	gtxns AssetAmount
	intc 1 // 0
	>=

	// transaction verification failed: {"txn":"xfer","field":"assetAmount","condition":"greaterThanEqualTo","expected":">=0"}
	assert
	b *if11_end

*if11_elseif1_condition:
	// contracts\BiatecClammPool.algo.ts:387
	// txAssetADeposit.typeEnum === TransactionType.Payment
	frame_dig -3 // txAssetADeposit: Txn
	gtxns TypeEnum
	intc 3 //  pay
	==
	bz *if11_else

	// *if11_elseif1_consequent
	// contracts\BiatecClammPool.algo.ts:388
	// payTx = txAssetADeposit as PayTxn
	frame_dig -3 // txAssetADeposit: Txn
	dup
	gtxns TypeEnum
	intc 3 //  pay
	==

	// failed to cast txAssetADeposit to pay
	assert
	frame_bury 5 // payTx: pay

	// contracts\BiatecClammPool.algo.ts:389
	// verifyPayTxn(payTx, {
	//         receiver: this.app.address,
	//         amount: { greaterThanEqualTo: 0 },
	//       })
	// verify pay
	frame_dig 5 // payTx: pay
	gtxns TypeEnum
	intc 3 //  pay
	==

	// transaction verification failed: {"txn":"payTx","field":"typeEnum","expected":"pay"}
	assert

	// verify receiver
	frame_dig 5 // payTx: pay
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payTx","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig 5 // payTx: pay
	gtxns Amount
	intc 1 // 0
	>=

	// transaction verification failed: {"txn":"payTx","field":"amount","condition":"greaterThanEqualTo","expected":">=0"}
	assert
	b *if11_end

*if11_else:
	// contracts\BiatecClammPool.algo.ts:394
	// assert(false, 'Unsupported tx type of the asset A')
	intc 1 // 0

	// Unsupported tx type of the asset A
	assert

*if11_end:
	// *if12_condition
	// contracts\BiatecClammPool.algo.ts:397
	// assetB.id > 0
	frame_dig -6 // assetB: AssetID
	intc 1 // 0
	>
	bz *if12_else

	// *if12_consequent
	// contracts\BiatecClammPool.algo.ts:398
	// assert(txAssetBDeposit.typeEnum === TransactionType.AssetTransfer)
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns TypeEnum
	intc 7 //  axfer
	==
	assert

	// contracts\BiatecClammPool.algo.ts:399
	// bDepositInBaseScale = (txAssetBDeposit.assetAmount as uint256) * this.assetBDecimalsScaleFromBase.value
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	itob
	bytec 10 //  "bd"
	app_global_get
	b*
	frame_bury 3 // bDepositInBaseScale: unsafe uint256
	b *if12_end

*if12_else:
	// contracts\BiatecClammPool.algo.ts:401
	// assert(txAssetBDeposit.typeEnum === TransactionType.Payment)
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns TypeEnum
	intc 3 //  pay
	==
	assert

	// contracts\BiatecClammPool.algo.ts:402
	// bDepositInBaseScale = (txAssetBDeposit.amount as uint256) * this.assetBDecimalsScaleFromBase.value
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns Amount
	itob
	bytec 10 //  "bd"
	app_global_get
	b*
	frame_bury 3 // bDepositInBaseScale: unsafe uint256

*if12_end:
	// *if13_condition
	// contracts\BiatecClammPool.algo.ts:405
	// txAssetBDeposit.typeEnum === TransactionType.AssetTransfer
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns TypeEnum
	intc 7 //  axfer
	==
	bz *if13_elseif1_condition

	// *if13_consequent
	// contracts\BiatecClammPool.algo.ts:406
	// xfer = txAssetBDeposit as AssetTransferTxn
	frame_dig -4 // txAssetBDeposit: Txn
	dup
	gtxns TypeEnum
	intc 7 //  axfer
	==

	// failed to cast txAssetBDeposit to axfer
	assert
	frame_bury 6 // xfer: axfer

	// contracts\BiatecClammPool.algo.ts:407
	// verifyAssetTransferTxn(xfer, {
	//         assetReceiver: this.app.address,
	//         xferAsset: assetB,
	//         assetAmount: { greaterThanEqualTo: 0 },
	//       })
	// verify axfer
	frame_dig 6 // xfer: axfer
	gtxns TypeEnum
	intc 7 //  axfer
	==

	// transaction verification failed: {"txn":"xfer","field":"typeEnum","expected":"axfer"}
	assert

	// verify assetReceiver
	frame_dig 6 // xfer: axfer
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"xfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig 6 // xfer: axfer
	gtxns XferAsset
	frame_dig -6 // assetB: AssetID
	==

	// transaction verification failed: {"txn":"xfer","field":"xferAsset","expected":"assetB"}
	assert

	// verify assetAmount
	frame_dig 6 // xfer: axfer
	gtxns AssetAmount
	intc 1 // 0
	>=

	// transaction verification failed: {"txn":"xfer","field":"assetAmount","condition":"greaterThanEqualTo","expected":">=0"}
	assert
	b *if13_end

*if13_elseif1_condition:
	// contracts\BiatecClammPool.algo.ts:412
	// txAssetBDeposit.typeEnum === TransactionType.Payment
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns TypeEnum
	intc 3 //  pay
	==
	bz *if13_else

	// *if13_elseif1_consequent
	// contracts\BiatecClammPool.algo.ts:413
	// payTx = txAssetBDeposit as PayTxn
	frame_dig -4 // txAssetBDeposit: Txn
	dup
	gtxns TypeEnum
	intc 3 //  pay
	==

	// failed to cast txAssetBDeposit to pay
	assert
	frame_bury 7 // payTx: pay

	// contracts\BiatecClammPool.algo.ts:414
	// verifyPayTxn(payTx, {
	//         receiver: this.app.address,
	//         amount: { greaterThanEqualTo: 0 },
	//       })
	// verify pay
	frame_dig 7 // payTx: pay
	gtxns TypeEnum
	intc 3 //  pay
	==

	// transaction verification failed: {"txn":"payTx","field":"typeEnum","expected":"pay"}
	assert

	// verify receiver
	frame_dig 7 // payTx: pay
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payTx","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig 7 // payTx: pay
	gtxns Amount
	intc 1 // 0
	>=

	// transaction verification failed: {"txn":"payTx","field":"amount","condition":"greaterThanEqualTo","expected":">=0"}
	assert
	b *if13_end

*if13_else:
	// contracts\BiatecClammPool.algo.ts:419
	// assert(false, 'Unsupported tx type of the asset B')
	intc 1 // 0

	// Unsupported tx type of the asset B
	assert

*if13_end:
	// contracts\BiatecClammPool.algo.ts:441
	// this.processAddLiquidity(zeroUint256, zeroUint256, assetLpDelicmalScale2Scale, assetLp, false)
	intc 1 // 0
	frame_dig -7 // assetLp: AssetID
	frame_dig 0 // assetLpDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	intc 2 // 256
	<=

	// assetLpDelicmalScale2Scale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 3 //  zeroUint256: uint256
	dup
	callsub processAddLiquidity

	// *if14_condition
	// contracts\BiatecClammPool.algo.ts:445
	// this.priceMinSqrt.value === this.priceMaxSqrt.value
	bytec 15 //  "pMinS"
	app_global_get
	bytec 16 //  "pMaxS"
	app_global_get
	b==
	bz *if14_end

	// *if14_consequent
	// contracts\BiatecClammPool.algo.ts:446
	// return this.processAddLiquidity(aDepositInBaseScale, bDepositInBaseScale, assetLpDelicmalScale2Scale, assetLp, true);
	intc 3 // 1
	frame_dig -7 // assetLp: AssetID
	frame_dig 0 // assetLpDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	intc 2 // 256
	<=

	// assetLpDelicmalScale2Scale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 3 // bDepositInBaseScale: unsafe uint256
	dup
	bitlen
	intc 2 // 256
	<=

	// bDepositInBaseScale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 2 // aDepositInBaseScale: unsafe uint256
	dup
	bitlen
	intc 2 // 256
	<=

	// aDepositInBaseScale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub processAddLiquidity
	b *addLiquidity*return

*if14_end:
	// contracts\BiatecClammPool.algo.ts:456
	// ret = this.processAddLiquidity(aDepositInBaseScale, bDepositInBaseScale, assetLpDelicmalScale2Scale, assetLp, true)
	intc 3 // 1
	frame_dig -7 // assetLp: AssetID
	frame_dig 0 // assetLpDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	intc 2 // 256
	<=

	// assetLpDelicmalScale2Scale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 3 // bDepositInBaseScale: unsafe uint256
	dup
	bitlen
	intc 2 // 256
	<=

	// bDepositInBaseScale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 2 // aDepositInBaseScale: unsafe uint256
	dup
	bitlen
	intc 2 // 256
	<=

	// aDepositInBaseScale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub processAddLiquidity
	frame_bury 8 // ret: uint64

	// contracts\BiatecClammPool.algo.ts:458
	// newPrice = this.calculatePrice(
	//       this.assetABalanceBaseScale.value, // assetAQuantity: uint256,
	//       this.assetBBalanceBaseScale.value, // assetBQuantity: uint256,
	//       this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//       this.priceMaxSqrt.value, // priceMaxSqrt: uint256,
	//       this.Liquidity.value // liquidity: uint256
	//     )
	bytec 8 //  "L"
	app_global_get
	bytec 16 //  "pMaxS"
	app_global_get
	bytec 15 //  "pMinS"
	app_global_get
	bytec 5 //  "bb"
	app_global_get
	bytec 4 //  "ab"
	app_global_get
	callsub calculatePrice
	frame_bury 9 // newPrice: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:466
	// this.currentPrice.value = newPrice as uint64
	bytec 17 //  "price"
	frame_dig 9 // newPrice: unsafe uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// newPrice as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	app_global_put

	// contracts\BiatecClammPool.algo.ts:467
	// return ret;
	frame_dig 8 // ret: uint64

*addLiquidity*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 9
	retsub

// processAddLiquidity(realAssetADeposit: uint256, realAssetBDeposit: uint256, assetLpDelicmalScale2Scale: uint256, assetLp: AssetID, send: boolean): uint64
//
// This method is used in addLiquidity to process the liquidity addition from calculated values
// @param realAssetADeposit Real asset a deposit
// @param realAssetBDeposit Real asset b deposit
// @param assetLpDelicmalScale2Scale LP decimal scale
// @param assetLp LP Asset
// @returns LP Token quantity distributed
processAddLiquidity:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 13

	// contracts\BiatecClammPool.algo.ts:582
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 1 // 0
	itxn_field Fee
	bytec 6 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:583
	// oldLiquidity = this.Liquidity.value
	bytec 8 //  "L"
	app_global_get
	frame_bury 0 // oldLiquidity: uint256

	// contracts\BiatecClammPool.algo.ts:585
	// this.assetABalanceBaseScale.value = this.assetABalanceBaseScale.value + realAssetADeposit
	bytec 4 //  "ab"
	dup
	app_global_get
	frame_dig -1 // realAssetADeposit: uint256
	b+
	dup
	bitlen
	intc 2 // 256
	<=

	// this.assetABalanceBaseScale.value + realAssetADeposit overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:586
	// this.assetBBalanceBaseScale.value = this.assetBBalanceBaseScale.value + realAssetBDeposit
	bytec 5 //  "bb"
	dup
	app_global_get
	frame_dig -2 // realAssetBDeposit: uint256
	b+
	dup
	bitlen
	intc 2 // 256
	<=

	// this.assetBBalanceBaseScale.value + realAssetBDeposit overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:589
	// newLiquidity = this.setCurrentLiquidityNonDecreasing(oldLiquidity)
	frame_dig 0 // oldLiquidity: uint256
	callsub setCurrentLiquidityNonDecreasing
	frame_bury 1 // newLiquidity: unsafe uint256

	// *if15_condition
	// contracts\BiatecClammPool.algo.ts:591
	// send
	frame_dig -5 // send: boolean
	bz *if15_end

	// *if15_consequent
	// contracts\BiatecClammPool.algo.ts:592
	// liquidityDelta = newLiquidity - oldLiquidity
	frame_dig 1 // newLiquidity: unsafe uint256
	frame_dig 0 // oldLiquidity: uint256
	b-
	frame_bury 2 // liquidityDelta: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:593
	// lpDeltaBase = liquidityDelta
	frame_dig 2 // liquidityDelta: unsafe uint256
	frame_bury 3 // lpDeltaBase: unsafe uint256

	// *if16_condition
	// contracts\BiatecClammPool.algo.ts:594
	// lpDeltaBase > <uint256>0
	frame_dig 3 // lpDeltaBase: unsafe uint256
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	bz *if16_end

	// *if16_consequent
	// contracts\BiatecClammPool.algo.ts:596
	// distributedBefore = ((Uint<256>(TOTAL_SUPPLY) as uint256) - (this.app.address.assetBalance(assetLp) as uint256)) * assetLpDelicmalScale2Scale
	bytec 27 // 0x000000000000000000000000000000000000000000000000f9ccd8a1c5080000
	global CurrentApplicationAddress
	frame_dig -4 // assetLp: AssetID
	asset_holding_get AssetBalance
	pop
	itob
	b-
	frame_dig -3 // assetLpDelicmalScale2Scale: uint256
	b*
	frame_bury 4 // distributedBefore: unsafe uint256

	// *if17_condition
	// contracts\BiatecClammPool.algo.ts:597
	// distributedBefore > <uint256>0
	frame_dig 4 // distributedBefore: unsafe uint256
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	bz *if17_end

	// *if17_consequent
	// contracts\BiatecClammPool.algo.ts:598
	// contributionScaled = <uint256>0
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 5 // contributionScaled: unsafe uint256

	// *if18_condition
	// contracts\BiatecClammPool.algo.ts:599
	// realAssetADeposit > <uint256>0
	frame_dig -1 // realAssetADeposit: uint256
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	bz *if18_elseif1_condition

	// *if18_consequent
	// contracts\BiatecClammPool.algo.ts:601
	// contributionScaled = (realAssetADeposit * newLiquidity) / this.assetABalanceBaseScale.value
	frame_dig -1 // realAssetADeposit: uint256
	frame_dig 1 // newLiquidity: unsafe uint256
	b*
	bytec 4 //  "ab"
	app_global_get
	b/
	frame_bury 5 // contributionScaled: unsafe uint256
	b *if18_end

*if18_elseif1_condition:
	// contracts\BiatecClammPool.algo.ts:602
	// realAssetBDeposit > <uint256>0
	frame_dig -2 // realAssetBDeposit: uint256
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	bz *if18_end

	// *if18_elseif1_consequent
	// contracts\BiatecClammPool.algo.ts:603
	// contributionScaled = (realAssetBDeposit * newLiquidity) / this.assetBBalanceBaseScale.value
	frame_dig -2 // realAssetBDeposit: uint256
	frame_dig 1 // newLiquidity: unsafe uint256
	b*
	bytec 5 //  "bb"
	app_global_get
	b/
	frame_bury 5 // contributionScaled: unsafe uint256

*if18_end:
	// *if19_condition
	// contracts\BiatecClammPool.algo.ts:605
	// contributionScaled > <uint256>0
	frame_dig 5 // contributionScaled: unsafe uint256
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	bz *if19_end

	// *if19_consequent
	// contracts\BiatecClammPool.algo.ts:606
	// usersFeeLiquidity = this.LiquidityUsersFromFees.value
	bytec 12 //  "Lu"
	app_global_get
	frame_bury 6 // usersFeeLiquidity: uint256

	// contracts\BiatecClammPool.algo.ts:607
	// sumDistributedAndFees = distributedBefore + usersFeeLiquidity
	frame_dig 4 // distributedBefore: unsafe uint256
	frame_dig 6 // usersFeeLiquidity: uint256
	b+
	frame_bury 7 // sumDistributedAndFees: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:609
	// diff = sumDistributedAndFees >= contributionScaled ? sumDistributedAndFees - contributionScaled : contributionScaled - sumDistributedAndFees
	frame_dig 7 // sumDistributedAndFees: unsafe uint256
	frame_dig 5 // contributionScaled: unsafe uint256
	b>=
	bz *ternary3_false
	frame_dig 7 // sumDistributedAndFees: unsafe uint256
	frame_dig 5 // contributionScaled: unsafe uint256
	b-
	b *ternary3_end

*ternary3_false:
	frame_dig 5 // contributionScaled: unsafe uint256
	frame_dig 7 // sumDistributedAndFees: unsafe uint256
	b-

*ternary3_end:
	frame_bury 8 // diff: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:610
	// discriminant = diff * diff + <uint256>4 * contributionScaled * distributedBefore
	frame_dig 8 // diff: unsafe uint256
	frame_dig 8 // diff: unsafe uint256
	b*
	bytec 28 // 0x0000000000000000000000000000000000000000000000000000000000000004
	frame_dig 5 // contributionScaled: unsafe uint256
	b*
	frame_dig 4 // distributedBefore: unsafe uint256
	b*
	b+
	frame_bury 9 // discriminant: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:611
	// sqrtTerm = sqrt(discriminant)
	frame_dig 9 // discriminant: unsafe uint256
	bsqrt
	frame_bury 10 // sqrtTerm: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:612
	// numerator = <uint256>0
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 11 // numerator: unsafe uint256

	// *if20_condition
	// contracts\BiatecClammPool.algo.ts:613
	// contributionScaled >= sumDistributedAndFees
	frame_dig 5 // contributionScaled: unsafe uint256
	frame_dig 7 // sumDistributedAndFees: unsafe uint256
	b>=
	bz *if20_else

	// *if20_consequent
	// contracts\BiatecClammPool.algo.ts:614
	// numerator = sqrtTerm + (contributionScaled - sumDistributedAndFees)
	frame_dig 10 // sqrtTerm: unsafe uint256
	frame_dig 5 // contributionScaled: unsafe uint256
	frame_dig 7 // sumDistributedAndFees: unsafe uint256
	b-
	b+
	frame_bury 11 // numerator: unsafe uint256
	b *if20_end

*if20_else:
	// contracts\BiatecClammPool.algo.ts:616
	// numerator = sqrtTerm - (sumDistributedAndFees - contributionScaled)
	frame_dig 10 // sqrtTerm: unsafe uint256
	frame_dig 7 // sumDistributedAndFees: unsafe uint256
	frame_dig 5 // contributionScaled: unsafe uint256
	b-
	b-
	frame_bury 11 // numerator: unsafe uint256

*if20_end:
	// contracts\BiatecClammPool.algo.ts:618
	// solution = numerator / <uint256>2
	frame_dig 11 // numerator: unsafe uint256
	bytec 20 // 0x0000000000000000000000000000000000000000000000000000000000000002
	b/
	frame_bury 12 // solution: unsafe uint256

	// *if21_condition
	// contracts\BiatecClammPool.algo.ts:620
	// solution > <uint256>0 && solution < lpDeltaBase
	frame_dig 12 // solution: unsafe uint256
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	dup
	bz *skip_and0
	frame_dig 12 // solution: unsafe uint256
	frame_dig 3 // lpDeltaBase: unsafe uint256
	b<
	&&

*skip_and0:
	bz *if21_end

	// *if21_consequent
	// contracts\BiatecClammPool.algo.ts:621
	// lpDeltaBase = solution
	frame_dig 12 // solution: unsafe uint256
	frame_bury 3 // lpDeltaBase: unsafe uint256

*if21_end:

*if19_end:

*if17_end:

*if16_end:
	// contracts\BiatecClammPool.algo.ts:626
	// lpTokensToSend = (lpDeltaBase / assetLpDelicmalScale2Scale) as uint64
	frame_dig 3 // lpDeltaBase: unsafe uint256
	frame_dig -3 // assetLpDelicmalScale2Scale: uint256
	b/
	dup
	bitlen
	intc 4 // 64
	<=

	// (lpDeltaBase / assetLpDelicmalScale2Scale) as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 13 // lpTokensToSend: uint64

	// *if22_condition
	// contracts\BiatecClammPool.algo.ts:627
	// lpTokensToSend === 0 && lpDeltaBase > <uint256>0
	frame_dig 13 // lpTokensToSend: uint64
	intc 1 // 0
	==
	dup
	bz *skip_and1
	frame_dig 3 // lpDeltaBase: unsafe uint256
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	&&

*skip_and1:
	bz *if22_end

	// *if22_consequent
	// contracts\BiatecClammPool.algo.ts:628
	// lpTokensToSend = 1
	intc 3 // 1
	frame_bury 13 // lpTokensToSend: uint64

*if22_end:
	// contracts\BiatecClammPool.algo.ts:630
	// assert(lpTokensToSend > 0, 'LP-ZERO-ERR')
	frame_dig 13 // lpTokensToSend: uint64
	intc 1 // 0
	>

	// LP-ZERO-ERR
	assert

	// contracts\BiatecClammPool.algo.ts:631
	// this.doAxfer(this.txn.sender, assetLp, lpTokensToSend)
	frame_dig 13 // lpTokensToSend: uint64
	frame_dig -4 // assetLp: AssetID
	txn Sender
	callsub doAxfer

	// contracts\BiatecClammPool.algo.ts:632
	// return lpTokensToSend as uint64;
	frame_dig 13 // lpTokensToSend: uint64
	b *processAddLiquidity*return

*if15_end:
	// contracts\BiatecClammPool.algo.ts:634
	// return 0;
	intc 1 // 0

*processAddLiquidity*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 13
	retsub

// calculateCurrentLiquidity(): uint256
calculateCurrentLiquidity:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 7

	// contracts\BiatecClammPool.algo.ts:639
	// x = this.assetABalanceBaseScale.value
	bytec 4 //  "ab"
	app_global_get
	frame_bury 0 // x: uint256

	// contracts\BiatecClammPool.algo.ts:640
	// y = this.assetBBalanceBaseScale.value
	bytec 5 //  "bb"
	app_global_get
	frame_bury 1 // y: uint256

	// contracts\BiatecClammPool.algo.ts:641
	// priceMin = this.priceMin.value as uint256
	bytec 35 //  "pMin"
	app_global_get
	itob
	frame_bury 2 // priceMin: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:642
	// priceMax = this.priceMax.value as uint256
	bytec 23 //  "pMax"
	app_global_get
	itob
	frame_bury 3 // priceMax: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:643
	// priceMinSqrt = this.priceMinSqrt.value
	bytec 15 //  "pMinS"
	app_global_get
	frame_bury 4 // priceMinSqrt: uint256

	// contracts\BiatecClammPool.algo.ts:644
	// priceMaxSqrt = this.priceMaxSqrt.value
	bytec 16 //  "pMaxS"
	app_global_get
	frame_bury 5 // priceMaxSqrt: uint256

	// contracts\BiatecClammPool.algo.ts:645
	// newLiquidity = <uint256>0
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 6 // newLiquidity: unsafe uint256

	// *if23_condition
	// contracts\BiatecClammPool.algo.ts:646
	// priceMin === priceMax
	frame_dig 2 // priceMin: unsafe uint256
	frame_dig 3 // priceMax: unsafe uint256
	b==
	bz *if23_else

	// *if23_consequent
	// contracts\BiatecClammPool.algo.ts:647
	// newLiquidity = this.calculateLiquidityFlatPrice(x, y, priceMin)
	frame_dig 2 // priceMin: unsafe uint256
	dup
	bitlen
	intc 2 // 256
	<=

	// priceMin overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 1 // y: uint256
	frame_dig 0 // x: uint256
	callsub calculateLiquidityFlatPrice
	frame_bury 6 // newLiquidity: unsafe uint256
	b *if23_end

*if23_else:
	// contracts\BiatecClammPool.algo.ts:649
	// D_SQRT = this.calculateLiquidityD(x, y, priceMin, priceMax, priceMinSqrt, priceMaxSqrt)
	frame_dig 5 // priceMaxSqrt: uint256
	frame_dig 4 // priceMinSqrt: uint256
	frame_dig 3 // priceMax: unsafe uint256
	dup
	bitlen
	intc 2 // 256
	<=

	// priceMax overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 2 // priceMin: unsafe uint256
	dup
	bitlen
	intc 2 // 256
	<=

	// priceMin overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 1 // y: uint256
	frame_dig 0 // x: uint256
	callsub calculateLiquidityD
	frame_bury 7 // D_SQRT: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:650
	// newLiquidity = this.calculateLiquidityWithD(x, y, priceMinSqrt, priceMaxSqrt, D_SQRT)
	frame_dig 7 // D_SQRT: unsafe uint256
	dup
	bitlen
	intc 2 // 256
	<=

	// D_SQRT overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 5 // priceMaxSqrt: uint256
	frame_dig 4 // priceMinSqrt: uint256
	frame_dig 1 // y: uint256
	frame_dig 0 // x: uint256
	callsub calculateLiquidityWithD
	frame_bury 6 // newLiquidity: unsafe uint256

*if23_end:
	// contracts\BiatecClammPool.algo.ts:652
	// return newLiquidity;
	frame_dig 6 // newLiquidity: unsafe uint256

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 7
	retsub

// setCurrentLiquidity(): void
setCurrentLiquidity:
	proto 0 0

	// contracts\BiatecClammPool.algo.ts:656
	// this.Liquidity.value = this.calculateCurrentLiquidity()
	bytec 8 //  "L"
	callsub calculateCurrentLiquidity
	dup
	bitlen
	intc 2 // 256
	<=

	// this.calculateCurrentLiquidity() overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put
	retsub

// setCurrentLiquidityNonDecreasing(oldLiquidity: uint256): uint256
setCurrentLiquidityNonDecreasing:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts\BiatecClammPool.algo.ts:660
	// projectedLiquidity = this.calculateCurrentLiquidity()
	callsub calculateCurrentLiquidity
	frame_bury 0 // projectedLiquidity: unsafe uint256

	// *if24_condition
	// contracts\BiatecClammPool.algo.ts:661
	// projectedLiquidity >= oldLiquidity
	frame_dig 0 // projectedLiquidity: unsafe uint256
	frame_dig -1 // oldLiquidity: uint256
	b>=
	bz *if24_end

	// *if24_consequent
	// contracts\BiatecClammPool.algo.ts:662
	// this.Liquidity.value = projectedLiquidity
	bytec 8 //  "L"
	frame_dig 0 // projectedLiquidity: unsafe uint256
	dup
	bitlen
	intc 2 // 256
	<=

	// projectedLiquidity overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:663
	// return projectedLiquidity;
	frame_dig 0 // projectedLiquidity: unsafe uint256
	b *setCurrentLiquidityNonDecreasing*return

*if24_end:
	// contracts\BiatecClammPool.algo.ts:665
	// liquidityDrop = (oldLiquidity - projectedLiquidity) as uint256
	frame_dig -1 // oldLiquidity: uint256
	frame_dig 0 // projectedLiquidity: unsafe uint256
	b-
	frame_bury 1 // liquidityDrop: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:666
	// allowedDrop = this.getLiquidityRoundingAllowance()
	callsub getLiquidityRoundingAllowance
	frame_bury 2 // allowedDrop: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:667
	// assert(liquidityDrop <= allowedDrop, 'ERR-LIQ-DROP')
	frame_dig 1 // liquidityDrop: unsafe uint256
	frame_dig 2 // allowedDrop: unsafe uint256
	b<=

	// ERR-LIQ-DROP
	assert

	// contracts\BiatecClammPool.algo.ts:668
	// this.Liquidity.value = oldLiquidity
	bytec 8 //  "L"
	frame_dig -1 // oldLiquidity: uint256
	app_global_put

	// contracts\BiatecClammPool.algo.ts:669
	// return oldLiquidity;
	frame_dig -1 // oldLiquidity: uint256

*setCurrentLiquidityNonDecreasing*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// getLiquidityRoundingAllowance(): uint256
getLiquidityRoundingAllowance:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts\BiatecClammPool.algo.ts:673
	// scaleA = this.assetADecimalsScaleFromBase.value
	bytec 9 //  "ad"
	app_global_get
	frame_bury 0 // scaleA: uint256

	// contracts\BiatecClammPool.algo.ts:674
	// scaleB = this.assetBDecimalsScaleFromBase.value
	bytec 10 //  "bd"
	app_global_get
	frame_bury 1 // scaleB: uint256

	// contracts\BiatecClammPool.algo.ts:675
	// return scaleA * scaleB + scaleA + scaleB;
	frame_dig 0 // scaleA: uint256
	frame_dig 1 // scaleB: uint256
	b*
	frame_dig 0 // scaleA: uint256
	b+
	frame_dig 1 // scaleB: uint256
	b+

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// removeLiquidity(uint64,uint64,axfer,uint64,uint64,uint64)uint256
*abi_route_removeLiquidity:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// assetLp: uint64
	txna ApplicationArgs 5
	btoi

	// assetB: uint64
	txna ApplicationArgs 4
	btoi

	// assetA: uint64
	txna ApplicationArgs 3
	btoi

	// txLpXfer: axfer
	txn GroupIndex
	intc 3 // 1
	-
	dup
	gtxns TypeEnum
	intc 7 //  axfer
	==

	// argument 3 (txLpXfer) for removeLiquidity must be a axfer transaction
	assert

	// appBiatecIdentityProvider: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute removeLiquidity(uint64,uint64,axfer,uint64,uint64,uint64)uint256
	callsub removeLiquidity
	dup
	bitlen
	intc 2 // 256
	<=

	// removeLiquidity return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// removeLiquidity(appBiatecConfigProvider: AppID, appBiatecIdentityProvider: AppID, txLpXfer: AssetTransferTxn, assetA: AssetID, assetB: AssetID, assetLp: AssetID): uint256
//
// This method retrieves from the liquidity provider LP token and returns Asset A and Asset B from the Automated Market Maker Concentrated Liqudidity Pool
// @param appBiatecConfigProvider Configuration reference
// @param appBiatecIdentityProvider Identity service reference
// @param txLpXfer Transfer of the LP token
// @param assetLp LP pool asset
// @param assetA Asset A
// @param assetB Asset B
// @returns LP position reduced
removeLiquidity:
	proto 6 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 11

	// well formed mint
	// contracts\BiatecClammPool.algo.ts:690
	// this.checkAssets(assetA, assetB, assetLp)
	frame_dig -6 // assetLp: AssetID
	frame_dig -5 // assetB: AssetID
	frame_dig -4 // assetA: AssetID
	callsub checkAssets

	// contracts\BiatecClammPool.algo.ts:691
	// verifyAssetTransferTxn(txLpXfer, {
	//       assetReceiver: this.app.address,
	//       xferAsset: assetLp,
	//       assetAmount: { greaterThanEqualTo: 0 },
	//     })
	// verify assetReceiver
	frame_dig -3 // txLpXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"txLpXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -3 // txLpXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -6 // assetLp: AssetID
	==

	// transaction verification failed: {"txn":"txLpXfer","field":"xferAsset","expected":"assetLp"}
	assert

	// verify assetAmount
	frame_dig -3 // txLpXfer: AssetTransferTxn
	gtxns AssetAmount
	intc 1 // 0
	>=

	// transaction verification failed: {"txn":"txLpXfer","field":"assetAmount","condition":"greaterThanEqualTo","expected":">=0"}
	assert

	// contracts\BiatecClammPool.algo.ts:697
	// this.verifyIdentity(appBiatecConfigProvider, appBiatecIdentityProvider)
	frame_dig -2 // appBiatecIdentityProvider: AppID
	frame_dig -1 // appBiatecConfigProvider: AppID
	callsub verifyIdentity

	// contracts\BiatecClammPool.algo.ts:700
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 1 // 0
	itxn_field Fee
	bytec 6 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:701
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 1 // 0
	itxn_field Fee
	bytec 6 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:703
	// assetLpDelicmalScale2Scale = <uint256>LP_SCALE_DECIMALS
	intc 9 // 10
	intc 10 // 3
	exp
	itob
	frame_bury 0 // assetLpDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:705
	// lpDelta = txLpXfer.assetAmount as uint256
	frame_dig -3 // txLpXfer: AssetTransferTxn
	gtxns AssetAmount
	itob
	frame_bury 1 // lpDelta: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:706
	// lpDeltaBase = lpDelta * assetLpDelicmalScale2Scale
	frame_dig 1 // lpDelta: unsafe uint256
	frame_dig 0 // assetLpDelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 2 // lpDeltaBase: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:707
	// lpDeltaWithFees = lpDeltaBase
	frame_dig 2 // lpDeltaBase: unsafe uint256
	frame_bury 3 // lpDeltaWithFees: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:708
	// lpWithOthers = this.calculateDistributedLiquidity(assetLp, lpDelta)
	frame_dig 1 // lpDelta: unsafe uint256
	dup
	bitlen
	intc 2 // 256
	<=

	// lpDelta overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig -6 // assetLp: AssetID
	callsub calculateDistributedLiquidity
	frame_bury 4 // lpWithOthers: unsafe uint256

	// *if25_condition
	// contracts\BiatecClammPool.algo.ts:709
	// lpWithOthers > <uint256>0
	frame_dig 4 // lpWithOthers: unsafe uint256
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	bz *if25_end

	// *if25_consequent
	// contracts\BiatecClammPool.algo.ts:710
	// myPortionOfFeesCollected = (this.LiquidityUsersFromFees.value * lpDeltaBase) / lpWithOthers
	bytec 12 //  "Lu"
	app_global_get
	frame_dig 2 // lpDeltaBase: unsafe uint256
	b*
	frame_dig 4 // lpWithOthers: unsafe uint256
	b/
	frame_bury 5 // myPortionOfFeesCollected: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:711
	// lpDeltaWithFees = lpDeltaBase + myPortionOfFeesCollected
	frame_dig 2 // lpDeltaBase: unsafe uint256
	frame_dig 5 // myPortionOfFeesCollected: unsafe uint256
	b+
	frame_bury 3 // lpDeltaWithFees: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:712
	// this.LiquidityUsersFromFees.value = this.LiquidityUsersFromFees.value - myPortionOfFeesCollected
	bytec 12 //  "Lu"
	dup
	app_global_get
	frame_dig 5 // myPortionOfFeesCollected: unsafe uint256
	b-
	dup
	bitlen
	intc 2 // 256
	<=

	// this.LiquidityUsersFromFees.value - myPortionOfFeesCollected overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

*if25_end:
	// contracts\BiatecClammPool.algo.ts:714
	// aToSend = this.calculateAssetAWithdrawOnLpDeposit(lpDeltaWithFees, this.assetABalanceBaseScale.value, this.Liquidity.value)
	bytec 8 //  "L"
	app_global_get
	bytec 4 //  "ab"
	app_global_get
	frame_dig 3 // lpDeltaWithFees: unsafe uint256
	dup
	bitlen
	intc 2 // 256
	<=

	// lpDeltaWithFees overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub calculateAssetAWithdrawOnLpDeposit
	frame_bury 6 // aToSend: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:715
	// aToSend64 = (aToSend / this.assetADecimalsScaleFromBase.value) as uint64
	frame_dig 6 // aToSend: unsafe uint256
	bytec 9 //  "ad"
	app_global_get
	b/
	dup
	bitlen
	intc 4 // 64
	<=

	// (aToSend / this.assetADecimalsScaleFromBase.value) as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 7 // aToSend64: uint64

	// *if26_condition
	// contracts\BiatecClammPool.algo.ts:716
	// aToSend64 > 0
	frame_dig 7 // aToSend64: uint64
	intc 1 // 0
	>
	bz *if26_end

	// *if26_consequent
	// contracts\BiatecClammPool.algo.ts:717
	// this.doAxfer(this.txn.sender, assetA, aToSend64)
	frame_dig 7 // aToSend64: uint64
	frame_dig -4 // assetA: AssetID
	txn Sender
	callsub doAxfer

*if26_end:
	// contracts\BiatecClammPool.algo.ts:719
	// bToSend = this.calculateAssetAWithdrawOnLpDeposit(lpDeltaWithFees, this.assetBBalanceBaseScale.value, this.Liquidity.value)
	bytec 8 //  "L"
	app_global_get
	bytec 5 //  "bb"
	app_global_get
	frame_dig 3 // lpDeltaWithFees: unsafe uint256
	dup
	bitlen
	intc 2 // 256
	<=

	// lpDeltaWithFees overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub calculateAssetAWithdrawOnLpDeposit
	frame_bury 8 // bToSend: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:720
	// bToSend64 = (bToSend / this.assetBDecimalsScaleFromBase.value) as uint64
	frame_dig 8 // bToSend: unsafe uint256
	bytec 10 //  "bd"
	app_global_get
	b/
	dup
	bitlen
	intc 4 // 64
	<=

	// (bToSend / this.assetBDecimalsScaleFromBase.value) as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 9 // bToSend64: uint64

	// *if27_condition
	// contracts\BiatecClammPool.algo.ts:721
	// bToSend64 > 0
	frame_dig 9 // bToSend64: uint64
	intc 1 // 0
	>
	bz *if27_end

	// *if27_consequent
	// contracts\BiatecClammPool.algo.ts:722
	// this.doAxfer(this.txn.sender, assetB, bToSend64)
	frame_dig 9 // bToSend64: uint64
	frame_dig -5 // assetB: AssetID
	txn Sender
	callsub doAxfer

*if27_end:
	// contracts\BiatecClammPool.algo.ts:726
	// assert(aToSend64 > 0 || bToSend64 > 0, 'ERR-REM-ZERO')
	frame_dig 7 // aToSend64: uint64
	intc 1 // 0
	>
	dup
	bnz *skip_or0
	frame_dig 9 // bToSend64: uint64
	intc 1 // 0
	>
	||

*skip_or0:
	// ERR-REM-ZERO
	assert

	// contracts\BiatecClammPool.algo.ts:728
	// newAssetA = this.assetABalanceBaseScale.value - aToSend
	bytec 4 //  "ab"
	app_global_get
	frame_dig 6 // aToSend: unsafe uint256
	b-
	frame_bury 10 // newAssetA: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:729
	// newAssetB = this.assetBBalanceBaseScale.value - bToSend
	bytec 5 //  "bb"
	app_global_get
	frame_dig 8 // bToSend: unsafe uint256
	b-
	frame_bury 11 // newAssetB: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:730
	// this.assetABalanceBaseScale.value = newAssetA
	bytec 4 //  "ab"
	frame_dig 10 // newAssetA: unsafe uint256
	dup
	bitlen
	intc 2 // 256
	<=

	// newAssetA overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:731
	// this.assetBBalanceBaseScale.value = newAssetB
	bytec 5 //  "bb"
	frame_dig 11 // newAssetB: unsafe uint256
	dup
	bitlen
	intc 2 // 256
	<=

	// newAssetB overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:732
	// this.setCurrentLiquidity()
	callsub setCurrentLiquidity

	// contracts\BiatecClammPool.algo.ts:733
	// return lpDeltaWithFees / assetLpDelicmalScale2Scale;
	frame_dig 3 // lpDeltaWithFees: unsafe uint256
	frame_dig 0 // assetLpDelicmalScale2Scale: unsafe uint256
	b/

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 11
	retsub

// removeLiquidityAdmin(uint64,uint64,uint64,uint64,uint256)uint256
*abi_route_removeLiquidityAdmin:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// amount: uint256
	txna ApplicationArgs 5
	dup
	len
	intc 0 // 32
	==

	// argument 0 (amount) for removeLiquidityAdmin must be a uint256
	assert

	// assetLp: uint64
	txna ApplicationArgs 4
	btoi

	// assetB: uint64
	txna ApplicationArgs 3
	btoi

	// assetA: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute removeLiquidityAdmin(uint64,uint64,uint64,uint64,uint256)uint256
	callsub removeLiquidityAdmin
	dup
	bitlen
	intc 2 // 256
	<=

	// removeLiquidityAdmin return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// removeLiquidityAdmin(appBiatecConfigProvider: AppID, assetA: AssetID, assetB: AssetID, assetLp: AssetID, amount: uint256): uint256
//
// This method allows biatec admin to reduce the lp position created by lp fees allocation.
//
// Only addressExecutiveFee is allowed to execute this method.
//
// @param appBiatecConfigProvider Biatec config app. Only addressExecutiveFee is allowed to execute this method.
// @param assetA Asset A
// @param assetB Asset B
// @param amount Amount to withdraw. If zero, removes all available lps from fees.
//
// @returns LP position reduced
removeLiquidityAdmin:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 9

	// well formed mint
	// contracts\BiatecClammPool.algo.ts:750
	// this.checkAssets(assetA, assetB, assetLp)
	frame_dig -4 // assetLp: AssetID
	frame_dig -3 // assetB: AssetID
	frame_dig -2 // assetA: AssetID
	callsub checkAssets

	// contracts\BiatecClammPool.algo.ts:752
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value)
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 13 //  "bc"
	app_global_get
	==
	assert

	// contracts\BiatecClammPool.algo.ts:753
	// addressExecutiveFee = appBiatecConfigProvider.globalState('ef') as Address
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 24 //  "ef"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('ef')
	assert
	frame_bury 0 // addressExecutiveFee: address

	// contracts\BiatecClammPool.algo.ts:755
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 19 //  "s"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('s')
	assert
	frame_bury 1 // paused: uint64

	// contracts\BiatecClammPool.algo.ts:756
	// assert(paused === 0, 'E_PAUSED')
	frame_dig 1 // paused: uint64
	intc 1 // 0
	==

	// E_PAUSED
	assert

	// contracts\BiatecClammPool.algo.ts:762
	// assert(this.txn.sender === addressExecutiveFee, 'ERR-EXEC-ONLY')
	txn Sender
	frame_dig 0 // addressExecutiveFee: address
	==

	// ERR-EXEC-ONLY
	assert

	// contracts\BiatecClammPool.algo.ts:764
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 1 // 0
	itxn_field Fee
	bytec 6 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:765
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 1 // 0
	itxn_field Fee
	bytec 6 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:768
	// assetLpDelicmalScale2Scale = <uint256>LP_SCALE_DECIMALS
	intc 9 // 10
	intc 10 // 3
	exp
	itob
	frame_bury 2 // assetLpDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:770
	// lpDeltaWithFees = amount
	frame_dig -5 // amount: uint256
	frame_bury 3 // lpDeltaWithFees: unsafe uint256

	// *if28_condition
	// contracts\BiatecClammPool.algo.ts:771
	// lpDeltaWithFees === <uint256>0
	frame_dig 3 // lpDeltaWithFees: unsafe uint256
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b==
	bz *if28_end

	// *if28_consequent
	// contracts\BiatecClammPool.algo.ts:771
	// lpDeltaWithFees = this.LiquidityBiatecFromFees.value
	bytec 14 //  "Lb"
	app_global_get
	frame_bury 3 // lpDeltaWithFees: unsafe uint256

*if28_end:
	// contracts\BiatecClammPool.algo.ts:772
	// assert(
	//       lpDeltaWithFees <= this.LiquidityBiatecFromFees.value,
	//       'ERR-TOO-MUCH' // 'Biatec cannot take more lp then is collected in fees'
	//     )
	frame_dig 3 // lpDeltaWithFees: unsafe uint256
	bytec 14 //  "Lb"
	app_global_get
	b<=

	// ERR-TOO-MUCH
	assert

	// contracts\BiatecClammPool.algo.ts:776
	// this.LiquidityBiatecFromFees.value = this.LiquidityBiatecFromFees.value - lpDeltaWithFees
	bytec 14 //  "Lb"
	dup
	app_global_get
	frame_dig 3 // lpDeltaWithFees: unsafe uint256
	b-
	dup
	bitlen
	intc 2 // 256
	<=

	// this.LiquidityBiatecFromFees.value - lpDeltaWithFees overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:777
	// aToSend = this.calculateAssetAWithdrawOnLpDeposit(lpDeltaWithFees, this.assetABalanceBaseScale.value, this.Liquidity.value)
	bytec 8 //  "L"
	app_global_get
	bytec 4 //  "ab"
	app_global_get
	frame_dig 3 // lpDeltaWithFees: unsafe uint256
	dup
	bitlen
	intc 2 // 256
	<=

	// lpDeltaWithFees overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub calculateAssetAWithdrawOnLpDeposit
	frame_bury 4 // aToSend: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:778
	// aToSend64 = (aToSend / this.assetADecimalsScaleFromBase.value) as uint64
	frame_dig 4 // aToSend: unsafe uint256
	bytec 9 //  "ad"
	app_global_get
	b/
	dup
	bitlen
	intc 4 // 64
	<=

	// (aToSend / this.assetADecimalsScaleFromBase.value) as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 5 // aToSend64: uint64

	// *if29_condition
	// contracts\BiatecClammPool.algo.ts:779
	// aToSend64 > 0
	frame_dig 5 // aToSend64: uint64
	intc 1 // 0
	>
	bz *if29_end

	// *if29_consequent
	// contracts\BiatecClammPool.algo.ts:780
	// this.doAxfer(this.txn.sender, assetA, aToSend64)
	frame_dig 5 // aToSend64: uint64
	frame_dig -2 // assetA: AssetID
	txn Sender
	callsub doAxfer

*if29_end:
	// contracts\BiatecClammPool.algo.ts:782
	// bToSend = this.calculateAssetAWithdrawOnLpDeposit(lpDeltaWithFees, this.assetBBalanceBaseScale.value, this.Liquidity.value)
	bytec 8 //  "L"
	app_global_get
	bytec 5 //  "bb"
	app_global_get
	frame_dig 3 // lpDeltaWithFees: unsafe uint256
	dup
	bitlen
	intc 2 // 256
	<=

	// lpDeltaWithFees overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub calculateAssetAWithdrawOnLpDeposit
	frame_bury 6 // bToSend: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:783
	// bToSend64 = (bToSend / this.assetBDecimalsScaleFromBase.value) as uint64
	frame_dig 6 // bToSend: unsafe uint256
	bytec 10 //  "bd"
	app_global_get
	b/
	dup
	bitlen
	intc 4 // 64
	<=

	// (bToSend / this.assetBDecimalsScaleFromBase.value) as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 7 // bToSend64: uint64

	// *if30_condition
	// contracts\BiatecClammPool.algo.ts:784
	// bToSend64 > 0
	frame_dig 7 // bToSend64: uint64
	intc 1 // 0
	>
	bz *if30_end

	// *if30_consequent
	// contracts\BiatecClammPool.algo.ts:785
	// this.doAxfer(this.txn.sender, assetB, bToSend64)
	frame_dig 7 // bToSend64: uint64
	frame_dig -3 // assetB: AssetID
	txn Sender
	callsub doAxfer

*if30_end:
	// contracts\BiatecClammPool.algo.ts:788
	// newAssetA = this.assetABalanceBaseScale.value - aToSend
	bytec 4 //  "ab"
	app_global_get
	frame_dig 4 // aToSend: unsafe uint256
	b-
	frame_bury 8 // newAssetA: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:789
	// newAssetB = this.assetBBalanceBaseScale.value - bToSend
	bytec 5 //  "bb"
	app_global_get
	frame_dig 6 // bToSend: unsafe uint256
	b-
	frame_bury 9 // newAssetB: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:790
	// this.assetABalanceBaseScale.value = newAssetA
	bytec 4 //  "ab"
	frame_dig 8 // newAssetA: unsafe uint256
	dup
	bitlen
	intc 2 // 256
	<=

	// newAssetA overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:791
	// this.assetBBalanceBaseScale.value = newAssetB
	bytec 5 //  "bb"
	frame_dig 9 // newAssetB: unsafe uint256
	dup
	bitlen
	intc 2 // 256
	<=

	// newAssetB overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:792
	// this.setCurrentLiquidity()
	callsub setCurrentLiquidity

	// contracts\BiatecClammPool.algo.ts:793
	// return lpDeltaWithFees / assetLpDelicmalScale2Scale;
	frame_dig 3 // lpDeltaWithFees: unsafe uint256
	frame_dig 2 // assetLpDelicmalScale2Scale: unsafe uint256
	b/

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 9
	retsub

// verifyIdentity(appBiatecConfigProvider: AppID, appBiatecIdentityProvider: AppID): UserInfoShortV1
//
// Checks if config matches with the app configuration, identity matches with the config, and user is not banned.
//
// Fetches the user info from the identity app and returns the engagement, verification class,...
//
// @param appBiatecConfigProvider Biatec config provider
// @param appBiatecIdentityProvider Biatec identity provider
// @returns User info object
verifyIdentity:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts\BiatecClammPool.algo.ts:806
	// assert(
	//       appBiatecConfigProvider === this.appBiatecConfigProvider.value,
	//       'ERR-INVALID-CONFIG' // 'Configuration app does not match'
	//     )
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 13 //  "bc"
	app_global_get
	==

	// ERR-INVALID-CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:810
	// identityFromConfig = appBiatecConfigProvider.globalState('i') as AppID
	frame_dig -1 // appBiatecConfigProvider: AppID
	pushbytes 0x69 // "i"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('i')
	assert
	frame_bury 0 // identityFromConfig: uint64

	// contracts\BiatecClammPool.algo.ts:811
	// assert(
	//       appBiatecIdentityProvider === identityFromConfig,
	//       'ERR-WRONG-IDENT' // appBiatecIdentityProvider must match to the config in appBiatecConfigProvider'
	//     )
	frame_dig -2 // appBiatecIdentityProvider: AppID
	frame_dig 0 // identityFromConfig: uint64
	==

	// ERR-WRONG-IDENT
	assert

	// contracts\BiatecClammPool.algo.ts:816
	// user = sendMethodCall<[Address, uint8], UserInfoShortV1>({
	//       name: 'getUserShort',
	//       methodArgs: [this.txn.sender, <uint8>1],
	//       fee: 0,
	//       applicationID: appBiatecIdentityProvider,
	//     })
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	pushbytes 0x127ffb7b // method "getUserShort(address,uint8)(uint8,uint64,uint64,uint64,bool)"
	itxn_field ApplicationArgs

	// contracts\BiatecClammPool.algo.ts:818
	// methodArgs: [this.txn.sender, <uint8>1]
	txn Sender
	itxn_field ApplicationArgs
	pushbytes 0x01
	itxn_field ApplicationArgs

	// contracts\BiatecClammPool.algo.ts:819
	// fee: 0
	intc 1 // 0
	itxn_field Fee

	// contracts\BiatecClammPool.algo.ts:820
	// applicationID: appBiatecIdentityProvider
	frame_dig -2 // appBiatecIdentityProvider: AppID
	itxn_field ApplicationID

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 3 // 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 1 // user: (uint8,uint64,uint64,uint64,bool)

	// contracts\BiatecClammPool.algo.ts:822
	// assert(
	//       !user.isLocked,
	//       'ERR-USER-LOCKED' // 'User must not be locked'
	//     )
	frame_dig 1 // user: (uint8,uint64,uint64,uint64,bool)
	store 255 // full array
	load 255 // full array
	pushint 200
	getbit
	!

	// ERR-USER-LOCKED
	assert

	// contracts\BiatecClammPool.algo.ts:826
	// assert(
	//       user.verificationClass >= this.verificationClass.value, // if(user.verificationClass >= this.verificationClass.value) then ok
	//       'ERR-LOW-VER' // 'User cannot interact with this smart contract as his verification class is lower then required here'
	//     )
	frame_dig 1 // user: (uint8,uint64,uint64,uint64,bool)
	store 255 // full array
	load 255 // full array
	extract 1 8
	btoi
	bytec 30 //  "c"
	app_global_get
	>=

	// ERR-LOW-VER
	assert

	// contracts\BiatecClammPool.algo.ts:831
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 19 //  "s"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('s')
	assert
	frame_bury 2 // paused: uint64

	// contracts\BiatecClammPool.algo.ts:832
	// assert(paused === 0, 'E_PAUSED')
	frame_dig 2 // paused: uint64
	intc 1 // 0
	==

	// E_PAUSED
	assert

	// contracts\BiatecClammPool.algo.ts:834
	// return user;
	frame_dig 1 // user: (uint8,uint64,uint64,uint64,bool)

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// swap(uint64,uint64,uint64,txn,uint64,uint64,uint64)uint256
*abi_route_swap:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// minimumToReceive: uint64
	txna ApplicationArgs 6
	btoi

	// assetB: uint64
	txna ApplicationArgs 5
	btoi

	// assetA: uint64
	txna ApplicationArgs 4
	btoi

	// txSwap: txn
	txn GroupIndex
	intc 3 // 1
	-

	// appBiatecPoolProvider: uint64
	txna ApplicationArgs 3
	btoi

	// appBiatecIdentityProvider: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute swap(uint64,uint64,uint64,txn,uint64,uint64,uint64)uint256
	callsub swap
	dup
	bitlen
	intc 2 // 256
	<=

	// swap return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// swap(appBiatecConfigProvider: AppID, appBiatecIdentityProvider: AppID, appBiatecPoolProvider: AppID, txSwap: Txn, assetA: AssetID, assetB: AssetID, minimumToReceive: uint64): uint256
//
// Swap Asset A to Asset B or Asset B to Asst A
// @param txSwap Transfer of the token to be deposited to the pool. To the owner the other asset will be sent.
// @param assetA Asset A
// @param assetB Asset B
// @param minimumToReceive If number greater then zero, the check is performed for the output of the other asset
swap:
	proto 7 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 32

	// contracts\BiatecClammPool.algo.ts:845
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 1 // 0
	itxn_field Fee
	bytec 6 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:846
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 1 // 0
	itxn_field Fee
	bytec 6 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:847
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 1 // 0
	itxn_field Fee
	bytec 6 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// well formed swap
	// contracts\BiatecClammPool.algo.ts:849
	// this.checkAssetsAB(assetA, assetB)
	frame_dig -6 // assetB: AssetID
	frame_dig -5 // assetA: AssetID
	callsub checkAssetsAB

	// *if31_condition
	// contracts\BiatecClammPool.algo.ts:851
	// txSwap.typeEnum === TransactionType.Payment
	frame_dig -4 // txSwap: Txn
	gtxns TypeEnum
	intc 3 //  pay
	==
	bz *if31_else

	// *if31_consequent
	// contracts\BiatecClammPool.algo.ts:852
	// assert(assetA.id === 0 || assetB.id === 0, 'Payment can be done only when one of the pool assets is native token')
	frame_dig -5 // assetA: AssetID
	intc 1 // 0
	==
	dup
	bnz *skip_or1
	frame_dig -6 // assetB: AssetID
	intc 1 // 0
	==
	||

*skip_or1:
	// Payment can be done only when one of the pool assets is native token
	assert

	// contracts\BiatecClammPool.algo.ts:854
	// verifyPayTxn(txSwap, {
	//         amount: { greaterThan: 0 },
	//         receiver: this.app.address,
	//         sender: this.txn.sender,
	//       })
	// verify pay
	frame_dig -4 // txSwap: Txn
	gtxns TypeEnum
	intc 3 //  pay
	==

	// transaction verification failed: {"txn":"txSwap","field":"typeEnum","expected":"pay"}
	assert

	// verify amount
	frame_dig -4 // txSwap: Txn
	gtxns Amount
	intc 1 // 0
	>

	// transaction verification failed: {"txn":"txSwap","field":"amount","condition":"greaterThan","expected":">0"}
	assert

	// verify receiver
	frame_dig -4 // txSwap: Txn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"txSwap","field":"receiver","expected":"this.app.address"}
	assert

	// verify sender
	frame_dig -4 // txSwap: Txn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"txSwap","field":"sender","expected":"this.txn.sender"}
	assert
	b *if31_end

*if31_else:
	// contracts\BiatecClammPool.algo.ts:860
	// assert(txSwap.typeEnum === TransactionType.AssetTransfer)
	frame_dig -4 // txSwap: Txn
	gtxns TypeEnum
	intc 7 //  axfer
	==
	assert

	// contracts\BiatecClammPool.algo.ts:862
	// verifyAssetTransferTxn(txSwap, {
	//         assetAmount: { greaterThan: 0 },
	//         assetReceiver: this.app.address,
	//         sender: this.txn.sender,
	//         xferAsset: { includedIn: [assetA, assetB] },
	//       })
	// verify axfer
	frame_dig -4 // txSwap: Txn
	gtxns TypeEnum
	intc 7 //  axfer
	==

	// transaction verification failed: {"txn":"txSwap","field":"typeEnum","expected":"axfer"}
	assert

	// verify assetAmount
	frame_dig -4 // txSwap: Txn
	gtxns AssetAmount
	intc 1 // 0
	>

	// transaction verification failed: {"txn":"txSwap","field":"assetAmount","condition":"greaterThan","expected":">0"}
	assert

	// verify assetReceiver
	frame_dig -4 // txSwap: Txn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"txSwap","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify sender
	frame_dig -4 // txSwap: Txn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"txSwap","field":"sender","expected":"this.txn.sender"}
	assert

	// verify xferAsset
	frame_dig -4 // txSwap: Txn
	gtxns XferAsset
	frame_dig -5 // assetA: AssetID
	==
	frame_dig -4 // txSwap: Txn
	gtxns XferAsset
	frame_dig -6 // assetB: AssetID
	==
	||

	// transaction verification failed: {"txn":{"txnText":"txSwap"},"field":"xferAsset","condition":"includedIn","expected":"[assetA, assetB]"}
	assert

*if31_end:
	// contracts\BiatecClammPool.algo.ts:870
	// poolProviderFromConfig = appBiatecConfigProvider.globalState('p') as AppID
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 29 //  "p"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('p')
	assert
	frame_bury 0 // poolProviderFromConfig: uint64

	// contracts\BiatecClammPool.algo.ts:871
	// assert(
	//       appBiatecPoolProvider === poolProviderFromConfig,
	//       'ERR-INVALID-PP' // appBiatecPoolProvider must match to the config in appBiatecConfigProvider'
	//     )
	frame_dig -3 // appBiatecPoolProvider: AppID
	frame_dig 0 // poolProviderFromConfig: uint64
	==

	// ERR-INVALID-PP
	assert

	// contracts\BiatecClammPool.algo.ts:875
	// user = this.verifyIdentity(appBiatecConfigProvider, appBiatecIdentityProvider)
	frame_dig -2 // appBiatecIdentityProvider: AppID
	frame_dig -1 // appBiatecConfigProvider: AppID
	callsub verifyIdentity
	frame_bury 1 // user: (uint8,uint64,uint64,uint64,bool)

	// contracts\BiatecClammPool.algo.ts:877
	// feesMultiplier = (s - ((this.fee.value as uint256) * (user.feeMultiplier as uint256)) / (user.base as uint256)) as uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	bytec 18 //  "f"
	app_global_get
	itob
	frame_dig 1 // user: (uint8,uint64,uint64,uint64,bool)
	store 255 // full array
	load 255 // full array
	extract 9 8
	btoi
	itob
	b*
	frame_dig 1 // user: (uint8,uint64,uint64,uint64,bool)
	store 255 // full array
	load 255 // full array
	extract 17 8
	btoi
	itob
	b/
	b-
	frame_bury 2 // feesMultiplier: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:878
	// ret: uint64 = 0
	intc 1 // 0
	frame_bury 3 // ret: uint64

	// contracts\BiatecClammPool.algo.ts:879
	// amountAForStatsInAssetDecimals = 0
	intc 1 // 0
	frame_bury 4 // amountAForStatsInAssetDecimals: uint64

	// contracts\BiatecClammPool.algo.ts:880
	// amountBForStatsInAssetDecimals = 0
	intc 1 // 0
	frame_bury 5 // amountBForStatsInAssetDecimals: uint64

	// contracts\BiatecClammPool.algo.ts:881
	// feeAmountAForStatsInBaseScale = 0
	intc 1 // 0
	frame_bury 6 // feeAmountAForStatsInBaseScale: uint64

	// contracts\BiatecClammPool.algo.ts:882
	// feeAmountBForStatsInBaseScale = 0
	intc 1 // 0
	frame_bury 7 // feeAmountBForStatsInBaseScale: uint64

	// contracts\BiatecClammPool.algo.ts:884
	// isAssetA = false
	intc 1 // 0
	frame_bury 8 // isAssetA: bool

	// *if32_condition
	// contracts\BiatecClammPool.algo.ts:885
	// txSwap.typeEnum === TransactionType.Payment
	frame_dig -4 // txSwap: Txn
	gtxns TypeEnum
	intc 3 //  pay
	==
	bz *if32_else

	// *if32_consequent
	// contracts\BiatecClammPool.algo.ts:886
	// isAssetA = assetA.id === 0
	frame_dig -5 // assetA: AssetID
	intc 1 // 0
	==
	frame_bury 8 // isAssetA: bool
	b *if32_end

*if32_else:
	// contracts\BiatecClammPool.algo.ts:888
	// isAssetA = txSwap.xferAsset === assetA
	frame_dig -4 // txSwap: Txn
	gtxns XferAsset
	frame_dig -5 // assetA: AssetID
	==
	frame_bury 8 // isAssetA: bool

*if32_end:
	// contracts\BiatecClammPool.algo.ts:890
	// realSwapBaseDecimals = <uint256>0
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 9 // realSwapBaseDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:891
	// inAssetInBaseScale = <uint256>0
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 10 // inAssetInBaseScale: unsafe uint256

	// *if33_condition
	// contracts\BiatecClammPool.algo.ts:892
	// isAssetA
	frame_dig 8 // isAssetA: bool
	bz *if33_end

	// *if33_consequent
	// contracts\BiatecClammPool.algo.ts:893
	// assetInAssetDecimals = <uint256>0
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 11 // assetInAssetDecimals: unsafe uint256

	// *if34_condition
	// contracts\BiatecClammPool.algo.ts:894
	// txSwap.typeEnum === TransactionType.Payment
	frame_dig -4 // txSwap: Txn
	gtxns TypeEnum
	intc 3 //  pay
	==
	bz *if34_else

	// *if34_consequent
	// contracts\BiatecClammPool.algo.ts:895
	// assetInAssetDecimals = txSwap.amount as uint256
	frame_dig -4 // txSwap: Txn
	gtxns Amount
	itob
	frame_bury 11 // assetInAssetDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:896
	// amountAForStatsInAssetDecimals = txSwap.amount
	frame_dig -4 // txSwap: Txn
	gtxns Amount
	frame_bury 4 // amountAForStatsInAssetDecimals: uint64
	b *if34_end

*if34_else:
	// contracts\BiatecClammPool.algo.ts:898
	// assetInAssetDecimals = txSwap.assetAmount as uint256
	frame_dig -4 // txSwap: Txn
	gtxns AssetAmount
	itob
	frame_bury 11 // assetInAssetDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:899
	// amountAForStatsInAssetDecimals = txSwap.assetAmount
	frame_dig -4 // txSwap: Txn
	gtxns AssetAmount
	frame_bury 4 // amountAForStatsInAssetDecimals: uint64

*if34_end:
	// contracts\BiatecClammPool.algo.ts:901
	// inAssetInBaseScale = (assetInAssetDecimals * this.assetADecimalsScaleFromBase.value) as uint256
	frame_dig 11 // assetInAssetDecimals: unsafe uint256
	bytec 9 //  "ad"
	app_global_get
	b*
	frame_bury 10 // inAssetInBaseScale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:902
	// inAssetAfterFee = (inAssetInBaseScale * feesMultiplier) / s
	frame_dig 10 // inAssetInBaseScale: unsafe uint256
	frame_dig 2 // feesMultiplier: unsafe uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 12 // inAssetAfterFee: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:904
	// toSwap = this.calculateAssetBWithdrawOnAssetADeposit(
	//         inAssetAfterFee,
	//         this.assetABalanceBaseScale.value,
	//         this.assetBBalanceBaseScale.value,
	//         this.priceMinSqrt.value,
	//         this.priceMaxSqrt.value,
	//         this.Liquidity.value
	//       )
	bytec 8 //  "L"
	app_global_get
	bytec 16 //  "pMaxS"
	app_global_get
	bytec 15 //  "pMinS"
	app_global_get
	bytec 5 //  "bb"
	app_global_get
	bytec 4 //  "ab"
	app_global_get
	frame_dig 12 // inAssetAfterFee: unsafe uint256
	dup
	bitlen
	intc 2 // 256
	<=

	// inAssetAfterFee overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub calculateAssetBWithdrawOnAssetADeposit
	frame_bury 13 // toSwap: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:912
	// realSwapBaseDecimals = toSwap
	frame_dig 13 // toSwap: unsafe uint256
	frame_bury 9 // realSwapBaseDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:913
	// realSwapBDecimals = (toSwap / this.assetBDecimalsScaleFromBase.value) as uint256
	frame_dig 13 // toSwap: unsafe uint256
	bytec 10 //  "bd"
	app_global_get
	b/
	frame_bury 14 // realSwapBDecimals: unsafe uint256

	// *if35_condition
	// contracts\BiatecClammPool.algo.ts:915
	// realSwapBDecimals * this.assetBDecimalsScaleFromBase.value !== toSwap
	frame_dig 14 // realSwapBDecimals: unsafe uint256
	bytec 10 //  "bd"
	app_global_get
	b*
	frame_dig 13 // toSwap: unsafe uint256
	b!=
	bz *if35_end

	// *if35_consequent
	// contracts\BiatecClammPool.algo.ts:916
	// realSwapBDecimals = realSwapBDecimals - <uint256>1
	frame_dig 14 // realSwapBDecimals: unsafe uint256
	bytec 31 // 0x0000000000000000000000000000000000000000000000000000000000000001
	b-
	frame_bury 14 // realSwapBDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:917
	// realSwapBaseDecimals = realSwapBDecimals * this.assetBDecimalsScaleFromBase.value
	frame_dig 14 // realSwapBDecimals: unsafe uint256
	bytec 10 //  "bd"
	app_global_get
	b*
	frame_bury 9 // realSwapBaseDecimals: unsafe uint256

*if35_end:
	// contracts\BiatecClammPool.algo.ts:919
	// toSwapBDecimals = realSwapBDecimals as uint64
	frame_dig 14 // realSwapBDecimals: unsafe uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// realSwapBDecimals as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 15 // toSwapBDecimals: uint64

	// contracts\BiatecClammPool.algo.ts:920
	// ret = toSwapBDecimals
	frame_dig 15 // toSwapBDecimals: uint64
	frame_bury 3 // ret: uint64

	// *if36_condition
	// contracts\BiatecClammPool.algo.ts:921
	// minimumToReceive > 0
	frame_dig -7 // minimumToReceive: uint64
	intc 1 // 0
	>
	bz *if36_end

	// *if36_consequent
	// contracts\BiatecClammPool.algo.ts:923
	// assert(toSwapBDecimals >= minimumToReceive, 'Minimum to receive is not met')
	frame_dig 15 // toSwapBDecimals: uint64
	frame_dig -7 // minimumToReceive: uint64
	>=

	// Minimum to receive is not met
	assert

*if36_end:
	// contracts\BiatecClammPool.algo.ts:925
	// amountBForStatsInAssetDecimals = toSwapBDecimals
	frame_dig 15 // toSwapBDecimals: uint64
	frame_bury 5 // amountBForStatsInAssetDecimals: uint64

	// contracts\BiatecClammPool.algo.ts:926
	// this.doAxfer(this.txn.sender, assetB, toSwapBDecimals)
	frame_dig 15 // toSwapBDecimals: uint64
	frame_dig -6 // assetB: AssetID
	txn Sender
	callsub doAxfer

	// contracts\BiatecClammPool.algo.ts:928
	// this.assetABalanceBaseScale.value = this.assetABalanceBaseScale.value + inAssetInBaseScale
	bytec 4 //  "ab"
	dup
	app_global_get
	frame_dig 10 // inAssetInBaseScale: unsafe uint256
	b+
	dup
	bitlen
	intc 2 // 256
	<=

	// this.assetABalanceBaseScale.value + inAssetInBaseScale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:929
	// this.assetBBalanceBaseScale.value = this.assetBBalanceBaseScale.value - realSwapBaseDecimals
	bytec 5 //  "bb"
	dup
	app_global_get
	frame_dig 9 // realSwapBaseDecimals: unsafe uint256
	b-
	dup
	bitlen
	intc 2 // 256
	<=

	// this.assetBBalanceBaseScale.value - realSwapBaseDecimals overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

*if33_end:
	// *if37_condition
	// contracts\BiatecClammPool.algo.ts:932
	// !isAssetA
	frame_dig 8 // isAssetA: bool
	!
	bz *if37_end

	// *if37_consequent
	// contracts\BiatecClammPool.algo.ts:933
	// assetInAssetDecimals = <uint256>0
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 16 // assetInAssetDecimals: unsafe uint256

	// *if38_condition
	// contracts\BiatecClammPool.algo.ts:934
	// txSwap.typeEnum === TransactionType.Payment
	frame_dig -4 // txSwap: Txn
	gtxns TypeEnum
	intc 3 //  pay
	==
	bz *if38_else

	// *if38_consequent
	// contracts\BiatecClammPool.algo.ts:935
	// assetInAssetDecimals = txSwap.amount as uint256
	frame_dig -4 // txSwap: Txn
	gtxns Amount
	itob
	frame_bury 16 // assetInAssetDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:936
	// amountBForStatsInAssetDecimals = txSwap.amount
	frame_dig -4 // txSwap: Txn
	gtxns Amount
	frame_bury 5 // amountBForStatsInAssetDecimals: uint64
	b *if38_end

*if38_else:
	// contracts\BiatecClammPool.algo.ts:938
	// assetInAssetDecimals = txSwap.assetAmount as uint256
	frame_dig -4 // txSwap: Txn
	gtxns AssetAmount
	itob
	frame_bury 16 // assetInAssetDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:939
	// amountBForStatsInAssetDecimals = txSwap.assetAmount
	frame_dig -4 // txSwap: Txn
	gtxns AssetAmount
	frame_bury 5 // amountBForStatsInAssetDecimals: uint64

*if38_end:
	// contracts\BiatecClammPool.algo.ts:941
	// inAssetInBaseScale = (assetInAssetDecimals * this.assetBDecimalsScaleFromBase.value) as uint256
	frame_dig 16 // assetInAssetDecimals: unsafe uint256
	bytec 10 //  "bd"
	app_global_get
	b*
	frame_bury 10 // inAssetInBaseScale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:942
	// inAssetAfterFee = (inAssetInBaseScale * feesMultiplier) / s
	frame_dig 10 // inAssetInBaseScale: unsafe uint256
	frame_dig 2 // feesMultiplier: unsafe uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 17 // inAssetAfterFee: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:943
	// toSwap = this.calculateAssetAWithdrawOnAssetBDeposit(
	//         inAssetAfterFee,
	//         this.assetABalanceBaseScale.value,
	//         this.assetBBalanceBaseScale.value,
	//         this.priceMinSqrt.value,
	//         this.priceMaxSqrt.value,
	//         this.Liquidity.value
	//       )
	bytec 8 //  "L"
	app_global_get
	bytec 16 //  "pMaxS"
	app_global_get
	bytec 15 //  "pMinS"
	app_global_get
	bytec 5 //  "bb"
	app_global_get
	bytec 4 //  "ab"
	app_global_get
	frame_dig 17 // inAssetAfterFee: unsafe uint256
	dup
	bitlen
	intc 2 // 256
	<=

	// inAssetAfterFee overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub calculateAssetAWithdrawOnAssetBDeposit
	frame_bury 18 // toSwap: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:951
	// realSwapBaseDecimals = toSwap
	frame_dig 18 // toSwap: unsafe uint256
	frame_bury 9 // realSwapBaseDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:952
	// realSwapADecimals = toSwap / this.assetADecimalsScaleFromBase.value
	frame_dig 18 // toSwap: unsafe uint256
	bytec 9 //  "ad"
	app_global_get
	b/
	frame_bury 19 // realSwapADecimals: unsafe uint256

	// *if39_condition
	// contracts\BiatecClammPool.algo.ts:954
	// realSwapADecimals * this.assetADecimalsScaleFromBase.value !== toSwap
	frame_dig 19 // realSwapADecimals: unsafe uint256
	bytec 9 //  "ad"
	app_global_get
	b*
	frame_dig 18 // toSwap: unsafe uint256
	b!=
	bz *if39_end

	// *if39_consequent
	// contracts\BiatecClammPool.algo.ts:955
	// realSwapADecimals = realSwapADecimals - <uint256>1
	frame_dig 19 // realSwapADecimals: unsafe uint256
	bytec 31 // 0x0000000000000000000000000000000000000000000000000000000000000001
	b-
	frame_bury 19 // realSwapADecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:956
	// realSwapBaseDecimals = realSwapADecimals * this.assetADecimalsScaleFromBase.value
	frame_dig 19 // realSwapADecimals: unsafe uint256
	bytec 9 //  "ad"
	app_global_get
	b*
	frame_bury 9 // realSwapBaseDecimals: unsafe uint256

*if39_end:
	// contracts\BiatecClammPool.algo.ts:958
	// toSwapADecimals = realSwapADecimals as uint64
	frame_dig 19 // realSwapADecimals: unsafe uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// realSwapADecimals as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 20 // toSwapADecimals: uint64

	// contracts\BiatecClammPool.algo.ts:959
	// ret = toSwapADecimals
	frame_dig 20 // toSwapADecimals: uint64
	frame_bury 3 // ret: uint64

	// *if40_condition
	// contracts\BiatecClammPool.algo.ts:960
	// minimumToReceive > 0
	frame_dig -7 // minimumToReceive: uint64
	intc 1 // 0
	>
	bz *if40_end

	// *if40_consequent
	// contracts\BiatecClammPool.algo.ts:962
	// assert(toSwapADecimals >= minimumToReceive, 'Minimum to receive is not met')
	frame_dig 20 // toSwapADecimals: uint64
	frame_dig -7 // minimumToReceive: uint64
	>=

	// Minimum to receive is not met
	assert

*if40_end:
	// contracts\BiatecClammPool.algo.ts:964
	// amountAForStatsInAssetDecimals = toSwapADecimals
	frame_dig 20 // toSwapADecimals: uint64
	frame_bury 4 // amountAForStatsInAssetDecimals: uint64

	// contracts\BiatecClammPool.algo.ts:965
	// this.doAxfer(this.txn.sender, assetA, toSwapADecimals)
	frame_dig 20 // toSwapADecimals: uint64
	frame_dig -5 // assetA: AssetID
	txn Sender
	callsub doAxfer

	// contracts\BiatecClammPool.algo.ts:967
	// this.assetBBalanceBaseScale.value = this.assetBBalanceBaseScale.value + inAssetInBaseScale
	bytec 5 //  "bb"
	dup
	app_global_get
	frame_dig 10 // inAssetInBaseScale: unsafe uint256
	b+
	dup
	bitlen
	intc 2 // 256
	<=

	// this.assetBBalanceBaseScale.value + inAssetInBaseScale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:968
	// this.assetABalanceBaseScale.value = this.assetABalanceBaseScale.value - realSwapBaseDecimals
	bytec 4 //  "ab"
	dup
	app_global_get
	frame_dig 9 // realSwapBaseDecimals: unsafe uint256
	b-
	dup
	bitlen
	intc 2 // 256
	<=

	// this.assetABalanceBaseScale.value - realSwapBaseDecimals overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

*if37_end:
	// contracts\BiatecClammPool.algo.ts:970
	// oldL = this.Liquidity.value
	bytec 8 //  "L"
	app_global_get
	frame_bury 21 // oldL: uint256

	// contracts\BiatecClammPool.algo.ts:971
	// newL = this.setCurrentLiquidityNonDecreasing(oldL)
	frame_dig 21 // oldL: uint256
	callsub setCurrentLiquidityNonDecreasing
	frame_bury 22 // newL: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:975
	// diff = (newL - oldL) as uint256
	frame_dig 22 // newL: unsafe uint256
	frame_dig 21 // oldL: uint256
	b-
	frame_bury 23 // diff: unsafe uint256

	// *if41_condition
	// contracts\BiatecClammPool.algo.ts:977
	// isAssetA
	frame_dig 8 // isAssetA: bool
	bz *if41_else

	// *if41_consequent
	// contracts\BiatecClammPool.algo.ts:979
	// feeB256 = (this.assetABalanceBaseScale.value * diff) / newL
	bytec 4 //  "ab"
	app_global_get
	frame_dig 23 // diff: unsafe uint256
	b*
	frame_dig 22 // newL: unsafe uint256
	b/
	frame_bury 24 // feeB256: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:980
	// feeAmountAForStatsInBaseScale = feeB256 as uint64
	frame_dig 24 // feeB256: unsafe uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// feeB256 as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 6 // feeAmountAForStatsInBaseScale: uint64

	// contracts\BiatecClammPool.algo.ts:981
	// feeAmountBForStatsInBaseScale = 0
	intc 1 // 0
	frame_bury 7 // feeAmountBForStatsInBaseScale: uint64
	b *if41_end

*if41_else:
	// contracts\BiatecClammPool.algo.ts:984
	// feeB256 = (this.assetBBalanceBaseScale.value * diff) / newL
	bytec 5 //  "bb"
	app_global_get
	frame_dig 23 // diff: unsafe uint256
	b*
	frame_dig 22 // newL: unsafe uint256
	b/
	frame_bury 25 // feeB256: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:985
	// feeAmountAForStatsInBaseScale = 0
	intc 1 // 0
	frame_bury 6 // feeAmountAForStatsInBaseScale: uint64

	// contracts\BiatecClammPool.algo.ts:986
	// feeAmountBForStatsInBaseScale = feeB256 as uint64
	frame_dig 25 // feeB256: unsafe uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// feeB256 as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 7 // feeAmountBForStatsInBaseScale: uint64

*if41_end:
	// contracts\BiatecClammPool.algo.ts:989
	// biatecFee = this.appBiatecConfigProvider.value.globalState('f') as uint256
	bytec 13 //  "bc"
	app_global_get
	bytec 18 //  "f"
	app_global_get_ex

	// global state value does not exist: this.appBiatecConfigProvider.value.globalState('f')
	assert
	frame_bury 26 // biatecFee: uint256

	// *if42_condition
	// contracts\BiatecClammPool.algo.ts:990
	// biatecFee === <uint256>0
	frame_dig 26 // biatecFee: uint256
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b==
	bz *if42_else

	// *if42_consequent
	// contracts\BiatecClammPool.algo.ts:991
	// usersLiquidityFromFeeIncrement = diff
	frame_dig 23 // diff: unsafe uint256
	frame_bury 27 // usersLiquidityFromFeeIncrement: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:992
	// this.LiquidityUsersFromFees.value = this.LiquidityUsersFromFees.value + usersLiquidityFromFeeIncrement
	bytec 12 //  "Lu"
	dup
	app_global_get
	frame_dig 27 // usersLiquidityFromFeeIncrement: unsafe uint256
	b+
	dup
	bitlen
	intc 2 // 256
	<=

	// this.LiquidityUsersFromFees.value + usersLiquidityFromFeeIncrement overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put
	b *if42_end

*if42_else:
	// contracts\BiatecClammPool.algo.ts:994
	// usersLiquidityFromFeeIncrement = (diff * (s - biatecFee)) / s
	frame_dig 23 // diff: unsafe uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	frame_dig 26 // biatecFee: uint256
	b-
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 28 // usersLiquidityFromFeeIncrement: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:995
	// biatecLiquidityFromFeeIncrement = diff - usersLiquidityFromFeeIncrement
	frame_dig 23 // diff: unsafe uint256
	frame_dig 28 // usersLiquidityFromFeeIncrement: unsafe uint256
	b-
	frame_bury 29 // biatecLiquidityFromFeeIncrement: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:996
	// this.LiquidityUsersFromFees.value = this.LiquidityUsersFromFees.value + usersLiquidityFromFeeIncrement
	bytec 12 //  "Lu"
	dup
	app_global_get
	frame_dig 28 // usersLiquidityFromFeeIncrement: unsafe uint256
	b+
	dup
	bitlen
	intc 2 // 256
	<=

	// this.LiquidityUsersFromFees.value + usersLiquidityFromFeeIncrement overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:997
	// this.LiquidityBiatecFromFees.value = this.LiquidityBiatecFromFees.value + biatecLiquidityFromFeeIncrement
	bytec 14 //  "Lb"
	dup
	app_global_get
	frame_dig 29 // biatecLiquidityFromFeeIncrement: unsafe uint256
	b+
	dup
	bitlen
	intc 2 // 256
	<=

	// this.LiquidityBiatecFromFees.value + biatecLiquidityFromFeeIncrement overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

*if42_end:
	// contracts\BiatecClammPool.algo.ts:1000
	// newPrice = this.calculatePrice(
	//       this.assetABalanceBaseScale.value, // assetAQuantity: uint256,
	//       this.assetBBalanceBaseScale.value, // assetBQuantity: uint256,
	//       this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//       this.priceMaxSqrt.value, // priceMaxSqrt: uint256,
	//       this.Liquidity.value // liquidity: uint256
	//     )
	bytec 8 //  "L"
	app_global_get
	bytec 16 //  "pMaxS"
	app_global_get
	bytec 15 //  "pMinS"
	app_global_get
	bytec 5 //  "bb"
	app_global_get
	bytec 4 //  "ab"
	app_global_get
	callsub calculatePrice
	frame_bury 30 // newPrice: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1007
	// assert(amountAForStatsInAssetDecimals > 0 && amountBForStatsInAssetDecimals > 0, 'Stats to register must not be empty')
	frame_dig 4 // amountAForStatsInAssetDecimals: uint64
	intc 1 // 0
	>
	dup
	bz *skip_and2
	frame_dig 5 // amountBForStatsInAssetDecimals: uint64
	intc 1 // 0
	>
	&&

*skip_and2:
	// Stats to register must not be empty
	assert

	// contracts\BiatecClammPool.algo.ts:1009
	// assetADelicmalScale2Scale: uint64 = this.assetADecimalsScaleFromBase.value as uint64
	bytec 9 //  "ad"
	app_global_get
	dup
	bitlen
	intc 4 // 64
	<=

	// this.assetADecimalsScaleFromBase.value as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	frame_bury 31 // assetADelicmalScale2Scale: uint64

	// contracts\BiatecClammPool.algo.ts:1010
	// assetBDelicmalScale2Scale: uint64 = this.assetBDecimalsScaleFromBase.value as uint64
	bytec 10 //  "bd"
	app_global_get
	dup
	bitlen
	intc 4 // 64
	<=

	// this.assetBDecimalsScaleFromBase.value as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	frame_bury 32 // assetBDelicmalScale2Scale: uint64

	// contracts\BiatecClammPool.algo.ts:1011
	// sendMethodCall<[AppID, AssetID, AssetID, uint64, uint64, uint64, uint64, uint64, uint64, uint64], void>({
	//       name: 'registerTrade',
	//       methodArgs: [
	//         globals.currentApplicationID,
	//         assetA,
	//         assetB,
	//         this.currentPrice.value as uint64,
	//         newPrice as uint64,
	//         amountAForStatsInAssetDecimals * assetADelicmalScale2Scale,
	//         amountBForStatsInAssetDecimals * assetBDelicmalScale2Scale,
	//         feeAmountAForStatsInBaseScale,
	//         feeAmountBForStatsInBaseScale,
	//         SCALE,
	//       ],
	//       fee: 0,
	//       applicationID: appBiatecPoolProvider,
	//     })
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	pushbytes 0xe13e4f5a // method "registerTrade(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)void"
	itxn_field ApplicationArgs

	// contracts\BiatecClammPool.algo.ts:1013
	// methodArgs: [
	//         globals.currentApplicationID,
	//         assetA,
	//         assetB,
	//         this.currentPrice.value as uint64,
	//         newPrice as uint64,
	//         amountAForStatsInAssetDecimals * assetADelicmalScale2Scale,
	//         amountBForStatsInAssetDecimals * assetBDelicmalScale2Scale,
	//         feeAmountAForStatsInBaseScale,
	//         feeAmountBForStatsInBaseScale,
	//         SCALE,
	//       ]
	global CurrentApplicationID
	itob
	itxn_field ApplicationArgs
	frame_dig -5 // assetA: AssetID
	itob
	itxn_field ApplicationArgs
	frame_dig -6 // assetB: AssetID
	itob
	itxn_field ApplicationArgs
	bytec 17 //  "price"
	app_global_get
	itob
	itxn_field ApplicationArgs
	frame_dig 30 // newPrice: unsafe uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// newPrice as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	itob
	itxn_field ApplicationArgs
	frame_dig 4 // amountAForStatsInAssetDecimals: uint64
	frame_dig 31 // assetADelicmalScale2Scale: uint64
	*
	itob
	itxn_field ApplicationArgs
	frame_dig 5 // amountBForStatsInAssetDecimals: uint64
	frame_dig 32 // assetBDelicmalScale2Scale: uint64
	*
	itob
	itxn_field ApplicationArgs
	frame_dig 6 // feeAmountAForStatsInBaseScale: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig 7 // feeAmountBForStatsInBaseScale: uint64
	itob
	itxn_field ApplicationArgs
	bytec 32 // 0x000000003b9aca00
	itxn_field ApplicationArgs

	// contracts\BiatecClammPool.algo.ts:1025
	// fee: 0
	intc 1 // 0
	itxn_field Fee

	// contracts\BiatecClammPool.algo.ts:1026
	// applicationID: appBiatecPoolProvider
	frame_dig -3 // appBiatecPoolProvider: AppID
	itxn_field ApplicationID

	// Submit inner transaction
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:1029
	// this.currentPrice.value = newPrice as uint64
	bytec 17 //  "price"
	frame_dig 30 // newPrice: unsafe uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// newPrice as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	app_global_put

	// contracts\BiatecClammPool.algo.ts:1051
	// return ret as uint256;
	frame_dig 3 // ret: uint64
	itob

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 32
	retsub

// distributeExcessAssets(uint64,uint64,uint64,uint256,uint256)uint256
*abi_route_distributeExcessAssets:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// amountB: uint256
	txna ApplicationArgs 5
	dup
	len
	intc 0 // 32
	==

	// argument 0 (amountB) for distributeExcessAssets must be a uint256
	assert

	// amountA: uint256
	txna ApplicationArgs 4
	dup
	len
	intc 0 // 32
	==

	// argument 1 (amountA) for distributeExcessAssets must be a uint256
	assert

	// assetB: uint64
	txna ApplicationArgs 3
	btoi

	// assetA: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute distributeExcessAssets(uint64,uint64,uint64,uint256,uint256)uint256
	callsub distributeExcessAssets
	dup
	bitlen
	intc 2 // 256
	<=

	// distributeExcessAssets return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// distributeExcessAssets(appBiatecConfigProvider: AppID, assetA: AssetID, assetB: AssetID, amountA: uint256, amountB: uint256): uint256
//
// If someone deposits excess assets to the LP pool, addressExecutiveFee can either distribute them to the lp tokens or withdraw it, depending on the use case.
// If someone sent there assets in fault, the withrawing can be use to return them back. If the pool received assets for example for having its algo stake online and recieved rewards it is prefered to distribute them to the current LP holders.
//
// This method is used to distribute amount a and amount b of asset a and asset b to holders as the fee income.
//
// Only addressExecutiveFee is allowed to execute this method.
//
// @param appBiatecConfigProvider Biatec config app. Only addressExecutiveFee is allowed to execute this method.
// @param assetA Asset A
// @param assetB Asset B
// @param amountA Amount of asset A to be deposited to the liquidity. In base decimals (9)
// @param amountB Amount of asset B to be deposited to the liquidity. In base decimals (9)
distributeExcessAssets:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 9

	// contracts\BiatecClammPool.algo.ts:1069
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 1 // 0
	itxn_field Fee
	bytec 6 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:1070
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 1 // 0
	itxn_field Fee
	bytec 6 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:1071
	// this.checkAssetsAB(assetA, assetB)
	frame_dig -3 // assetB: AssetID
	frame_dig -2 // assetA: AssetID
	callsub checkAssetsAB

	// contracts\BiatecClammPool.algo.ts:1073
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value, 'E_CONFIG')
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 13 //  "bc"
	app_global_get
	==

	// E_CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:1074
	// addressExecutiveFee = appBiatecConfigProvider.globalState('ef') as Address
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 24 //  "ef"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('ef')
	assert
	frame_bury 0 // addressExecutiveFee: address

	// contracts\BiatecClammPool.algo.ts:1076
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 19 //  "s"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('s')
	assert
	frame_bury 1 // paused: uint64

	// contracts\BiatecClammPool.algo.ts:1077
	// assert(paused === 0, 'E_PAUSED')
	frame_dig 1 // paused: uint64
	intc 1 // 0
	==

	// E_PAUSED
	assert

	// contracts\BiatecClammPool.algo.ts:1079
	// assert(
	//       this.txn.sender === addressExecutiveFee,
	//       'E_SENDER' // 'Only fee executor setup in the config can take the collected fees'
	//     )
	txn Sender
	frame_dig 0 // addressExecutiveFee: address
	==

	// E_SENDER
	assert

	// contracts\BiatecClammPool.algo.ts:1084
	// this.assetABalanceBaseScale.value = this.assetABalanceBaseScale.value + amountA
	bytec 4 //  "ab"
	dup
	app_global_get
	frame_dig -4 // amountA: uint256
	b+
	dup
	bitlen
	intc 2 // 256
	<=

	// this.assetABalanceBaseScale.value + amountA overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:1085
	// this.assetBBalanceBaseScale.value = this.assetBBalanceBaseScale.value + amountB
	bytec 5 //  "bb"
	dup
	app_global_get
	frame_dig -5 // amountB: uint256
	b+
	dup
	bitlen
	intc 2 // 256
	<=

	// this.assetBBalanceBaseScale.value + amountB overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// *if43_condition
	// contracts\BiatecClammPool.algo.ts:1086
	// assetA.id === 0
	frame_dig -2 // assetA: AssetID
	intc 1 // 0
	==
	bz *if43_else

	// *if43_consequent
	// contracts\BiatecClammPool.algo.ts:1087
	// assert(
	//         ((this.app.address.balance - 1_000_000) as uint256) * this.assetADecimalsScaleFromBase.value >= this.assetABalanceBaseScale.value,
	//         'E_A0_B' // 'It is not possible to set higher assetABalance in algos then is in the app balance'
	//       )
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	intc 11 // 1_000_000
	-
	itob
	bytec 9 //  "ad"
	app_global_get
	b*
	bytec 4 //  "ab"
	app_global_get
	b>=

	// E_A0_B
	assert
	b *if43_end

*if43_else:
	// contracts\BiatecClammPool.algo.ts:1092
	// assert(
	//         (this.app.address.assetBalance(assetA) as uint256) * this.assetADecimalsScaleFromBase.value >= this.assetABalanceBaseScale.value,
	//         'E_A_B' // 'It is not possible to set higher assetABalance then is in the app balance'
	//       )
	global CurrentApplicationAddress
	frame_dig -2 // assetA: AssetID
	asset_holding_get AssetBalance
	pop
	itob
	bytec 9 //  "ad"
	app_global_get
	b*
	bytec 4 //  "ab"
	app_global_get
	b>=

	// E_A_B
	assert

*if43_end:
	// *if44_condition
	// contracts\BiatecClammPool.algo.ts:1097
	// assetB.id === 0
	frame_dig -3 // assetB: AssetID
	intc 1 // 0
	==
	bz *if44_else

	// *if44_consequent
	// contracts\BiatecClammPool.algo.ts:1098
	// assert(
	//         ((this.app.address.balance - 1_000_000) as uint256) * this.assetBDecimalsScaleFromBase.value >= this.assetBBalanceBaseScale.value,
	//         'E_B0_B' // 'It is not possible to set higher assetBBalance in algos then is in the app balance'
	//       )
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	intc 11 // 1_000_000
	-
	itob
	bytec 10 //  "bd"
	app_global_get
	b*
	bytec 5 //  "bb"
	app_global_get
	b>=

	// E_B0_B
	assert
	b *if44_end

*if44_else:
	// contracts\BiatecClammPool.algo.ts:1103
	// assert(
	//         (this.app.address.assetBalance(assetB) as uint256) * this.assetBDecimalsScaleFromBase.value >= this.assetBBalanceBaseScale.value,
	//         'E_B_B' // 'It is not possible to set higher assetBBalance then is in the app balance'
	//       )
	global CurrentApplicationAddress
	frame_dig -3 // assetB: AssetID
	asset_holding_get AssetBalance
	pop
	itob
	bytec 10 //  "bd"
	app_global_get
	b*
	bytec 5 //  "bb"
	app_global_get
	b>=

	// E_B_B
	assert

*if44_end:
	// contracts\BiatecClammPool.algo.ts:1108
	// oldL = this.Liquidity.value
	bytec 8 //  "L"
	app_global_get
	frame_bury 2 // oldL: uint256

	// contracts\BiatecClammPool.algo.ts:1109
	// newL = this.setCurrentLiquidityNonDecreasing(oldL)
	frame_dig 2 // oldL: uint256
	callsub setCurrentLiquidityNonDecreasing
	frame_bury 3 // newL: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1111
	// diff = (newL - oldL) as uint256
	frame_dig 3 // newL: unsafe uint256
	frame_dig 2 // oldL: uint256
	b-
	frame_bury 4 // diff: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1113
	// biatecFee = this.appBiatecConfigProvider.value.globalState('f') as uint256
	bytec 13 //  "bc"
	app_global_get
	bytec 18 //  "f"
	app_global_get_ex

	// global state value does not exist: this.appBiatecConfigProvider.value.globalState('f')
	assert
	frame_bury 5 // biatecFee: uint256

	// *if45_condition
	// contracts\BiatecClammPool.algo.ts:1114
	// biatecFee === <uint256>0
	frame_dig 5 // biatecFee: uint256
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b==
	bz *if45_else

	// *if45_consequent
	// contracts\BiatecClammPool.algo.ts:1115
	// usersLiquidityFromFeeIncrement = diff
	frame_dig 4 // diff: unsafe uint256
	frame_bury 6 // usersLiquidityFromFeeIncrement: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1116
	// this.LiquidityUsersFromFees.value = this.LiquidityUsersFromFees.value + usersLiquidityFromFeeIncrement
	bytec 12 //  "Lu"
	dup
	app_global_get
	frame_dig 6 // usersLiquidityFromFeeIncrement: unsafe uint256
	b+
	dup
	bitlen
	intc 2 // 256
	<=

	// this.LiquidityUsersFromFees.value + usersLiquidityFromFeeIncrement overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put
	b *if45_end

*if45_else:
	// contracts\BiatecClammPool.algo.ts:1118
	// usersLiquidityFromFeeIncrement = (diff * (s - biatecFee)) / s
	frame_dig 4 // diff: unsafe uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	frame_dig 5 // biatecFee: uint256
	b-
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 7 // usersLiquidityFromFeeIncrement: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1119
	// biatecLiquidityFromFeeIncrement = diff - usersLiquidityFromFeeIncrement
	frame_dig 4 // diff: unsafe uint256
	frame_dig 7 // usersLiquidityFromFeeIncrement: unsafe uint256
	b-
	frame_bury 8 // biatecLiquidityFromFeeIncrement: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1120
	// this.LiquidityUsersFromFees.value = this.LiquidityUsersFromFees.value + usersLiquidityFromFeeIncrement
	bytec 12 //  "Lu"
	dup
	app_global_get
	frame_dig 7 // usersLiquidityFromFeeIncrement: unsafe uint256
	b+
	dup
	bitlen
	intc 2 // 256
	<=

	// this.LiquidityUsersFromFees.value + usersLiquidityFromFeeIncrement overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:1121
	// this.LiquidityBiatecFromFees.value = this.LiquidityBiatecFromFees.value + biatecLiquidityFromFeeIncrement
	bytec 14 //  "Lb"
	dup
	app_global_get
	frame_dig 8 // biatecLiquidityFromFeeIncrement: unsafe uint256
	b+
	dup
	bitlen
	intc 2 // 256
	<=

	// this.LiquidityBiatecFromFees.value + biatecLiquidityFromFeeIncrement overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

*if45_end:
	// contracts\BiatecClammPool.algo.ts:1124
	// newPrice = this.calculatePrice(
	//       this.assetABalanceBaseScale.value, // assetAQuantity: uint256,
	//       this.assetBBalanceBaseScale.value, // assetBQuantity: uint256,
	//       this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//       this.priceMaxSqrt.value, // priceMaxSqrt: uint256,
	//       this.Liquidity.value // liquidity: uint256
	//     )
	bytec 8 //  "L"
	app_global_get
	bytec 16 //  "pMaxS"
	app_global_get
	bytec 15 //  "pMinS"
	app_global_get
	bytec 5 //  "bb"
	app_global_get
	bytec 4 //  "ab"
	app_global_get
	callsub calculatePrice
	frame_bury 9 // newPrice: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1131
	// this.currentPrice.value = newPrice as uint64
	bytec 17 //  "price"
	frame_dig 9 // newPrice: unsafe uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// newPrice as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	app_global_put

	// contracts\BiatecClammPool.algo.ts:1132
	// return diff;
	frame_dig 4 // diff: unsafe uint256

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 9
	retsub

// withdrawExcessAssets(uint64,uint64,uint64,uint64,uint64)uint64
*abi_route_withdrawExcessAssets:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// amountB: uint64
	txna ApplicationArgs 5
	btoi

	// amountA: uint64
	txna ApplicationArgs 4
	btoi

	// assetB: uint64
	txna ApplicationArgs 3
	btoi

	// assetA: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute withdrawExcessAssets(uint64,uint64,uint64,uint64,uint64)uint64
	callsub withdrawExcessAssets
	itob
	concat
	log
	intc 3 // 1
	return

// withdrawExcessAssets(appBiatecConfigProvider: AppID, assetA: AssetID, assetB: AssetID, amountA: uint64, amountB: uint64): uint64
//
// If someone deposits excess assets to the LP pool, addressExecutiveFee can either distribute them to the lp tokens or withdraw it, depending on the use case.
// If someone sent there assets in fault, the withrawing can be use to return them back. If the pool received assets for example for having its algo stake online and recieved rewards it is prefered to distribute them to the current LP holders.
//
// This method is used to distribute amount a and amount b of asset a and asset b to addressExecutiveFee account.
//
// Only addressExecutiveFee is allowed to execute this method.
//
// @param appBiatecConfigProvider Biatec config app. Only addressExecutiveFee is allowed to execute this method.
// @param assetA Asset A
// @param assetB Asset B
// @param amountA Amount of asset A to be deposited to the liquidity. In asset a decimals
// @param amountB Amount of asset B to be deposited to the liquidity. In asset b decimals
withdrawExcessAssets:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts\BiatecClammPool.algo.ts:1150
	// this.checkAssetsAB(assetA, assetB)
	frame_dig -3 // assetB: AssetID
	frame_dig -2 // assetA: AssetID
	callsub checkAssetsAB

	// contracts\BiatecClammPool.algo.ts:1152
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value, 'E_CONFIG')
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 13 //  "bc"
	app_global_get
	==

	// E_CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:1153
	// addressExecutiveFee = appBiatecConfigProvider.globalState('ef') as Address
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 24 //  "ef"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('ef')
	assert
	frame_bury 0 // addressExecutiveFee: address

	// contracts\BiatecClammPool.algo.ts:1155
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 19 //  "s"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('s')
	assert
	frame_bury 1 // paused: uint64

	// contracts\BiatecClammPool.algo.ts:1156
	// assert(paused === 0, 'E_PAUSED')
	frame_dig 1 // paused: uint64
	intc 1 // 0
	==

	// E_PAUSED
	assert

	// contracts\BiatecClammPool.algo.ts:1158
	// assert(
	//       this.txn.sender === addressExecutiveFee,
	//       'E_SENDER' // 'Only fee executor setup in the config can take the collected fees'
	//     )
	txn Sender
	frame_dig 0 // addressExecutiveFee: address
	==

	// E_SENDER
	assert

	// *if46_condition
	// contracts\BiatecClammPool.algo.ts:1163
	// amountA > 0
	frame_dig -4 // amountA: uint64
	intc 1 // 0
	>
	bz *if46_end

	// *if46_consequent
	// contracts\BiatecClammPool.algo.ts:1164
	// this.doAxfer(this.txn.sender, assetA, amountA)
	frame_dig -4 // amountA: uint64
	frame_dig -2 // assetA: AssetID
	txn Sender
	callsub doAxfer

*if46_end:
	// *if47_condition
	// contracts\BiatecClammPool.algo.ts:1166
	// amountB > 0
	frame_dig -5 // amountB: uint64
	intc 1 // 0
	>
	bz *if47_end

	// *if47_consequent
	// contracts\BiatecClammPool.algo.ts:1167
	// this.doAxfer(this.txn.sender, assetB, amountB)
	frame_dig -5 // amountB: uint64
	frame_dig -3 // assetB: AssetID
	txn Sender
	callsub doAxfer

*if47_end:
	// *if48_condition
	// contracts\BiatecClammPool.algo.ts:1170
	// assetA.id === 0
	frame_dig -2 // assetA: AssetID
	intc 1 // 0
	==
	bz *if48_else

	// *if48_consequent
	// contracts\BiatecClammPool.algo.ts:1171
	// assert(
	//         ((this.app.address.balance - 1_000_000) as uint256) * this.assetADecimalsScaleFromBase.value >= this.assetABalanceBaseScale.value,
	//         'E_A0_B' // 'It is not possible to set higher assetABalance in algos then is in the app balance'
	//       )
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	intc 11 // 1_000_000
	-
	itob
	bytec 9 //  "ad"
	app_global_get
	b*
	bytec 4 //  "ab"
	app_global_get
	b>=

	// E_A0_B
	assert
	b *if48_end

*if48_else:
	// contracts\BiatecClammPool.algo.ts:1176
	// assert(
	//         (this.app.address.assetBalance(assetA) as uint256) * this.assetADecimalsScaleFromBase.value >= this.assetABalanceBaseScale.value,
	//         'E_A_B' // 'It is not possible to set higher assetABalance then is in the app balance'
	//       )
	global CurrentApplicationAddress
	frame_dig -2 // assetA: AssetID
	asset_holding_get AssetBalance
	pop
	itob
	bytec 9 //  "ad"
	app_global_get
	b*
	bytec 4 //  "ab"
	app_global_get
	b>=

	// E_A_B
	assert

*if48_end:
	// *if49_condition
	// contracts\BiatecClammPool.algo.ts:1181
	// assetB.id === 0
	frame_dig -3 // assetB: AssetID
	intc 1 // 0
	==
	bz *if49_else

	// *if49_consequent
	// contracts\BiatecClammPool.algo.ts:1182
	// assert(
	//         ((this.app.address.balance - 1_000_000) as uint256) * this.assetBDecimalsScaleFromBase.value >= this.assetBBalanceBaseScale.value,
	//         'E_B0_B' // 'It is not possible to set higher assetBBalance in algos then is in the app balance'
	//       )
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	intc 11 // 1_000_000
	-
	itob
	bytec 10 //  "bd"
	app_global_get
	b*
	bytec 5 //  "bb"
	app_global_get
	b>=

	// E_B0_B
	assert
	b *if49_end

*if49_else:
	// contracts\BiatecClammPool.algo.ts:1187
	// assert(
	//         (this.app.address.assetBalance(assetB) as uint256) * this.assetBDecimalsScaleFromBase.value >= this.assetBBalanceBaseScale.value,
	//         'E_B_B' // 'It is not possible to set higher assetBBalance then is in the app balance'
	//       )
	global CurrentApplicationAddress
	frame_dig -3 // assetB: AssetID
	asset_holding_get AssetBalance
	pop
	itob
	bytec 10 //  "bd"
	app_global_get
	b*
	bytec 5 //  "bb"
	app_global_get
	b>=

	// E_B_B
	assert

*if49_end:
	// contracts\BiatecClammPool.algo.ts:1193
	// return amountA + amountB;
	frame_dig -4 // amountA: uint64
	frame_dig -5 // amountB: uint64
	+

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// sendOnlineKeyRegistration(uint64,byte[],byte[],byte[],uint64,uint64,uint64,uint64)void
*abi_route_sendOnlineKeyRegistration:
	// fee: uint64
	txna ApplicationArgs 8
	btoi

	// voteKeyDilution: uint64
	txna ApplicationArgs 7
	btoi

	// voteLast: uint64
	txna ApplicationArgs 6
	btoi

	// voteFirst: uint64
	txna ApplicationArgs 5
	btoi

	// stateProofPk: byte[]
	txna ApplicationArgs 4
	extract 2 0

	// selectionPk: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// votePk: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute sendOnlineKeyRegistration(uint64,byte[],byte[],byte[],uint64,uint64,uint64,uint64)void
	callsub sendOnlineKeyRegistration
	intc 3 // 1
	return

// sendOnlineKeyRegistration(appBiatecConfigProvider: AppID, votePk: bytes, selectionPk: bytes, stateProofPk: bytes, voteFirst: uint64, voteLast: uint64, voteKeyDilution: uint64, fee: uint64): void
//
// addressExecutiveFee can perfom key registration for this LP pool
//
// Only addressExecutiveFee is allowed to execute this method.
sendOnlineKeyRegistration:
	proto 8 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts\BiatecClammPool.algo.ts:1202
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value, 'E_CONFIG')
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 13 //  "bc"
	app_global_get
	==

	// E_CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:1203
	// addressExecutiveFee = appBiatecConfigProvider.globalState('ef') as Address
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 24 //  "ef"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('ef')
	assert
	frame_bury 0 // addressExecutiveFee: address

	// contracts\BiatecClammPool.algo.ts:1204
	// assert(
	//       this.txn.sender === addressExecutiveFee,
	//       'E_SENDER' // 'Only fee executor setup in the config can take the collected fees'
	//     )
	txn Sender
	frame_dig 0 // addressExecutiveFee: address
	==

	// E_SENDER
	assert

	// contracts\BiatecClammPool.algo.ts:1208
	// sendOnlineKeyRegistration({
	//       selectionPK: selectionPk,
	//       stateProofPK: stateProofPk,
	//       voteFirst: voteFirst,
	//       voteKeyDilution: voteKeyDilution,
	//       voteLast: voteLast,
	//       votePK: votePk,
	//       fee: fee,
	//     })
	itxn_begin
	intc 12 //  keyreg
	itxn_field TypeEnum

	// contracts\BiatecClammPool.algo.ts:1209
	// selectionPK: selectionPk
	frame_dig -3 // selectionPk: bytes
	itxn_field SelectionPK

	// contracts\BiatecClammPool.algo.ts:1210
	// stateProofPK: stateProofPk
	frame_dig -4 // stateProofPk: bytes
	itxn_field StateProofPK

	// contracts\BiatecClammPool.algo.ts:1211
	// voteFirst: voteFirst
	frame_dig -5 // voteFirst: uint64
	itxn_field VoteFirst

	// contracts\BiatecClammPool.algo.ts:1212
	// voteKeyDilution: voteKeyDilution
	frame_dig -7 // voteKeyDilution: uint64
	itxn_field VoteKeyDilution

	// contracts\BiatecClammPool.algo.ts:1213
	// voteLast: voteLast
	frame_dig -6 // voteLast: uint64
	itxn_field VoteLast

	// contracts\BiatecClammPool.algo.ts:1214
	// votePK: votePk
	frame_dig -2 // votePk: bytes
	itxn_field VotePK

	// contracts\BiatecClammPool.algo.ts:1215
	// fee: fee
	frame_dig -8 // fee: uint64
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// calculateDistributedLiquidity(uint64,uint256)uint256
*abi_route_calculateDistributedLiquidity:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// currentDeposit: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 0 (currentDeposit) for calculateDistributedLiquidity must be a uint256
	assert

	// assetLp: uint64
	txna ApplicationArgs 1
	btoi

	// execute calculateDistributedLiquidity(uint64,uint256)uint256
	callsub calculateDistributedLiquidity
	dup
	bitlen
	intc 2 // 256
	<=

	// calculateDistributedLiquidity return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateDistributedLiquidity(assetLp: AssetID, currentDeposit: uint256): uint256
//
// addressExecutiveFee can perfom key unregistration for this LP pool
//
// Only addressExecutiveFee is allowed to execute this method.
//
//
// Calculates the number of LP tokens issued to users
calculateDistributedLiquidity:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 4

	// contracts\BiatecClammPool.algo.ts:1243
	// current = (this.app.address.assetBalance(assetLp) as uint256) - currentDeposit
	global CurrentApplicationAddress
	frame_dig -1 // assetLp: AssetID
	asset_holding_get AssetBalance
	pop
	itob
	frame_dig -2 // currentDeposit: uint256
	b-
	frame_bury 0 // current: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1244
	// minted = Uint<256>(TOTAL_SUPPLY) as uint256
	bytec 27 // 0x000000000000000000000000000000000000000000000000f9ccd8a1c5080000
	frame_bury 1 // minted: uint256

	// contracts\BiatecClammPool.algo.ts:1245
	// distributedLPTokens = minted - current
	bytec 27 //  minted: uint256
	frame_dig 0 // current: unsafe uint256
	b-
	frame_bury 2 // distributedLPTokens: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1247
	// assetLpDelicmalScale2Scale = <uint256>LP_SCALE_DECIMALS
	intc 9 // 10
	intc 10 // 3
	exp
	itob
	frame_bury 3 // assetLpDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1248
	// ret = distributedLPTokens * assetLpDelicmalScale2Scale
	frame_dig 2 // distributedLPTokens: unsafe uint256
	frame_dig 3 // assetLpDelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 4 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1249
	// return ret;
	frame_dig 4 // ret: unsafe uint256

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 4
	retsub

// calculateLiquidityFlatPrice(uint256,uint256,uint256)uint256
*abi_route_calculateLiquidityFlatPrice:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// price: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 0 (price) for calculateLiquidityFlatPrice must be a uint256
	assert

	// y: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 1 (y) for calculateLiquidityFlatPrice must be a uint256
	assert

	// x: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 2 (x) for calculateLiquidityFlatPrice must be a uint256
	assert

	// execute calculateLiquidityFlatPrice(uint256,uint256,uint256)uint256
	callsub calculateLiquidityFlatPrice
	dup
	bitlen
	intc 2 // 256
	<=

	// calculateLiquidityFlatPrice return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateLiquidityFlatPrice(x: uint256, y: uint256, price: uint256): uint256
calculateLiquidityFlatPrice:
	proto 3 1

	// contracts\BiatecClammPool.algo.ts:1268
	// return (x * price) / s + y;
	frame_dig -1 // x: uint256
	frame_dig -3 // price: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_dig -2 // y: uint256
	b+
	retsub

// calculateLiquidityD(uint256,uint256,uint256,uint256,uint256,uint256)uint256
*abi_route_calculateLiquidityD:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// priceMaxSqrt: uint256
	txna ApplicationArgs 6
	dup
	len
	intc 0 // 32
	==

	// argument 0 (priceMaxSqrt) for calculateLiquidityD must be a uint256
	assert

	// priceMinSqrt: uint256
	txna ApplicationArgs 5
	dup
	len
	intc 0 // 32
	==

	// argument 1 (priceMinSqrt) for calculateLiquidityD must be a uint256
	assert

	// priceMax: uint256
	txna ApplicationArgs 4
	dup
	len
	intc 0 // 32
	==

	// argument 2 (priceMax) for calculateLiquidityD must be a uint256
	assert

	// priceMin: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 3 (priceMin) for calculateLiquidityD must be a uint256
	assert

	// y: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 4 (y) for calculateLiquidityD must be a uint256
	assert

	// x: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 5 (x) for calculateLiquidityD must be a uint256
	assert

	// execute calculateLiquidityD(uint256,uint256,uint256,uint256,uint256,uint256)uint256
	callsub calculateLiquidityD
	dup
	bitlen
	intc 2 // 256
	<=

	// calculateLiquidityD return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateLiquidityD(x: uint256, y: uint256, priceMin: uint256, priceMax: uint256, priceMinSqrt: uint256, priceMaxSqrt: uint256): uint256
//
// Calculates the liquidity  from the x - Asset A position and y - Asset B position
// This method calculates discriminant - first part of the calculation.
// It is divided so that the readonly method does not need to charge fees
//
// @param x Asset A position balanced on the curve
// @param y Asset B position balanced on the curve
// @param priceMin Minimum price variable in base scale decimals (pa)
// @param priceMax Maximum price variable in base scale decimals (pb)
// @param priceMinSqrt sqrt(priceMin) in base scale decimals Variable pas
// @param priceMaxSqrt sqrt(priceMax) in base scale decimals Variable pbs
// @returns Liquidity is constant in swapping each direction. On deposit the diff between the liquidity is number of LP tokens received by user.
calculateLiquidityD:
	proto 6 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 8

	// contracts\BiatecClammPool.algo.ts:1315
	// D1 = (x * x * priceMin) / s / s
	frame_dig -1 // x: uint256
	frame_dig -1 // x: uint256
	b*
	frame_dig -3 // priceMin: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 0 // D1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1317
	// D2 = (y * y) / priceMax
	frame_dig -2 // y: uint256
	frame_dig -2 // y: uint256
	b*
	frame_dig -4 // priceMax: uint256
	b/
	frame_bury 1 // D2: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1319
	// D3_1 = <uint256>2 * x * y * priceMinSqrt
	bytec 20 // 0x0000000000000000000000000000000000000000000000000000000000000002
	frame_dig -1 // x: uint256
	b*
	frame_dig -2 // y: uint256
	b*
	frame_dig -5 // priceMinSqrt: uint256
	b*
	frame_bury 2 // D3_1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1320
	// D3 = D3_1 / priceMaxSqrt / s
	frame_dig 2 // D3_1: unsafe uint256
	frame_dig -6 // priceMaxSqrt: uint256
	b/
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 3 // D3: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1323
	// D4 = (<uint256>4 * x * y) / s
	bytec 28 // 0x0000000000000000000000000000000000000000000000000000000000000004
	frame_dig -1 // x: uint256
	b*
	frame_dig -2 // y: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 4 // D4: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1325
	// D5_1 = <uint256>4 * x * y * priceMinSqrt
	bytec 28 // 0x0000000000000000000000000000000000000000000000000000000000000004
	frame_dig -1 // x: uint256
	b*
	frame_dig -2 // y: uint256
	b*
	frame_dig -5 // priceMinSqrt: uint256
	b*
	frame_bury 5 // D5_1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1326
	// D5 = D5_1 / priceMaxSqrt / s
	frame_dig 5 // D5_1: unsafe uint256
	frame_dig -6 // priceMaxSqrt: uint256
	b/
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 6 // D5: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1327
	// D = D1 + D2 + D3 + D4 - D5
	frame_dig 0 // D1: unsafe uint256
	frame_dig 1 // D2: unsafe uint256
	b+
	frame_dig 3 // D3: unsafe uint256
	b+
	frame_dig 4 // D4: unsafe uint256
	b+
	frame_dig 6 // D5: unsafe uint256
	b-
	frame_bury 7 // D: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1328
	// D_SQRT = sqrt(s * D)
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	frame_dig 7 // D: unsafe uint256
	b*
	bsqrt
	frame_bury 8 // D_SQRT: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1329
	// return D_SQRT;
	frame_dig 8 // D_SQRT: unsafe uint256

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 8
	retsub

// calculateLiquidityWithD(uint256,uint256,uint256,uint256,uint256)uint256
*abi_route_calculateLiquidityWithD:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// dSqrt: uint256
	txna ApplicationArgs 5
	dup
	len
	intc 0 // 32
	==

	// argument 0 (dSqrt) for calculateLiquidityWithD must be a uint256
	assert

	// priceMaxSqrt: uint256
	txna ApplicationArgs 4
	dup
	len
	intc 0 // 32
	==

	// argument 1 (priceMaxSqrt) for calculateLiquidityWithD must be a uint256
	assert

	// priceMinSqrt: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 2 (priceMinSqrt) for calculateLiquidityWithD must be a uint256
	assert

	// y: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 3 (y) for calculateLiquidityWithD must be a uint256
	assert

	// x: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 4 (x) for calculateLiquidityWithD must be a uint256
	assert

	// execute calculateLiquidityWithD(uint256,uint256,uint256,uint256,uint256)uint256
	callsub calculateLiquidityWithD
	dup
	bitlen
	intc 2 // 256
	<=

	// calculateLiquidityWithD return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateLiquidityWithD(x: uint256, y: uint256, priceMinSqrt: uint256, priceMaxSqrt: uint256, dSqrt: uint256): uint256
//
// Calculates the liquidity  from the x - Asset A position and y - Asset B position
//
// @param x Asset A position balanced on the curve
// @param y Asset B position balanced on the curve
// @param priceMinSqrt sqrt(priceMin) in base scale decimals Variable pas
// @param priceMaxSqrt sqrt(priceMax) in base scale decimals Variable pbs
// @returns Liquidity is constant in swapping each direction. On deposit the diff between the liquidity is number of LP tokens received by user.
calculateLiquidityWithD:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 11

	// contracts\BiatecClammPool.algo.ts:1373
	// L1 = (x * priceMinSqrt) / s
	frame_dig -1 // x: uint256
	frame_dig -3 // priceMinSqrt: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 0 // L1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1376
	// L2 = (y * s) / priceMaxSqrt
	frame_dig -2 // y: uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig -4 // priceMaxSqrt: uint256
	b/
	frame_bury 1 // L2: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1381
	// L3_0 = <uint256>2
	bytec 20 // 0x0000000000000000000000000000000000000000000000000000000000000002
	frame_bury 2 // L3_0: uint256

	// contracts\BiatecClammPool.algo.ts:1382
	// L3_1 = L3_0 * priceMinSqrt
	bytec 20 //  L3_0: uint256
	frame_dig -3 // priceMinSqrt: uint256
	b*
	frame_bury 3 // L3_1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1383
	// L3_2 = L3_1 * s
	frame_dig 3 // L3_1: unsafe uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_bury 4 // L3_2: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1384
	// L3 = L3_2 / priceMaxSqrt
	frame_dig 4 // L3_2: unsafe uint256
	frame_dig -4 // priceMaxSqrt: uint256
	b/
	frame_bury 5 // L3: unsafe uint256

	// *if50_condition
	// contracts\BiatecClammPool.algo.ts:1385
	// <uint256>2 * s > L3
	bytec 20 // 0x0000000000000000000000000000000000000000000000000000000000000002
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 5 // L3: unsafe uint256
	b>
	bz *if50_end

	// *if50_consequent
	// contracts\BiatecClammPool.algo.ts:1386
	// nom = L1 + L2 + dSqrt
	frame_dig 0 // L1: unsafe uint256
	frame_dig 1 // L2: unsafe uint256
	b+
	frame_dig -5 // dSqrt: uint256
	b+
	frame_bury 6 // nom: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1387
	// den = <uint256>2 * s - L3
	bytec 20 // 0x0000000000000000000000000000000000000000000000000000000000000002
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 5 // L3: unsafe uint256
	b-
	frame_bury 7 // den: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1388
	// ret = (s * nom) / den
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	frame_dig 6 // nom: unsafe uint256
	b*
	frame_dig 7 // den: unsafe uint256
	b/
	frame_bury 8 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1389
	// return ret;
	frame_dig 8 // ret: unsafe uint256
	b *calculateLiquidityWithD*return

*if50_end:
	// contracts\BiatecClammPool.algo.ts:1391
	// nom = L1 + L2 - dSqrt
	frame_dig 0 // L1: unsafe uint256
	frame_dig 1 // L2: unsafe uint256
	b+
	frame_dig -5 // dSqrt: uint256
	b-
	frame_bury 9 // nom: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1392
	// den = L3 - <uint256>2 * s
	frame_dig 5 // L3: unsafe uint256
	bytec 20 // 0x0000000000000000000000000000000000000000000000000000000000000002
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	b-
	frame_bury 10 // den: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1393
	// ret = (s * nom) / den
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	frame_dig 9 // nom: unsafe uint256
	b*
	frame_dig 10 // den: unsafe uint256
	b/
	frame_bury 11 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1394
	// return ret;
	frame_dig 11 // ret: unsafe uint256

*calculateLiquidityWithD*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 11
	retsub

// calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256
*abi_route_calculatePrice:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// liquidity: uint256
	txna ApplicationArgs 5
	dup
	len
	intc 0 // 32
	==

	// argument 0 (liquidity) for calculatePrice must be a uint256
	assert

	// priceMaxSqrt: uint256
	txna ApplicationArgs 4
	dup
	len
	intc 0 // 32
	==

	// argument 1 (priceMaxSqrt) for calculatePrice must be a uint256
	assert

	// priceMinSqrt: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 2 (priceMinSqrt) for calculatePrice must be a uint256
	assert

	// assetBQuantity: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 3 (assetBQuantity) for calculatePrice must be a uint256
	assert

	// assetAQuantity: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 4 (assetAQuantity) for calculatePrice must be a uint256
	assert

	// execute calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256
	callsub calculatePrice
	dup
	bitlen
	intc 2 // 256
	<=

	// calculatePrice return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculatePrice(assetAQuantity: uint256, assetBQuantity: uint256, priceMinSqrt: uint256, priceMaxSqrt: uint256, liquidity: uint256): uint256
//
// Get the current price when asset a has x
// @param assetAQuantity x
// @param assetBQuantity y
// @param priceMinSqrt sqrt(priceMin)
// @param priceMaxSqrt sqrt(priceMax)
// @param liquidity Current pool liquidity - L variable
// @returns the price with specified quantity with the price range set in the contract
calculatePrice:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 7

	// *if51_condition
	// contracts\BiatecClammPool.algo.ts:1412
	// priceMinSqrt === priceMaxSqrt
	frame_dig -3 // priceMinSqrt: uint256
	frame_dig -4 // priceMaxSqrt: uint256
	b==
	bz *if51_end

	// *if51_consequent
	// contracts\BiatecClammPool.algo.ts:1413
	// ret = (priceMinSqrt * priceMinSqrt) / s
	frame_dig -3 // priceMinSqrt: uint256
	frame_dig -3 // priceMinSqrt: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 0 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1414
	// return ret;
	frame_dig 0 // ret: unsafe uint256
	b *calculatePrice*return

*if51_end:
	// contracts\BiatecClammPool.algo.ts:1417
	// a = priceMinSqrt
	frame_dig -3 // priceMinSqrt: uint256
	frame_bury 1 // a: uint256

	// contracts\BiatecClammPool.algo.ts:1418
	// b = priceMaxSqrt
	frame_dig -4 // priceMaxSqrt: uint256
	frame_bury 2 // b: uint256

	// contracts\BiatecClammPool.algo.ts:1419
	// P1 = (liquidity * a) / s
	frame_dig -5 // liquidity: uint256
	frame_dig 1 // a: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 3 // P1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1420
	// P2 = (liquidity * s) / b
	frame_dig -5 // liquidity: uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 2 // b: uint256
	b/
	frame_bury 4 // P2: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1421
	// Nom = assetBQuantity + P1
	frame_dig -2 // assetBQuantity: uint256
	frame_dig 3 // P1: unsafe uint256
	b+
	frame_bury 5 // Nom: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1422
	// Denom = assetAQuantity + P2
	frame_dig -1 // assetAQuantity: uint256
	frame_dig 4 // P2: unsafe uint256
	b+
	frame_bury 6 // Denom: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1423
	// ret = (Nom * s) / Denom
	frame_dig 5 // Nom: unsafe uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 6 // Denom: unsafe uint256
	b/
	frame_bury 7 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1424
	// return ret;
	frame_dig 7 // ret: unsafe uint256

*calculatePrice*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 7
	retsub

// calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256
*abi_route_calculateAssetBWithdrawOnAssetADeposit:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// liquidity: uint256
	txna ApplicationArgs 6
	dup
	len
	intc 0 // 32
	==

	// argument 0 (liquidity) for calculateAssetBWithdrawOnAssetADeposit must be a uint256
	assert

	// priceMaxSqrt: uint256
	txna ApplicationArgs 5
	dup
	len
	intc 0 // 32
	==

	// argument 1 (priceMaxSqrt) for calculateAssetBWithdrawOnAssetADeposit must be a uint256
	assert

	// priceMinSqrt: uint256
	txna ApplicationArgs 4
	dup
	len
	intc 0 // 32
	==

	// argument 2 (priceMinSqrt) for calculateAssetBWithdrawOnAssetADeposit must be a uint256
	assert

	// assetBBalance: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 3 (assetBBalance) for calculateAssetBWithdrawOnAssetADeposit must be a uint256
	assert

	// assetABalance: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 4 (assetABalance) for calculateAssetBWithdrawOnAssetADeposit must be a uint256
	assert

	// inAmount: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 5 (inAmount) for calculateAssetBWithdrawOnAssetADeposit must be a uint256
	assert

	// execute calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256
	callsub calculateAssetBWithdrawOnAssetADeposit
	dup
	bitlen
	intc 2 // 256
	<=

	// calculateAssetBWithdrawOnAssetADeposit return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateAssetBWithdrawOnAssetADeposit(inAmount: uint256, assetABalance: uint256, assetBBalance: uint256, priceMinSqrt: uint256, priceMaxSqrt: uint256, liquidity: uint256): uint256
//
// Calculates how much asset B will be taken from the smart contract on asset A deposit
// @param inAmount Asset A amount in Base decimal representation.. If asset has 6 decimals, 1 is represented as 1000000000
// @param assetABalance Asset A balance. Variable ab, in base scale
// @param assetBBalance Asset B balance. Variable bb, in base scale
// @param priceMinSqrt sqrt(Min price). Variable pMinS, in base scale
// @param priceMaxSqrt sqrt(Max price). Variable pMaxS, in base scale
// @param liquidity sqrt(Max price). Variable L, in base scale
// @returns Amount of asset B to be given to the caller before fees. The result is in Base decimals (9)
calculateAssetBWithdrawOnAssetADeposit:
	proto 6 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 7

	// *if52_condition
	// contracts\BiatecClammPool.algo.ts:1440
	// priceMinSqrt === priceMaxSqrt
	frame_dig -4 // priceMinSqrt: uint256
	frame_dig -5 // priceMaxSqrt: uint256
	b==
	bz *if52_end

	// *if52_consequent
	// contracts\BiatecClammPool.algo.ts:1441
	// ret = (inAmount * priceMinSqrt * priceMinSqrt) / s / s
	frame_dig -1 // inAmount: uint256
	frame_dig -4 // priceMinSqrt: uint256
	b*
	frame_dig -4 // priceMinSqrt: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 0 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1442
	// return ret;
	frame_dig 0 // ret: unsafe uint256
	b *calculateAssetBWithdrawOnAssetADeposit*return

*if52_end:
	// contracts\BiatecClammPool.algo.ts:1466
	// P1 = (((((priceMinSqrt /* 10D */ * priceMaxSqrt) /* 10D */ / s) * inAmount) /* AD */ / s) * liquidity) /* 10D */ / s
	frame_dig -4 // priceMinSqrt: uint256
	frame_dig -5 // priceMaxSqrt: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_dig -1 // inAmount: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_dig -6 // liquidity: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 1 // P1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1468
	// P2 = (((priceMaxSqrt /* 10D */ * inAmount) /* AD */ / s) * assetBBalance) /* BD */ / s
	frame_dig -5 // priceMaxSqrt: uint256
	frame_dig -1 // inAmount: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_dig -3 // assetBBalance: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 2 // P2: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1470
	// P3 = (priceMaxSqrt /* 10D */ * inAmount) /* AD */ / s
	frame_dig -5 // priceMaxSqrt: uint256
	frame_dig -1 // inAmount: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 3 // P3: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1472
	// P4 = (priceMaxSqrt /* 10D */ * assetABalance) /* 10D */ / s
	frame_dig -5 // priceMaxSqrt: uint256
	frame_dig -2 // assetABalance: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 4 // P4: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1474
	// P12 = P1 + P2
	frame_dig 1 // P1: unsafe uint256
	frame_dig 2 // P2: unsafe uint256
	b+
	frame_bury 5 // P12: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1476
	// P345 = P3 + P4 + liquidity
	frame_dig 3 // P3: unsafe uint256
	frame_dig 4 // P4: unsafe uint256
	b+
	frame_dig -6 // liquidity: uint256
	b+
	frame_bury 6 // P345: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1478
	// ret = (P12 * s) / P345
	frame_dig 5 // P12: unsafe uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 6 // P345: unsafe uint256
	b/
	frame_bury 7 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1479
	// return ret;
	frame_dig 7 // ret: unsafe uint256

*calculateAssetBWithdrawOnAssetADeposit*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 7
	retsub

// calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256
*abi_route_calculateAssetAWithdrawOnAssetBDeposit:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// liquidity: uint256
	txna ApplicationArgs 6
	dup
	len
	intc 0 // 32
	==

	// argument 0 (liquidity) for calculateAssetAWithdrawOnAssetBDeposit must be a uint256
	assert

	// priceMaxSqrt: uint256
	txna ApplicationArgs 5
	dup
	len
	intc 0 // 32
	==

	// argument 1 (priceMaxSqrt) for calculateAssetAWithdrawOnAssetBDeposit must be a uint256
	assert

	// priceMinSqrt: uint256
	txna ApplicationArgs 4
	dup
	len
	intc 0 // 32
	==

	// argument 2 (priceMinSqrt) for calculateAssetAWithdrawOnAssetBDeposit must be a uint256
	assert

	// assetBBalance: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 3 (assetBBalance) for calculateAssetAWithdrawOnAssetBDeposit must be a uint256
	assert

	// assetABalance: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 4 (assetABalance) for calculateAssetAWithdrawOnAssetBDeposit must be a uint256
	assert

	// inAmount: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 5 (inAmount) for calculateAssetAWithdrawOnAssetBDeposit must be a uint256
	assert

	// execute calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256
	callsub calculateAssetAWithdrawOnAssetBDeposit
	dup
	bitlen
	intc 2 // 256
	<=

	// calculateAssetAWithdrawOnAssetBDeposit return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateAssetAWithdrawOnAssetBDeposit(inAmount: uint256, assetABalance: uint256, assetBBalance: uint256, priceMinSqrt: uint256, priceMaxSqrt: uint256, liquidity: uint256): uint256
//
// Calculates how much asset A will be taken from the smart contract on asset B deposit
// @param inAmount Asset B amount in Base decimal representation.. If asset has 6 decimals, 1 is represented as 1000000000
// @param assetABalance Asset A balance. Variable ab, in base scale
// @param assetBBalance Asset B balance. Variable bb, in base scale
// @param priceMinSqrt sqrt(Min price). Variable pMinS, in base scale
// @param priceMaxSqrt sqrt(Max price). Variable pMaxS, in base scale
// @param liquidity sqrt(Max price). Variable L, in base scale
//
// @returns Amount of asset A to be given to the caller before fees. The result is in Base decimals (9)
calculateAssetAWithdrawOnAssetBDeposit:
	proto 6 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 13

	// *if53_condition
	// contracts\BiatecClammPool.algo.ts:1495
	// priceMinSqrt === priceMaxSqrt
	frame_dig -4 // priceMinSqrt: uint256
	frame_dig -5 // priceMaxSqrt: uint256
	b==
	bz *if53_end

	// *if53_consequent
	// contracts\BiatecClammPool.algo.ts:1496
	// ret = (inAmount * s * s) / priceMinSqrt / priceMinSqrt
	frame_dig -1 // inAmount: uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig -4 // priceMinSqrt: uint256
	b/
	frame_dig -4 // priceMinSqrt: uint256
	b/
	frame_bury 0 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1497
	// return ret;
	frame_dig 0 // ret: unsafe uint256
	b *calculateAssetAWithdrawOnAssetBDeposit*return

*if53_end:
	// contracts\BiatecClammPool.algo.ts:1512
	// x = assetABalance
	frame_dig -2 // assetABalance: uint256
	frame_bury 1 // x: uint256

	// contracts\BiatecClammPool.algo.ts:1513
	// y = assetBBalance
	frame_dig -3 // assetBBalance: uint256
	frame_bury 2 // y: uint256

	// contracts\BiatecClammPool.algo.ts:1514
	// a = priceMinSqrt
	frame_dig -4 // priceMinSqrt: uint256
	frame_bury 3 // a: uint256

	// contracts\BiatecClammPool.algo.ts:1515
	// b = priceMaxSqrt
	frame_dig -5 // priceMaxSqrt: uint256
	frame_bury 4 // b: uint256

	// contracts\BiatecClammPool.algo.ts:1516
	// L = liquidity
	frame_dig -6 // liquidity: uint256
	frame_bury 5 // L: uint256

	// contracts\BiatecClammPool.algo.ts:1519
	// P1 = (inAmount * L) / s
	frame_dig -1 // inAmount: uint256
	frame_dig 5 // L: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 6 // P1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1521
	// P2 = (((b * inAmount) / s) * x) / s
	frame_dig 4 // b: uint256
	frame_dig -1 // inAmount: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_dig 1 // x: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 7 // P2: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1523
	// nom = P1 + P2
	frame_dig 6 // P1: unsafe uint256
	frame_dig 7 // P2: unsafe uint256
	b+
	frame_bury 8 // nom: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1525
	// P3 = (((a * b) / s) * L) / s
	frame_dig 3 // a: uint256
	frame_dig 4 // b: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_dig 5 // L: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 9 // P3: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1527
	// P4 = (b * inAmount) / s
	frame_dig 4 // b: uint256
	frame_dig -1 // inAmount: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 10 // P4: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1529
	// P5 = (b * y) / s
	frame_dig 4 // b: uint256
	frame_dig 2 // y: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 11 // P5: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1531
	// denom = P3 + P4 + P5
	frame_dig 9 // P3: unsafe uint256
	frame_dig 10 // P4: unsafe uint256
	b+
	frame_dig 11 // P5: unsafe uint256
	b+
	frame_bury 12 // denom: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1533
	// ret = (nom * s) / denom
	frame_dig 8 // nom: unsafe uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 12 // denom: unsafe uint256
	b/
	frame_bury 13 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1534
	// return ret;
	frame_dig 13 // ret: unsafe uint256

*calculateAssetAWithdrawOnAssetBDeposit*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 13
	retsub

// calculateAssetAWithdrawOnLpDeposit(uint256,uint256,uint256)uint256
*abi_route_calculateAssetAWithdrawOnLpDeposit:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// liquidity: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 0 (liquidity) for calculateAssetAWithdrawOnLpDeposit must be a uint256
	assert

	// assetABalance: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 1 (assetABalance) for calculateAssetAWithdrawOnLpDeposit must be a uint256
	assert

	// inAmount: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 2 (inAmount) for calculateAssetAWithdrawOnLpDeposit must be a uint256
	assert

	// execute calculateAssetAWithdrawOnLpDeposit(uint256,uint256,uint256)uint256
	callsub calculateAssetAWithdrawOnLpDeposit
	dup
	bitlen
	intc 2 // 256
	<=

	// calculateAssetAWithdrawOnLpDeposit return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateAssetAWithdrawOnLpDeposit(inAmount: uint256, assetABalance: uint256, liquidity: uint256): uint256
//
// Calculates how much asset A will be taken from the smart contract on LP asset deposit
// @param inAmount LP Asset amount in Base decimal representation..
// @param assetABalance Asset A balance. Variable ab, in base scale
// @param liquidity Current liquidity. Variable L, in base scale
//
// @returns Amount of asset A to be given to the caller before fees. The result is in Base decimals (9)
calculateAssetAWithdrawOnLpDeposit:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts\BiatecClammPool.algo.ts:1550
	// ret = (assetABalance * inAmount) / liquidity
	frame_dig -2 // assetABalance: uint256
	frame_dig -1 // inAmount: uint256
	b*
	frame_dig -3 // liquidity: uint256
	b/
	frame_bury 0 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1551
	// return ret;
	frame_dig 0 // ret: unsafe uint256

	// set the subroutine return value
	frame_bury 0
	retsub

// calculateAssetBDepositOnAssetADeposit(uint256,uint256,uint256,uint256)uint256
*abi_route_calculateAssetBDepositOnAssetADeposit:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// assetBBalance: uint256
	txna ApplicationArgs 4
	dup
	len
	intc 0 // 32
	==

	// argument 0 (assetBBalance) for calculateAssetBDepositOnAssetADeposit must be a uint256
	assert

	// assetABalance: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 1 (assetABalance) for calculateAssetBDepositOnAssetADeposit must be a uint256
	assert

	// inAmountB: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 2 (inAmountB) for calculateAssetBDepositOnAssetADeposit must be a uint256
	assert

	// inAmountA: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 3 (inAmountA) for calculateAssetBDepositOnAssetADeposit must be a uint256
	assert

	// execute calculateAssetBDepositOnAssetADeposit(uint256,uint256,uint256,uint256)uint256
	callsub calculateAssetBDepositOnAssetADeposit
	dup
	bitlen
	intc 2 // 256
	<=

	// calculateAssetBDepositOnAssetADeposit return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateAssetBDepositOnAssetADeposit(inAmountA: uint256, inAmountB: uint256, assetABalance: uint256, assetBBalance: uint256): uint256
//
// Calculates how much asset B should be deposited when user deposit asset a and b.
//
// On deposit min(calculateAssetBDepositOnAssetADeposit, calculateAssetADepositOnAssetBDeposit) should be considered for the real deposit and rest should be swapped or returned back to user
//
// @param inAmountA Asset A amount in Base decimal representation
// @param inAmountB Asset B amount in Base decimal representation
// @param assetABalance Asset A balance. Variable ab, in base scale
// @param assetBBalance Asset B balance. Variable bb, in base scale
//
// @returns Amount of asset B to be given to the caller before fees. The result is in Base decimals (9)
calculateAssetBDepositOnAssetADeposit:
	proto 4 1

	// *if54_condition
	// contracts\BiatecClammPool.algo.ts:1568
	// assetABalance > <uint256>0
	frame_dig -3 // assetABalance: uint256
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	bz *if54_end

	// *if54_consequent
	// contracts\BiatecClammPool.algo.ts:1569
	// return (inAmountA * assetBBalance) / assetABalance;
	frame_dig -1 // inAmountA: uint256
	frame_dig -4 // assetBBalance: uint256
	b*
	frame_dig -3 // assetABalance: uint256
	b/
	retsub

*if54_end:
	// contracts\BiatecClammPool.algo.ts:1572
	// return inAmountB;
	frame_dig -2 // inAmountB: uint256
	retsub

// calculateAssetADepositOnAssetBDeposit(uint256,uint256,uint256,uint256)uint256
*abi_route_calculateAssetADepositOnAssetBDeposit:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// assetBBalance: uint256
	txna ApplicationArgs 4
	dup
	len
	intc 0 // 32
	==

	// argument 0 (assetBBalance) for calculateAssetADepositOnAssetBDeposit must be a uint256
	assert

	// assetABalance: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 1 (assetABalance) for calculateAssetADepositOnAssetBDeposit must be a uint256
	assert

	// inAmountB: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 2 (inAmountB) for calculateAssetADepositOnAssetBDeposit must be a uint256
	assert

	// inAmountA: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 3 (inAmountA) for calculateAssetADepositOnAssetBDeposit must be a uint256
	assert

	// execute calculateAssetADepositOnAssetBDeposit(uint256,uint256,uint256,uint256)uint256
	callsub calculateAssetADepositOnAssetBDeposit
	dup
	bitlen
	intc 2 // 256
	<=

	// calculateAssetADepositOnAssetBDeposit return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateAssetADepositOnAssetBDeposit(inAmountA: uint256, inAmountB: uint256, assetABalance: uint256, assetBBalance: uint256): uint256
//
// Calculates how much asset A should be deposited when user deposit asset a and b
//
// On deposit min(calculateAssetBDepositOnAssetADeposit, calculateAssetADepositOnAssetBDeposit) should be considered for the real deposit and rest should be swapped or returned back to user
//
// @param inAmountA Asset A amount in Base decimal representation
// @param inAmountB Asset B amount in Base decimal representation
// @param assetABalance Asset A balance. Variable ab, in base scale
// @param assetBBalance Asset B balance. Variable bb, in base scale
//
// @returns Amount of asset A to be deposited. The result is in Base decimals (9)
calculateAssetADepositOnAssetBDeposit:
	proto 4 1

	// *if55_condition
	// contracts\BiatecClammPool.algo.ts:1589
	// assetBBalance > <uint256>0
	frame_dig -4 // assetBBalance: uint256
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	bz *if55_end

	// *if55_consequent
	// contracts\BiatecClammPool.algo.ts:1590
	// return (inAmountB * assetABalance) / assetBBalance;
	frame_dig -2 // inAmountB: uint256
	frame_dig -3 // assetABalance: uint256
	b*
	frame_dig -4 // assetBBalance: uint256
	b/
	retsub

*if55_end:
	// contracts\BiatecClammPool.algo.ts:1593
	// return inAmountA;
	frame_dig -1 // inAmountA: uint256
	retsub

// status(uint64,uint64,uint64,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
*abi_route_status:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// assetLp: uint64
	txna ApplicationArgs 4
	btoi

	// assetB: uint64
	txna ApplicationArgs 3
	btoi

	// assetA: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute status(uint64,uint64,uint64,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	callsub status
	concat
	log
	intc 3 // 1
	return

// status(appBiatecConfigProvider: AppID, assetA: AssetID, assetB: AssetID, assetLp: AssetID): AmmStatus
status:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts\BiatecClammPool.algo.ts:1598
	// assert(
	//       appBiatecConfigProvider === this.appBiatecConfigProvider.value,
	//       'E_CONFIG' // 'appBiatecConfigProvider must match to the global variable app id'
	//     )
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 13 //  "bc"
	app_global_get
	==

	// E_CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:1602
	// assert(assetA.id === this.assetA.value)
	frame_dig -2 // assetA: AssetID
	bytec 25 //  "a"
	app_global_get
	==
	assert

	// contracts\BiatecClammPool.algo.ts:1603
	// assert(assetB.id === this.assetB.value)
	frame_dig -3 // assetB: AssetID
	bytec 26 //  "b"
	app_global_get
	==
	assert

	// contracts\BiatecClammPool.algo.ts:1604
	// assert(this.assetLp.value === assetLp.id, 'E_LP')
	bytec 21 //  "lp"
	app_global_get
	frame_dig -4 // assetLp: AssetID
	==

	// E_LP
	assert

	// contracts\BiatecClammPool.algo.ts:1605
	// biatecFee = this.appBiatecConfigProvider.value.globalState('f') as uint256
	bytec 13 //  "bc"
	app_global_get
	bytec 18 //  "f"
	app_global_get_ex

	// global state value does not exist: this.appBiatecConfigProvider.value.globalState('f')
	assert
	frame_bury 0 // biatecFee: uint256

	// contracts\BiatecClammPool.algo.ts:1606
	// realBalanceA = assetA.id === 0 ? globals.currentApplicationAddress.balance - globals.currentApplicationAddress.minBalance : globals.currentApplicationAddress.assetBalance(assetA)
	frame_dig -2 // assetA: AssetID
	intc 1 // 0
	==
	bz *ternary4_false
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	-
	b *ternary4_end

*ternary4_false:
	global CurrentApplicationAddress
	frame_dig -2 // assetA: AssetID
	asset_holding_get AssetBalance
	pop

*ternary4_end:
	frame_bury 1 // realBalanceA: uint64

	// contracts\BiatecClammPool.algo.ts:1607
	// realBalanceB = assetB.id === 0 ? globals.currentApplicationAddress.balance - globals.currentApplicationAddress.minBalance : globals.currentApplicationAddress.assetBalance(assetB)
	frame_dig -3 // assetB: AssetID
	intc 1 // 0
	==
	bz *ternary5_false
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	-
	b *ternary5_end

*ternary5_false:
	global CurrentApplicationAddress
	frame_dig -3 // assetB: AssetID
	asset_holding_get AssetBalance
	pop

*ternary5_end:
	frame_bury 2 // realBalanceB: uint64

	// contracts\BiatecClammPool.algo.ts:1608
	// return {
	//       assetA: this.assetA.value,
	//       assetB: this.assetB.value,
	//       poolToken: this.assetLp.value,
	//       assetABalance: this.assetABalanceBaseScale.value as uint64,
	//       assetBBalance: this.assetBBalanceBaseScale.value as uint64,
	//       realABalance: realBalanceA,
	//       realBBalance: realBalanceB,
	//       fee: this.fee.value,
	//       biatecFee: biatecFee as uint64,
	//       currentLiquidity: this.Liquidity.value as uint64,
	//       liquidityBiatecFromFees: this.LiquidityBiatecFromFees.value as uint64,
	//       liquidityUsersFromFees: this.LiquidityUsersFromFees.value as uint64,
	//       price: this.currentPrice.value as uint64,
	//       priceMaxSqrt: this.priceMaxSqrt.value as uint64,
	//       priceMinSqrt: this.priceMinSqrt.value as uint64,
	//       releasedLiquidity: this.calculateDistributedLiquidity(assetLp, <uint256>0) as uint64,
	//       scale: SCALE,
	//       verificationClass: this.verificationClass.value,
	//     };
	bytec 32 // 0x000000003b9aca00
	bytec 4 //  "ab"
	app_global_get
	dup
	bitlen
	intc 4 // 64
	<=

	// this.assetABalanceBaseScale.value as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	concat
	bytec 5 //  "bb"
	app_global_get
	dup
	bitlen
	intc 4 // 64
	<=

	// this.assetBBalanceBaseScale.value as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	concat
	frame_dig 1 // realBalanceA: uint64
	itob
	concat
	frame_dig 2 // realBalanceB: uint64
	itob
	concat
	bytec 15 //  "pMinS"
	app_global_get
	dup
	bitlen
	intc 4 // 64
	<=

	// this.priceMinSqrt.value as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	concat
	bytec 16 //  "pMaxS"
	app_global_get
	dup
	bitlen
	intc 4 // 64
	<=

	// this.priceMaxSqrt.value as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	concat
	bytec 8 //  "L"
	app_global_get
	dup
	bitlen
	intc 4 // 64
	<=

	// this.Liquidity.value as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	concat
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_dig -4 // assetLp: AssetID
	callsub calculateDistributedLiquidity
	dup
	bitlen
	intc 4 // 64
	<=

	// this.calculateDistributedLiquidity(assetLp, <uint256>0) as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	itob
	concat
	bytec 12 //  "Lu"
	app_global_get
	dup
	bitlen
	intc 4 // 64
	<=

	// this.LiquidityUsersFromFees.value as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	concat
	bytec 14 //  "Lb"
	app_global_get
	dup
	bitlen
	intc 4 // 64
	<=

	// this.LiquidityBiatecFromFees.value as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	concat
	bytec 25 //  "a"
	app_global_get
	itob
	concat
	bytec 26 //  "b"
	app_global_get
	itob
	concat
	bytec 21 //  "lp"
	app_global_get
	itob
	concat
	bytec 17 //  "price"
	app_global_get
	itob
	concat
	bytec 18 //  "f"
	app_global_get
	itob
	concat
	frame_dig 0 // biatecFee: uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// biatecFee as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	concat
	bytec 30 //  "c"
	app_global_get
	itob
	concat

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0xd1717fe5 // method "getCurrentPrice()uint64"
	pushbytes 0xe3a43a4a // method "getPriceDivider()uint64"
	pushbytes 0x1d764a9e // method "getLPTokenId()uint64"
	pushbytes 0x15f1c484 // method "bootstrap(uint64,uint64,uint64,uint64,pay,uint64,uint64,uint64,uint64,uint64,byte[])uint64"
	pushbytes 0xd5c89baf // method "bootstrapStep2()void"
	pushbytes 0x0440fa8f // method "addLiquidity(uint64,uint64,txn,txn,uint64,uint64,uint64)uint64"
	pushbytes 0x549a90a4 // method "removeLiquidity(uint64,uint64,axfer,uint64,uint64,uint64)uint256"
	pushbytes 0x894a934f // method "removeLiquidityAdmin(uint64,uint64,uint64,uint64,uint256)uint256"
	pushbytes 0x2013349e // method "swap(uint64,uint64,uint64,txn,uint64,uint64,uint64)uint256"
	pushbytes 0xce564412 // method "distributeExcessAssets(uint64,uint64,uint64,uint256,uint256)uint256"
	pushbytes 0x22b746c8 // method "withdrawExcessAssets(uint64,uint64,uint64,uint64,uint64)uint64"
	pushbytes 0x67914264 // method "sendOnlineKeyRegistration(uint64,byte[],byte[],byte[],uint64,uint64,uint64,uint64)void"
	pushbytes 0x39eca854 // method "calculateDistributedLiquidity(uint64,uint256)uint256"
	pushbytes 0xff695816 // method "calculateLiquidityFlatPrice(uint256,uint256,uint256)uint256"
	pushbytes 0xdca3d4d6 // method "calculateLiquidityD(uint256,uint256,uint256,uint256,uint256,uint256)uint256"
	pushbytes 0x69d623b1 // method "calculateLiquidityWithD(uint256,uint256,uint256,uint256,uint256)uint256"
	pushbytes 0x3c2c7e4a // method "calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256"
	pushbytes 0x4bf571b6 // method "calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256"
	pushbytes 0x52f7923f // method "calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256"
	pushbytes 0x6c25b3f3 // method "calculateAssetAWithdrawOnLpDeposit(uint256,uint256,uint256)uint256"
	pushbytes 0xe64ddd82 // method "calculateAssetBDepositOnAssetADeposit(uint256,uint256,uint256,uint256)uint256"
	pushbytes 0x49f68370 // method "calculateAssetADepositOnAssetBDeposit(uint256,uint256,uint256,uint256)uint256"
	pushbytes 0x4feca359 // method "status(uint64,uint64,uint64,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)"
	txna ApplicationArgs 0
	match *abi_route_getCurrentPrice *abi_route_getPriceDivider *abi_route_getLPTokenId *abi_route_bootstrap *abi_route_bootstrapStep2 *abi_route_addLiquidity *abi_route_removeLiquidity *abi_route_removeLiquidityAdmin *abi_route_swap *abi_route_distributeExcessAssets *abi_route_withdrawExcessAssets *abi_route_sendOnlineKeyRegistration *abi_route_calculateDistributedLiquidity *abi_route_calculateLiquidityFlatPrice *abi_route_calculateLiquidityD *abi_route_calculateLiquidityWithD *abi_route_calculatePrice *abi_route_calculateAssetBWithdrawOnAssetADeposit *abi_route_calculateAssetAWithdrawOnAssetBDeposit *abi_route_calculateAssetAWithdrawOnLpDeposit *abi_route_calculateAssetBDepositOnAssetADeposit *abi_route_calculateAssetADepositOnAssetBDeposit *abi_route_status

	// this contract does not implement the given ABI method for call NoOp
	err

*call_UpdateApplication:
	pushbytes 0x5fc885a0 // method "updateApplication(uint64,byte[])void"
	txna ApplicationArgs 0
	match *abi_route_updateApplication

	// this contract does not implement the given ABI method for call UpdateApplication
	err
#pragma version 10
intcblock 32 256 0 1 64 6 8 4 5 10 3 9 1_000_000 2
bytecblock 0x 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 0x000000000000000000000000000000000000000000000000000000003b9aca00 0x6162 0x6262 0x0000000000000000000000000000000000000000000000000000000000000000 0x0a8101 0x151f7c75 0x4c 0x704d696e53 0x704d617853 0xFFFFFFFFFFFFFFFF 0x6164 0x704d696e 0x6264 0x4c75 0x704d6178 0x6263 0x4c62 0x7072696365 0x66 0x73 0x0000000000000000000000000000000000000000000000000000000000000002 0x6c70 0x6566 0x61 0x62 0x70 0x63 0x0000000000000000000000000000000000000000000000000000000000000001 0x000000000000000000000000000000000000000000000000f9ccd8a1c5080000 0x0000000000000000000000000000000000000000000000000000000000000004 "BIATEC-CLAMM-01-05-01" 0x000000003b9aca00 0x7363616c65 0x7363766572 0x414c474f 0x00

// This TEAL was generated by TEALScript v0.106.3
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 5 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_UpdateApplication *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	intc 3 // 1
	return

// createApplication(): void
//
// Initial setup
createApplication:
	proto 0 0

	// contracts\BiatecClammPool.algo.ts:115
	// log(version)
	bytec 32 // "BIATEC-CLAMM-01-05-01"
	log

	// contracts\BiatecClammPool.algo.ts:116
	// this.scale.value = SCALE
	bytec 34 //  "scale"
	pushint 1000000000
	app_global_put

	// contracts\BiatecClammPool.algo.ts:117
	// this.fee.value = <uint64>0
	bytec 20 //  "f"
	intc 2 // 0
	app_global_put

	// contracts\BiatecClammPool.algo.ts:118
	// this.Liqudity.value = <uint256>0
	bytec 8 //  "L"
	bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
	app_global_put

	// contracts\BiatecClammPool.algo.ts:119
	// this.LiqudityBiatecFromFees.value = <uint256>0
	bytec 18 //  "Lb"
	bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
	app_global_put

	// contracts\BiatecClammPool.algo.ts:120
	// this.LiqudityUsersFromFees.value = <uint256>0
	bytec 15 //  "Lu"
	bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
	app_global_put

	// contracts\BiatecClammPool.algo.ts:121
	// this.priceMax.value = 0
	bytec 16 //  "pMax"
	intc 2 // 0
	app_global_put

	// contracts\BiatecClammPool.algo.ts:122
	// this.version.value = version
	bytec 35 //  "scver"
	bytec 32 // "BIATEC-CLAMM-01-05-01"
	app_global_put

	// contracts\BiatecClammPool.algo.ts:123
	// this.setupFinished.value = false
	bytec 21 //  "s"
	intc 2 // 0
	bytec 37 // 0x00
	intc 2 // 0
	uncover 2
	setbit
	app_global_put
	retsub

// updateApplication(uint64,byte[])void
*abi_route_updateApplication:
	// newVersion: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateApplication(uint64,byte[])void
	callsub updateApplication
	intc 3 // 1
	return

// updateApplication(appBiatecConfigProvider: AppID, newVersion: bytes): void
//
// addressUdpater from global biatec configuration is allowed to update application
updateApplication:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts\BiatecClammPool.algo.ts:130
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value, 'E_CONFIG')
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 17 //  "bc"
	app_global_get
	==

	// E_CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:131
	// addressUdpater = appBiatecConfigProvider.globalState('u') as Address
	frame_dig -1 // appBiatecConfigProvider: AppID
	pushbytes 0x75 // "u"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('u')
	assert
	frame_bury 0 // addressUdpater: address

	// contracts\BiatecClammPool.algo.ts:132
	// assert(this.txn.sender === addressUdpater, 'E_UPDATER')
	txn Sender
	frame_dig 0 // addressUdpater: address
	==

	// E_UPDATER
	assert

	// contracts\BiatecClammPool.algo.ts:133
	// this.version.value = newVersion
	bytec 35 //  "scver"
	frame_dig -2 // newVersion: bytes
	app_global_put
	retsub

// getCurrentPrice()uint64
*abi_route_getCurrentPrice:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// execute getCurrentPrice()uint64
	callsub getCurrentPrice
	itob
	concat
	log
	intc 3 // 1
	return

// getCurrentPrice(): uint64
getCurrentPrice:
	proto 0 1

	// contracts\BiatecClammPool.algo.ts:138
	// return this.currentPrice.value;
	bytec 19 //  "price"
	app_global_get
	retsub

// getPriceDivider()uint64
*abi_route_getPriceDivider:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// execute getPriceDivider()uint64
	callsub getPriceDivider
	itob
	concat
	log
	intc 3 // 1
	return

// getPriceDivider(): uint64
getPriceDivider:
	proto 0 1

	// contracts\BiatecClammPool.algo.ts:143
	// return this.scale.value;
	bytec 34 //  "scale"
	app_global_get
	retsub

// getLPTokenId()uint64
*abi_route_getLPTokenId:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// execute getLPTokenId()uint64
	callsub getLPTokenId
	itob
	concat
	log
	intc 3 // 1
	return

// getLPTokenId(): uint64
getLPTokenId:
	proto 0 1

	// contracts\BiatecClammPool.algo.ts:148
	// return this.assetLp.value;
	bytec 23 //  "lp"
	app_global_get
	retsub

// bootstrap(uint64,uint64,uint64,uint64,pay,uint64,uint64,uint64,uint64,uint64)uint64
*abi_route_bootstrap:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// verificationClass: uint64
	txna ApplicationArgs 9
	btoi

	// currentPrice: uint64
	txna ApplicationArgs 8
	btoi

	// priceMax: uint64
	txna ApplicationArgs 7
	btoi

	// priceMin: uint64
	txna ApplicationArgs 6
	btoi

	// fee: uint64
	txna ApplicationArgs 5
	btoi

	// txSeed: pay
	txn GroupIndex
	intc 3 // 1
	-
	dup
	gtxns TypeEnum
	intc 3 //  pay
	==

	// argument 5 (txSeed) for bootstrap must be a pay transaction
	assert

	// appBiatecPoolProvider: uint64
	txna ApplicationArgs 4
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 3
	btoi

	// assetB: uint64
	txna ApplicationArgs 2
	btoi

	// assetA: uint64
	txna ApplicationArgs 1
	btoi

	// execute bootstrap(uint64,uint64,uint64,uint64,pay,uint64,uint64,uint64,uint64,uint64)uint64
	callsub bootstrap
	itob
	concat
	log
	intc 3 // 1
	return

// bootstrap(assetA: AssetID, assetB: AssetID, appBiatecConfigProvider: AppID, appBiatecPoolProvider: AppID, txSeed: PayTxn, fee: uint64, priceMin: uint64, priceMax: uint64, currentPrice: uint64, verificationClass: uint64): uint64
//
// Only Biatec Pool Provider can deploy and bootsrap this smart contract
// @param assetA Asset A ID must be lower then Asset B ID
// @param assetB Asset B
// @param appBiatecConfigProvider Biatec amm provider
// @param appBiatecPoolProvider Pool provider
// @param txSeed Seed transaction so that smart contract can opt in to the assets
// @param fee Fee in base level (9 decimals). value 1_000_000_000 = 1 = 100%. 10_000_000 = 1%. 1_000_000 = 0.1%
// @param priceMin Min price range. At this point all assets are in asset A.
// @param priceMax Max price range. At this point all assets are in asset B.
// @param currentPrice Deployer can specify the current price for easier deployemnt.
// @param verificationClass Minimum verification level from the biatec identity. Level 0 means no kyc.
// @returns LP token ID
bootstrap:
	proto 10 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 5

	// contracts\BiatecClammPool.algo.ts:177
	// assert(globals.callerApplicationID == appBiatecPoolProvider, 'Only the pool provider can init this contract')
	global CallerApplicationID
	frame_dig -4 // appBiatecPoolProvider: AppID
	==

	// Only the pool provider can init this contract
	assert

	// contracts\BiatecClammPool.algo.ts:178
	// verifyPayTxn(txSeed, { receiver: this.app.address, amount: { greaterThanEqualTo: 400_000 } })
	// verify receiver
	frame_dig -5 // txSeed: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"txSeed","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -5 // txSeed: PayTxn
	gtxns Amount
	pushint 400_000
	>=

	// transaction verification failed: {"txn":"txSeed","field":"amount","condition":"greaterThanEqualTo","expected":">=400_000"}
	assert

	// contracts\BiatecClammPool.algo.ts:179
	// assert(this.priceMax.value === 0, 'E_PRICE_MAX')
	bytec 16 //  "pMax"
	app_global_get
	intc 2 // 0
	==

	// E_PRICE_MAX
	assert

	// contracts\BiatecClammPool.algo.ts:180
	// assert(this.txn.sender === this.app.creator, 'E_SENDER')
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==

	// E_SENDER
	assert

	// contracts\BiatecClammPool.algo.ts:181
	// assert(priceMax > 0, 'E_PRICE')
	frame_dig -8 // priceMax: uint64
	intc 2 // 0
	>

	// E_PRICE
	assert

	// contracts\BiatecClammPool.algo.ts:183
	// assert(assetA.id !== assetB.id, 'Asset A must not be asset B')
	frame_dig -1 // assetA: AssetID
	frame_dig -2 // assetB: AssetID
	!=

	// Asset A must not be asset B
	assert

	// contracts\BiatecClammPool.algo.ts:184
	// assert(fee <= SCALE / 10)
	frame_dig -6 // fee: uint64
	pushint 100000000
	<=
	assert

	// contracts\BiatecClammPool.algo.ts:186
	// assert(!this.currentPrice.exists)
	txna Applications 0
	bytec 19 //  "price"
	app_global_get_ex
	swap
	pop
	!
	assert

	// *if0_condition
	// contracts\BiatecClammPool.algo.ts:187
	// assetA.id > 0
	frame_dig -1 // assetA: AssetID
	intc 2 // 0
	>
	bz *if0_end

	// *if0_consequent
	// contracts\BiatecClammPool.algo.ts:188
	// assert(assetA.decimals <= SCALE_DECIMALS)
	frame_dig -1 // assetA: AssetID
	asset_params_get AssetDecimals
	pop
	intc 11 // 9
	<=
	assert

*if0_end:
	// *if1_condition
	// contracts\BiatecClammPool.algo.ts:190
	// assetB.id > 0
	frame_dig -2 // assetB: AssetID
	intc 2 // 0
	>
	bz *if1_end

	// *if1_consequent
	// contracts\BiatecClammPool.algo.ts:191
	// assert(assetB.decimals <= SCALE_DECIMALS)
	frame_dig -2 // assetB: AssetID
	asset_params_get AssetDecimals
	pop
	intc 11 // 9
	<=
	assert

*if1_end:
	// contracts\BiatecClammPool.algo.ts:194
	// assert(this.fee.value <= 0, 'E_FEE')
	bytec 20 //  "f"
	app_global_get
	intc 2 // 0
	<=

	// E_FEE
	assert

	// contracts\BiatecClammPool.algo.ts:196
	// poolProviderFromConfig = appBiatecConfigProvider.globalState('p') as AppID
	frame_dig -3 // appBiatecConfigProvider: AppID
	bytec 27 //  "p"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('p')
	assert
	frame_bury 0 // poolProviderFromConfig: uint64

	// contracts\BiatecClammPool.algo.ts:197
	// assert(
	//       appBiatecPoolProvider === poolProviderFromConfig,
	//       'E_CONFIG' // 'appBiatecPoolProvider must match to the config in appBiatecConfigProvider'
	//     )
	frame_dig -4 // appBiatecPoolProvider: AppID
	frame_dig 0 // poolProviderFromConfig: uint64
	==

	// E_CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:201
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -3 // appBiatecConfigProvider: AppID
	bytec 21 //  "s"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('s')
	assert
	frame_bury 1 // paused: uint64

	// contracts\BiatecClammPool.algo.ts:202
	// assert(paused === 0, 'E_PAUSED')
	frame_dig 1 // paused: uint64
	intc 2 // 0
	==

	// E_PAUSED
	assert

	// contracts\BiatecClammPool.algo.ts:204
	// this.appBiatecConfigProvider.value = appBiatecConfigProvider
	bytec 17 //  "bc"
	frame_dig -3 // appBiatecConfigProvider: AppID
	app_global_put

	// contracts\BiatecClammPool.algo.ts:206
	// this.priceMin.value = priceMin
	bytec 13 //  "pMin"
	frame_dig -7 // priceMin: uint64
	app_global_put

	// contracts\BiatecClammPool.algo.ts:207
	// this.priceMax.value = priceMax
	bytec 16 //  "pMax"
	frame_dig -8 // priceMax: uint64
	app_global_put

	// contracts\BiatecClammPool.algo.ts:208
	// this.priceMinSqrt.value = sqrt((priceMin as uint256) * s)
	bytec 9 //  "pMinS"
	frame_dig -7 // priceMin: uint64
	itob
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	bsqrt
	dup
	bitlen
	intc 1 // 256
	<=

	// sqrt((priceMin as uint256) * s) overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:209
	// this.priceMaxSqrt.value = sqrt((priceMax as uint256) * s)
	bytec 10 //  "pMaxS"
	frame_dig -8 // priceMax: uint64
	itob
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	bsqrt
	dup
	bitlen
	intc 1 // 256
	<=

	// sqrt((priceMax as uint256) * s) overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:210
	// this.assetABalance.value = <uint256>0
	bytec 3 //  "ab"
	bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
	app_global_put

	// contracts\BiatecClammPool.algo.ts:211
	// this.assetBBalance.value = <uint256>0
	bytec 4 //  "bb"
	bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
	app_global_put

	// contracts\BiatecClammPool.algo.ts:212
	// this.currentPrice.value = currentPrice
	bytec 19 //  "price"
	frame_dig -9 // currentPrice: uint64
	app_global_put

	// contracts\BiatecClammPool.algo.ts:214
	// this.assetA.value = assetA.id
	bytec 25 //  "a"
	frame_dig -1 // assetA: AssetID
	app_global_put

	// contracts\BiatecClammPool.algo.ts:215
	// this.assetB.value = assetB.id
	bytec 26 //  "b"
	frame_dig -2 // assetB: AssetID
	app_global_put

	// contracts\BiatecClammPool.algo.ts:216
	// this.assetLp.value = this.doCreatePoolToken(assetA, assetB).id
	bytec 23 //  "lp"
	frame_dig -2 // assetB: AssetID
	frame_dig -1 // assetA: AssetID
	callsub doCreatePoolToken
	app_global_put

	// contracts\BiatecClammPool.algo.ts:217
	// this.fee.value = fee
	bytec 20 //  "f"
	frame_dig -6 // fee: uint64
	app_global_put

	// contracts\BiatecClammPool.algo.ts:218
	// this.doOptIn(assetA)
	frame_dig -1 // assetA: AssetID
	callsub doOptIn

	// contracts\BiatecClammPool.algo.ts:219
	// this.doOptIn(assetB)
	frame_dig -2 // assetB: AssetID
	callsub doOptIn

	// contracts\BiatecClammPool.algo.ts:220
	// this.verificationClass.value = verificationClass
	bytec 28 //  "c"
	frame_dig -10 // verificationClass: uint64
	app_global_put

	// contracts\BiatecClammPool.algo.ts:222
	// assetADecimals = 6
	intc 5 // 6
	frame_bury 2 // assetADecimals: uint64

	// *if2_condition
	// contracts\BiatecClammPool.algo.ts:223
	// assetA.id > 0
	frame_dig -1 // assetA: AssetID
	intc 2 // 0
	>
	bz *if2_end

	// *if2_consequent
	// contracts\BiatecClammPool.algo.ts:223
	// assetADecimals = assetA.decimals
	frame_dig -1 // assetA: AssetID
	asset_params_get AssetDecimals
	pop
	frame_bury 2 // assetADecimals: uint64

*if2_end:
	// contracts\BiatecClammPool.algo.ts:224
	// assetBDecimals = 6
	intc 5 // 6
	frame_bury 3 // assetBDecimals: uint64

	// *if3_condition
	// contracts\BiatecClammPool.algo.ts:225
	// assetB.id > 0
	frame_dig -2 // assetB: AssetID
	intc 2 // 0
	>
	bz *if3_end

	// *if3_consequent
	// contracts\BiatecClammPool.algo.ts:225
	// assetBDecimals = assetB.decimals
	frame_dig -2 // assetB: AssetID
	asset_params_get AssetDecimals
	pop
	frame_bury 3 // assetBDecimals: uint64

*if3_end:
	// contracts\BiatecClammPool.algo.ts:227
	// assetADelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetADecimals)) as uint256
	intc 9 // 10
	intc 11 // 9
	frame_dig 2 // assetADecimals: uint64
	-
	exp
	itob
	frame_bury 4 // assetADelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:229
	// assetBDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetBDecimals)) as uint256
	intc 9 // 10
	intc 11 // 9
	frame_dig 3 // assetBDecimals: uint64
	-
	exp
	itob
	frame_bury 5 // assetBDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:230
	// this.assetADecimals.value = assetADelicmalScale2Scale
	bytec 12 //  "ad"
	frame_dig 4 // assetADelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// assetADelicmalScale2Scale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:231
	// this.assetBDecimals.value = assetBDelicmalScale2Scale
	bytec 14 //  "bd"
	frame_dig 5 // assetBDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// assetBDelicmalScale2Scale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:232
	// return this.assetLp.value;
	bytec 23 //  "lp"
	app_global_get

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 5
	retsub

// bootstrapStep2()void
*abi_route_bootstrapStep2:
	// execute bootstrapStep2()void
	callsub bootstrapStep2
	intc 3 // 1
	return

// bootstrapStep2(): void
//
// When we know the app id of this pool, we can register it properly at the pool provider
bootstrapStep2:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts\BiatecClammPool.algo.ts:238
	// assert(!this.setupFinished.value)
	bytec 21 //  "s"
	app_global_get
	intc 2 // 0
	getbit
	!
	assert

	// contracts\BiatecClammPool.algo.ts:239
	// appBiatecConfigProvider = this.appBiatecConfigProvider.value as AppID
	bytec 17 //  "bc"
	app_global_get
	frame_bury 0 // appBiatecConfigProvider: uint64

	// contracts\BiatecClammPool.algo.ts:240
	// appBiatecPoolProvider = appBiatecConfigProvider.globalState('p') as AppID
	frame_dig 0 // appBiatecConfigProvider: uint64
	bytec 27 //  "p"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('p')
	assert
	frame_bury 1 // appBiatecPoolProvider: uint64

	// contracts\BiatecClammPool.algo.ts:241
	// sendMethodCall<[], void>({
	//       name: 'registerPool',
	//       methodArgs: [],
	//       fee: 0,
	//       applicationID: appBiatecPoolProvider,
	//     })
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	pushbytes 0x40540ee6 // method "registerPool()void"
	itxn_field ApplicationArgs

	// contracts\BiatecClammPool.algo.ts:243
	// methodArgs: []
	// contracts\BiatecClammPool.algo.ts:244
	// fee: 0
	intc 2 // 0
	itxn_field Fee

	// contracts\BiatecClammPool.algo.ts:245
	// applicationID: appBiatecPoolProvider
	frame_dig 1 // appBiatecPoolProvider: uint64
	itxn_field ApplicationID

	// Submit inner transaction
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:247
	// this.setupFinished.value = true
	bytec 21 //  "s"
	intc 3 // 1
	bytec 37 // 0x00
	intc 2 // 0
	uncover 2
	setbit
	app_global_put
	retsub

// doAxfer(receiver: Address, asset: AssetID, amount: uint64): void
//
// Executes xfer of pay payment methods to specified receiver from smart contract aggregated account with specified asset and amount in tokens decimals
// @param receiver Receiver
// @param asset Asset. Zero for algo
// @param amount Amount to transfer
doAxfer:
	proto 3 0

	// *if4_condition
	// contracts\BiatecClammPool.algo.ts:256
	// asset.id === 0
	frame_dig -2 // asset: AssetID
	intc 2 // 0
	==
	bz *if4_else

	// *if4_consequent
	// contracts\BiatecClammPool.algo.ts:257
	// sendPayment({
	//         receiver: receiver,
	//         amount: amount,
	//         fee: 0,
	//       })
	itxn_begin
	intc 3 //  pay
	itxn_field TypeEnum

	// contracts\BiatecClammPool.algo.ts:258
	// receiver: receiver
	frame_dig -1 // receiver: Address
	itxn_field Receiver

	// contracts\BiatecClammPool.algo.ts:259
	// amount: amount
	frame_dig -3 // amount: uint64
	itxn_field Amount

	// contracts\BiatecClammPool.algo.ts:260
	// fee: 0
	intc 2 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if4_end

*if4_else:
	// contracts\BiatecClammPool.algo.ts:263
	// sendAssetTransfer({
	//         assetReceiver: receiver,
	//         xferAsset: asset,
	//         assetAmount: amount,
	//         fee: 0,
	//       })
	itxn_begin
	intc 7 //  axfer
	itxn_field TypeEnum

	// contracts\BiatecClammPool.algo.ts:264
	// assetReceiver: receiver
	frame_dig -1 // receiver: Address
	itxn_field AssetReceiver

	// contracts\BiatecClammPool.algo.ts:265
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// contracts\BiatecClammPool.algo.ts:266
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// contracts\BiatecClammPool.algo.ts:267
	// fee: 0
	intc 2 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if4_end:
	retsub

// doOptIn(asset: AssetID): void
//
// Performs opt in to the asset. If native token is provided (0) it does not perform any action
// @param asset Asset to opt in to
doOptIn:
	proto 1 0

	// *if5_condition
	// contracts\BiatecClammPool.algo.ts:277
	// asset.id > 0
	frame_dig -1 // asset: AssetID
	intc 2 // 0
	>
	bz *if5_end

	// *if5_consequent
	// contracts\BiatecClammPool.algo.ts:279
	// this.doAxfer(this.app.address, asset, 0)
	intc 2 // 0
	frame_dig -1 // asset: AssetID
	global CurrentApplicationAddress
	callsub doAxfer

*if5_end:
	retsub

// doCreatePoolToken(assetA: AssetID, assetB: AssetID): AssetID
//
// Creates LP token
// @param assetA Asset A
// @param assetB Asset B
// @returns id of the token
doCreatePoolToken:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts\BiatecClammPool.algo.ts:292
	// nameAssetA = 'ALGO'
	bytec 36 //  "ALGO"
	frame_bury 0 // nameAssetA: byte[]

	// *if6_condition
	// contracts\BiatecClammPool.algo.ts:293
	// assetA.id > 0
	frame_dig -1 // assetA: AssetID
	intc 2 // 0
	>
	bz *if6_end

	// *if6_consequent
	// contracts\BiatecClammPool.algo.ts:294
	// nameAssetA = assetA.unitName
	frame_dig -1 // assetA: AssetID
	asset_params_get AssetUnitName
	pop
	frame_bury 0 // nameAssetA: byte[]

*if6_end:
	// contracts\BiatecClammPool.algo.ts:296
	// nameAssetB = 'ALGO'
	bytec 36 //  "ALGO"
	frame_bury 1 // nameAssetB: byte[]

	// *if7_condition
	// contracts\BiatecClammPool.algo.ts:297
	// assetB.id > 0
	frame_dig -2 // assetB: AssetID
	intc 2 // 0
	>
	bz *if7_end

	// *if7_consequent
	// contracts\BiatecClammPool.algo.ts:298
	// nameAssetB = assetB.unitName
	frame_dig -2 // assetB: AssetID
	asset_params_get AssetUnitName
	pop
	frame_bury 1 // nameAssetB: byte[]

*if7_end:
	// contracts\BiatecClammPool.algo.ts:301
	// name =
	//       'B-' +
	//       //this.verificationClass.value.toString() +
	//       //'-' +
	//       nameAssetA +
	//       '-' +
	//       nameAssetB
	pushbytes 0x422d // "B-"
	frame_dig 0 // nameAssetA: byte[]
	concat
	pushbytes 0x2d // "-"
	concat
	frame_dig 1 // nameAssetB: byte[]
	concat
	frame_bury 2 // name: byte[]

	// contracts\BiatecClammPool.algo.ts:311
	// return sendAssetCreation({
	//       configAssetName: name,
	//       configAssetUnitName: 'BLP', // Biatec LP token
	//       // eslint-disable-next-line no-loss-of-precision
	//       configAssetTotal: Uint<64>(TOTAL_SUPPLY),
	//       configAssetDecimals: LP_TOKEN_DECIMALS,
	//       configAssetManager: this.app.address,
	//       configAssetReserve: this.app.address,
	//     });
	itxn_begin
	intc 10 //  acfg
	itxn_field TypeEnum

	// contracts\BiatecClammPool.algo.ts:312
	// configAssetName: name
	frame_dig 2 // name: byte[]
	itxn_field ConfigAssetName

	// contracts\BiatecClammPool.algo.ts:313
	// configAssetUnitName: 'BLP'
	pushbytes 0x424c50 // "BLP"
	itxn_field ConfigAssetUnitName

	// contracts\BiatecClammPool.algo.ts:315
	// configAssetTotal: Uint<64>(TOTAL_SUPPLY)
	pushint 18000000000000000000
	itxn_field ConfigAssetTotal

	// contracts\BiatecClammPool.algo.ts:316
	// configAssetDecimals: LP_TOKEN_DECIMALS
	intc 5 // 6
	itxn_field ConfigAssetDecimals

	// contracts\BiatecClammPool.algo.ts:317
	// configAssetManager: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetManager

	// contracts\BiatecClammPool.algo.ts:318
	// configAssetReserve: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetReserve

	// Fee field not set, defaulting to 0
	intc 2 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn CreatedAssetID

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// checkAssetsAB(assetA: AssetID, assetB: AssetID): void
checkAssetsAB:
	proto 2 0

	// contracts\BiatecClammPool.algo.ts:323
	// assert(assetA.id === this.assetA.value, 'assetA does not match')
	frame_dig -1 // assetA: AssetID
	bytec 25 //  "a"
	app_global_get
	==

	// assetA does not match
	assert

	// contracts\BiatecClammPool.algo.ts:324
	// assert(assetB.id === this.assetB.value, 'assetB does not match')
	frame_dig -2 // assetB: AssetID
	bytec 26 //  "b"
	app_global_get
	==

	// assetB does not match
	assert
	retsub

// checkAssets(assetA: AssetID, assetB: AssetID, assetLp: AssetID): void
checkAssets:
	proto 3 0

	// contracts\BiatecClammPool.algo.ts:328
	// this.checkAssetsAB(assetA, assetB)
	frame_dig -2 // assetB: AssetID
	frame_dig -1 // assetA: AssetID
	callsub checkAssetsAB

	// contracts\BiatecClammPool.algo.ts:329
	// assert(assetLp.id === this.assetLp.value, 'assetLp does not match')
	frame_dig -3 // assetLp: AssetID
	bytec 23 //  "lp"
	app_global_get
	==

	// assetLp does not match
	assert
	retsub

// addLiquidity(uint64,uint64,txn,txn,uint64,uint64,uint64)uint64
*abi_route_addLiquidity:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// assetLp: uint64
	txna ApplicationArgs 5
	btoi

	// assetB: uint64
	txna ApplicationArgs 4
	btoi

	// assetA: uint64
	txna ApplicationArgs 3
	btoi

	// txAssetBDeposit: txn
	txn GroupIndex
	intc 3 // 1
	-

	// txAssetADeposit: txn
	txn GroupIndex
	intc 13 // 2
	-

	// appBiatecIdentityProvider: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute addLiquidity(uint64,uint64,txn,txn,uint64,uint64,uint64)uint64
	callsub addLiquidity
	itob
	concat
	log
	intc 3 // 1
	return

// addLiquidity(appBiatecConfigProvider: AppID, appBiatecIdentityProvider: AppID, txAssetADeposit: Txn, txAssetBDeposit: Txn, assetA: AssetID, assetB: AssetID, assetLp: AssetID): uint64
//
// This method adds Asset A and Asset B to the Automated Market Maker Concentrated Liqudidity Pool and send to the liqudidty provider the liqudity token
// @param appBiatecConfigProvider Configuration reference
// @param appBiatecIdentityProvider Identity service reference
// @param txAssetADeposit Transfer of asset A to the LP pool
// @param txAssetBDeposit Transfer of asset B to the LP pool
// @param assetLp Liquidity pool asset
// @param assetA Asset A
// @param assetB Asset B
// @returns LP Token quantity distributed
addLiquidity:
	proto 7 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 20

	// contracts\BiatecClammPool.algo.ts:352
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 2 // 0
	itxn_field Fee
	bytec 6 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:353
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 2 // 0
	itxn_field Fee
	bytec 6 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// well formed mint
	// contracts\BiatecClammPool.algo.ts:355
	// this.checkAssets(assetA, assetB, assetLp)
	frame_dig -7 // assetLp: AssetID
	frame_dig -6 // assetB: AssetID
	frame_dig -5 // assetA: AssetID
	callsub checkAssets

	// contracts\BiatecClammPool.algo.ts:357
	// this.verifyIdentity(appBiatecConfigProvider, appBiatecIdentityProvider)
	frame_dig -2 // appBiatecIdentityProvider: AppID
	frame_dig -1 // appBiatecConfigProvider: AppID
	callsub verifyIdentity

	// contracts\BiatecClammPool.algo.ts:359
	// assetLpDelicmalScale2Scale = <uint256>LP_SCALE_DECIMALS
	intc 9 // 10
	intc 10 // 3
	exp
	itob
	frame_bury 0 // assetLpDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:361
	// aDepositInBaseScale = <uint256>0
	bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 1 // aDepositInBaseScale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:362
	// bDepositInBaseScale = <uint256>0
	bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 2 // bDepositInBaseScale: unsafe uint256

	// *if8_condition
	// contracts\BiatecClammPool.algo.ts:363
	// assetA.id > 0
	frame_dig -5 // assetA: AssetID
	intc 2 // 0
	>
	bz *if8_else

	// *if8_consequent
	// contracts\BiatecClammPool.algo.ts:364
	// assert(txAssetADeposit.typeEnum === TransactionType.AssetTransfer)
	frame_dig -3 // txAssetADeposit: Txn
	gtxns TypeEnum
	intc 7 //  axfer
	==
	assert

	// contracts\BiatecClammPool.algo.ts:365
	// aDepositInBaseScale = (txAssetADeposit.assetAmount as uint256) * this.assetADecimals.value
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	itob
	bytec 12 //  "ad"
	app_global_get
	b*
	frame_bury 1 // aDepositInBaseScale: unsafe uint256
	b *if8_end

*if8_else:
	// contracts\BiatecClammPool.algo.ts:367
	// assert(txAssetADeposit.typeEnum === TransactionType.Payment)
	frame_dig -3 // txAssetADeposit: Txn
	gtxns TypeEnum
	intc 3 //  pay
	==
	assert

	// contracts\BiatecClammPool.algo.ts:368
	// aDepositInBaseScale = (txAssetADeposit.amount as uint256) * this.assetADecimals.value
	frame_dig -3 // txAssetADeposit: Txn
	gtxns Amount
	itob
	bytec 12 //  "ad"
	app_global_get
	b*
	frame_bury 1 // aDepositInBaseScale: unsafe uint256

*if8_end:
	// *if9_condition
	// contracts\BiatecClammPool.algo.ts:371
	// txAssetADeposit.typeEnum === TransactionType.AssetTransfer
	frame_dig -3 // txAssetADeposit: Txn
	gtxns TypeEnum
	intc 7 //  axfer
	==
	bz *if9_elseif1_condition

	// *if9_consequent
	// contracts\BiatecClammPool.algo.ts:372
	// xfer = txAssetADeposit as AssetTransferTxn
	frame_dig -3 // txAssetADeposit: Txn
	dup
	gtxns TypeEnum
	intc 7 //  axfer
	==

	// failed to cast txAssetADeposit to axfer
	assert
	frame_bury 3 // xfer: axfer

	// contracts\BiatecClammPool.algo.ts:373
	// verifyAssetTransferTxn(xfer, {
	//         assetReceiver: this.app.address,
	//         xferAsset: assetA,
	//         assetAmount: { greaterThanEqualTo: 0 },
	//       })
	// verify axfer
	frame_dig 3 // xfer: axfer
	gtxns TypeEnum
	intc 7 //  axfer
	==

	// transaction verification failed: {"txn":"xfer","field":"typeEnum","expected":"axfer"}
	assert

	// verify assetReceiver
	frame_dig 3 // xfer: axfer
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"xfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig 3 // xfer: axfer
	gtxns XferAsset
	frame_dig -5 // assetA: AssetID
	==

	// transaction verification failed: {"txn":"xfer","field":"xferAsset","expected":"assetA"}
	assert

	// verify assetAmount
	frame_dig 3 // xfer: axfer
	gtxns AssetAmount
	intc 2 // 0
	>=

	// transaction verification failed: {"txn":"xfer","field":"assetAmount","condition":"greaterThanEqualTo","expected":">=0"}
	assert
	b *if9_end

*if9_elseif1_condition:
	// contracts\BiatecClammPool.algo.ts:378
	// txAssetADeposit.typeEnum === TransactionType.Payment
	frame_dig -3 // txAssetADeposit: Txn
	gtxns TypeEnum
	intc 3 //  pay
	==
	bz *if9_else

	// *if9_elseif1_consequent
	// contracts\BiatecClammPool.algo.ts:379
	// payTx = txAssetADeposit as PayTxn
	frame_dig -3 // txAssetADeposit: Txn
	dup
	gtxns TypeEnum
	intc 3 //  pay
	==

	// failed to cast txAssetADeposit to pay
	assert
	frame_bury 4 // payTx: pay

	// contracts\BiatecClammPool.algo.ts:380
	// verifyPayTxn(payTx, {
	//         receiver: this.app.address,
	//         amount: { greaterThanEqualTo: 0 },
	//       })
	// verify pay
	frame_dig 4 // payTx: pay
	gtxns TypeEnum
	intc 3 //  pay
	==

	// transaction verification failed: {"txn":"payTx","field":"typeEnum","expected":"pay"}
	assert

	// verify receiver
	frame_dig 4 // payTx: pay
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payTx","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig 4 // payTx: pay
	gtxns Amount
	intc 2 // 0
	>=

	// transaction verification failed: {"txn":"payTx","field":"amount","condition":"greaterThanEqualTo","expected":">=0"}
	assert
	b *if9_end

*if9_else:
	// contracts\BiatecClammPool.algo.ts:385
	// assert(false, 'Unsupported tx type of the asset A')
	intc 2 // 0

	// Unsupported tx type of the asset A
	assert

*if9_end:
	// *if10_condition
	// contracts\BiatecClammPool.algo.ts:388
	// assetB.id > 0
	frame_dig -6 // assetB: AssetID
	intc 2 // 0
	>
	bz *if10_else

	// *if10_consequent
	// contracts\BiatecClammPool.algo.ts:389
	// assert(txAssetBDeposit.typeEnum === TransactionType.AssetTransfer)
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns TypeEnum
	intc 7 //  axfer
	==
	assert

	// contracts\BiatecClammPool.algo.ts:390
	// bDepositInBaseScale = (txAssetBDeposit.assetAmount as uint256) * this.assetBDecimals.value
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	itob
	bytec 14 //  "bd"
	app_global_get
	b*
	frame_bury 2 // bDepositInBaseScale: unsafe uint256
	b *if10_end

*if10_else:
	// contracts\BiatecClammPool.algo.ts:392
	// assert(txAssetBDeposit.typeEnum === TransactionType.Payment)
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns TypeEnum
	intc 3 //  pay
	==
	assert

	// contracts\BiatecClammPool.algo.ts:393
	// bDepositInBaseScale = (txAssetBDeposit.amount as uint256) * this.assetBDecimals.value
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns Amount
	itob
	bytec 14 //  "bd"
	app_global_get
	b*
	frame_bury 2 // bDepositInBaseScale: unsafe uint256

*if10_end:
	// *if11_condition
	// contracts\BiatecClammPool.algo.ts:396
	// txAssetBDeposit.typeEnum === TransactionType.AssetTransfer
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns TypeEnum
	intc 7 //  axfer
	==
	bz *if11_elseif1_condition

	// *if11_consequent
	// contracts\BiatecClammPool.algo.ts:397
	// xfer = txAssetBDeposit as AssetTransferTxn
	frame_dig -4 // txAssetBDeposit: Txn
	dup
	gtxns TypeEnum
	intc 7 //  axfer
	==

	// failed to cast txAssetBDeposit to axfer
	assert
	frame_bury 5 // xfer: axfer

	// contracts\BiatecClammPool.algo.ts:398
	// verifyAssetTransferTxn(xfer, {
	//         assetReceiver: this.app.address,
	//         xferAsset: assetB,
	//         assetAmount: { greaterThanEqualTo: 0 },
	//       })
	// verify axfer
	frame_dig 5 // xfer: axfer
	gtxns TypeEnum
	intc 7 //  axfer
	==

	// transaction verification failed: {"txn":"xfer","field":"typeEnum","expected":"axfer"}
	assert

	// verify assetReceiver
	frame_dig 5 // xfer: axfer
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"xfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig 5 // xfer: axfer
	gtxns XferAsset
	frame_dig -6 // assetB: AssetID
	==

	// transaction verification failed: {"txn":"xfer","field":"xferAsset","expected":"assetB"}
	assert

	// verify assetAmount
	frame_dig 5 // xfer: axfer
	gtxns AssetAmount
	intc 2 // 0
	>=

	// transaction verification failed: {"txn":"xfer","field":"assetAmount","condition":"greaterThanEqualTo","expected":">=0"}
	assert
	b *if11_end

*if11_elseif1_condition:
	// contracts\BiatecClammPool.algo.ts:403
	// txAssetBDeposit.typeEnum === TransactionType.Payment
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns TypeEnum
	intc 3 //  pay
	==
	bz *if11_else

	// *if11_elseif1_consequent
	// contracts\BiatecClammPool.algo.ts:404
	// payTx = txAssetBDeposit as PayTxn
	frame_dig -4 // txAssetBDeposit: Txn
	dup
	gtxns TypeEnum
	intc 3 //  pay
	==

	// failed to cast txAssetBDeposit to pay
	assert
	frame_bury 6 // payTx: pay

	// contracts\BiatecClammPool.algo.ts:405
	// verifyPayTxn(payTx, {
	//         receiver: this.app.address,
	//         amount: { greaterThanEqualTo: 0 },
	//       })
	// verify pay
	frame_dig 6 // payTx: pay
	gtxns TypeEnum
	intc 3 //  pay
	==

	// transaction verification failed: {"txn":"payTx","field":"typeEnum","expected":"pay"}
	assert

	// verify receiver
	frame_dig 6 // payTx: pay
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payTx","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig 6 // payTx: pay
	gtxns Amount
	intc 2 // 0
	>=

	// transaction verification failed: {"txn":"payTx","field":"amount","condition":"greaterThanEqualTo","expected":">=0"}
	assert
	b *if11_end

*if11_else:
	// contracts\BiatecClammPool.algo.ts:410
	// assert(false, 'Unsupported tx type of the asset B')
	intc 2 // 0

	// Unsupported tx type of the asset B
	assert

*if11_end:
	// *if12_condition
	// contracts\BiatecClammPool.algo.ts:415
	// this.priceMinSqrt.value === this.priceMaxSqrt.value
	bytec 9 //  "pMinS"
	app_global_get
	bytec 10 //  "pMaxS"
	app_global_get
	b==
	bz *if12_end

	// *if12_consequent
	// contracts\BiatecClammPool.algo.ts:416
	// return this.processAddLiqudity(aDepositInBaseScale, bDepositInBaseScale, assetLpDelicmalScale2Scale, assetLp);
	frame_dig -7 // assetLp: AssetID
	frame_dig 0 // assetLpDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// assetLpDelicmalScale2Scale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 2 // bDepositInBaseScale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// bDepositInBaseScale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 1 // aDepositInBaseScale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// aDepositInBaseScale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub processAddLiqudity
	b *addLiquidity*return

*if12_end:
	// *if13_condition
	// contracts\BiatecClammPool.algo.ts:421
	// this.assetABalance.value === <uint256>0 && this.assetBBalance.value === <uint256>0
	bytec 3 //  "ab"
	app_global_get
	bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b==
	dup
	bz *skip_and0
	bytec 4 //  "bb"
	app_global_get
	bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b==
	&&

*skip_and0:
	bz *if13_end

	// *if13_consequent
	// contracts\BiatecClammPool.algo.ts:426
	// ret = this.processAddLiqudity(
	//         aDepositInBaseScale,
	//         bDepositInBaseScale,
	//         assetLpDelicmalScale2Scale,
	//         assetLp
	//       )
	frame_dig -7 // assetLp: AssetID
	frame_dig 0 // assetLpDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// assetLpDelicmalScale2Scale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 2 // bDepositInBaseScale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// bDepositInBaseScale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 1 // aDepositInBaseScale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// aDepositInBaseScale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub processAddLiqudity
	frame_bury 7 // ret: uint64

	// contracts\BiatecClammPool.algo.ts:433
	// newPrice = this.calculatePrice(
	//         this.assetABalance.value, // assetAQuantity: uint256,
	//         this.assetBBalance.value, // assetBQuantity: uint256,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value, // priceMaxSqrt: uint256,
	//         this.Liqudity.value // liquidity: uint256
	//       )
	bytec 8 //  "L"
	app_global_get
	bytec 10 //  "pMaxS"
	app_global_get
	bytec 9 //  "pMinS"
	app_global_get
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculatePrice
	frame_bury 8 // newPrice: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:441
	// this.currentPrice.value = newPrice as uint64
	bytec 19 //  "price"
	frame_dig 8 // newPrice: unsafe uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// newPrice as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	app_global_put

	// contracts\BiatecClammPool.algo.ts:442
	// return ret;
	frame_dig 7 // ret: uint64
	b *addLiquidity*return

*if13_end:
	// contracts\BiatecClammPool.algo.ts:449
	// a = this.calculateAssetADepositOnAssetBDeposit(
	//       aDepositInBaseScale,
	//       bDepositInBaseScale,
	//       this.assetABalance.value,
	//       this.assetBBalance.value
	//     )
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	frame_dig 2 // bDepositInBaseScale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// bDepositInBaseScale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 1 // aDepositInBaseScale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// aDepositInBaseScale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub calculateAssetADepositOnAssetBDeposit
	frame_bury 9 // a: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:456
	// b = this.calculateAssetBDepositOnAssetADeposit(
	//       aDepositInBaseScale,
	//       bDepositInBaseScale,
	//       this.assetABalance.value,
	//       this.assetBBalance.value
	//     )
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	frame_dig 2 // bDepositInBaseScale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// bDepositInBaseScale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 1 // aDepositInBaseScale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// aDepositInBaseScale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub calculateAssetBDepositOnAssetADeposit
	frame_bury 10 // b: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:462
	// expectedADepositB64 = (a / this.assetADecimals.value) as uint64
	frame_dig 9 // a: unsafe uint256
	bytec 12 //  "ad"
	app_global_get
	b/
	dup
	bitlen
	intc 4 // 64
	<=

	// (a / this.assetADecimals.value) as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 11 // expectedADepositB64: uint64

	// contracts\BiatecClammPool.algo.ts:463
	// expectedBDepositB64 = (b / this.assetBDecimals.value) as uint64
	frame_dig 10 // b: unsafe uint256
	bytec 14 //  "bd"
	app_global_get
	b/
	dup
	bitlen
	intc 4 // 64
	<=

	// (b / this.assetBDecimals.value) as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 12 // expectedBDepositB64: uint64

	// *if14_condition
	// contracts\BiatecClammPool.algo.ts:465
	// expectedADepositB64 > txAssetADeposit.assetAmount
	frame_dig 11 // expectedADepositB64: uint64
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	>
	bz *if14_end

	// *if14_consequent
	// *if15_condition
	// contracts\BiatecClammPool.algo.ts:472
	// expectedBDepositB64 > txAssetBDeposit.assetAmount
	frame_dig 12 // expectedBDepositB64: uint64
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	>
	bz *if15_end

	// *if15_consequent
	// contracts\BiatecClammPool.algo.ts:473
	// assert(false, 'Dominant is asset B')
	intc 2 // 0

	// Dominant is asset B
	assert

*if15_end:
	// *if16_condition
	// contracts\BiatecClammPool.algo.ts:475
	// txAssetBDeposit.assetAmount - expectedBDepositB64 > 0
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	frame_dig 12 // expectedBDepositB64: uint64
	-
	intc 2 // 0
	>
	bz *if16_end

	// *if16_consequent
	// contracts\BiatecClammPool.algo.ts:477
	// this.doAxfer(this.txn.sender, assetB, txAssetBDeposit.assetAmount - expectedBDepositB64)
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	frame_dig 12 // expectedBDepositB64: uint64
	-
	frame_dig -6 // assetB: AssetID
	txn Sender
	callsub doAxfer

*if16_end:
	// contracts\BiatecClammPool.algo.ts:479
	// realAssetADeposit = aDepositInBaseScale
	frame_dig 1 // aDepositInBaseScale: unsafe uint256
	frame_bury 13 // realAssetADeposit: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:480
	// realAssetBDeposit = (expectedBDepositB64 as uint256) * this.assetBDecimals.value
	frame_dig 12 // expectedBDepositB64: uint64
	itob
	bytec 14 //  "bd"
	app_global_get
	b*
	frame_bury 14 // realAssetBDeposit: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:481
	// return this.processAddLiqudity(realAssetADeposit, realAssetBDeposit, assetLpDelicmalScale2Scale, assetLp);
	frame_dig -7 // assetLp: AssetID
	frame_dig 0 // assetLpDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// assetLpDelicmalScale2Scale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 14 // realAssetBDeposit: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// realAssetBDeposit overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 13 // realAssetADeposit: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// realAssetADeposit overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub processAddLiqudity
	b *addLiquidity*return

*if14_end:
	// *if17_condition
	// contracts\BiatecClammPool.algo.ts:484
	// expectedBDepositB64 > txAssetBDeposit.assetAmount
	frame_dig 12 // expectedBDepositB64: uint64
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	>
	bz *if17_end

	// *if17_consequent
	// *if18_condition
	// contracts\BiatecClammPool.algo.ts:491
	// expectedADepositB64 > txAssetADeposit.assetAmount
	frame_dig 11 // expectedADepositB64: uint64
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	>
	bz *if18_end

	// *if18_consequent
	// contracts\BiatecClammPool.algo.ts:492
	// assert(false, 'Dominant is asset A')
	intc 2 // 0

	// Dominant is asset A
	assert

*if18_end:
	// *if19_condition
	// contracts\BiatecClammPool.algo.ts:494
	// txAssetADeposit.assetAmount - expectedADepositB64 > 0
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	frame_dig 11 // expectedADepositB64: uint64
	-
	intc 2 // 0
	>
	bz *if19_end

	// *if19_consequent
	// contracts\BiatecClammPool.algo.ts:496
	// this.doAxfer(this.txn.sender, assetB, txAssetADeposit.assetAmount - expectedADepositB64)
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	frame_dig 11 // expectedADepositB64: uint64
	-
	frame_dig -6 // assetB: AssetID
	txn Sender
	callsub doAxfer

*if19_end:
	// contracts\BiatecClammPool.algo.ts:498
	// realAssetADeposit = (expectedADepositB64 as uint256) * this.assetADecimals.value
	frame_dig 11 // expectedADepositB64: uint64
	itob
	bytec 12 //  "ad"
	app_global_get
	b*
	frame_bury 15 // realAssetADeposit: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:499
	// realAssetBDeposit = bDepositInBaseScale
	frame_dig 2 // bDepositInBaseScale: unsafe uint256
	frame_bury 16 // realAssetBDeposit: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:500
	// return this.processAddLiqudity(realAssetADeposit, realAssetBDeposit, assetLpDelicmalScale2Scale, assetLp);
	frame_dig -7 // assetLp: AssetID
	frame_dig 0 // assetLpDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// assetLpDelicmalScale2Scale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 16 // realAssetBDeposit: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// realAssetBDeposit overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 15 // realAssetADeposit: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// realAssetADeposit overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub processAddLiqudity
	b *addLiquidity*return

*if17_end:
	// *if20_condition
	// contracts\BiatecClammPool.algo.ts:502
	// expectedADepositB64 === txAssetADeposit.assetAmount && expectedBDepositB64 === txAssetBDeposit.assetAmount
	frame_dig 11 // expectedADepositB64: uint64
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	==
	dup
	bz *skip_and1
	frame_dig 12 // expectedBDepositB64: uint64
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	==
	&&

*skip_and1:
	bz *if20_end

	// *if20_consequent
	// contracts\BiatecClammPool.algo.ts:503
	// realAssetADeposit = aDepositInBaseScale
	frame_dig 1 // aDepositInBaseScale: unsafe uint256
	frame_bury 17 // realAssetADeposit: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:504
	// realAssetBDeposit = bDepositInBaseScale
	frame_dig 2 // bDepositInBaseScale: unsafe uint256
	frame_bury 18 // realAssetBDeposit: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:505
	// return this.processAddLiqudity(realAssetADeposit, realAssetBDeposit, assetLpDelicmalScale2Scale, assetLp);
	frame_dig -7 // assetLp: AssetID
	frame_dig 0 // assetLpDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// assetLpDelicmalScale2Scale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 18 // realAssetBDeposit: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// realAssetBDeposit overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 17 // realAssetADeposit: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// realAssetADeposit overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub processAddLiqudity
	b *addLiquidity*return

*if20_end:
	// *if21_condition
	// contracts\BiatecClammPool.algo.ts:508
	// expectedADepositB64 === txAssetADeposit.assetAmount && expectedBDepositB64 === txAssetBDeposit.assetAmount
	frame_dig 11 // expectedADepositB64: uint64
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	==
	dup
	bz *skip_and2
	frame_dig 12 // expectedBDepositB64: uint64
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	==
	&&

*skip_and2:
	bz *if21_end

	// *if21_consequent
	// contracts\BiatecClammPool.algo.ts:509
	// realAssetADeposit = aDepositInBaseScale
	frame_dig 1 // aDepositInBaseScale: unsafe uint256
	frame_bury 19 // realAssetADeposit: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:510
	// realAssetBDeposit = bDepositInBaseScale
	frame_dig 2 // bDepositInBaseScale: unsafe uint256
	frame_bury 20 // realAssetBDeposit: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:511
	// return this.processAddLiqudity(realAssetADeposit, realAssetBDeposit, assetLpDelicmalScale2Scale, assetLp);
	frame_dig -7 // assetLp: AssetID
	frame_dig 0 // assetLpDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// assetLpDelicmalScale2Scale overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 20 // realAssetBDeposit: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// realAssetBDeposit overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 19 // realAssetADeposit: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// realAssetADeposit overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub processAddLiqudity
	b *addLiquidity*return

*if21_end:
	// *if22_condition
	// contracts\BiatecClammPool.algo.ts:514
	// expectedADepositB64 === 0 && expectedBDepositB64 === 0
	frame_dig 11 // expectedADepositB64: uint64
	intc 2 // 0
	==
	dup
	bz *skip_and3
	frame_dig 12 // expectedBDepositB64: uint64
	intc 2 // 0
	==
	&&

*skip_and3:
	bz *if22_end

	// *if22_consequent
	// *if23_condition
	// contracts\BiatecClammPool.algo.ts:516
	// txAssetADeposit.assetAmount > 0
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	intc 2 // 0
	>
	bz *if23_end

	// *if23_consequent
	// contracts\BiatecClammPool.algo.ts:517
	// this.doAxfer(this.txn.sender, assetA, txAssetADeposit.assetAmount)
	frame_dig -3 // txAssetADeposit: Txn
	gtxns AssetAmount
	frame_dig -5 // assetA: AssetID
	txn Sender
	callsub doAxfer

*if23_end:
	// *if24_condition
	// contracts\BiatecClammPool.algo.ts:519
	// txAssetBDeposit.assetAmount > 0
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	intc 2 // 0
	>
	bz *if24_end

	// *if24_consequent
	// contracts\BiatecClammPool.algo.ts:520
	// this.doAxfer(this.txn.sender, assetB, txAssetBDeposit.assetAmount)
	frame_dig -4 // txAssetBDeposit: Txn
	gtxns AssetAmount
	frame_dig -6 // assetB: AssetID
	txn Sender
	callsub doAxfer

*if24_end:
	// contracts\BiatecClammPool.algo.ts:522
	// return 0;
	intc 2 // 0
	b *addLiquidity*return

*if22_end:
	// contracts\BiatecClammPool.algo.ts:524
	// assert(false, 'failed to calculate exact liqudidity')
	intc 2 // 0

	// failed to calculate exact liqudidity
	assert

	// contracts\BiatecClammPool.algo.ts:525
	// return expectedBDepositB64;
	frame_dig 12 // expectedBDepositB64: uint64

*addLiquidity*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 20
	retsub

// processAddLiqudity(realAssetADeposit: uint256, realAssetBDeposit: uint256, assetLpDelicmalScale2Scale: uint256, assetLp: AssetID): uint64
//
// This method is used in addLiquidity to process the liquidity addition from calculated values
// @param realAssetADeposit Real asset a deposit
// @param realAssetBDeposit Real asset b deposit
// @param assetLpDelicmalScale2Scale LP decimal scale
// @param assetLp LP Asset
// @returns LP Token quantity distributed
processAddLiqudity:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 8

	// contracts\BiatecClammPool.algo.ts:542
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 2 // 0
	itxn_field Fee
	bytec 6 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:544
	// this.assetABalance.value = this.assetABalance.value + realAssetADeposit
	bytec 3 //  "ab"
	dup
	app_global_get
	frame_dig -1 // realAssetADeposit: uint256
	b+
	dup
	bitlen
	intc 1 // 256
	<=

	// this.assetABalance.value + realAssetADeposit overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:545
	// this.assetBBalance.value = this.assetBBalance.value + realAssetBDeposit
	bytec 4 //  "bb"
	dup
	app_global_get
	frame_dig -2 // realAssetBDeposit: uint256
	b+
	dup
	bitlen
	intc 1 // 256
	<=

	// this.assetBBalance.value + realAssetBDeposit overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:548
	// x = this.assetABalance.value
	bytec 3 //  "ab"
	app_global_get
	frame_bury 0 // x: uint256

	// contracts\BiatecClammPool.algo.ts:549
	// y = this.assetBBalance.value
	bytec 4 //  "bb"
	app_global_get
	frame_bury 1 // y: uint256

	// contracts\BiatecClammPool.algo.ts:550
	// priceMin = this.priceMin.value as uint256
	bytec 13 //  "pMin"
	app_global_get
	itob
	frame_bury 2 // priceMin: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:551
	// priceMax = this.priceMax.value as uint256
	bytec 16 //  "pMax"
	app_global_get
	itob
	frame_bury 3 // priceMax: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:552
	// priceMinSqrt = this.priceMinSqrt.value
	bytec 9 //  "pMinS"
	app_global_get
	frame_bury 4 // priceMinSqrt: uint256

	// contracts\BiatecClammPool.algo.ts:553
	// priceMaxSqrt = this.priceMaxSqrt.value
	bytec 10 //  "pMaxS"
	app_global_get
	frame_bury 5 // priceMaxSqrt: uint256

	// contracts\BiatecClammPool.algo.ts:554
	// newLiqudity = <uint256>0
	bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 6 // newLiqudity: unsafe uint256

	// *if25_condition
	// contracts\BiatecClammPool.algo.ts:555
	// priceMin === priceMax
	frame_dig 2 // priceMin: unsafe uint256
	frame_dig 3 // priceMax: unsafe uint256
	b==
	bz *if25_else

	// *if25_consequent
	// contracts\BiatecClammPool.algo.ts:556
	// newLiqudity = this.calculateLiquidityFlatPrice(x, y, priceMin)
	frame_dig 2 // priceMin: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// priceMin overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 1 // y: uint256
	frame_dig 0 // x: uint256
	callsub calculateLiquidityFlatPrice
	frame_bury 6 // newLiqudity: unsafe uint256
	b *if25_end

*if25_else:
	// contracts\BiatecClammPool.algo.ts:558
	// D_SQRT = this.calculateLiquidityD(x, y, priceMin, priceMax, priceMinSqrt, priceMaxSqrt)
	frame_dig 5 // priceMaxSqrt: uint256
	frame_dig 4 // priceMinSqrt: uint256
	frame_dig 3 // priceMax: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// priceMax overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 2 // priceMin: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// priceMin overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 1 // y: uint256
	frame_dig 0 // x: uint256
	callsub calculateLiquidityD
	frame_bury 7 // D_SQRT: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:559
	// newLiqudity = this.calculateLiquidityWithD(x, y, priceMinSqrt, priceMaxSqrt, D_SQRT)
	frame_dig 7 // D_SQRT: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// D_SQRT overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig 5 // priceMaxSqrt: uint256
	frame_dig 4 // priceMinSqrt: uint256
	frame_dig 1 // y: uint256
	frame_dig 0 // x: uint256
	callsub calculateLiquidityWithD
	frame_bury 6 // newLiqudity: unsafe uint256

*if25_end:
	// contracts\BiatecClammPool.algo.ts:562
	// lpTokensToSend = ((newLiqudity - this.Liqudity.value) / assetLpDelicmalScale2Scale) as uint64
	frame_dig 6 // newLiqudity: unsafe uint256
	bytec 8 //  "L"
	app_global_get
	b-
	frame_dig -3 // assetLpDelicmalScale2Scale: uint256
	b/
	dup
	bitlen
	intc 4 // 64
	<=

	// ((newLiqudity - this.Liqudity.value) / assetLpDelicmalScale2Scale) as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 8 // lpTokensToSend: uint64

	// contracts\BiatecClammPool.algo.ts:564
	// this.Liqudity.value = newLiqudity
	bytec 8 //  "L"
	frame_dig 6 // newLiqudity: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// newLiqudity overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:566
	// this.doAxfer(this.txn.sender, assetLp, lpTokensToSend)
	frame_dig 8 // lpTokensToSend: uint64
	frame_dig -4 // assetLp: AssetID
	txn Sender
	callsub doAxfer

	// contracts\BiatecClammPool.algo.ts:572
	// assert(lpTokensToSend > 0, 'LP-ZERO-ERR')
	frame_dig 8 // lpTokensToSend: uint64
	intc 2 // 0
	>

	// LP-ZERO-ERR
	assert

	// contracts\BiatecClammPool.algo.ts:573
	// return lpTokensToSend as uint64;
	frame_dig 8 // lpTokensToSend: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 8
	retsub

// removeLiquidity(uint64,uint64,axfer,uint64,uint64,uint64)uint256
*abi_route_removeLiquidity:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// assetLp: uint64
	txna ApplicationArgs 5
	btoi

	// assetB: uint64
	txna ApplicationArgs 4
	btoi

	// assetA: uint64
	txna ApplicationArgs 3
	btoi

	// txLpXfer: axfer
	txn GroupIndex
	intc 3 // 1
	-
	dup
	gtxns TypeEnum
	intc 7 //  axfer
	==

	// argument 3 (txLpXfer) for removeLiquidity must be a axfer transaction
	assert

	// appBiatecIdentityProvider: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute removeLiquidity(uint64,uint64,axfer,uint64,uint64,uint64)uint256
	callsub removeLiquidity
	dup
	bitlen
	intc 1 // 256
	<=

	// removeLiquidity return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// removeLiquidity(appBiatecConfigProvider: AppID, appBiatecIdentityProvider: AppID, txLpXfer: AssetTransferTxn, assetA: AssetID, assetB: AssetID, assetLp: AssetID): uint256
//
// This method retrieves from the liquidity provider LP token and returns Asset A and Asset B from the Automated Market Maker Concentrated Liqudidity Pool
// @param appBiatecConfigProvider Configuration reference
// @param appBiatecIdentityProvider Identity service reference
// @param txLpXfer Transfer of the LP token
// @param assetLp LP pool asset
// @param assetA Asset A
// @param assetB Asset B
// @returns LP position reduced
removeLiquidity:
	proto 6 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 14

	// well formed mint
	// contracts\BiatecClammPool.algo.ts:595
	// this.checkAssets(assetA, assetB, assetLp)
	frame_dig -6 // assetLp: AssetID
	frame_dig -5 // assetB: AssetID
	frame_dig -4 // assetA: AssetID
	callsub checkAssets

	// contracts\BiatecClammPool.algo.ts:596
	// verifyAssetTransferTxn(txLpXfer, {
	//       assetReceiver: this.app.address,
	//       xferAsset: assetLp,
	//       assetAmount: { greaterThanEqualTo: 0 },
	//     })
	// verify assetReceiver
	frame_dig -3 // txLpXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"txLpXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -3 // txLpXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -6 // assetLp: AssetID
	==

	// transaction verification failed: {"txn":"txLpXfer","field":"xferAsset","expected":"assetLp"}
	assert

	// verify assetAmount
	frame_dig -3 // txLpXfer: AssetTransferTxn
	gtxns AssetAmount
	intc 2 // 0
	>=

	// transaction verification failed: {"txn":"txLpXfer","field":"assetAmount","condition":"greaterThanEqualTo","expected":">=0"}
	assert

	// contracts\BiatecClammPool.algo.ts:602
	// this.verifyIdentity(appBiatecConfigProvider, appBiatecIdentityProvider)
	frame_dig -2 // appBiatecIdentityProvider: AppID
	frame_dig -1 // appBiatecConfigProvider: AppID
	callsub verifyIdentity

	// contracts\BiatecClammPool.algo.ts:605
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 2 // 0
	itxn_field Fee
	bytec 6 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:606
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 2 // 0
	itxn_field Fee
	bytec 6 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:608
	// assetLpDelicmalScale2Scale = <uint256>LP_SCALE_DECIMALS
	intc 9 // 10
	intc 10 // 3
	exp
	itob
	frame_bury 0 // assetLpDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:610
	// lpDelta = txLpXfer.assetAmount as uint256
	frame_dig -3 // txLpXfer: AssetTransferTxn
	gtxns AssetAmount
	itob
	frame_bury 1 // lpDelta: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:611
	// lpDeltaBase = lpDelta * assetLpDelicmalScale2Scale
	frame_dig 1 // lpDelta: unsafe uint256
	frame_dig 0 // assetLpDelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 2 // lpDeltaBase: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:612
	// lpDeltaWithFees = lpDeltaBase
	frame_dig 2 // lpDeltaBase: unsafe uint256
	frame_bury 3 // lpDeltaWithFees: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:613
	// lpWithOthers = this.calculateDistributedLiquidity(assetLp, lpDelta)
	frame_dig 1 // lpDelta: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// lpDelta overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	frame_dig -6 // assetLp: AssetID
	callsub calculateDistributedLiquidity
	frame_bury 4 // lpWithOthers: unsafe uint256

	// *if26_condition
	// contracts\BiatecClammPool.algo.ts:614
	// lpWithOthers > <uint256>0
	frame_dig 4 // lpWithOthers: unsafe uint256
	bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	bz *if26_end

	// *if26_consequent
	// contracts\BiatecClammPool.algo.ts:616
	// myPortion = (lpDeltaBase * s) / lpWithOthers
	frame_dig 2 // lpDeltaBase: unsafe uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 4 // lpWithOthers: unsafe uint256
	b/
	frame_bury 5 // myPortion: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:617
	// myPortionOfFeesCollected = (this.LiqudityUsersFromFees.value * myPortion) / s
	bytec 15 //  "Lu"
	app_global_get
	frame_dig 5 // myPortion: unsafe uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 6 // myPortionOfFeesCollected: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:618
	// lpDeltaWithFees = lpDeltaBase + myPortionOfFeesCollected
	frame_dig 2 // lpDeltaBase: unsafe uint256
	frame_dig 6 // myPortionOfFeesCollected: unsafe uint256
	b+
	frame_bury 3 // lpDeltaWithFees: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:619
	// this.LiqudityUsersFromFees.value = this.LiqudityUsersFromFees.value - myPortionOfFeesCollected
	bytec 15 //  "Lu"
	dup
	app_global_get
	frame_dig 6 // myPortionOfFeesCollected: unsafe uint256
	b-
	dup
	bitlen
	intc 1 // 256
	<=

	// this.LiqudityUsersFromFees.value - myPortionOfFeesCollected overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

*if26_end:
	// contracts\BiatecClammPool.algo.ts:621
	// aToSend = this.calculateAssetAWithdrawOnLpDeposit(
	//       lpDeltaWithFees,
	//       this.assetABalance.value,
	//       this.Liqudity.value
	//     )
	bytec 8 //  "L"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	frame_dig 3 // lpDeltaWithFees: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// lpDeltaWithFees overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub calculateAssetAWithdrawOnLpDeposit
	frame_bury 7 // aToSend: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:626
	// aToSend64 = (aToSend / this.assetADecimals.value) as uint64
	frame_dig 7 // aToSend: unsafe uint256
	bytec 12 //  "ad"
	app_global_get
	b/
	dup
	bitlen
	intc 4 // 64
	<=

	// (aToSend / this.assetADecimals.value) as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 8 // aToSend64: uint64

	// *if27_condition
	// contracts\BiatecClammPool.algo.ts:627
	// aToSend64 > 0
	frame_dig 8 // aToSend64: uint64
	intc 2 // 0
	>
	bz *if27_end

	// *if27_consequent
	// contracts\BiatecClammPool.algo.ts:628
	// this.doAxfer(this.txn.sender, assetA, aToSend64)
	frame_dig 8 // aToSend64: uint64
	frame_dig -4 // assetA: AssetID
	txn Sender
	callsub doAxfer

*if27_end:
	// contracts\BiatecClammPool.algo.ts:630
	// bToSend = this.calculateAssetAWithdrawOnLpDeposit(
	//       lpDeltaWithFees,
	//       this.assetBBalance.value,
	//       this.Liqudity.value
	//     )
	bytec 8 //  "L"
	app_global_get
	bytec 4 //  "bb"
	app_global_get
	frame_dig 3 // lpDeltaWithFees: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// lpDeltaWithFees overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub calculateAssetAWithdrawOnLpDeposit
	frame_bury 9 // bToSend: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:635
	// bToSend64 = (bToSend / this.assetBDecimals.value) as uint64
	frame_dig 9 // bToSend: unsafe uint256
	bytec 14 //  "bd"
	app_global_get
	b/
	dup
	bitlen
	intc 4 // 64
	<=

	// (bToSend / this.assetBDecimals.value) as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 10 // bToSend64: uint64

	// *if28_condition
	// contracts\BiatecClammPool.algo.ts:636
	// bToSend64 > 0
	frame_dig 10 // bToSend64: uint64
	intc 2 // 0
	>
	bz *if28_end

	// *if28_consequent
	// contracts\BiatecClammPool.algo.ts:637
	// this.doAxfer(this.txn.sender, assetB, bToSend64)
	frame_dig 10 // bToSend64: uint64
	frame_dig -5 // assetB: AssetID
	txn Sender
	callsub doAxfer

*if28_end:
	// contracts\BiatecClammPool.algo.ts:641
	// assert(aToSend64 > 0 || bToSend64 > 0, 'ERR-REM-ZERO')
	frame_dig 8 // aToSend64: uint64
	intc 2 // 0
	>
	dup
	bnz *skip_or0
	frame_dig 10 // bToSend64: uint64
	intc 2 // 0
	>
	||

*skip_or0:
	// ERR-REM-ZERO
	assert

	// contracts\BiatecClammPool.algo.ts:643
	// newAssetA = this.assetABalance.value - aToSend
	bytec 3 //  "ab"
	app_global_get
	frame_dig 7 // aToSend: unsafe uint256
	b-
	frame_bury 11 // newAssetA: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:644
	// newAssetB = this.assetBBalance.value - bToSend
	bytec 4 //  "bb"
	app_global_get
	frame_dig 9 // bToSend: unsafe uint256
	b-
	frame_bury 12 // newAssetB: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:645
	// this.assetABalance.value = newAssetA
	bytec 3 //  "ab"
	frame_dig 11 // newAssetA: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// newAssetA overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:646
	// this.assetBBalance.value = newAssetB
	bytec 4 //  "bb"
	frame_dig 12 // newAssetB: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// newAssetB overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:650
	// lAfter = <uint256>0
	bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 13 // lAfter: unsafe uint256

	// *if29_condition
	// contracts\BiatecClammPool.algo.ts:651
	// this.priceMin.value === this.priceMax.value
	bytec 13 //  "pMin"
	app_global_get
	bytec 16 //  "pMax"
	app_global_get
	==
	bz *if29_else

	// *if29_consequent
	// contracts\BiatecClammPool.algo.ts:652
	// lAfter = this.calculateLiquidityFlatPrice(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMin.value as uint256
	//       )
	bytec 13 //  "pMin"
	app_global_get
	itob
	dup
	bitlen
	intc 1 // 256
	<=

	// this.priceMin.value as uint256 overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculateLiquidityFlatPrice
	frame_bury 13 // lAfter: unsafe uint256
	b *if29_end

*if29_else:
	// contracts\BiatecClammPool.algo.ts:658
	// D_SQRT = this.calculateLiquidityD(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMin.value as uint256, // priceMin: uint256,
	//         this.priceMax.value as uint256, // priceMax: uint256,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value // priceMaxSqrt: uint256,
	//       )
	bytec 10 //  "pMaxS"
	app_global_get
	bytec 9 //  "pMinS"
	app_global_get
	bytec 16 //  "pMax"
	app_global_get
	itob
	dup
	bitlen
	intc 1 // 256
	<=

	// this.priceMax.value as uint256 overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 13 //  "pMin"
	app_global_get
	itob
	dup
	bitlen
	intc 1 // 256
	<=

	// this.priceMin.value as uint256 overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculateLiquidityD
	frame_bury 14 // D_SQRT: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:666
	// lAfter = this.calculateLiquidityWithD(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value, // priceMaxSqrt: uint256,
	//         D_SQRT
	//       )
	frame_dig 14 // D_SQRT: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// D_SQRT overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 10 //  "pMaxS"
	app_global_get
	bytec 9 //  "pMinS"
	app_global_get
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculateLiquidityWithD
	frame_bury 13 // lAfter: unsafe uint256

*if29_end:
	// contracts\BiatecClammPool.algo.ts:674
	// this.Liqudity.value = lAfter
	bytec 8 //  "L"
	frame_dig 13 // lAfter: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// lAfter overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:675
	// return lpDeltaWithFees / assetLpDelicmalScale2Scale;
	frame_dig 3 // lpDeltaWithFees: unsafe uint256
	frame_dig 0 // assetLpDelicmalScale2Scale: unsafe uint256
	b/

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 14
	retsub

// removeLiquidityAdmin(uint64,uint64,uint64,uint64,uint256)uint256
*abi_route_removeLiquidityAdmin:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// amount: uint256
	txna ApplicationArgs 5
	dup
	len
	intc 0 // 32
	==

	// argument 0 (amount) for removeLiquidityAdmin must be a uint256
	assert

	// assetLp: uint64
	txna ApplicationArgs 4
	btoi

	// assetB: uint64
	txna ApplicationArgs 3
	btoi

	// assetA: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute removeLiquidityAdmin(uint64,uint64,uint64,uint64,uint256)uint256
	callsub removeLiquidityAdmin
	dup
	bitlen
	intc 1 // 256
	<=

	// removeLiquidityAdmin return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// removeLiquidityAdmin(appBiatecConfigProvider: AppID, assetA: AssetID, assetB: AssetID, assetLp: AssetID, amount: uint256): uint256
//
// This method allows biatec admin to reduce the lp position created by lp fees allocation.
//
// Only addressExecutiveFee is allowed to execute this method.
//
// @param appBiatecConfigProvider Biatec config app. Only addressExecutiveFee is allowed to execute this method.
// @param assetA Asset A
// @param assetB Asset B
// @param amount Amount to withdraw. If zero, removes all available lps from fees.
//
// @returns LP position reduced
removeLiquidityAdmin:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 11

	// well formed mint
	// contracts\BiatecClammPool.algo.ts:698
	// this.checkAssets(assetA, assetB, assetLp)
	frame_dig -4 // assetLp: AssetID
	frame_dig -3 // assetB: AssetID
	frame_dig -2 // assetA: AssetID
	callsub checkAssets

	// contracts\BiatecClammPool.algo.ts:700
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value)
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 17 //  "bc"
	app_global_get
	==
	assert

	// contracts\BiatecClammPool.algo.ts:701
	// addressExecutiveFee = appBiatecConfigProvider.globalState('ef') as Address
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 24 //  "ef"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('ef')
	assert
	frame_bury 0 // addressExecutiveFee: address

	// contracts\BiatecClammPool.algo.ts:703
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 21 //  "s"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('s')
	assert
	frame_bury 1 // paused: uint64

	// contracts\BiatecClammPool.algo.ts:704
	// assert(paused === 0, 'E_PAUSED')
	frame_dig 1 // paused: uint64
	intc 2 // 0
	==

	// E_PAUSED
	assert

	// contracts\BiatecClammPool.algo.ts:710
	// assert(this.txn.sender === addressExecutiveFee, 'ERR-EXEC-ONLY')
	txn Sender
	frame_dig 0 // addressExecutiveFee: address
	==

	// ERR-EXEC-ONLY
	assert

	// contracts\BiatecClammPool.algo.ts:712
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 2 // 0
	itxn_field Fee
	bytec 6 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:713
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 2 // 0
	itxn_field Fee
	bytec 6 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:716
	// assetLpDelicmalScale2Scale = <uint256>LP_SCALE_DECIMALS
	intc 9 // 10
	intc 10 // 3
	exp
	itob
	frame_bury 2 // assetLpDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:718
	// lpDeltaWithFees = amount
	frame_dig -5 // amount: uint256
	frame_bury 3 // lpDeltaWithFees: unsafe uint256

	// *if30_condition
	// contracts\BiatecClammPool.algo.ts:719
	// lpDeltaWithFees === <uint256>0
	frame_dig 3 // lpDeltaWithFees: unsafe uint256
	bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b==
	bz *if30_end

	// *if30_consequent
	// contracts\BiatecClammPool.algo.ts:719
	// lpDeltaWithFees = this.LiqudityBiatecFromFees.value
	bytec 18 //  "Lb"
	app_global_get
	frame_bury 3 // lpDeltaWithFees: unsafe uint256

*if30_end:
	// contracts\BiatecClammPool.algo.ts:720
	// assert(
	//       lpDeltaWithFees <= this.LiqudityBiatecFromFees.value,
	//       'ERR-TOO-MUCH' // 'Biatec cannot take more lp then is collected in fees'
	//     )
	frame_dig 3 // lpDeltaWithFees: unsafe uint256
	bytec 18 //  "Lb"
	app_global_get
	b<=

	// ERR-TOO-MUCH
	assert

	// contracts\BiatecClammPool.algo.ts:724
	// this.LiqudityBiatecFromFees.value = this.LiqudityBiatecFromFees.value - lpDeltaWithFees
	bytec 18 //  "Lb"
	dup
	app_global_get
	frame_dig 3 // lpDeltaWithFees: unsafe uint256
	b-
	dup
	bitlen
	intc 1 // 256
	<=

	// this.LiqudityBiatecFromFees.value - lpDeltaWithFees overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:725
	// aToSend = this.calculateAssetAWithdrawOnLpDeposit(
	//       lpDeltaWithFees,
	//       this.assetABalance.value,
	//       this.Liqudity.value
	//     )
	bytec 8 //  "L"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	frame_dig 3 // lpDeltaWithFees: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// lpDeltaWithFees overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub calculateAssetAWithdrawOnLpDeposit
	frame_bury 4 // aToSend: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:730
	// aToSend64 = (aToSend / this.assetADecimals.value) as uint64
	frame_dig 4 // aToSend: unsafe uint256
	bytec 12 //  "ad"
	app_global_get
	b/
	dup
	bitlen
	intc 4 // 64
	<=

	// (aToSend / this.assetADecimals.value) as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 5 // aToSend64: uint64

	// *if31_condition
	// contracts\BiatecClammPool.algo.ts:731
	// aToSend64 > 0
	frame_dig 5 // aToSend64: uint64
	intc 2 // 0
	>
	bz *if31_end

	// *if31_consequent
	// contracts\BiatecClammPool.algo.ts:732
	// this.doAxfer(this.txn.sender, assetA, aToSend64)
	frame_dig 5 // aToSend64: uint64
	frame_dig -2 // assetA: AssetID
	txn Sender
	callsub doAxfer

*if31_end:
	// contracts\BiatecClammPool.algo.ts:734
	// bToSend = this.calculateAssetAWithdrawOnLpDeposit(
	//       lpDeltaWithFees,
	//       this.assetBBalance.value,
	//       this.Liqudity.value
	//     )
	bytec 8 //  "L"
	app_global_get
	bytec 4 //  "bb"
	app_global_get
	frame_dig 3 // lpDeltaWithFees: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// lpDeltaWithFees overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub calculateAssetAWithdrawOnLpDeposit
	frame_bury 6 // bToSend: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:739
	// bToSend64 = (bToSend / this.assetBDecimals.value) as uint64
	frame_dig 6 // bToSend: unsafe uint256
	bytec 14 //  "bd"
	app_global_get
	b/
	dup
	bitlen
	intc 4 // 64
	<=

	// (bToSend / this.assetBDecimals.value) as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 7 // bToSend64: uint64

	// *if32_condition
	// contracts\BiatecClammPool.algo.ts:740
	// bToSend64 > 0
	frame_dig 7 // bToSend64: uint64
	intc 2 // 0
	>
	bz *if32_end

	// *if32_consequent
	// contracts\BiatecClammPool.algo.ts:741
	// this.doAxfer(this.txn.sender, assetB, bToSend64)
	frame_dig 7 // bToSend64: uint64
	frame_dig -3 // assetB: AssetID
	txn Sender
	callsub doAxfer

*if32_end:
	// contracts\BiatecClammPool.algo.ts:744
	// newAssetA = this.assetABalance.value - aToSend
	bytec 3 //  "ab"
	app_global_get
	frame_dig 4 // aToSend: unsafe uint256
	b-
	frame_bury 8 // newAssetA: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:745
	// newAssetB = this.assetBBalance.value - bToSend
	bytec 4 //  "bb"
	app_global_get
	frame_dig 6 // bToSend: unsafe uint256
	b-
	frame_bury 9 // newAssetB: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:746
	// this.assetABalance.value = newAssetA
	bytec 3 //  "ab"
	frame_dig 8 // newAssetA: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// newAssetA overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:747
	// this.assetBBalance.value = newAssetB
	bytec 4 //  "bb"
	frame_dig 9 // newAssetB: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// newAssetB overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:751
	// lAfter = <uint256>0
	bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 10 // lAfter: unsafe uint256

	// *if33_condition
	// contracts\BiatecClammPool.algo.ts:752
	// this.priceMin.value === this.priceMax.value
	bytec 13 //  "pMin"
	app_global_get
	bytec 16 //  "pMax"
	app_global_get
	==
	bz *if33_else

	// *if33_consequent
	// contracts\BiatecClammPool.algo.ts:753
	// lAfter = this.calculateLiquidityFlatPrice(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMin.value as uint256 // priceMin: uint256,
	//       )
	bytec 13 //  "pMin"
	app_global_get
	itob
	dup
	bitlen
	intc 1 // 256
	<=

	// this.priceMin.value as uint256 overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculateLiquidityFlatPrice
	frame_bury 10 // lAfter: unsafe uint256
	b *if33_end

*if33_else:
	// contracts\BiatecClammPool.algo.ts:759
	// D_SQRT = this.calculateLiquidityD(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMin.value as uint256, // priceMin: uint256,
	//         this.priceMax.value as uint256, // priceMax: uint256,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value // priceMaxSqrt: uint256,
	//       )
	bytec 10 //  "pMaxS"
	app_global_get
	bytec 9 //  "pMinS"
	app_global_get
	bytec 16 //  "pMax"
	app_global_get
	itob
	dup
	bitlen
	intc 1 // 256
	<=

	// this.priceMax.value as uint256 overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 13 //  "pMin"
	app_global_get
	itob
	dup
	bitlen
	intc 1 // 256
	<=

	// this.priceMin.value as uint256 overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculateLiquidityD
	frame_bury 11 // D_SQRT: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:767
	// lAfter = this.calculateLiquidityWithD(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value, // priceMaxSqrt: uint256,
	//         D_SQRT
	//       )
	frame_dig 11 // D_SQRT: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// D_SQRT overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 10 //  "pMaxS"
	app_global_get
	bytec 9 //  "pMinS"
	app_global_get
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculateLiquidityWithD
	frame_bury 10 // lAfter: unsafe uint256

*if33_end:
	// contracts\BiatecClammPool.algo.ts:775
	// this.Liqudity.value = lAfter
	bytec 8 //  "L"
	frame_dig 10 // lAfter: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// lAfter overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:776
	// return lpDeltaWithFees / assetLpDelicmalScale2Scale;
	frame_dig 3 // lpDeltaWithFees: unsafe uint256
	frame_dig 2 // assetLpDelicmalScale2Scale: unsafe uint256
	b/

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 11
	retsub

// verifyIdentity(appBiatecConfigProvider: AppID, appBiatecIdentityProvider: AppID): UserInfoShortV1
//
// Checks if config matches with the app configuration, identity matches with the config, and user is not banned.
//
// Fetches the user info from the identity app and returns the engagement, verification class,...
//
// @param appBiatecConfigProvider Biatec config provider
// @param appBiatecIdentityProvider Biatec identity provider
// @returns User info object
verifyIdentity:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts\BiatecClammPool.algo.ts:789
	// assert(
	//       appBiatecConfigProvider === this.appBiatecConfigProvider.value,
	//       'ERR-INVALID-CONFIG' // 'Configuration app does not match'
	//     )
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 17 //  "bc"
	app_global_get
	==

	// ERR-INVALID-CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:793
	// identityFromConfig = appBiatecConfigProvider.globalState('i') as AppID
	frame_dig -1 // appBiatecConfigProvider: AppID
	pushbytes 0x69 // "i"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('i')
	assert
	frame_bury 0 // identityFromConfig: uint64

	// contracts\BiatecClammPool.algo.ts:794
	// assert(
	//       appBiatecIdentityProvider === identityFromConfig,
	//       'ERR-WRONG-IDENT' // appBiatecIdentityProvider must match to the config in appBiatecConfigProvider'
	//     )
	frame_dig -2 // appBiatecIdentityProvider: AppID
	frame_dig 0 // identityFromConfig: uint64
	==

	// ERR-WRONG-IDENT
	assert

	// contracts\BiatecClammPool.algo.ts:799
	// user = sendMethodCall<[Address, uint8], UserInfoShortV1>({
	//       name: 'getUserShort',
	//       methodArgs: [this.txn.sender, <uint8>1],
	//       fee: 0,
	//       applicationID: appBiatecIdentityProvider,
	//     })
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	pushbytes 0x127ffb7b // method "getUserShort(address,uint8)(uint8,uint64,uint64,uint64,bool)"
	itxn_field ApplicationArgs

	// contracts\BiatecClammPool.algo.ts:801
	// methodArgs: [this.txn.sender, <uint8>1]
	txn Sender
	itxn_field ApplicationArgs
	pushbytes 0x01
	itxn_field ApplicationArgs

	// contracts\BiatecClammPool.algo.ts:802
	// fee: 0
	intc 2 // 0
	itxn_field Fee

	// contracts\BiatecClammPool.algo.ts:803
	// applicationID: appBiatecIdentityProvider
	frame_dig -2 // appBiatecIdentityProvider: AppID
	itxn_field ApplicationID

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 3 // 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 1 // user: (uint8,uint64,uint64,uint64,bool)

	// contracts\BiatecClammPool.algo.ts:805
	// assert(
	//       !user.isLocked,
	//       'ERR-USER-LOCKED' // 'User must not be locked'
	//     )
	frame_dig 1 // user: (uint8,uint64,uint64,uint64,bool)
	store 255 // full array
	load 255 // full array
	pushint 200
	getbit
	!

	// ERR-USER-LOCKED
	assert

	// contracts\BiatecClammPool.algo.ts:809
	// assert(
	//       user.verificationClass >= this.verificationClass.value, // if(user.verificationClass >= this.verificationClass.value) then ok
	//       'ERR-LOW-VER' // 'User cannot interact with this smart contract as his verification class is lower then required here'
	//     )
	frame_dig 1 // user: (uint8,uint64,uint64,uint64,bool)
	store 255 // full array
	load 255 // full array
	extract 1 8
	btoi
	bytec 28 //  "c"
	app_global_get
	>=

	// ERR-LOW-VER
	assert

	// contracts\BiatecClammPool.algo.ts:814
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 21 //  "s"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('s')
	assert
	frame_bury 2 // paused: uint64

	// contracts\BiatecClammPool.algo.ts:815
	// assert(paused === 0, 'E_PAUSED')
	frame_dig 2 // paused: uint64
	intc 2 // 0
	==

	// E_PAUSED
	assert

	// contracts\BiatecClammPool.algo.ts:817
	// return user;
	frame_dig 1 // user: (uint8,uint64,uint64,uint64,bool)

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// swap(uint64,uint64,uint64,txn,uint64,uint64,uint64)uint256
*abi_route_swap:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// minimumToReceive: uint64
	txna ApplicationArgs 6
	btoi

	// assetB: uint64
	txna ApplicationArgs 5
	btoi

	// assetA: uint64
	txna ApplicationArgs 4
	btoi

	// txSwap: txn
	txn GroupIndex
	intc 3 // 1
	-

	// appBiatecPoolProvider: uint64
	txna ApplicationArgs 3
	btoi

	// appBiatecIdentityProvider: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute swap(uint64,uint64,uint64,txn,uint64,uint64,uint64)uint256
	callsub swap
	dup
	bitlen
	intc 1 // 256
	<=

	// swap return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// swap(appBiatecConfigProvider: AppID, appBiatecIdentityProvider: AppID, appBiatecPoolProvider: AppID, txSwap: Txn, assetA: AssetID, assetB: AssetID, minimumToReceive: uint64): uint256
//
// Swap Asset A to Asset B or Asset B to Asst A
// @param txSwap Transfer of the token to be deposited to the pool. To the owner the other asset will be sent.
// @param assetA Asset A
// @param assetB Asset B
// @param minimumToReceive If number greater then zero, the check is performed for the output of the other asset
swap:
	proto 7 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 30

	// contracts\BiatecClammPool.algo.ts:836
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 2 // 0
	itxn_field Fee
	bytec 6 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:837
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 2 // 0
	itxn_field Fee
	bytec 6 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:838
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 2 // 0
	itxn_field Fee
	bytec 6 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// well formed swap
	// contracts\BiatecClammPool.algo.ts:840
	// this.checkAssetsAB(assetA, assetB)
	frame_dig -6 // assetB: AssetID
	frame_dig -5 // assetA: AssetID
	callsub checkAssetsAB

	// *if34_condition
	// contracts\BiatecClammPool.algo.ts:842
	// txSwap.typeEnum === TransactionType.Payment
	frame_dig -4 // txSwap: Txn
	gtxns TypeEnum
	intc 3 //  pay
	==
	bz *if34_else

	// *if34_consequent
	// contracts\BiatecClammPool.algo.ts:843
	// assert(
	//         assetA.id === 0 || assetB.id === 0,
	//         'Payment can be done only when one of the pool assets is native token'
	//       )
	frame_dig -5 // assetA: AssetID
	intc 2 // 0
	==
	dup
	bnz *skip_or1
	frame_dig -6 // assetB: AssetID
	intc 2 // 0
	==
	||

*skip_or1:
	// Payment can be done only when one of the pool assets is native token
	assert

	// contracts\BiatecClammPool.algo.ts:848
	// verifyPayTxn(txSwap, {
	//         amount: { greaterThan: 0 },
	//         receiver: this.app.address,
	//         sender: this.txn.sender,
	//       })
	// verify pay
	frame_dig -4 // txSwap: Txn
	gtxns TypeEnum
	intc 3 //  pay
	==

	// transaction verification failed: {"txn":"txSwap","field":"typeEnum","expected":"pay"}
	assert

	// verify amount
	frame_dig -4 // txSwap: Txn
	gtxns Amount
	intc 2 // 0
	>

	// transaction verification failed: {"txn":"txSwap","field":"amount","condition":"greaterThan","expected":">0"}
	assert

	// verify receiver
	frame_dig -4 // txSwap: Txn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"txSwap","field":"receiver","expected":"this.app.address"}
	assert

	// verify sender
	frame_dig -4 // txSwap: Txn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"txSwap","field":"sender","expected":"this.txn.sender"}
	assert
	b *if34_end

*if34_else:
	// contracts\BiatecClammPool.algo.ts:854
	// assert(txSwap.typeEnum === TransactionType.AssetTransfer)
	frame_dig -4 // txSwap: Txn
	gtxns TypeEnum
	intc 7 //  axfer
	==
	assert

	// contracts\BiatecClammPool.algo.ts:856
	// verifyAssetTransferTxn(txSwap, {
	//         assetAmount: { greaterThan: 0 },
	//         assetReceiver: this.app.address,
	//         sender: this.txn.sender,
	//         xferAsset: { includedIn: [assetA, assetB] },
	//       })
	// verify axfer
	frame_dig -4 // txSwap: Txn
	gtxns TypeEnum
	intc 7 //  axfer
	==

	// transaction verification failed: {"txn":"txSwap","field":"typeEnum","expected":"axfer"}
	assert

	// verify assetAmount
	frame_dig -4 // txSwap: Txn
	gtxns AssetAmount
	intc 2 // 0
	>

	// transaction verification failed: {"txn":"txSwap","field":"assetAmount","condition":"greaterThan","expected":">0"}
	assert

	// verify assetReceiver
	frame_dig -4 // txSwap: Txn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"txSwap","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify sender
	frame_dig -4 // txSwap: Txn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"txSwap","field":"sender","expected":"this.txn.sender"}
	assert

	// verify xferAsset
	frame_dig -4 // txSwap: Txn
	gtxns XferAsset
	frame_dig -5 // assetA: AssetID
	==
	frame_dig -4 // txSwap: Txn
	gtxns XferAsset
	frame_dig -6 // assetB: AssetID
	==
	||

	// transaction verification failed: {"txn":{"txnText":"txSwap"},"field":"xferAsset","condition":"includedIn","expected":"[assetA, assetB]"}
	assert

*if34_end:
	// contracts\BiatecClammPool.algo.ts:864
	// poolProviderFromConfig = appBiatecConfigProvider.globalState('p') as AppID
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 27 //  "p"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('p')
	assert
	frame_bury 0 // poolProviderFromConfig: uint64

	// contracts\BiatecClammPool.algo.ts:865
	// assert(
	//       appBiatecPoolProvider === poolProviderFromConfig,
	//       'ERR-INVALID-PP' // appBiatecPoolProvider must match to the config in appBiatecConfigProvider'
	//     )
	frame_dig -3 // appBiatecPoolProvider: AppID
	frame_dig 0 // poolProviderFromConfig: uint64
	==

	// ERR-INVALID-PP
	assert

	// contracts\BiatecClammPool.algo.ts:869
	// user = this.verifyIdentity(appBiatecConfigProvider, appBiatecIdentityProvider)
	frame_dig -2 // appBiatecIdentityProvider: AppID
	frame_dig -1 // appBiatecConfigProvider: AppID
	callsub verifyIdentity
	frame_bury 1 // user: (uint8,uint64,uint64,uint64,bool)

	// contracts\BiatecClammPool.algo.ts:871
	// feesMultiplier = (s -
	//       ((this.fee.value as uint256) * (user.feeMultiplier as uint256)) / (user.base as uint256)) as uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	bytec 20 //  "f"
	app_global_get
	itob
	frame_dig 1 // user: (uint8,uint64,uint64,uint64,bool)
	store 255 // full array
	load 255 // full array
	extract 9 8
	btoi
	itob
	b*
	frame_dig 1 // user: (uint8,uint64,uint64,uint64,bool)
	store 255 // full array
	load 255 // full array
	extract 17 8
	btoi
	itob
	b/
	b-
	frame_bury 2 // feesMultiplier: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:873
	// ret: uint64 = 0
	intc 2 // 0
	frame_bury 3 // ret: uint64

	// contracts\BiatecClammPool.algo.ts:874
	// amountAForStats = 0
	intc 2 // 0
	frame_bury 4 // amountAForStats: uint64

	// contracts\BiatecClammPool.algo.ts:875
	// amountBForStats = 0
	intc 2 // 0
	frame_bury 5 // amountBForStats: uint64

	// contracts\BiatecClammPool.algo.ts:876
	// feeAmountAForStats = 0
	intc 2 // 0
	frame_bury 6 // feeAmountAForStats: uint64

	// contracts\BiatecClammPool.algo.ts:877
	// feeAmountBForStats = 0
	intc 2 // 0
	frame_bury 7 // feeAmountBForStats: uint64

	// contracts\BiatecClammPool.algo.ts:879
	// isAssetA = false
	intc 2 // 0
	frame_bury 8 // isAssetA: bool

	// *if35_condition
	// contracts\BiatecClammPool.algo.ts:880
	// txSwap.typeEnum === TransactionType.Payment
	frame_dig -4 // txSwap: Txn
	gtxns TypeEnum
	intc 3 //  pay
	==
	bz *if35_else

	// *if35_consequent
	// contracts\BiatecClammPool.algo.ts:881
	// isAssetA = assetA.id === 0
	frame_dig -5 // assetA: AssetID
	intc 2 // 0
	==
	frame_bury 8 // isAssetA: bool
	b *if35_end

*if35_else:
	// contracts\BiatecClammPool.algo.ts:883
	// isAssetA = txSwap.xferAsset === assetA
	frame_dig -4 // txSwap: Txn
	gtxns XferAsset
	frame_dig -5 // assetA: AssetID
	==
	frame_bury 8 // isAssetA: bool

*if35_end:
	// contracts\BiatecClammPool.algo.ts:885
	// realSwapBaseDecimals = <uint256>0
	bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 9 // realSwapBaseDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:886
	// inAsset = <uint256>0
	bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 10 // inAsset: unsafe uint256

	// *if36_condition
	// contracts\BiatecClammPool.algo.ts:887
	// isAssetA
	frame_dig 8 // isAssetA: bool
	bz *if36_end

	// *if36_consequent
	// contracts\BiatecClammPool.algo.ts:888
	// assetInAssetDecimals = <uint256>0
	bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 11 // assetInAssetDecimals: unsafe uint256

	// *if37_condition
	// contracts\BiatecClammPool.algo.ts:889
	// txSwap.typeEnum === TransactionType.Payment
	frame_dig -4 // txSwap: Txn
	gtxns TypeEnum
	intc 3 //  pay
	==
	bz *if37_else

	// *if37_consequent
	// contracts\BiatecClammPool.algo.ts:890
	// assetInAssetDecimals = txSwap.amount as uint256
	frame_dig -4 // txSwap: Txn
	gtxns Amount
	itob
	frame_bury 11 // assetInAssetDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:891
	// amountAForStats = txSwap.amount
	frame_dig -4 // txSwap: Txn
	gtxns Amount
	frame_bury 4 // amountAForStats: uint64
	b *if37_end

*if37_else:
	// contracts\BiatecClammPool.algo.ts:893
	// assetInAssetDecimals = txSwap.assetAmount as uint256
	frame_dig -4 // txSwap: Txn
	gtxns AssetAmount
	itob
	frame_bury 11 // assetInAssetDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:894
	// amountAForStats = txSwap.assetAmount
	frame_dig -4 // txSwap: Txn
	gtxns AssetAmount
	frame_bury 4 // amountAForStats: uint64

*if37_end:
	// contracts\BiatecClammPool.algo.ts:896
	// inAsset = (assetInAssetDecimals * this.assetADecimals.value) as uint256
	frame_dig 11 // assetInAssetDecimals: unsafe uint256
	bytec 12 //  "ad"
	app_global_get
	b*
	frame_bury 10 // inAsset: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:897
	// inAssetAfterFee = (inAsset * feesMultiplier) / s
	frame_dig 10 // inAsset: unsafe uint256
	frame_dig 2 // feesMultiplier: unsafe uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 12 // inAssetAfterFee: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:899
	// toSwap = this.calculateAssetBWithdrawOnAssetADeposit(
	//         inAssetAfterFee,
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMinSqrt.value,
	//         this.priceMaxSqrt.value,
	//         this.Liqudity.value
	//       )
	bytec 8 //  "L"
	app_global_get
	bytec 10 //  "pMaxS"
	app_global_get
	bytec 9 //  "pMinS"
	app_global_get
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	frame_dig 12 // inAssetAfterFee: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// inAssetAfterFee overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub calculateAssetBWithdrawOnAssetADeposit
	frame_bury 13 // toSwap: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:907
	// realSwapBaseDecimals = toSwap
	frame_dig 13 // toSwap: unsafe uint256
	frame_bury 9 // realSwapBaseDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:908
	// realSwapBDecimals = (toSwap / this.assetBDecimals.value) as uint256
	frame_dig 13 // toSwap: unsafe uint256
	bytec 14 //  "bd"
	app_global_get
	b/
	frame_bury 14 // realSwapBDecimals: unsafe uint256

	// *if38_condition
	// contracts\BiatecClammPool.algo.ts:910
	// realSwapBDecimals * this.assetBDecimals.value !== toSwap
	frame_dig 14 // realSwapBDecimals: unsafe uint256
	bytec 14 //  "bd"
	app_global_get
	b*
	frame_dig 13 // toSwap: unsafe uint256
	b!=
	bz *if38_end

	// *if38_consequent
	// contracts\BiatecClammPool.algo.ts:911
	// realSwapBDecimals = realSwapBDecimals - <uint256>1
	frame_dig 14 // realSwapBDecimals: unsafe uint256
	bytec 29 // 0x0000000000000000000000000000000000000000000000000000000000000001
	b-
	frame_bury 14 // realSwapBDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:912
	// realSwapBaseDecimals = realSwapBDecimals * this.assetBDecimals.value
	frame_dig 14 // realSwapBDecimals: unsafe uint256
	bytec 14 //  "bd"
	app_global_get
	b*
	frame_bury 9 // realSwapBaseDecimals: unsafe uint256

*if38_end:
	// contracts\BiatecClammPool.algo.ts:914
	// toSwapBDecimals = realSwapBDecimals as uint64
	frame_dig 14 // realSwapBDecimals: unsafe uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// realSwapBDecimals as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 15 // toSwapBDecimals: uint64

	// contracts\BiatecClammPool.algo.ts:915
	// ret = toSwapBDecimals
	frame_dig 15 // toSwapBDecimals: uint64
	frame_bury 3 // ret: uint64

	// *if39_condition
	// contracts\BiatecClammPool.algo.ts:916
	// minimumToReceive > 0
	frame_dig -7 // minimumToReceive: uint64
	intc 2 // 0
	>
	bz *if39_end

	// *if39_consequent
	// contracts\BiatecClammPool.algo.ts:918
	// assert(toSwapBDecimals >= minimumToReceive, 'Minimum to receive is not met')
	frame_dig 15 // toSwapBDecimals: uint64
	frame_dig -7 // minimumToReceive: uint64
	>=

	// Minimum to receive is not met
	assert

*if39_end:
	// contracts\BiatecClammPool.algo.ts:920
	// amountBForStats = toSwapBDecimals
	frame_dig 15 // toSwapBDecimals: uint64
	frame_bury 5 // amountBForStats: uint64

	// contracts\BiatecClammPool.algo.ts:921
	// this.doAxfer(this.txn.sender, assetB, toSwapBDecimals)
	frame_dig 15 // toSwapBDecimals: uint64
	frame_dig -6 // assetB: AssetID
	txn Sender
	callsub doAxfer

	// contracts\BiatecClammPool.algo.ts:923
	// this.assetABalance.value = this.assetABalance.value + inAsset
	bytec 3 //  "ab"
	dup
	app_global_get
	frame_dig 10 // inAsset: unsafe uint256
	b+
	dup
	bitlen
	intc 1 // 256
	<=

	// this.assetABalance.value + inAsset overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:924
	// this.assetBBalance.value = this.assetBBalance.value - realSwapBaseDecimals
	bytec 4 //  "bb"
	dup
	app_global_get
	frame_dig 9 // realSwapBaseDecimals: unsafe uint256
	b-
	dup
	bitlen
	intc 1 // 256
	<=

	// this.assetBBalance.value - realSwapBaseDecimals overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

*if36_end:
	// *if40_condition
	// contracts\BiatecClammPool.algo.ts:927
	// !isAssetA
	frame_dig 8 // isAssetA: bool
	!
	bz *if40_end

	// *if40_consequent
	// contracts\BiatecClammPool.algo.ts:928
	// assetInAssetDecimals = <uint256>0
	bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 16 // assetInAssetDecimals: unsafe uint256

	// *if41_condition
	// contracts\BiatecClammPool.algo.ts:929
	// txSwap.typeEnum === TransactionType.Payment
	frame_dig -4 // txSwap: Txn
	gtxns TypeEnum
	intc 3 //  pay
	==
	bz *if41_else

	// *if41_consequent
	// contracts\BiatecClammPool.algo.ts:930
	// assetInAssetDecimals = txSwap.amount as uint256
	frame_dig -4 // txSwap: Txn
	gtxns Amount
	itob
	frame_bury 16 // assetInAssetDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:931
	// amountBForStats = txSwap.amount
	frame_dig -4 // txSwap: Txn
	gtxns Amount
	frame_bury 5 // amountBForStats: uint64
	b *if41_end

*if41_else:
	// contracts\BiatecClammPool.algo.ts:933
	// assetInAssetDecimals = txSwap.assetAmount as uint256
	frame_dig -4 // txSwap: Txn
	gtxns AssetAmount
	itob
	frame_bury 16 // assetInAssetDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:934
	// amountBForStats = txSwap.assetAmount
	frame_dig -4 // txSwap: Txn
	gtxns AssetAmount
	frame_bury 5 // amountBForStats: uint64

*if41_end:
	// contracts\BiatecClammPool.algo.ts:936
	// inAsset = (assetInAssetDecimals * this.assetBDecimals.value) as uint256
	frame_dig 16 // assetInAssetDecimals: unsafe uint256
	bytec 14 //  "bd"
	app_global_get
	b*
	frame_bury 10 // inAsset: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:937
	// inAssetAfterFee = (inAsset * feesMultiplier) / s
	frame_dig 10 // inAsset: unsafe uint256
	frame_dig 2 // feesMultiplier: unsafe uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 17 // inAssetAfterFee: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:938
	// toSwap = this.calculateAssetAWithdrawOnAssetBDeposit(
	//         inAssetAfterFee,
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMinSqrt.value,
	//         this.priceMaxSqrt.value,
	//         this.Liqudity.value
	//       )
	bytec 8 //  "L"
	app_global_get
	bytec 10 //  "pMaxS"
	app_global_get
	bytec 9 //  "pMinS"
	app_global_get
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	frame_dig 17 // inAssetAfterFee: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// inAssetAfterFee overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	callsub calculateAssetAWithdrawOnAssetBDeposit
	frame_bury 18 // toSwap: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:946
	// realSwapBaseDecimals = toSwap
	frame_dig 18 // toSwap: unsafe uint256
	frame_bury 9 // realSwapBaseDecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:947
	// realSwapADecimals = toSwap / this.assetADecimals.value
	frame_dig 18 // toSwap: unsafe uint256
	bytec 12 //  "ad"
	app_global_get
	b/
	frame_bury 19 // realSwapADecimals: unsafe uint256

	// *if42_condition
	// contracts\BiatecClammPool.algo.ts:949
	// realSwapADecimals * this.assetADecimals.value !== toSwap
	frame_dig 19 // realSwapADecimals: unsafe uint256
	bytec 12 //  "ad"
	app_global_get
	b*
	frame_dig 18 // toSwap: unsafe uint256
	b!=
	bz *if42_end

	// *if42_consequent
	// contracts\BiatecClammPool.algo.ts:950
	// realSwapADecimals = realSwapADecimals - <uint256>1
	frame_dig 19 // realSwapADecimals: unsafe uint256
	bytec 29 // 0x0000000000000000000000000000000000000000000000000000000000000001
	b-
	frame_bury 19 // realSwapADecimals: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:951
	// realSwapBaseDecimals = realSwapADecimals * this.assetADecimals.value
	frame_dig 19 // realSwapADecimals: unsafe uint256
	bytec 12 //  "ad"
	app_global_get
	b*
	frame_bury 9 // realSwapBaseDecimals: unsafe uint256

*if42_end:
	// contracts\BiatecClammPool.algo.ts:953
	// toSwapADecimals = realSwapADecimals as uint64
	frame_dig 19 // realSwapADecimals: unsafe uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// realSwapADecimals as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 20 // toSwapADecimals: uint64

	// contracts\BiatecClammPool.algo.ts:954
	// ret = toSwapADecimals
	frame_dig 20 // toSwapADecimals: uint64
	frame_bury 3 // ret: uint64

	// *if43_condition
	// contracts\BiatecClammPool.algo.ts:955
	// minimumToReceive > 0
	frame_dig -7 // minimumToReceive: uint64
	intc 2 // 0
	>
	bz *if43_end

	// *if43_consequent
	// contracts\BiatecClammPool.algo.ts:957
	// assert(toSwapADecimals >= minimumToReceive, 'Minimum to receive is not met')
	frame_dig 20 // toSwapADecimals: uint64
	frame_dig -7 // minimumToReceive: uint64
	>=

	// Minimum to receive is not met
	assert

*if43_end:
	// contracts\BiatecClammPool.algo.ts:959
	// amountAForStats = toSwapADecimals
	frame_dig 20 // toSwapADecimals: uint64
	frame_bury 4 // amountAForStats: uint64

	// contracts\BiatecClammPool.algo.ts:960
	// this.doAxfer(this.txn.sender, assetA, toSwapADecimals)
	frame_dig 20 // toSwapADecimals: uint64
	frame_dig -5 // assetA: AssetID
	txn Sender
	callsub doAxfer

	// contracts\BiatecClammPool.algo.ts:962
	// this.assetBBalance.value = this.assetBBalance.value + inAsset
	bytec 4 //  "bb"
	dup
	app_global_get
	frame_dig 10 // inAsset: unsafe uint256
	b+
	dup
	bitlen
	intc 1 // 256
	<=

	// this.assetBBalance.value + inAsset overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:963
	// this.assetABalance.value = this.assetABalance.value - realSwapBaseDecimals
	bytec 3 //  "ab"
	dup
	app_global_get
	frame_dig 9 // realSwapBaseDecimals: unsafe uint256
	b-
	dup
	bitlen
	intc 1 // 256
	<=

	// this.assetABalance.value - realSwapBaseDecimals overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

*if40_end:
	// contracts\BiatecClammPool.algo.ts:965
	// newL = <uint256>0
	bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 21 // newL: unsafe uint256

	// *if44_condition
	// contracts\BiatecClammPool.algo.ts:966
	// this.priceMin.value === this.priceMax.value
	bytec 13 //  "pMin"
	app_global_get
	bytec 16 //  "pMax"
	app_global_get
	==
	bz *if44_else

	// *if44_consequent
	// contracts\BiatecClammPool.algo.ts:967
	// newL = this.calculateLiquidityFlatPrice(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMin.value as uint256 // priceMin: uint256,
	//       )
	bytec 13 //  "pMin"
	app_global_get
	itob
	dup
	bitlen
	intc 1 // 256
	<=

	// this.priceMin.value as uint256 overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculateLiquidityFlatPrice
	frame_bury 21 // newL: unsafe uint256
	b *if44_end

*if44_else:
	// contracts\BiatecClammPool.algo.ts:973
	// D_SQRT = this.calculateLiquidityD(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMin.value as uint256, // priceMin: uint256,
	//         this.priceMax.value as uint256, // priceMax: uint256,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value // priceMaxSqrt: uint256,
	//       )
	bytec 10 //  "pMaxS"
	app_global_get
	bytec 9 //  "pMinS"
	app_global_get
	bytec 16 //  "pMax"
	app_global_get
	itob
	dup
	bitlen
	intc 1 // 256
	<=

	// this.priceMax.value as uint256 overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 13 //  "pMin"
	app_global_get
	itob
	dup
	bitlen
	intc 1 // 256
	<=

	// this.priceMin.value as uint256 overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculateLiquidityD
	frame_bury 22 // D_SQRT: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:981
	// newL = this.calculateLiquidityWithD(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value, // priceMaxSqrt: uint256,
	//         D_SQRT
	//       )
	frame_dig 22 // D_SQRT: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// D_SQRT overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 10 //  "pMaxS"
	app_global_get
	bytec 9 //  "pMinS"
	app_global_get
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculateLiquidityWithD
	frame_bury 21 // newL: unsafe uint256

*if44_end:
	// *if45_condition
	// contracts\BiatecClammPool.algo.ts:990
	// newL > this.Liqudity.value
	frame_dig 21 // newL: unsafe uint256
	bytec 8 //  "L"
	app_global_get
	b>
	bz *if45_end

	// *if45_consequent
	// contracts\BiatecClammPool.algo.ts:993
	// diff = (newL - this.Liqudity.value) as uint256
	frame_dig 21 // newL: unsafe uint256
	bytec 8 //  "L"
	app_global_get
	b-
	frame_bury 23 // diff: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:994
	// this.Liqudity.value = newL
	bytec 8 //  "L"
	frame_dig 21 // newL: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// newL overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// *if46_condition
	// contracts\BiatecClammPool.algo.ts:996
	// isAssetA
	frame_dig 8 // isAssetA: bool
	bz *if46_else

	// *if46_consequent
	// contracts\BiatecClammPool.algo.ts:998
	// feeB256 = (this.assetABalance.value * diff) / newL
	bytec 3 //  "ab"
	app_global_get
	frame_dig 23 // diff: unsafe uint256
	b*
	frame_dig 21 // newL: unsafe uint256
	b/
	frame_bury 24 // feeB256: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:999
	// feeAmountAForStats = feeB256 as uint64
	frame_dig 24 // feeB256: unsafe uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// feeB256 as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 6 // feeAmountAForStats: uint64

	// contracts\BiatecClammPool.algo.ts:1000
	// feeAmountBForStats = 0
	intc 2 // 0
	frame_bury 7 // feeAmountBForStats: uint64
	b *if46_end

*if46_else:
	// contracts\BiatecClammPool.algo.ts:1003
	// feeB256 = (this.assetBBalance.value * diff) / newL
	bytec 4 //  "bb"
	app_global_get
	frame_dig 23 // diff: unsafe uint256
	b*
	frame_dig 21 // newL: unsafe uint256
	b/
	frame_bury 25 // feeB256: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1004
	// feeAmountAForStats = 0
	intc 2 // 0
	frame_bury 6 // feeAmountAForStats: uint64

	// contracts\BiatecClammPool.algo.ts:1005
	// feeAmountBForStats = feeB256 as uint64
	frame_dig 25 // feeB256: unsafe uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// feeB256 as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	frame_bury 7 // feeAmountBForStats: uint64

*if46_end:
	// contracts\BiatecClammPool.algo.ts:1008
	// biatecFee = this.appBiatecConfigProvider.value.globalState('f') as uint256
	bytec 17 //  "bc"
	app_global_get
	bytec 20 //  "f"
	app_global_get_ex

	// global state value does not exist: this.appBiatecConfigProvider.value.globalState('f')
	assert
	frame_bury 26 // biatecFee: uint256

	// *if47_condition
	// contracts\BiatecClammPool.algo.ts:1009
	// biatecFee === <uint256>0
	frame_dig 26 // biatecFee: uint256
	bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b==
	bz *if47_else

	// *if47_consequent
	// contracts\BiatecClammPool.algo.ts:1010
	// usersLiquidityFromFeeIncrement = diff
	frame_dig 23 // diff: unsafe uint256
	frame_bury 27 // usersLiquidityFromFeeIncrement: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1011
	// this.LiqudityUsersFromFees.value = this.LiqudityUsersFromFees.value + usersLiquidityFromFeeIncrement
	bytec 15 //  "Lu"
	dup
	app_global_get
	frame_dig 27 // usersLiquidityFromFeeIncrement: unsafe uint256
	b+
	dup
	bitlen
	intc 1 // 256
	<=

	// this.LiqudityUsersFromFees.value + usersLiquidityFromFeeIncrement overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put
	b *if47_end

*if47_else:
	// contracts\BiatecClammPool.algo.ts:1013
	// usersLiquidityFromFeeIncrement = (diff * (s - biatecFee)) / s
	frame_dig 23 // diff: unsafe uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	frame_dig 26 // biatecFee: uint256
	b-
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 28 // usersLiquidityFromFeeIncrement: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1014
	// biatecLiquidityFromFeeIncrement = diff - usersLiquidityFromFeeIncrement
	frame_dig 23 // diff: unsafe uint256
	frame_dig 28 // usersLiquidityFromFeeIncrement: unsafe uint256
	b-
	frame_bury 29 // biatecLiquidityFromFeeIncrement: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1015
	// this.LiqudityUsersFromFees.value = this.LiqudityUsersFromFees.value + usersLiquidityFromFeeIncrement
	bytec 15 //  "Lu"
	dup
	app_global_get
	frame_dig 28 // usersLiquidityFromFeeIncrement: unsafe uint256
	b+
	dup
	bitlen
	intc 1 // 256
	<=

	// this.LiqudityUsersFromFees.value + usersLiquidityFromFeeIncrement overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:1016
	// this.LiqudityBiatecFromFees.value = this.LiqudityBiatecFromFees.value + biatecLiquidityFromFeeIncrement
	bytec 18 //  "Lb"
	dup
	app_global_get
	frame_dig 29 // biatecLiquidityFromFeeIncrement: unsafe uint256
	b+
	dup
	bitlen
	intc 1 // 256
	<=

	// this.LiqudityBiatecFromFees.value + biatecLiquidityFromFeeIncrement overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

*if47_end:

*if45_end:
	// contracts\BiatecClammPool.algo.ts:1019
	// newPrice = this.calculatePrice(
	//       this.assetABalance.value, // assetAQuantity: uint256,
	//       this.assetBBalance.value, // assetBQuantity: uint256,
	//       this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//       this.priceMaxSqrt.value, // priceMaxSqrt: uint256,
	//       this.Liqudity.value // liquidity: uint256
	//     )
	bytec 8 //  "L"
	app_global_get
	bytec 10 //  "pMaxS"
	app_global_get
	bytec 9 //  "pMinS"
	app_global_get
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculatePrice
	frame_bury 30 // newPrice: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1026
	// assert(amountAForStats > 0 && amountBForStats > 0, 'Stats to register must not be empty')
	frame_dig 4 // amountAForStats: uint64
	intc 2 // 0
	>
	dup
	bz *skip_and4
	frame_dig 5 // amountBForStats: uint64
	intc 2 // 0
	>
	&&

*skip_and4:
	// Stats to register must not be empty
	assert

	// contracts\BiatecClammPool.algo.ts:1027
	// sendMethodCall<[AppID, AssetID, AssetID, uint64, uint64, uint64, uint64, uint64, uint64, uint64], void>({
	//       name: 'registerTrade',
	//       methodArgs: [
	//         globals.currentApplicationID,
	//         assetA,
	//         assetB,
	//         this.currentPrice.value as uint64,
	//         newPrice as uint64,
	//         amountAForStats * (this.assetADecimals.value as uint64),
	//         amountBForStats * (this.assetBDecimals.value as uint64),
	//         feeAmountAForStats,
	//         feeAmountBForStats,
	//         SCALE,
	//       ],
	//       fee: 0,
	//       applicationID: appBiatecPoolProvider,
	//     })
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	pushbytes 0xe13e4f5a // method "registerTrade(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)void"
	itxn_field ApplicationArgs

	// contracts\BiatecClammPool.algo.ts:1029
	// methodArgs: [
	//         globals.currentApplicationID,
	//         assetA,
	//         assetB,
	//         this.currentPrice.value as uint64,
	//         newPrice as uint64,
	//         amountAForStats * (this.assetADecimals.value as uint64),
	//         amountBForStats * (this.assetBDecimals.value as uint64),
	//         feeAmountAForStats,
	//         feeAmountBForStats,
	//         SCALE,
	//       ]
	global CurrentApplicationID
	itob
	itxn_field ApplicationArgs
	frame_dig -5 // assetA: AssetID
	itob
	itxn_field ApplicationArgs
	frame_dig -6 // assetB: AssetID
	itob
	itxn_field ApplicationArgs
	bytec 19 //  "price"
	app_global_get
	itob
	itxn_field ApplicationArgs
	frame_dig 30 // newPrice: unsafe uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// newPrice as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	itob
	itxn_field ApplicationArgs
	frame_dig 4 // amountAForStats: uint64
	bytec 12 //  "ad"
	app_global_get
	dup
	bitlen
	intc 4 // 64
	<=

	// this.assetADecimals.value as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	*
	itob
	itxn_field ApplicationArgs
	frame_dig 5 // amountBForStats: uint64
	bytec 14 //  "bd"
	app_global_get
	dup
	bitlen
	intc 4 // 64
	<=

	// this.assetBDecimals.value as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	*
	itob
	itxn_field ApplicationArgs
	frame_dig 6 // feeAmountAForStats: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig 7 // feeAmountBForStats: uint64
	itob
	itxn_field ApplicationArgs
	bytec 33 // 0x000000003b9aca00
	itxn_field ApplicationArgs

	// contracts\BiatecClammPool.algo.ts:1041
	// fee: 0
	intc 2 // 0
	itxn_field Fee

	// contracts\BiatecClammPool.algo.ts:1042
	// applicationID: appBiatecPoolProvider
	frame_dig -3 // appBiatecPoolProvider: AppID
	itxn_field ApplicationID

	// Submit inner transaction
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:1045
	// this.currentPrice.value = newPrice as uint64
	bytec 19 //  "price"
	frame_dig 30 // newPrice: unsafe uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// newPrice as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	app_global_put

	// contracts\BiatecClammPool.algo.ts:1067
	// return ret as uint256;
	frame_dig 3 // ret: uint64
	itob

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 30
	retsub

// distributeExcessAssets(uint64,uint64,uint64,uint256,uint256)uint256
*abi_route_distributeExcessAssets:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// amountB: uint256
	txna ApplicationArgs 5
	dup
	len
	intc 0 // 32
	==

	// argument 0 (amountB) for distributeExcessAssets must be a uint256
	assert

	// amountA: uint256
	txna ApplicationArgs 4
	dup
	len
	intc 0 // 32
	==

	// argument 1 (amountA) for distributeExcessAssets must be a uint256
	assert

	// assetB: uint64
	txna ApplicationArgs 3
	btoi

	// assetA: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute distributeExcessAssets(uint64,uint64,uint64,uint256,uint256)uint256
	callsub distributeExcessAssets
	dup
	bitlen
	intc 1 // 256
	<=

	// distributeExcessAssets return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// distributeExcessAssets(appBiatecConfigProvider: AppID, assetA: AssetID, assetB: AssetID, amountA: uint256, amountB: uint256): uint256
//
// If someone deposits excess assets to the LP pool, addressExecutiveFee can either distribute them to the lp tokens or withdraw it, depending on the use case.
// If someone sent there assets in fault, the withrawing can be use to return them back. If the pool received assets for example for having its algo stake online and recieved rewards it is prefered to distribute them to the current LP holders.
//
// This method is used to distribute amount a and amount b of asset a and asset b to holders as the fee income.
//
// Only addressExecutiveFee is allowed to execute this method.
//
// @param appBiatecConfigProvider Biatec config app. Only addressExecutiveFee is allowed to execute this method.
// @param assetA Asset A
// @param assetB Asset B
// @param amountA Amount of asset A to be deposited to the liquidity. In base decimals (9)
// @param amountB Amount of asset B to be deposited to the liquidity. In base decimals (9)
distributeExcessAssets:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 9

	// contracts\BiatecClammPool.algo.ts:1091
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 2 // 0
	itxn_field Fee
	bytec 6 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:1092
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 2 // 0
	itxn_field Fee
	bytec 6 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecClammPool.algo.ts:1093
	// this.checkAssetsAB(assetA, assetB)
	frame_dig -3 // assetB: AssetID
	frame_dig -2 // assetA: AssetID
	callsub checkAssetsAB

	// contracts\BiatecClammPool.algo.ts:1095
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value, 'E_CONFIG')
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 17 //  "bc"
	app_global_get
	==

	// E_CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:1096
	// addressExecutiveFee = appBiatecConfigProvider.globalState('ef') as Address
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 24 //  "ef"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('ef')
	assert
	frame_bury 0 // addressExecutiveFee: address

	// contracts\BiatecClammPool.algo.ts:1098
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 21 //  "s"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('s')
	assert
	frame_bury 1 // paused: uint64

	// contracts\BiatecClammPool.algo.ts:1099
	// assert(paused === 0, 'E_PAUSED')
	frame_dig 1 // paused: uint64
	intc 2 // 0
	==

	// E_PAUSED
	assert

	// contracts\BiatecClammPool.algo.ts:1101
	// assert(
	//       this.txn.sender === addressExecutiveFee,
	//       'E_SENDER' // 'Only fee executor setup in the config can take the collected fees'
	//     )
	txn Sender
	frame_dig 0 // addressExecutiveFee: address
	==

	// E_SENDER
	assert

	// contracts\BiatecClammPool.algo.ts:1106
	// this.assetABalance.value = this.assetABalance.value + amountA
	bytec 3 //  "ab"
	dup
	app_global_get
	frame_dig -4 // amountA: uint256
	b+
	dup
	bitlen
	intc 1 // 256
	<=

	// this.assetABalance.value + amountA overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:1107
	// this.assetBBalance.value = this.assetBBalance.value + amountB
	bytec 4 //  "bb"
	dup
	app_global_get
	frame_dig -5 // amountB: uint256
	b+
	dup
	bitlen
	intc 1 // 256
	<=

	// this.assetBBalance.value + amountB overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// *if48_condition
	// contracts\BiatecClammPool.algo.ts:1108
	// assetA.id === 0
	frame_dig -2 // assetA: AssetID
	intc 2 // 0
	==
	bz *if48_else

	// *if48_consequent
	// contracts\BiatecClammPool.algo.ts:1109
	// assert(
	//         ((this.app.address.balance - 1_000_000) as uint256) * this.assetADecimals.value >= this.assetABalance.value,
	//         'E_A0_B' // 'It is not possible to set higher assetABalance in algos then is in the app balance'
	//       )
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	intc 12 // 1_000_000
	-
	itob
	bytec 12 //  "ad"
	app_global_get
	b*
	bytec 3 //  "ab"
	app_global_get
	b>=

	// E_A0_B
	assert
	b *if48_end

*if48_else:
	// contracts\BiatecClammPool.algo.ts:1114
	// assert(
	//         (this.app.address.assetBalance(assetA) as uint256) * this.assetADecimals.value >= this.assetABalance.value,
	//         'E_A_B' // 'It is not possible to set higher assetABalance then is in the app balance'
	//       )
	global CurrentApplicationAddress
	frame_dig -2 // assetA: AssetID
	asset_holding_get AssetBalance
	pop
	itob
	bytec 12 //  "ad"
	app_global_get
	b*
	bytec 3 //  "ab"
	app_global_get
	b>=

	// E_A_B
	assert

*if48_end:
	// contracts\BiatecClammPool.algo.ts:1119
	// assert(
	//       (this.app.address.assetBalance(assetB) as uint256) * this.assetBDecimals.value >= this.assetBBalance.value,
	//       'E_B_B' // 'It is not possible to set higher assetBBalance then is in the app balance'
	//     )
	global CurrentApplicationAddress
	frame_dig -3 // assetB: AssetID
	asset_holding_get AssetBalance
	pop
	itob
	bytec 14 //  "bd"
	app_global_get
	b*
	bytec 4 //  "bb"
	app_global_get
	b>=

	// E_B_B
	assert

	// contracts\BiatecClammPool.algo.ts:1123
	// newL = <uint256>0
	bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 2 // newL: unsafe uint256

	// *if49_condition
	// contracts\BiatecClammPool.algo.ts:1124
	// this.priceMin.value === this.priceMax.value
	bytec 13 //  "pMin"
	app_global_get
	bytec 16 //  "pMax"
	app_global_get
	==
	bz *if49_else

	// *if49_consequent
	// contracts\BiatecClammPool.algo.ts:1125
	// newL = this.calculateLiquidityFlatPrice(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMin.value as uint256 // priceMin: uint256,
	//       )
	bytec 13 //  "pMin"
	app_global_get
	itob
	dup
	bitlen
	intc 1 // 256
	<=

	// this.priceMin.value as uint256 overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculateLiquidityFlatPrice
	frame_bury 2 // newL: unsafe uint256
	b *if49_end

*if49_else:
	// contracts\BiatecClammPool.algo.ts:1131
	// D_SQRT = this.calculateLiquidityD(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMin.value as uint256, // priceMin: uint256,
	//         this.priceMax.value as uint256, // priceMax: uint256,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value // priceMaxSqrt: uint256,
	//       )
	bytec 10 //  "pMaxS"
	app_global_get
	bytec 9 //  "pMinS"
	app_global_get
	bytec 16 //  "pMax"
	app_global_get
	itob
	dup
	bitlen
	intc 1 // 256
	<=

	// this.priceMax.value as uint256 overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 13 //  "pMin"
	app_global_get
	itob
	dup
	bitlen
	intc 1 // 256
	<=

	// this.priceMin.value as uint256 overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculateLiquidityD
	frame_bury 3 // D_SQRT: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1139
	// newL = this.calculateLiquidityWithD(
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//         this.priceMaxSqrt.value, // priceMaxSqrt: uint256,
	//         D_SQRT
	//       )
	frame_dig 3 // D_SQRT: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// D_SQRT overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	bytec 10 //  "pMaxS"
	app_global_get
	bytec 9 //  "pMinS"
	app_global_get
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculateLiquidityWithD
	frame_bury 2 // newL: unsafe uint256

*if49_end:
	// contracts\BiatecClammPool.algo.ts:1148
	// diff = (newL - this.Liqudity.value) as uint256
	frame_dig 2 // newL: unsafe uint256
	bytec 8 //  "L"
	app_global_get
	b-
	frame_bury 4 // diff: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1149
	// this.Liqudity.value = newL
	bytec 8 //  "L"
	frame_dig 2 // newL: unsafe uint256
	dup
	bitlen
	intc 1 // 256
	<=

	// newL overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:1151
	// biatecFee = this.appBiatecConfigProvider.value.globalState('f') as uint256
	bytec 17 //  "bc"
	app_global_get
	bytec 20 //  "f"
	app_global_get_ex

	// global state value does not exist: this.appBiatecConfigProvider.value.globalState('f')
	assert
	frame_bury 5 // biatecFee: uint256

	// *if50_condition
	// contracts\BiatecClammPool.algo.ts:1152
	// biatecFee === <uint256>0
	frame_dig 5 // biatecFee: uint256
	bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b==
	bz *if50_else

	// *if50_consequent
	// contracts\BiatecClammPool.algo.ts:1153
	// usersLiquidityFromFeeIncrement = diff
	frame_dig 4 // diff: unsafe uint256
	frame_bury 6 // usersLiquidityFromFeeIncrement: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1154
	// this.LiqudityUsersFromFees.value = this.LiqudityUsersFromFees.value + usersLiquidityFromFeeIncrement
	bytec 15 //  "Lu"
	dup
	app_global_get
	frame_dig 6 // usersLiquidityFromFeeIncrement: unsafe uint256
	b+
	dup
	bitlen
	intc 1 // 256
	<=

	// this.LiqudityUsersFromFees.value + usersLiquidityFromFeeIncrement overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put
	b *if50_end

*if50_else:
	// contracts\BiatecClammPool.algo.ts:1156
	// usersLiquidityFromFeeIncrement = (diff * (s - biatecFee)) / s
	frame_dig 4 // diff: unsafe uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	frame_dig 5 // biatecFee: uint256
	b-
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 7 // usersLiquidityFromFeeIncrement: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1157
	// biatecLiquidityFromFeeIncrement = diff - usersLiquidityFromFeeIncrement
	frame_dig 4 // diff: unsafe uint256
	frame_dig 7 // usersLiquidityFromFeeIncrement: unsafe uint256
	b-
	frame_bury 8 // biatecLiquidityFromFeeIncrement: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1158
	// this.LiqudityUsersFromFees.value = this.LiqudityUsersFromFees.value + usersLiquidityFromFeeIncrement
	bytec 15 //  "Lu"
	dup
	app_global_get
	frame_dig 7 // usersLiquidityFromFeeIncrement: unsafe uint256
	b+
	dup
	bitlen
	intc 1 // 256
	<=

	// this.LiqudityUsersFromFees.value + usersLiquidityFromFeeIncrement overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecClammPool.algo.ts:1159
	// this.LiqudityBiatecFromFees.value = this.LiqudityBiatecFromFees.value + biatecLiquidityFromFeeIncrement
	bytec 18 //  "Lb"
	dup
	app_global_get
	frame_dig 8 // biatecLiquidityFromFeeIncrement: unsafe uint256
	b+
	dup
	bitlen
	intc 1 // 256
	<=

	// this.LiqudityBiatecFromFees.value + biatecLiquidityFromFeeIncrement overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put

*if50_end:
	// contracts\BiatecClammPool.algo.ts:1162
	// newPrice = this.calculatePrice(
	//       this.assetABalance.value, // assetAQuantity: uint256,
	//       this.assetBBalance.value, // assetBQuantity: uint256,
	//       this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//       this.priceMaxSqrt.value, // priceMaxSqrt: uint256,
	//       this.Liqudity.value // liquidity: uint256
	//     )
	bytec 8 //  "L"
	app_global_get
	bytec 10 //  "pMaxS"
	app_global_get
	bytec 9 //  "pMinS"
	app_global_get
	bytec 4 //  "bb"
	app_global_get
	bytec 3 //  "ab"
	app_global_get
	callsub calculatePrice
	frame_bury 9 // newPrice: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1169
	// this.currentPrice.value = newPrice as uint64
	bytec 19 //  "price"
	frame_dig 9 // newPrice: unsafe uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// newPrice as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	app_global_put

	// contracts\BiatecClammPool.algo.ts:1170
	// return diff;
	frame_dig 4 // diff: unsafe uint256

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 9
	retsub

// withdrawExcessAssets(uint64,uint64,uint64,uint64,uint64)uint64
*abi_route_withdrawExcessAssets:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// amountB: uint64
	txna ApplicationArgs 5
	btoi

	// amountA: uint64
	txna ApplicationArgs 4
	btoi

	// assetB: uint64
	txna ApplicationArgs 3
	btoi

	// assetA: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute withdrawExcessAssets(uint64,uint64,uint64,uint64,uint64)uint64
	callsub withdrawExcessAssets
	itob
	concat
	log
	intc 3 // 1
	return

// withdrawExcessAssets(appBiatecConfigProvider: AppID, assetA: AssetID, assetB: AssetID, amountA: uint64, amountB: uint64): uint64
//
// If someone deposits excess assets to the LP pool, addressExecutiveFee can either distribute them to the lp tokens or withdraw it, depending on the use case.
// If someone sent there assets in fault, the withrawing can be use to return them back. If the pool received assets for example for having its algo stake online and recieved rewards it is prefered to distribute them to the current LP holders.
//
// This method is used to distribute amount a and amount b of asset a and asset b to addressExecutiveFee account.
//
// Only addressExecutiveFee is allowed to execute this method.
//
// @param appBiatecConfigProvider Biatec config app. Only addressExecutiveFee is allowed to execute this method.
// @param assetA Asset A
// @param assetB Asset B
// @param amountA Amount of asset A to be deposited to the liquidity. In asset a decimals
// @param amountB Amount of asset B to be deposited to the liquidity. In asset b decimals
withdrawExcessAssets:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts\BiatecClammPool.algo.ts:1194
	// this.checkAssetsAB(assetA, assetB)
	frame_dig -3 // assetB: AssetID
	frame_dig -2 // assetA: AssetID
	callsub checkAssetsAB

	// contracts\BiatecClammPool.algo.ts:1196
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value, 'E_CONFIG')
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 17 //  "bc"
	app_global_get
	==

	// E_CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:1197
	// addressExecutiveFee = appBiatecConfigProvider.globalState('ef') as Address
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 24 //  "ef"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('ef')
	assert
	frame_bury 0 // addressExecutiveFee: address

	// contracts\BiatecClammPool.algo.ts:1199
	// paused = appBiatecConfigProvider.globalState('s') as uint64
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 21 //  "s"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('s')
	assert
	frame_bury 1 // paused: uint64

	// contracts\BiatecClammPool.algo.ts:1200
	// assert(paused === 0, 'E_PAUSED')
	frame_dig 1 // paused: uint64
	intc 2 // 0
	==

	// E_PAUSED
	assert

	// contracts\BiatecClammPool.algo.ts:1202
	// assert(
	//       this.txn.sender === addressExecutiveFee,
	//       'E_SENDER' // 'Only fee executor setup in the config can take the collected fees'
	//     )
	txn Sender
	frame_dig 0 // addressExecutiveFee: address
	==

	// E_SENDER
	assert

	// *if51_condition
	// contracts\BiatecClammPool.algo.ts:1207
	// amountA > 0
	frame_dig -4 // amountA: uint64
	intc 2 // 0
	>
	bz *if51_end

	// *if51_consequent
	// contracts\BiatecClammPool.algo.ts:1208
	// this.doAxfer(this.txn.sender, assetA, amountA)
	frame_dig -4 // amountA: uint64
	frame_dig -2 // assetA: AssetID
	txn Sender
	callsub doAxfer

*if51_end:
	// *if52_condition
	// contracts\BiatecClammPool.algo.ts:1210
	// amountB > 0
	frame_dig -5 // amountB: uint64
	intc 2 // 0
	>
	bz *if52_end

	// *if52_consequent
	// contracts\BiatecClammPool.algo.ts:1211
	// this.doAxfer(this.txn.sender, assetB, amountB)
	frame_dig -5 // amountB: uint64
	frame_dig -3 // assetB: AssetID
	txn Sender
	callsub doAxfer

*if52_end:
	// *if53_condition
	// contracts\BiatecClammPool.algo.ts:1214
	// assetA.id === 0
	frame_dig -2 // assetA: AssetID
	intc 2 // 0
	==
	bz *if53_else

	// *if53_consequent
	// contracts\BiatecClammPool.algo.ts:1215
	// assert(
	//         ((this.app.address.balance - 1_000_000) as uint256) * this.assetADecimals.value >= this.assetABalance.value,
	//         'E_A0_B' // 'It is not possible to set higher assetABalance in algos then is in the app balance'
	//       )
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	intc 12 // 1_000_000
	-
	itob
	bytec 12 //  "ad"
	app_global_get
	b*
	bytec 3 //  "ab"
	app_global_get
	b>=

	// E_A0_B
	assert
	b *if53_end

*if53_else:
	// contracts\BiatecClammPool.algo.ts:1220
	// assert(
	//         (this.app.address.assetBalance(assetA) as uint256) * this.assetADecimals.value >= this.assetABalance.value,
	//         'E_A_B' // 'It is not possible to set higher assetABalance then is in the app balance'
	//       )
	global CurrentApplicationAddress
	frame_dig -2 // assetA: AssetID
	asset_holding_get AssetBalance
	pop
	itob
	bytec 12 //  "ad"
	app_global_get
	b*
	bytec 3 //  "ab"
	app_global_get
	b>=

	// E_A_B
	assert

*if53_end:
	// contracts\BiatecClammPool.algo.ts:1225
	// assert(
	//       (this.app.address.assetBalance(assetB) as uint256) * this.assetBDecimals.value >= this.assetBBalance.value,
	//       'E_B_B' // 'It is not possible to set higher assetBBalance then is in the app balance'
	//     )
	global CurrentApplicationAddress
	frame_dig -3 // assetB: AssetID
	asset_holding_get AssetBalance
	pop
	itob
	bytec 14 //  "bd"
	app_global_get
	b*
	bytec 4 //  "bb"
	app_global_get
	b>=

	// E_B_B
	assert

	// contracts\BiatecClammPool.algo.ts:1230
	// return amountA + amountB;
	frame_dig -4 // amountA: uint64
	frame_dig -5 // amountB: uint64
	+

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// sendOnlineKeyRegistration(uint64,byte[],byte[],byte[],uint64,uint64,uint64)void
*abi_route_sendOnlineKeyRegistration:
	// voteKeyDilution: uint64
	txna ApplicationArgs 7
	btoi

	// voteLast: uint64
	txna ApplicationArgs 6
	btoi

	// voteFirst: uint64
	txna ApplicationArgs 5
	btoi

	// stateProofPk: byte[]
	txna ApplicationArgs 4
	extract 2 0

	// selectionPk: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// votePk: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute sendOnlineKeyRegistration(uint64,byte[],byte[],byte[],uint64,uint64,uint64)void
	callsub sendOnlineKeyRegistration
	intc 3 // 1
	return

// sendOnlineKeyRegistration(appBiatecConfigProvider: AppID, votePk: bytes, selectionPk: bytes, stateProofPk: bytes, voteFirst: uint64, voteLast: uint64, voteKeyDilution: uint64): void
//
// addressExecutiveFee can perfom key registration for this LP pool
//
// Only addressExecutiveFee is allowed to execute this method.
sendOnlineKeyRegistration:
	proto 7 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts\BiatecClammPool.algo.ts:1247
	// assert(appBiatecConfigProvider === this.appBiatecConfigProvider.value, 'E_CONFIG')
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 17 //  "bc"
	app_global_get
	==

	// E_CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:1248
	// addressExecutiveFee = appBiatecConfigProvider.globalState('ef') as Address
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 24 //  "ef"
	app_global_get_ex

	// global state value does not exist: appBiatecConfigProvider.globalState('ef')
	assert
	frame_bury 0 // addressExecutiveFee: address

	// contracts\BiatecClammPool.algo.ts:1249
	// assert(
	//       this.txn.sender === addressExecutiveFee,
	//       'E_SENDER' // 'Only fee executor setup in the config can take the collected fees'
	//     )
	txn Sender
	frame_dig 0 // addressExecutiveFee: address
	==

	// E_SENDER
	assert

	// contracts\BiatecClammPool.algo.ts:1253
	// sendOnlineKeyRegistration({
	//       selectionPK: selectionPk,
	//       stateProofPK: stateProofPk,
	//       voteFirst: voteFirst,
	//       voteKeyDilution: voteKeyDilution,
	//       voteLast: voteLast,
	//       votePK: votePk,
	//       fee: 0,
	//     })
	itxn_begin
	intc 13 //  keyreg
	itxn_field TypeEnum

	// contracts\BiatecClammPool.algo.ts:1254
	// selectionPK: selectionPk
	frame_dig -3 // selectionPk: bytes
	itxn_field SelectionPK

	// contracts\BiatecClammPool.algo.ts:1255
	// stateProofPK: stateProofPk
	frame_dig -4 // stateProofPk: bytes
	itxn_field StateProofPK

	// contracts\BiatecClammPool.algo.ts:1256
	// voteFirst: voteFirst
	frame_dig -5 // voteFirst: uint64
	itxn_field VoteFirst

	// contracts\BiatecClammPool.algo.ts:1257
	// voteKeyDilution: voteKeyDilution
	frame_dig -7 // voteKeyDilution: uint64
	itxn_field VoteKeyDilution

	// contracts\BiatecClammPool.algo.ts:1258
	// voteLast: voteLast
	frame_dig -6 // voteLast: uint64
	itxn_field VoteLast

	// contracts\BiatecClammPool.algo.ts:1259
	// votePK: votePk
	frame_dig -2 // votePk: bytes
	itxn_field VotePK

	// contracts\BiatecClammPool.algo.ts:1260
	// fee: 0
	intc 2 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// calculateDistributedLiquidity(uint64,uint256)uint256
*abi_route_calculateDistributedLiquidity:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// currentDeposit: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 0 (currentDeposit) for calculateDistributedLiquidity must be a uint256
	assert

	// assetLp: uint64
	txna ApplicationArgs 1
	btoi

	// execute calculateDistributedLiquidity(uint64,uint256)uint256
	callsub calculateDistributedLiquidity
	dup
	bitlen
	intc 1 // 256
	<=

	// calculateDistributedLiquidity return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateDistributedLiquidity(assetLp: AssetID, currentDeposit: uint256): uint256
//
// addressExecutiveFee can perfom key unregistration for this LP pool
//
// Only addressExecutiveFee is allowed to execute this method.
//
//
// Calculates the number of LP tokens issued to users
calculateDistributedLiquidity:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 4

	// contracts\BiatecClammPool.algo.ts:1288
	// current = (this.app.address.assetBalance(assetLp) as uint256) - currentDeposit
	global CurrentApplicationAddress
	frame_dig -1 // assetLp: AssetID
	asset_holding_get AssetBalance
	pop
	itob
	frame_dig -2 // currentDeposit: uint256
	b-
	frame_bury 0 // current: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1289
	// minted = Uint<256>(TOTAL_SUPPLY) as uint256
	bytec 30 // 0x000000000000000000000000000000000000000000000000f9ccd8a1c5080000
	frame_bury 1 // minted: uint256

	// contracts\BiatecClammPool.algo.ts:1290
	// distributedLPTokens = minted - current
	bytec 30 //  minted: uint256
	frame_dig 0 // current: unsafe uint256
	b-
	frame_bury 2 // distributedLPTokens: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1292
	// assetLpDelicmalScale2Scale = <uint256>LP_SCALE_DECIMALS
	intc 9 // 10
	intc 10 // 3
	exp
	itob
	frame_bury 3 // assetLpDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1293
	// ret = distributedLPTokens * assetLpDelicmalScale2Scale
	frame_dig 2 // distributedLPTokens: unsafe uint256
	frame_dig 3 // assetLpDelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 4 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1294
	// return ret;
	frame_dig 4 // ret: unsafe uint256

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 4
	retsub

// calculateLiquidityFlatPrice(uint256,uint256,uint256)uint256
*abi_route_calculateLiquidityFlatPrice:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// price: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 0 (price) for calculateLiquidityFlatPrice must be a uint256
	assert

	// y: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 1 (y) for calculateLiquidityFlatPrice must be a uint256
	assert

	// x: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 2 (x) for calculateLiquidityFlatPrice must be a uint256
	assert

	// execute calculateLiquidityFlatPrice(uint256,uint256,uint256)uint256
	callsub calculateLiquidityFlatPrice
	dup
	bitlen
	intc 1 // 256
	<=

	// calculateLiquidityFlatPrice return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateLiquidityFlatPrice(x: uint256, y: uint256, price: uint256): uint256
calculateLiquidityFlatPrice:
	proto 3 1

	// contracts\BiatecClammPool.algo.ts:1313
	// return (x * price) / s + y;
	frame_dig -1 // x: uint256
	frame_dig -3 // price: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_dig -2 // y: uint256
	b+
	retsub

// calculateLiquidityD(uint256,uint256,uint256,uint256,uint256,uint256)uint256
*abi_route_calculateLiquidityD:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// priceMaxSqrt: uint256
	txna ApplicationArgs 6
	dup
	len
	intc 0 // 32
	==

	// argument 0 (priceMaxSqrt) for calculateLiquidityD must be a uint256
	assert

	// priceMinSqrt: uint256
	txna ApplicationArgs 5
	dup
	len
	intc 0 // 32
	==

	// argument 1 (priceMinSqrt) for calculateLiquidityD must be a uint256
	assert

	// priceMax: uint256
	txna ApplicationArgs 4
	dup
	len
	intc 0 // 32
	==

	// argument 2 (priceMax) for calculateLiquidityD must be a uint256
	assert

	// priceMin: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 3 (priceMin) for calculateLiquidityD must be a uint256
	assert

	// y: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 4 (y) for calculateLiquidityD must be a uint256
	assert

	// x: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 5 (x) for calculateLiquidityD must be a uint256
	assert

	// execute calculateLiquidityD(uint256,uint256,uint256,uint256,uint256,uint256)uint256
	callsub calculateLiquidityD
	dup
	bitlen
	intc 1 // 256
	<=

	// calculateLiquidityD return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateLiquidityD(x: uint256, y: uint256, priceMin: uint256, priceMax: uint256, priceMinSqrt: uint256, priceMaxSqrt: uint256): uint256
//
// Calculates the liquidity  from the x - Asset A position and y - Asset B position
// This method calculates discriminant - first part of the calculation.
// It is divided so that the readonly method does not need to charge fees
//
// @param x Asset A position balanced on the curve
// @param y Asset B position balanced on the curve
// @param priceMin Minimum price variable in base scale decimals (pa)
// @param priceMax Maximum price variable in base scale decimals (pb)
// @param priceMinSqrt sqrt(priceMin) in base scale decimals Variable pas
// @param priceMaxSqrt sqrt(priceMax) in base scale decimals Variable pbs
// @returns Liquidity is constant in swapping each direction. On deposit the diff between the liquidity is number of LP tokens received by user.
calculateLiquidityD:
	proto 6 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 8

	// contracts\BiatecClammPool.algo.ts:1367
	// D1 = (x * x * priceMin) / s / s
	frame_dig -1 // x: uint256
	frame_dig -1 // x: uint256
	b*
	frame_dig -3 // priceMin: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 0 // D1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1369
	// D2 = (y * y) / priceMax
	frame_dig -2 // y: uint256
	frame_dig -2 // y: uint256
	b*
	frame_dig -4 // priceMax: uint256
	b/
	frame_bury 1 // D2: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1371
	// D3_1 = <uint256>2 * x * y * priceMinSqrt
	bytec 22 // 0x0000000000000000000000000000000000000000000000000000000000000002
	frame_dig -1 // x: uint256
	b*
	frame_dig -2 // y: uint256
	b*
	frame_dig -5 // priceMinSqrt: uint256
	b*
	frame_bury 2 // D3_1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1372
	// D3 = D3_1 / priceMaxSqrt / s
	frame_dig 2 // D3_1: unsafe uint256
	frame_dig -6 // priceMaxSqrt: uint256
	b/
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 3 // D3: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1375
	// D4 = (<uint256>4 * x * y) / s
	bytec 31 // 0x0000000000000000000000000000000000000000000000000000000000000004
	frame_dig -1 // x: uint256
	b*
	frame_dig -2 // y: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 4 // D4: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1377
	// D5_1 = <uint256>4 * x * y * priceMinSqrt
	bytec 31 // 0x0000000000000000000000000000000000000000000000000000000000000004
	frame_dig -1 // x: uint256
	b*
	frame_dig -2 // y: uint256
	b*
	frame_dig -5 // priceMinSqrt: uint256
	b*
	frame_bury 5 // D5_1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1378
	// D5 = D5_1 / priceMaxSqrt / s
	frame_dig 5 // D5_1: unsafe uint256
	frame_dig -6 // priceMaxSqrt: uint256
	b/
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 6 // D5: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1379
	// D = D1 + D2 + D3 + D4 - D5
	frame_dig 0 // D1: unsafe uint256
	frame_dig 1 // D2: unsafe uint256
	b+
	frame_dig 3 // D3: unsafe uint256
	b+
	frame_dig 4 // D4: unsafe uint256
	b+
	frame_dig 6 // D5: unsafe uint256
	b-
	frame_bury 7 // D: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1380
	// D_SQRT = sqrt(s * D)
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	frame_dig 7 // D: unsafe uint256
	b*
	bsqrt
	frame_bury 8 // D_SQRT: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1381
	// return D_SQRT;
	frame_dig 8 // D_SQRT: unsafe uint256

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 8
	retsub

// calculateLiquidityWithD(uint256,uint256,uint256,uint256,uint256)uint256
*abi_route_calculateLiquidityWithD:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// dSqrt: uint256
	txna ApplicationArgs 5
	dup
	len
	intc 0 // 32
	==

	// argument 0 (dSqrt) for calculateLiquidityWithD must be a uint256
	assert

	// priceMaxSqrt: uint256
	txna ApplicationArgs 4
	dup
	len
	intc 0 // 32
	==

	// argument 1 (priceMaxSqrt) for calculateLiquidityWithD must be a uint256
	assert

	// priceMinSqrt: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 2 (priceMinSqrt) for calculateLiquidityWithD must be a uint256
	assert

	// y: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 3 (y) for calculateLiquidityWithD must be a uint256
	assert

	// x: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 4 (x) for calculateLiquidityWithD must be a uint256
	assert

	// execute calculateLiquidityWithD(uint256,uint256,uint256,uint256,uint256)uint256
	callsub calculateLiquidityWithD
	dup
	bitlen
	intc 1 // 256
	<=

	// calculateLiquidityWithD return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateLiquidityWithD(x: uint256, y: uint256, priceMinSqrt: uint256, priceMaxSqrt: uint256, dSqrt: uint256): uint256
//
// Calculates the liquidity  from the x - Asset A position and y - Asset B position
//
// @param x Asset A position balanced on the curve
// @param y Asset B position balanced on the curve
// @param priceMinSqrt sqrt(priceMin) in base scale decimals Variable pas
// @param priceMaxSqrt sqrt(priceMax) in base scale decimals Variable pbs
// @returns Liquidity is constant in swapping each direction. On deposit the diff between the liquidity is number of LP tokens received by user.
calculateLiquidityWithD:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 11

	// contracts\BiatecClammPool.algo.ts:1431
	// L1 = (x * priceMinSqrt) / s
	frame_dig -1 // x: uint256
	frame_dig -3 // priceMinSqrt: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 0 // L1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1434
	// L2 = (y * s) / priceMaxSqrt
	frame_dig -2 // y: uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig -4 // priceMaxSqrt: uint256
	b/
	frame_bury 1 // L2: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1439
	// L3_0 = <uint256>2
	bytec 22 // 0x0000000000000000000000000000000000000000000000000000000000000002
	frame_bury 2 // L3_0: uint256

	// contracts\BiatecClammPool.algo.ts:1440
	// L3_1 = L3_0 * priceMinSqrt
	bytec 22 //  L3_0: uint256
	frame_dig -3 // priceMinSqrt: uint256
	b*
	frame_bury 3 // L3_1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1441
	// L3_2 = L3_1 * s
	frame_dig 3 // L3_1: unsafe uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_bury 4 // L3_2: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1442
	// L3 = L3_2 / priceMaxSqrt
	frame_dig 4 // L3_2: unsafe uint256
	frame_dig -4 // priceMaxSqrt: uint256
	b/
	frame_bury 5 // L3: unsafe uint256

	// *if54_condition
	// contracts\BiatecClammPool.algo.ts:1443
	// <uint256>2 * s > L3
	bytec 22 // 0x0000000000000000000000000000000000000000000000000000000000000002
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 5 // L3: unsafe uint256
	b>
	bz *if54_end

	// *if54_consequent
	// contracts\BiatecClammPool.algo.ts:1444
	// nom = L1 + L2 + dSqrt
	frame_dig 0 // L1: unsafe uint256
	frame_dig 1 // L2: unsafe uint256
	b+
	frame_dig -5 // dSqrt: uint256
	b+
	frame_bury 6 // nom: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1445
	// den = <uint256>2 * s - L3
	bytec 22 // 0x0000000000000000000000000000000000000000000000000000000000000002
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 5 // L3: unsafe uint256
	b-
	frame_bury 7 // den: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1446
	// ret = (s * nom) / den
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	frame_dig 6 // nom: unsafe uint256
	b*
	frame_dig 7 // den: unsafe uint256
	b/
	frame_bury 8 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1447
	// return ret;
	frame_dig 8 // ret: unsafe uint256
	b *calculateLiquidityWithD*return

*if54_end:
	// contracts\BiatecClammPool.algo.ts:1449
	// nom = L1 + L2 - dSqrt
	frame_dig 0 // L1: unsafe uint256
	frame_dig 1 // L2: unsafe uint256
	b+
	frame_dig -5 // dSqrt: uint256
	b-
	frame_bury 9 // nom: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1450
	// den = L3 - <uint256>2 * s
	frame_dig 5 // L3: unsafe uint256
	bytec 22 // 0x0000000000000000000000000000000000000000000000000000000000000002
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	b-
	frame_bury 10 // den: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1451
	// ret = (s * nom) / den
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	frame_dig 9 // nom: unsafe uint256
	b*
	frame_dig 10 // den: unsafe uint256
	b/
	frame_bury 11 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1452
	// return ret;
	frame_dig 11 // ret: unsafe uint256

*calculateLiquidityWithD*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 11
	retsub

// calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256
*abi_route_calculatePrice:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// liquidity: uint256
	txna ApplicationArgs 5
	dup
	len
	intc 0 // 32
	==

	// argument 0 (liquidity) for calculatePrice must be a uint256
	assert

	// priceMaxSqrt: uint256
	txna ApplicationArgs 4
	dup
	len
	intc 0 // 32
	==

	// argument 1 (priceMaxSqrt) for calculatePrice must be a uint256
	assert

	// priceMinSqrt: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 2 (priceMinSqrt) for calculatePrice must be a uint256
	assert

	// assetBQuantity: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 3 (assetBQuantity) for calculatePrice must be a uint256
	assert

	// assetAQuantity: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 4 (assetAQuantity) for calculatePrice must be a uint256
	assert

	// execute calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256
	callsub calculatePrice
	dup
	bitlen
	intc 1 // 256
	<=

	// calculatePrice return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculatePrice(assetAQuantity: uint256, assetBQuantity: uint256, priceMinSqrt: uint256, priceMaxSqrt: uint256, liquidity: uint256): uint256
//
// Get the current price when asset a has x
// @param assetAQuantity x
// @param assetBQuantity y
// @param priceMinSqrt sqrt(priceMin)
// @param priceMaxSqrt sqrt(priceMax)
// @param liquidity Current pool liquidity - L variable
// @returns the price with specified quantity with the price range set in the contract
calculatePrice:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 7

	// *if55_condition
	// contracts\BiatecClammPool.algo.ts:1476
	// priceMinSqrt === priceMaxSqrt
	frame_dig -3 // priceMinSqrt: uint256
	frame_dig -4 // priceMaxSqrt: uint256
	b==
	bz *if55_end

	// *if55_consequent
	// contracts\BiatecClammPool.algo.ts:1477
	// ret = (priceMinSqrt * priceMinSqrt) / s
	frame_dig -3 // priceMinSqrt: uint256
	frame_dig -3 // priceMinSqrt: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 0 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1478
	// return ret;
	frame_dig 0 // ret: unsafe uint256
	b *calculatePrice*return

*if55_end:
	// contracts\BiatecClammPool.algo.ts:1481
	// a = priceMinSqrt
	frame_dig -3 // priceMinSqrt: uint256
	frame_bury 1 // a: uint256

	// contracts\BiatecClammPool.algo.ts:1482
	// b = priceMaxSqrt
	frame_dig -4 // priceMaxSqrt: uint256
	frame_bury 2 // b: uint256

	// contracts\BiatecClammPool.algo.ts:1483
	// P1 = (liquidity * a) / s
	frame_dig -5 // liquidity: uint256
	frame_dig 1 // a: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 3 // P1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1484
	// P2 = (liquidity * s) / b
	frame_dig -5 // liquidity: uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 2 // b: uint256
	b/
	frame_bury 4 // P2: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1485
	// Nom = assetBQuantity + P1
	frame_dig -2 // assetBQuantity: uint256
	frame_dig 3 // P1: unsafe uint256
	b+
	frame_bury 5 // Nom: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1486
	// Denom = assetAQuantity + P2
	frame_dig -1 // assetAQuantity: uint256
	frame_dig 4 // P2: unsafe uint256
	b+
	frame_bury 6 // Denom: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1487
	// ret = (Nom * s) / Denom
	frame_dig 5 // Nom: unsafe uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 6 // Denom: unsafe uint256
	b/
	frame_bury 7 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1488
	// return ret;
	frame_dig 7 // ret: unsafe uint256

*calculatePrice*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 7
	retsub

// calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256
*abi_route_calculateAssetBWithdrawOnAssetADeposit:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// liqudity: uint256
	txna ApplicationArgs 6
	dup
	len
	intc 0 // 32
	==

	// argument 0 (liqudity) for calculateAssetBWithdrawOnAssetADeposit must be a uint256
	assert

	// priceMaxSqrt: uint256
	txna ApplicationArgs 5
	dup
	len
	intc 0 // 32
	==

	// argument 1 (priceMaxSqrt) for calculateAssetBWithdrawOnAssetADeposit must be a uint256
	assert

	// priceMinSqrt: uint256
	txna ApplicationArgs 4
	dup
	len
	intc 0 // 32
	==

	// argument 2 (priceMinSqrt) for calculateAssetBWithdrawOnAssetADeposit must be a uint256
	assert

	// assetBBalance: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 3 (assetBBalance) for calculateAssetBWithdrawOnAssetADeposit must be a uint256
	assert

	// assetABalance: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 4 (assetABalance) for calculateAssetBWithdrawOnAssetADeposit must be a uint256
	assert

	// inAmount: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 5 (inAmount) for calculateAssetBWithdrawOnAssetADeposit must be a uint256
	assert

	// execute calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256
	callsub calculateAssetBWithdrawOnAssetADeposit
	dup
	bitlen
	intc 1 // 256
	<=

	// calculateAssetBWithdrawOnAssetADeposit return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateAssetBWithdrawOnAssetADeposit(inAmount: uint256, assetABalance: uint256, assetBBalance: uint256, priceMinSqrt: uint256, priceMaxSqrt: uint256, liqudity: uint256): uint256
//
// Calculates how much asset B will be taken from the smart contract on asset A deposit
// @param inAmount Asset A amount in Base decimal representation.. If asset has 6 decimals, 1 is represented as 1000000000
// @param assetABalance Asset A balance. Variable ab, in base scale
// @param assetBBalance Asset B balance. Variable bb, in base scale
// @param priceMinSqrt sqrt(Min price). Variable pMinS, in base scale
// @param priceMaxSqrt sqrt(Max price). Variable pMaxS, in base scale
// @param liqudity sqrt(Max price). Variable L, in base scale
// @returns Amount of asset B to be given to the caller before fees. The result is in Base decimals (9)
calculateAssetBWithdrawOnAssetADeposit:
	proto 6 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 12

	// *if56_condition
	// contracts\BiatecClammPool.algo.ts:1511
	// priceMinSqrt === priceMaxSqrt
	frame_dig -4 // priceMinSqrt: uint256
	frame_dig -5 // priceMaxSqrt: uint256
	b==
	bz *if56_end

	// *if56_consequent
	// contracts\BiatecClammPool.algo.ts:1512
	// ret = (inAmount * priceMinSqrt * priceMinSqrt) / s / s
	frame_dig -1 // inAmount: uint256
	frame_dig -4 // priceMinSqrt: uint256
	b*
	frame_dig -4 // priceMinSqrt: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 0 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1513
	// return ret;
	frame_dig 0 // ret: unsafe uint256
	b *calculateAssetBWithdrawOnAssetADeposit*return

*if56_end:
	// contracts\BiatecClammPool.algo.ts:1531
	// x = assetABalance
	frame_dig -2 // assetABalance: uint256
	frame_bury 1 // x: uint256

	// contracts\BiatecClammPool.algo.ts:1532
	// y = assetBBalance
	frame_dig -3 // assetBBalance: uint256
	frame_bury 2 // y: uint256

	// contracts\BiatecClammPool.algo.ts:1533
	// a = priceMinSqrt
	frame_dig -4 // priceMinSqrt: uint256
	frame_bury 3 // a: uint256

	// contracts\BiatecClammPool.algo.ts:1534
	// b = priceMaxSqrt
	frame_dig -5 // priceMaxSqrt: uint256
	frame_bury 4 // b: uint256

	// contracts\BiatecClammPool.algo.ts:1535
	// L = liqudity
	frame_dig -6 // liqudity: uint256
	frame_bury 5 // L: uint256

	// contracts\BiatecClammPool.algo.ts:1537
	// P1 = (((((a /* 10D */ * b) /* 10D */ / s) * inAmount) /* AD */ / s) * L) /* 10D */ / s
	frame_dig 3 // a: uint256
	frame_dig 4 // b: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_dig -1 // inAmount: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_dig 5 // L: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 6 // P1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1539
	// P2 = (((b /* 10D */ * inAmount) /* AD */ / s) * y) /* BD */ / s
	frame_dig 4 // b: uint256
	frame_dig -1 // inAmount: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_dig 2 // y: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 7 // P2: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1541
	// P3 = (b /* 10D */ * inAmount) /* AD */ / s
	frame_dig 4 // b: uint256
	frame_dig -1 // inAmount: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 8 // P3: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1543
	// P4 = (b /* 10D */ * x) /* 10D */ / s
	frame_dig 4 // b: uint256
	frame_dig 1 // x: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 9 // P4: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1545
	// P12 = P1 + P2
	frame_dig 6 // P1: unsafe uint256
	frame_dig 7 // P2: unsafe uint256
	b+
	frame_bury 10 // P12: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1547
	// P345 = P3 + P4 + L
	frame_dig 8 // P3: unsafe uint256
	frame_dig 9 // P4: unsafe uint256
	b+
	frame_dig 5 // L: uint256
	b+
	frame_bury 11 // P345: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1549
	// ret = (P12 * s) / P345
	frame_dig 10 // P12: unsafe uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 11 // P345: unsafe uint256
	b/
	frame_bury 12 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1550
	// return ret;
	frame_dig 12 // ret: unsafe uint256

*calculateAssetBWithdrawOnAssetADeposit*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 12
	retsub

// calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256
*abi_route_calculateAssetAWithdrawOnAssetBDeposit:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// liqudity: uint256
	txna ApplicationArgs 6
	dup
	len
	intc 0 // 32
	==

	// argument 0 (liqudity) for calculateAssetAWithdrawOnAssetBDeposit must be a uint256
	assert

	// priceMaxSqrt: uint256
	txna ApplicationArgs 5
	dup
	len
	intc 0 // 32
	==

	// argument 1 (priceMaxSqrt) for calculateAssetAWithdrawOnAssetBDeposit must be a uint256
	assert

	// priceMinSqrt: uint256
	txna ApplicationArgs 4
	dup
	len
	intc 0 // 32
	==

	// argument 2 (priceMinSqrt) for calculateAssetAWithdrawOnAssetBDeposit must be a uint256
	assert

	// assetBBalance: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 3 (assetBBalance) for calculateAssetAWithdrawOnAssetBDeposit must be a uint256
	assert

	// assetABalance: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 4 (assetABalance) for calculateAssetAWithdrawOnAssetBDeposit must be a uint256
	assert

	// inAmount: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 5 (inAmount) for calculateAssetAWithdrawOnAssetBDeposit must be a uint256
	assert

	// execute calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256
	callsub calculateAssetAWithdrawOnAssetBDeposit
	dup
	bitlen
	intc 1 // 256
	<=

	// calculateAssetAWithdrawOnAssetBDeposit return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateAssetAWithdrawOnAssetBDeposit(inAmount: uint256, assetABalance: uint256, assetBBalance: uint256, priceMinSqrt: uint256, priceMaxSqrt: uint256, liqudity: uint256): uint256
//
// Calculates how much asset A will be taken from the smart contract on asset B deposit
// @param inAmount Asset B amount in Base decimal representation.. If asset has 6 decimals, 1 is represented as 1000000000
// @param assetABalance Asset A balance. Variable ab, in base scale
// @param assetBBalance Asset B balance. Variable bb, in base scale
// @param priceMinSqrt sqrt(Min price). Variable pMinS, in base scale
// @param priceMaxSqrt sqrt(Max price). Variable pMaxS, in base scale
// @param liqudity sqrt(Max price). Variable L, in base scale
//
// @returns Amount of asset A to be given to the caller before fees. The result is in Base decimals (9)
calculateAssetAWithdrawOnAssetBDeposit:
	proto 6 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 13

	// *if57_condition
	// contracts\BiatecClammPool.algo.ts:1573
	// priceMinSqrt === priceMaxSqrt
	frame_dig -4 // priceMinSqrt: uint256
	frame_dig -5 // priceMaxSqrt: uint256
	b==
	bz *if57_end

	// *if57_consequent
	// contracts\BiatecClammPool.algo.ts:1574
	// ret = (inAmount * s * s) / priceMinSqrt / priceMinSqrt
	frame_dig -1 // inAmount: uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig -4 // priceMinSqrt: uint256
	b/
	frame_dig -4 // priceMinSqrt: uint256
	b/
	frame_bury 0 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1575
	// return ret;
	frame_dig 0 // ret: unsafe uint256
	b *calculateAssetAWithdrawOnAssetBDeposit*return

*if57_end:
	// contracts\BiatecClammPool.algo.ts:1590
	// x = assetABalance
	frame_dig -2 // assetABalance: uint256
	frame_bury 1 // x: uint256

	// contracts\BiatecClammPool.algo.ts:1591
	// y = assetBBalance
	frame_dig -3 // assetBBalance: uint256
	frame_bury 2 // y: uint256

	// contracts\BiatecClammPool.algo.ts:1592
	// a = priceMinSqrt
	frame_dig -4 // priceMinSqrt: uint256
	frame_bury 3 // a: uint256

	// contracts\BiatecClammPool.algo.ts:1593
	// b = priceMaxSqrt
	frame_dig -5 // priceMaxSqrt: uint256
	frame_bury 4 // b: uint256

	// contracts\BiatecClammPool.algo.ts:1594
	// L = liqudity
	frame_dig -6 // liqudity: uint256
	frame_bury 5 // L: uint256

	// contracts\BiatecClammPool.algo.ts:1597
	// P1 = (inAmount * L) / s
	frame_dig -1 // inAmount: uint256
	frame_dig 5 // L: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 6 // P1: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1599
	// P2 = (((b * inAmount) / s) * x) / s
	frame_dig 4 // b: uint256
	frame_dig -1 // inAmount: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_dig 1 // x: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 7 // P2: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1601
	// nom = P1 + P2
	frame_dig 6 // P1: unsafe uint256
	frame_dig 7 // P2: unsafe uint256
	b+
	frame_bury 8 // nom: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1603
	// P3 = (((a * b) / s) * L) / s
	frame_dig 3 // a: uint256
	frame_dig 4 // b: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_dig 5 // L: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 9 // P3: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1605
	// P4 = (b * inAmount) / s
	frame_dig 4 // b: uint256
	frame_dig -1 // inAmount: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 10 // P4: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1607
	// P5 = (b * y) / s
	frame_dig 4 // b: uint256
	frame_dig 2 // y: uint256
	b*
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b/
	frame_bury 11 // P5: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1609
	// denom = P3 + P4 + P5
	frame_dig 9 // P3: unsafe uint256
	frame_dig 10 // P4: unsafe uint256
	b+
	frame_dig 11 // P5: unsafe uint256
	b+
	frame_bury 12 // denom: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1611
	// ret = (nom * s) / denom
	frame_dig 8 // nom: unsafe uint256
	bytec 2 // 0x000000000000000000000000000000000000000000000000000000003b9aca00
	b*
	frame_dig 12 // denom: unsafe uint256
	b/
	frame_bury 13 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1612
	// return ret;
	frame_dig 13 // ret: unsafe uint256

*calculateAssetAWithdrawOnAssetBDeposit*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 13
	retsub

// calculateAssetAWithdrawOnLpDeposit(uint256,uint256,uint256)uint256
*abi_route_calculateAssetAWithdrawOnLpDeposit:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// liqudity: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 0 (liqudity) for calculateAssetAWithdrawOnLpDeposit must be a uint256
	assert

	// assetABalance: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 1 (assetABalance) for calculateAssetAWithdrawOnLpDeposit must be a uint256
	assert

	// inAmount: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 2 (inAmount) for calculateAssetAWithdrawOnLpDeposit must be a uint256
	assert

	// execute calculateAssetAWithdrawOnLpDeposit(uint256,uint256,uint256)uint256
	callsub calculateAssetAWithdrawOnLpDeposit
	dup
	bitlen
	intc 1 // 256
	<=

	// calculateAssetAWithdrawOnLpDeposit return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateAssetAWithdrawOnLpDeposit(inAmount: uint256, assetABalance: uint256, liqudity: uint256): uint256
//
// Calculates how much asset A will be taken from the smart contract on LP asset deposit
// @param inAmount LP Asset amount in Base decimal representation..
// @param assetABalance Asset A balance. Variable ab, in base scale
// @param liqudity Current liqudity. Variable L, in base scale
//
// @returns Amount of asset A to be given to the caller before fees. The result is in Base decimals (9)
calculateAssetAWithdrawOnLpDeposit:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts\BiatecClammPool.algo.ts:1628
	// ret = (assetABalance * inAmount) / liqudity
	frame_dig -2 // assetABalance: uint256
	frame_dig -1 // inAmount: uint256
	b*
	frame_dig -3 // liqudity: uint256
	b/
	frame_bury 0 // ret: unsafe uint256

	// contracts\BiatecClammPool.algo.ts:1629
	// return ret;
	frame_dig 0 // ret: unsafe uint256

	// set the subroutine return value
	frame_bury 0
	retsub

// calculateAssetBDepositOnAssetADeposit(uint256,uint256,uint256,uint256)uint256
*abi_route_calculateAssetBDepositOnAssetADeposit:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// assetBBalance: uint256
	txna ApplicationArgs 4
	dup
	len
	intc 0 // 32
	==

	// argument 0 (assetBBalance) for calculateAssetBDepositOnAssetADeposit must be a uint256
	assert

	// assetABalance: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 1 (assetABalance) for calculateAssetBDepositOnAssetADeposit must be a uint256
	assert

	// inAmountB: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 2 (inAmountB) for calculateAssetBDepositOnAssetADeposit must be a uint256
	assert

	// inAmountA: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 3 (inAmountA) for calculateAssetBDepositOnAssetADeposit must be a uint256
	assert

	// execute calculateAssetBDepositOnAssetADeposit(uint256,uint256,uint256,uint256)uint256
	callsub calculateAssetBDepositOnAssetADeposit
	dup
	bitlen
	intc 1 // 256
	<=

	// calculateAssetBDepositOnAssetADeposit return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateAssetBDepositOnAssetADeposit(inAmountA: uint256, inAmountB: uint256, assetABalance: uint256, assetBBalance: uint256): uint256
//
// Calculates how much asset B should be deposited when user deposit asset a and b.
//
// On deposit min(calculateAssetBDepositOnAssetADeposit, calculateAssetADepositOnAssetBDeposit) should be considered for the real deposit and rest should be swapped or returned back to user
//
// @param inAmountA Asset A amount in Base decimal representation
// @param inAmountB Asset B amount in Base decimal representation
// @param assetABalance Asset A balance. Variable ab, in base scale
// @param assetBBalance Asset B balance. Variable bb, in base scale
//
// @returns Amount of asset B to be given to the caller before fees. The result is in Base decimals (9)
calculateAssetBDepositOnAssetADeposit:
	proto 4 1

	// *if58_condition
	// contracts\BiatecClammPool.algo.ts:1651
	// assetABalance > <uint256>0
	frame_dig -3 // assetABalance: uint256
	bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	bz *if58_end

	// *if58_consequent
	// contracts\BiatecClammPool.algo.ts:1652
	// return (inAmountA * assetBBalance) / assetABalance;
	frame_dig -1 // inAmountA: uint256
	frame_dig -4 // assetBBalance: uint256
	b*
	frame_dig -3 // assetABalance: uint256
	b/
	retsub

*if58_end:
	// contracts\BiatecClammPool.algo.ts:1655
	// return inAmountB;
	frame_dig -2 // inAmountB: uint256
	retsub

// calculateAssetADepositOnAssetBDeposit(uint256,uint256,uint256,uint256)uint256
*abi_route_calculateAssetADepositOnAssetBDeposit:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// assetBBalance: uint256
	txna ApplicationArgs 4
	dup
	len
	intc 0 // 32
	==

	// argument 0 (assetBBalance) for calculateAssetADepositOnAssetBDeposit must be a uint256
	assert

	// assetABalance: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 1 (assetABalance) for calculateAssetADepositOnAssetBDeposit must be a uint256
	assert

	// inAmountB: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 2 (inAmountB) for calculateAssetADepositOnAssetBDeposit must be a uint256
	assert

	// inAmountA: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 3 (inAmountA) for calculateAssetADepositOnAssetBDeposit must be a uint256
	assert

	// execute calculateAssetADepositOnAssetBDeposit(uint256,uint256,uint256,uint256)uint256
	callsub calculateAssetADepositOnAssetBDeposit
	dup
	bitlen
	intc 1 // 256
	<=

	// calculateAssetADepositOnAssetBDeposit return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 3 // 1
	return

// calculateAssetADepositOnAssetBDeposit(inAmountA: uint256, inAmountB: uint256, assetABalance: uint256, assetBBalance: uint256): uint256
//
// Calculates how much asset A should be deposited when user deposit asset a and b
//
// On deposit min(calculateAssetBDepositOnAssetADeposit, calculateAssetADepositOnAssetBDeposit) should be considered for the real deposit and rest should be swapped or returned back to user
//
// @param inAmountA Asset A amount in Base decimal representation
// @param inAmountB Asset B amount in Base decimal representation
// @param assetABalance Asset A balance. Variable ab, in base scale
// @param assetBBalance Asset B balance. Variable bb, in base scale
//
// @returns Amount of asset A to be deposited. The result is in Base decimals (9)
calculateAssetADepositOnAssetBDeposit:
	proto 4 1

	// *if59_condition
	// contracts\BiatecClammPool.algo.ts:1677
	// assetBBalance > <uint256>0
	frame_dig -4 // assetBBalance: uint256
	bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	bz *if59_end

	// *if59_consequent
	// contracts\BiatecClammPool.algo.ts:1678
	// return (inAmountB * assetABalance) / assetBBalance;
	frame_dig -2 // inAmountB: uint256
	frame_dig -3 // assetABalance: uint256
	b*
	frame_dig -4 // assetBBalance: uint256
	b/
	retsub

*if59_end:
	// contracts\BiatecClammPool.algo.ts:1681
	// return inAmountA;
	frame_dig -1 // inAmountA: uint256
	retsub

// status(uint64,uint64,uint64,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
*abi_route_status:
	// The ABI return prefix
	bytec 7 // 0x151f7c75

	// assetLp: uint64
	txna ApplicationArgs 4
	btoi

	// assetB: uint64
	txna ApplicationArgs 3
	btoi

	// assetA: uint64
	txna ApplicationArgs 2
	btoi

	// appBiatecConfigProvider: uint64
	txna ApplicationArgs 1
	btoi

	// execute status(uint64,uint64,uint64,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	callsub status
	concat
	log
	intc 3 // 1
	return

// status(appBiatecConfigProvider: AppID, assetA: AssetID, assetB: AssetID, assetLp: AssetID): AmmStatus
status:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts\BiatecClammPool.algo.ts:1686
	// assert(
	//       appBiatecConfigProvider === this.appBiatecConfigProvider.value,
	//       'E_CONFIG' // 'appBiatecConfigProvider must match to the global variable app id'
	//     )
	frame_dig -1 // appBiatecConfigProvider: AppID
	bytec 17 //  "bc"
	app_global_get
	==

	// E_CONFIG
	assert

	// contracts\BiatecClammPool.algo.ts:1690
	// assert(assetA.id === this.assetA.value)
	frame_dig -2 // assetA: AssetID
	bytec 25 //  "a"
	app_global_get
	==
	assert

	// contracts\BiatecClammPool.algo.ts:1691
	// assert(assetB.id === this.assetB.value)
	frame_dig -3 // assetB: AssetID
	bytec 26 //  "b"
	app_global_get
	==
	assert

	// contracts\BiatecClammPool.algo.ts:1692
	// assert(this.assetLp.value === assetLp.id, 'E_LP')
	bytec 23 //  "lp"
	app_global_get
	frame_dig -4 // assetLp: AssetID
	==

	// E_LP
	assert

	// contracts\BiatecClammPool.algo.ts:1693
	// biatecFee = this.appBiatecConfigProvider.value.globalState('f') as uint256
	bytec 17 //  "bc"
	app_global_get
	bytec 20 //  "f"
	app_global_get_ex

	// global state value does not exist: this.appBiatecConfigProvider.value.globalState('f')
	assert
	frame_bury 0 // biatecFee: uint256

	// contracts\BiatecClammPool.algo.ts:1694
	// realBalanceA =
	//       assetA.id === 0
	//         ? globals.currentApplicationAddress.balance
	//         : globals.currentApplicationAddress.assetBalance(assetA)
	frame_dig -2 // assetA: AssetID
	intc 2 // 0
	==
	bz *ternary0_false
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	b *ternary0_end

*ternary0_false:
	global CurrentApplicationAddress
	frame_dig -2 // assetA: AssetID
	asset_holding_get AssetBalance
	pop

*ternary0_end:
	frame_bury 1 // realBalanceA: uint64

	// contracts\BiatecClammPool.algo.ts:1698
	// realBalanceB = globals.currentApplicationAddress.assetBalance(assetB)
	global CurrentApplicationAddress
	frame_dig -3 // assetB: AssetID
	asset_holding_get AssetBalance
	pop
	frame_bury 2 // realBalanceB: uint64

	// contracts\BiatecClammPool.algo.ts:1699
	// return {
	//       assetA: this.assetA.value,
	//       assetB: this.assetB.value,
	//       poolToken: this.assetLp.value,
	//       assetABalance: this.assetABalance.value as uint64,
	//       assetBBalance: this.assetBBalance.value as uint64,
	//       realABalance: realBalanceA,
	//       realBBalance: realBalanceB,
	//       fee: this.fee.value,
	//       biatecFee: biatecFee as uint64,
	//       currentLiqudity: this.Liqudity.value as uint64,
	//       liqudityBiatecFromFees: this.LiqudityBiatecFromFees.value as uint64,
	//       liqudityUsersFromFees: this.LiqudityUsersFromFees.value as uint64,
	//       price: this.currentPrice.value as uint64,
	//       priceMaxSqrt: this.priceMaxSqrt.value as uint64,
	//       priceMinSqrt: this.priceMinSqrt.value as uint64,
	//       releasedLiqudity: this.calculateDistributedLiquidity(assetLp, <uint256>0) as uint64,
	//       scale: SCALE,
	//       verificationClass: this.verificationClass.value,
	//     };
	bytec 33 // 0x000000003b9aca00
	bytec 3 //  "ab"
	app_global_get
	dup
	bitlen
	intc 4 // 64
	<=

	// this.assetABalance.value as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	concat
	bytec 4 //  "bb"
	app_global_get
	dup
	bitlen
	intc 4 // 64
	<=

	// this.assetBBalance.value as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	concat
	frame_dig 1 // realBalanceA: uint64
	itob
	concat
	frame_dig 2 // realBalanceB: uint64
	itob
	concat
	bytec 9 //  "pMinS"
	app_global_get
	dup
	bitlen
	intc 4 // 64
	<=

	// this.priceMinSqrt.value as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	concat
	bytec 10 //  "pMaxS"
	app_global_get
	dup
	bitlen
	intc 4 // 64
	<=

	// this.priceMaxSqrt.value as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	concat
	bytec 8 //  "L"
	app_global_get
	dup
	bitlen
	intc 4 // 64
	<=

	// this.Liqudity.value as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	concat
	bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_dig -4 // assetLp: AssetID
	callsub calculateDistributedLiquidity
	dup
	bitlen
	intc 4 // 64
	<=

	// this.calculateDistributedLiquidity(assetLp, <uint256>0) as uint64 overflowed 64 bits
	assert
	bytec 11 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 6 // 8
	-
	swap
	substring3
	btoi
	itob
	concat
	bytec 15 //  "Lu"
	app_global_get
	dup
	bitlen
	intc 4 // 64
	<=

	// this.LiqudityUsersFromFees.value as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	concat
	bytec 18 //  "Lb"
	app_global_get
	dup
	bitlen
	intc 4 // 64
	<=

	// this.LiqudityBiatecFromFees.value as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	concat
	bytec 25 //  "a"
	app_global_get
	itob
	concat
	bytec 26 //  "b"
	app_global_get
	itob
	concat
	bytec 23 //  "lp"
	app_global_get
	itob
	concat
	bytec 19 //  "price"
	app_global_get
	itob
	concat
	bytec 20 //  "f"
	app_global_get
	itob
	concat
	frame_dig 0 // biatecFee: uint256
	dup
	bitlen
	intc 4 // 64
	<=

	// biatecFee as uint64 overflowed 64 bits
	assert
	extract 24 8
	btoi
	itob
	concat
	bytec 28 //  "c"
	app_global_get
	itob
	concat

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0xd1717fe5 // method "getCurrentPrice()uint64"
	pushbytes 0xe3a43a4a // method "getPriceDivider()uint64"
	pushbytes 0x1d764a9e // method "getLPTokenId()uint64"
	pushbytes 0x2bfffa75 // method "bootstrap(uint64,uint64,uint64,uint64,pay,uint64,uint64,uint64,uint64,uint64)uint64"
	pushbytes 0xd5c89baf // method "bootstrapStep2()void"
	pushbytes 0x0440fa8f // method "addLiquidity(uint64,uint64,txn,txn,uint64,uint64,uint64)uint64"
	pushbytes 0x549a90a4 // method "removeLiquidity(uint64,uint64,axfer,uint64,uint64,uint64)uint256"
	pushbytes 0x894a934f // method "removeLiquidityAdmin(uint64,uint64,uint64,uint64,uint256)uint256"
	pushbytes 0x2013349e // method "swap(uint64,uint64,uint64,txn,uint64,uint64,uint64)uint256"
	pushbytes 0xce564412 // method "distributeExcessAssets(uint64,uint64,uint64,uint256,uint256)uint256"
	pushbytes 0x22b746c8 // method "withdrawExcessAssets(uint64,uint64,uint64,uint64,uint64)uint64"
	pushbytes 0x83925c17 // method "sendOnlineKeyRegistration(uint64,byte[],byte[],byte[],uint64,uint64,uint64)void"
	pushbytes 0x39eca854 // method "calculateDistributedLiquidity(uint64,uint256)uint256"
	pushbytes 0xff695816 // method "calculateLiquidityFlatPrice(uint256,uint256,uint256)uint256"
	pushbytes 0xdca3d4d6 // method "calculateLiquidityD(uint256,uint256,uint256,uint256,uint256,uint256)uint256"
	pushbytes 0x69d623b1 // method "calculateLiquidityWithD(uint256,uint256,uint256,uint256,uint256)uint256"
	pushbytes 0x3c2c7e4a // method "calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256"
	pushbytes 0x4bf571b6 // method "calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256"
	pushbytes 0x52f7923f // method "calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256"
	pushbytes 0x6c25b3f3 // method "calculateAssetAWithdrawOnLpDeposit(uint256,uint256,uint256)uint256"
	pushbytes 0xe64ddd82 // method "calculateAssetBDepositOnAssetADeposit(uint256,uint256,uint256,uint256)uint256"
	pushbytes 0x49f68370 // method "calculateAssetADepositOnAssetBDeposit(uint256,uint256,uint256,uint256)uint256"
	pushbytes 0x4feca359 // method "status(uint64,uint64,uint64,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)"
	txna ApplicationArgs 0
	match *abi_route_getCurrentPrice *abi_route_getPriceDivider *abi_route_getLPTokenId *abi_route_bootstrap *abi_route_bootstrapStep2 *abi_route_addLiquidity *abi_route_removeLiquidity *abi_route_removeLiquidityAdmin *abi_route_swap *abi_route_distributeExcessAssets *abi_route_withdrawExcessAssets *abi_route_sendOnlineKeyRegistration *abi_route_calculateDistributedLiquidity *abi_route_calculateLiquidityFlatPrice *abi_route_calculateLiquidityD *abi_route_calculateLiquidityWithD *abi_route_calculatePrice *abi_route_calculateAssetBWithdrawOnAssetADeposit *abi_route_calculateAssetAWithdrawOnAssetBDeposit *abi_route_calculateAssetAWithdrawOnLpDeposit *abi_route_calculateAssetBDepositOnAssetADeposit *abi_route_calculateAssetADepositOnAssetBDeposit *abi_route_status

	// this contract does not implement the given ABI method for call NoOp
	err

*call_UpdateApplication:
	pushbytes 0x5fc885a0 // method "updateApplication(uint64,byte[])void"
	txna ApplicationArgs 0
	match *abi_route_updateApplication

	// this contract does not implement the given ABI method for call UpdateApplication
	err
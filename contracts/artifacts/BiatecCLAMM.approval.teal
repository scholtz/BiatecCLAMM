#pragma version 10

// This TEAL was generated by TEALScript v0.86.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	err

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	int 1
	return

// createApplication(): void
//
// Initial setup
createApplication:
	proto 0 0

	// contracts\BiatecCLAMM.algo.ts:79
	// log(version)
	byte "CLAMM-01-01-01"
	log

	// contracts\BiatecCLAMM.algo.ts:80
	// this.governor.value = Address.fromBytes(governor)
	byte 0x67 // "g"
	byte "ALGONAUTSPIUHDCX3SLFXOFDUKOE4VY36XV4JX2JHQTWJNKVBKPEBQACRY"
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:81
	// this.scale.value = SCALE
	byte 0x7363616c65 // "scale"
	int 1000000000
	app_global_put
	retsub

// getCurrentPrice()uint64
*abi_route_getCurrentPrice:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getCurrentPrice()uint64
	callsub getCurrentPrice
	itob
	concat
	log
	int 1
	return

// getCurrentPrice(): uint64
getCurrentPrice:
	proto 0 1

	// contracts\BiatecCLAMM.algo.ts:86
	// return this.ratio.value;
	byte 0x72 // "r"
	app_global_get
	retsub

// getPriceDivider()uint64
*abi_route_getPriceDivider:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getPriceDivider()uint64
	callsub getPriceDivider
	itob
	concat
	log
	int 1
	return

// getPriceDivider(): uint64
getPriceDivider:
	proto 0 1

	// contracts\BiatecCLAMM.algo.ts:91
	// return this.scale.value;
	byte 0x7363616c65 // "scale"
	app_global_get
	retsub

// getLPTokenId()uint64
*abi_route_getLPTokenId:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getLPTokenId()uint64
	callsub getLPTokenId
	itob
	concat
	log
	int 1
	return

// getLPTokenId(): uint64
getLPTokenId:
	proto 0 1

	// contracts\BiatecCLAMM.algo.ts:96
	// return this.poolToken.value.id;
	byte 0x70 // "p"
	app_global_get
	retsub

// bootstrap(pay,uint64,uint64,uint32,uint64,uint64,uint64,uint8,uint64,uint64)uint64
*abi_route_bootstrap:
	// The ABI return prefix
	byte 0x151f7c75

	// poolProvider: uint64
	txna ApplicationArgs 9
	btoi

	// identityProvider: uint64
	txna ApplicationArgs 8
	btoi

	// verificationClass: uint8
	txna ApplicationArgs 7
	dup
	len
	int 1
	==
	assert
	btoi

	// currentPrice: uint64
	txna ApplicationArgs 6
	btoi

	// priceMaxB: uint64
	txna ApplicationArgs 5
	btoi

	// priceMaxA: uint64
	txna ApplicationArgs 4
	btoi

	// feeB100000: uint32
	txna ApplicationArgs 3
	dup
	len
	int 4
	==
	assert
	btoi

	// assetB: uint64
	txna ApplicationArgs 2
	btoi

	// assetA: uint64
	txna ApplicationArgs 1
	btoi

	// txSeed: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute bootstrap(pay,uint64,uint64,uint32,uint64,uint64,uint64,uint8,uint64,uint64)uint64
	callsub bootstrap
	itob
	concat
	log
	int 1
	return

// bootstrap(txSeed: PayTxn, assetA: AssetID, assetB: AssetID, feeB100000: uint32, priceMaxA: uint64, priceMaxB: uint64, currentPrice: uint64, verificationClass: uint8, identityProvider: AppID, poolProvider: AppID): AssetID
//
// Anybody can deploy the clamm smart contract
// @param txSeed Seed transaction so that smart contract can opt in to the assets
// @param assetA Asset A ID must be lower then Asset B ID
// @param assetB Asset B
// @param feeB100000 Fee in 100000 base level. value 10000 = 10000/100000 = 0,1 = 10% fee. 1000 = 1%. 100 = 0,1%. 10 = 0,01% = 1 base point
// @param verificationClass Asset B
// @returns LP token ID
bootstrap:
	proto 10 1

	// contracts\BiatecCLAMM.algo.ts:120
	// verifyPayTxn(txSeed, { receiver: this.app.address, amount: { greaterThanEqualTo: 300_000 } })
	// verify receiver
	frame_dig -1 // txSeed: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // txSeed: PayTxn
	gtxns Amount
	int 300_000
	>=
	assert

	// contracts\BiatecCLAMM.algo.ts:121
	// assert(this.governor.value === Address.fromBytes(governor))
	byte 0x67 // "g"
	app_global_get
	byte "ALGONAUTSPIUHDCX3SLFXOFDUKOE4VY36XV4JX2JHQTWJNKVBKPEBQACRY"
	==
	assert

	// contracts\BiatecCLAMM.algo.ts:122
	// assert(assetA < assetB)
	frame_dig -2 // assetA: AssetID
	frame_dig -3 // assetB: AssetID
	<
	assert

	// contracts\BiatecCLAMM.algo.ts:123
	// assert(feeB100000 < 1000000)
	frame_dig -4 // feeB100000: uint32
	int 1000000
	<
	assert

	// contracts\BiatecCLAMM.algo.ts:124
	// assert(verificationClass < 4)
	frame_dig -8 // verificationClass: uint8
	int 4
	<
	assert

	// contracts\BiatecCLAMM.algo.ts:125
	// assert(!this.ratio.exists)
	txna Applications 0
	byte 0x72 // "r"
	app_global_get_ex
	swap
	pop
	!
	assert

	// contracts\BiatecCLAMM.algo.ts:126
	// assert(assetA.decimals <= SCALE_DECIMALS)
	frame_dig -2 // assetA: AssetID
	asset_params_get AssetDecimals
	pop
	int 9
	<=
	assert

	// contracts\BiatecCLAMM.algo.ts:127
	// assert(assetB.decimals <= SCALE_DECIMALS)
	frame_dig -3 // assetB: AssetID
	asset_params_get AssetDecimals
	pop
	int 9
	<=
	assert

	// contracts\BiatecCLAMM.algo.ts:129
	// this.identityProvider.value = identityProvider
	byte 0x69 // "i"
	frame_dig -9 // identityProvider: AppID
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:130
	// this.poolProvider.value = poolProvider
	byte 0x7070 // "pp"
	frame_dig -10 // poolProvider: AppID
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:132
	// this.priceMaxA.value = priceMaxA
	byte 0x7061 // "pa"
	frame_dig -5 // priceMaxA: uint64
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:133
	// this.priceMaxB.value = priceMaxB
	byte 0x7062 // "pb"
	frame_dig -6 // priceMaxB: uint64
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:134
	// this.priceMaxASqrt.value = sqrt(priceMaxA * SCALE)
	byte 0x706173 // "pas"
	frame_dig -5 // priceMaxA: uint64
	int 1000000000
	*
	sqrt
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:135
	// this.priceMaxBSqrt.value = sqrt(priceMaxB * SCALE)
	byte 0x706273 // "pbs"
	frame_dig -6 // priceMaxB: uint64
	int 1000000000
	*
	sqrt
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:136
	// this.assetABalance.value = 0
	byte 0x6162 // "ab"
	int 0
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:137
	// this.assetBBalance.value = 0
	byte 0x6262 // "bb"
	int 0
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:138
	// this.ratio.value = currentPrice
	byte 0x72 // "r"
	frame_dig -7 // currentPrice: uint64
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:140
	// this.assetA.value = assetA
	byte 0x61 // "a"
	frame_dig -2 // assetA: AssetID
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:141
	// this.assetB.value = assetB
	byte 0x62 // "b"
	frame_dig -3 // assetB: AssetID
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:142
	// this.poolToken.value = this.doCreatePoolToken(assetA, assetB)
	byte 0x70 // "p"
	frame_dig -3 // assetB: AssetID
	frame_dig -2 // assetA: AssetID
	callsub doCreatePoolToken
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:143
	// this.feeB100000.value = feeB100000
	byte 0x66 // "f"
	frame_dig -4 // feeB100000: uint32
	itob
	extract 4 4
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:145
	// this.doOptIn(assetA)
	frame_dig -2 // assetA: AssetID
	callsub doOptIn

	// contracts\BiatecCLAMM.algo.ts:146
	// this.doOptIn(assetB)
	frame_dig -3 // assetB: AssetID
	callsub doOptIn

	// contracts\BiatecCLAMM.algo.ts:148
	// return this.poolToken.value;
	byte 0x70 // "p"
	app_global_get
	retsub

// doAxfer(receiver: Address, asset: AssetID, amount: uint64): void
doAxfer:
	proto 3 0

	// contracts\BiatecCLAMM.algo.ts:152
	// sendAssetTransfer({
	//       assetReceiver: receiver,
	//       xferAsset: asset,
	//       assetAmount: amount,
	//       fee: 0,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts\BiatecCLAMM.algo.ts:153
	// assetReceiver: receiver
	frame_dig -1 // receiver: Address
	itxn_field AssetReceiver

	// contracts\BiatecCLAMM.algo.ts:154
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// contracts\BiatecCLAMM.algo.ts:155
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// contracts\BiatecCLAMM.algo.ts:156
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// doOptIn(asset: AssetID): void
doOptIn:
	proto 1 0

	// *if0_condition
	// contracts\BiatecCLAMM.algo.ts:161
	// asset.id > 0
	frame_dig -1 // asset: AssetID
	int 0
	>
	bz *if0_end

	// *if0_consequent
	// contracts\BiatecCLAMM.algo.ts:163
	// this.doAxfer(this.app.address, asset, 0)
	int 0
	frame_dig -1 // asset: AssetID
	global CurrentApplicationAddress
	callsub doAxfer

*if0_end:
	retsub

// doCreatePoolToken(assetA: AssetID, assetB: AssetID): AssetID
doCreatePoolToken:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts\BiatecCLAMM.algo.ts:171
	// name = 'B-' + assetA.unitName + '-' + assetB.unitName
	byte 0x422d // "B-"
	frame_dig -1 // assetA: AssetID
	asset_params_get AssetUnitName
	pop
	concat
	byte 0x2d // "-"
	concat
	frame_dig -2 // assetB: AssetID
	asset_params_get AssetUnitName
	pop
	concat
	frame_bury 0 // name: byte[]

	// contracts\BiatecCLAMM.algo.ts:173
	// return sendAssetCreation({
	//       configAssetName: name,
	//       configAssetUnitName: 'BLP',
	//       configAssetTotal: TOTAL_SUPPLY,
	//       configAssetDecimals: LP_TOKEN_DECIMALS,
	//       configAssetManager: this.app.address,
	//       configAssetReserve: this.app.address,
	//     });
	itxn_begin
	int acfg
	itxn_field TypeEnum

	// contracts\BiatecCLAMM.algo.ts:174
	// configAssetName: name
	frame_dig 0 // name: byte[]
	itxn_field ConfigAssetName

	// contracts\BiatecCLAMM.algo.ts:175
	// configAssetUnitName: 'BLP'
	byte 0x424c50 // "BLP"
	itxn_field ConfigAssetUnitName

	// contracts\BiatecCLAMM.algo.ts:176
	// configAssetTotal: TOTAL_SUPPLY
	int 10000000000000000
	itxn_field ConfigAssetTotal

	// contracts\BiatecCLAMM.algo.ts:177
	// configAssetDecimals: LP_TOKEN_DECIMALS
	int 6
	itxn_field ConfigAssetDecimals

	// contracts\BiatecCLAMM.algo.ts:178
	// configAssetManager: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetManager

	// contracts\BiatecCLAMM.algo.ts:179
	// configAssetReserve: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetReserve

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn CreatedAssetID

	// set the subroutine return value
	frame_bury 0
	retsub

// addLiquidity(txn,txn,uint64,uint64,uint64)uint64
*abi_route_addLiquidity:
	// The ABI return prefix
	byte 0x151f7c75

	// assetB: uint64
	txna ApplicationArgs 3
	btoi

	// assetA: uint64
	txna ApplicationArgs 2
	btoi

	// poolAsset: uint64
	txna ApplicationArgs 1
	btoi

	// txAssetBDeposit: txn
	txn GroupIndex
	int 1
	-

	// txAssetADeposit: txn
	txn GroupIndex
	int 2
	-

	// execute addLiquidity(txn,txn,uint64,uint64,uint64)uint64
	callsub addLiquidity
	itob
	concat
	log
	int 1
	return

// addLiquidity(txAssetADeposit: Txn, txAssetBDeposit: Txn, poolAsset: AssetID, assetA: AssetID, assetB: AssetID): uint64
//
// This method adds Asset A and Asset B to the Automated Market Maker Concentrated Liqudidity Pool and send to the liqudidty provider the liqudity token
// @param txAssetADeposit Transfer of asset A to the LP pool
// @param txAssetBDeposit Transfer of asset B to the LP pool
// @param poolAsset LP pool asset
// @param assetA Asset A
// @param assetB Asset B
// @returns LP Token quantity distributed
addLiquidity:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// well formed mint
	// contracts\BiatecCLAMM.algo.ts:202
	// assert(assetA === this.assetA.value)
	frame_dig -4 // assetA: AssetID
	byte 0x61 // "a"
	app_global_get
	==
	assert

	// contracts\BiatecCLAMM.algo.ts:203
	// assert(assetB === this.assetB.value)
	frame_dig -5 // assetB: AssetID
	byte 0x62 // "b"
	app_global_get
	==
	assert

	// contracts\BiatecCLAMM.algo.ts:204
	// assert(poolAsset === this.poolToken.value)
	frame_dig -3 // poolAsset: AssetID
	byte 0x70 // "p"
	app_global_get
	==
	assert

	// *if1_condition
	// contracts\BiatecCLAMM.algo.ts:212
	// true
	int 1
	bz *if1_end

	// *if1_consequent
	// contracts\BiatecCLAMM.algo.ts:213
	// xfer = txAssetADeposit as AssetTransferTxn
	frame_dig -1 // txAssetADeposit: Txn
	dup
	gtxns TypeEnum
	int axfer
	==
	assert
	frame_bury 0 // xfer: axfer

	// contracts\BiatecCLAMM.algo.ts:214
	// verifyAssetTransferTxn(xfer, {
	//         assetReceiver: this.app.address,
	//         xferAsset: assetA,
	//         assetAmount: { greaterThanEqualTo: 0 },
	//       })
	// verify axfer
	frame_dig 0 // xfer: axfer
	gtxns TypeEnum
	int axfer
	==
	assert

	// verify assetReceiver
	frame_dig 0 // xfer: axfer
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert

	// verify xferAsset
	frame_dig 0 // xfer: axfer
	gtxns XferAsset
	frame_dig -4 // assetA: AssetID
	==
	assert

	// verify assetAmount
	frame_dig 0 // xfer: axfer
	gtxns AssetAmount
	int 0
	>=
	assert

*if1_end:
	// *if2_condition
	// contracts\BiatecCLAMM.algo.ts:229
	// true
	int 1
	bz *if2_end

	// *if2_consequent
	// contracts\BiatecCLAMM.algo.ts:230
	// xfer = txAssetBDeposit as AssetTransferTxn
	frame_dig -2 // txAssetBDeposit: Txn
	dup
	gtxns TypeEnum
	int axfer
	==
	assert
	frame_bury 1 // xfer: axfer

	// contracts\BiatecCLAMM.algo.ts:231
	// verifyAssetTransferTxn(xfer, {
	//         assetReceiver: this.app.address,
	//         xferAsset: assetB,
	//         assetAmount: { greaterThanEqualTo: 0 },
	//       })
	// verify axfer
	frame_dig 1 // xfer: axfer
	gtxns TypeEnum
	int axfer
	==
	assert

	// verify assetReceiver
	frame_dig 1 // xfer: axfer
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert

	// verify xferAsset
	frame_dig 1 // xfer: axfer
	gtxns XferAsset
	frame_dig -5 // assetB: AssetID
	==
	assert

	// verify assetAmount
	frame_dig 1 // xfer: axfer
	gtxns AssetAmount
	int 0
	>=
	assert

*if2_end:
	// *if3_condition
	// contracts\BiatecCLAMM.algo.ts:240
	// this.app.address.assetBalance(assetA) === txAssetADeposit.assetAmount &&
	//       this.app.address.assetBalance(assetB) === txAssetBDeposit.assetAmount
	global CurrentApplicationAddress
	frame_dig -4 // assetA: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -1 // txAssetADeposit: Txn
	gtxns AssetAmount
	==
	dup
	bz *skip_and0
	global CurrentApplicationAddress
	frame_dig -5 // assetB: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -2 // txAssetBDeposit: Txn
	gtxns AssetAmount
	==
	&&

*skip_and0:
	bz *if3_end

	// *if3_consequent
	// contracts\BiatecCLAMM.algo.ts:247
	// this.assetABalance.value = txAssetADeposit.assetAmount
	byte 0x6162 // "ab"
	frame_dig -1 // txAssetADeposit: Txn
	gtxns AssetAmount
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:248
	// this.assetBBalance.value = txAssetBDeposit.assetAmount
	byte 0x6262 // "bb"
	frame_dig -2 // txAssetBDeposit: Txn
	gtxns AssetAmount
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:249
	// toMint = this.calculateL(this.assetABalance.value, this.assetBBalance.value)
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	callsub calculateL
	frame_bury 2 // toMint: uint64

	// contracts\BiatecCLAMM.algo.ts:250
	// this.Liqudity.value = toMint
	byte 0x4c // "L"
	frame_dig 2 // toMint: uint64
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:253
	// return toMint;
	frame_dig 2 // toMint: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

*if3_end:
	// contracts\BiatecCLAMM.algo.ts:255
	// return 0;
	int 0

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// calculateL(x: uint64, y: uint64): uint64
calculateL:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 15

	// contracts\BiatecCLAMM.algo.ts:287
	// D1: uint64 = (((x * x) / SCALE) * this.priceMaxA.value) / SCALE
	frame_dig -1 // x: uint64
	frame_dig -1 // x: uint64
	*
	int 1000000000
	/
	byte 0x7061 // "pa"
	app_global_get
	*
	int 1000000000
	/
	frame_bury 0 // D1: uint64

	// contracts\BiatecCLAMM.algo.ts:289
	// D2: uint64 = (y * y) / this.priceMaxB.value
	frame_dig -2 // y: uint64
	frame_dig -2 // y: uint64
	*
	byte 0x7062 // "pb"
	app_global_get
	/
	frame_bury 1 // D2: uint64

	// contracts\BiatecCLAMM.algo.ts:291
	// D3: uint64 = (((2 * x * y) / SCALE) * this.priceMaxASqrt.value) / SCALE / this.priceMaxBSqrt.value
	int 2
	frame_dig -1 // x: uint64
	*
	frame_dig -2 // y: uint64
	*
	int 1000000000
	/
	byte 0x706173 // "pas"
	app_global_get
	*
	int 1000000000
	/
	byte 0x706273 // "pbs"
	app_global_get
	/
	frame_bury 2 // D3: uint64

	// contracts\BiatecCLAMM.algo.ts:294
	// D4: uint64 = (4 * x * y) / SCALE
	int 4
	frame_dig -1 // x: uint64
	*
	frame_dig -2 // y: uint64
	*
	int 1000000000
	/
	frame_bury 3 // D4: uint64

	// contracts\BiatecCLAMM.algo.ts:296
	// D5: uint64 = (((4 * x * y) / SCALE) * this.priceMaxASqrt.value) / SCALE / this.priceMaxBSqrt.value
	int 4
	frame_dig -1 // x: uint64
	*
	frame_dig -2 // y: uint64
	*
	int 1000000000
	/
	byte 0x706173 // "pas"
	app_global_get
	*
	int 1000000000
	/
	byte 0x706273 // "pbs"
	app_global_get
	/
	frame_bury 4 // D5: uint64

	// contracts\BiatecCLAMM.algo.ts:297
	// D = D1 + D2 + D3 + D4 - D5
	frame_dig 0 // D1: uint64
	frame_dig 1 // D2: uint64
	+
	frame_dig 2 // D3: uint64
	+
	frame_dig 3 // D4: uint64
	+
	frame_dig 4 // D5: uint64
	-
	frame_bury 5 // D: uint64

	// contracts\BiatecCLAMM.algo.ts:302
	// L1: uint64 = (x * this.priceMaxASqrt.value) / SCALE
	frame_dig -1 // x: uint64
	byte 0x706173 // "pas"
	app_global_get
	*
	int 1000000000
	/
	frame_bury 6 // L1: uint64

	// contracts\BiatecCLAMM.algo.ts:304
	// L2: uint64 = (y * SCALE) / this.priceMaxBSqrt.value
	frame_dig -2 // y: uint64
	int 1000000000
	*
	byte 0x706273 // "pbs"
	app_global_get
	/
	frame_bury 7 // L2: uint64

	// contracts\BiatecCLAMM.algo.ts:306
	// L3: uint64 = (2 * this.priceMaxASqrt.value * SCALE) / this.priceMaxBSqrt.value
	int 2
	byte 0x706173 // "pas"
	app_global_get
	*
	int 1000000000
	*
	byte 0x706273 // "pbs"
	app_global_get
	/
	frame_bury 8 // L3: uint64

	// contracts\BiatecCLAMM.algo.ts:309
	// D_SQRT = sqrt(SCALE * D)
	int 1000000000
	frame_dig 5 // D: uint64
	*
	sqrt
	frame_bury 9 // D_SQRT: uint64

	// *if4_condition
	// contracts\BiatecCLAMM.algo.ts:311
	// 2 * SCALE > L3
	int 2000000000
	frame_dig 8 // L3: uint64
	>
	bz *if4_end

	// *if4_consequent
	// contracts\BiatecCLAMM.algo.ts:312
	// nom: uint64 = L1 + L2 + D_SQRT
	frame_dig 6 // L1: uint64
	frame_dig 7 // L2: uint64
	+
	frame_dig 9 // D_SQRT: uint64
	+
	frame_bury 10 // nom: uint64

	// contracts\BiatecCLAMM.algo.ts:313
	// den: uint64 = 2 * SCALE - L3
	int 2000000000
	frame_dig 8 // L3: uint64
	-
	frame_bury 11 // den: uint64

	// contracts\BiatecCLAMM.algo.ts:314
	// ret: uint64 = (SCALE * nom) / den
	int 1000000000
	frame_dig 10 // nom: uint64
	*
	frame_dig 11 // den: uint64
	/
	frame_bury 12 // ret: uint64

	// contracts\BiatecCLAMM.algo.ts:315
	// return ret;
	frame_dig 12 // ret: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 12
	retsub

*if4_end:
	// contracts\BiatecCLAMM.algo.ts:317
	// nom: uint64 = L1 + L2 - D_SQRT
	frame_dig 6 // L1: uint64
	frame_dig 7 // L2: uint64
	+
	frame_dig 9 // D_SQRT: uint64
	-
	frame_bury 13 // nom: uint64

	// contracts\BiatecCLAMM.algo.ts:318
	// den: uint64 = L3 - 2 * SCALE
	frame_dig 8 // L3: uint64
	int 2000000000
	-
	frame_bury 14 // den: uint64

	// contracts\BiatecCLAMM.algo.ts:319
	// ret: uint64 = (SCALE * nom) / den
	int 1000000000
	frame_dig 13 // nom: uint64
	*
	frame_dig 14 // den: uint64
	/
	frame_bury 15 // ret: uint64

	// contracts\BiatecCLAMM.algo.ts:320
	// return ret;
	frame_dig 15 // ret: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 15
	retsub

// getHypotheticPrice(uint64,uint64,uint64,uint64,uint64,uint64,uint64)uint64
*abi_route_getHypotheticPrice:
	// The ABI return prefix
	byte 0x151f7c75

	// assetBDecimals: uint64
	txna ApplicationArgs 7
	btoi

	// assetADecimals: uint64
	txna ApplicationArgs 6
	btoi

	// liquidity: uint64
	txna ApplicationArgs 5
	btoi

	// priceMaxBSqrt: uint64
	txna ApplicationArgs 4
	btoi

	// priceMaxASqrt: uint64
	txna ApplicationArgs 3
	btoi

	// assetBQuantity: uint64
	txna ApplicationArgs 2
	btoi

	// assetAQuantity: uint64
	txna ApplicationArgs 1
	btoi

	// execute getHypotheticPrice(uint64,uint64,uint64,uint64,uint64,uint64,uint64)uint64
	callsub getHypotheticPrice
	itob
	concat
	log
	int 1
	return

// getHypotheticPrice(assetAQuantity: uint64, assetBQuantity: uint64, priceMaxASqrt: uint64, priceMaxBSqrt: uint64, liquidity: uint64, assetADecimals: uint64, assetBDecimals: uint64): uint64
//
// Get the current price when asset a has x
// @param assetAQuantity x
// @param assetBQuantity y
// @returns the price with specified quantity with the price range set in the contract
getHypotheticPrice:
	proto 7 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 8

	// contracts\BiatecCLAMM.algo.ts:343
	// assetADelicmalScale2Scale: uint64 = 10 ** (SCALE_DECIMALS - assetADecimals)
	int 10
	int 9
	frame_dig -6 // assetADecimals: uint64
	-
	exp
	frame_bury 0 // assetADelicmalScale2Scale: uint64

	// contracts\BiatecCLAMM.algo.ts:344
	// assetBDelicmalScale2Scale: uint64 = 10 ** (SCALE_DECIMALS - assetBDecimals)
	int 10
	int 9
	frame_dig -7 // assetBDecimals: uint64
	-
	exp
	frame_bury 1 // assetBDelicmalScale2Scale: uint64

	// contracts\BiatecCLAMM.algo.ts:345
	// a: uint64 = priceMaxASqrt
	frame_dig -3 // priceMaxASqrt: uint64
	frame_bury 2 // a: uint64

	// contracts\BiatecCLAMM.algo.ts:346
	// b: uint64 = priceMaxBSqrt
	frame_dig -4 // priceMaxBSqrt: uint64
	frame_bury 3 // b: uint64

	// contracts\BiatecCLAMM.algo.ts:347
	// P1: uint64 = (liquidity * a) / SCALE
	frame_dig -5 // liquidity: uint64
	frame_dig 2 // a: uint64
	*
	int 1000000000
	/
	frame_bury 4 // P1: uint64

	// contracts\BiatecCLAMM.algo.ts:348
	// P2: uint64 = (liquidity * SCALE) / b
	frame_dig -5 // liquidity: uint64
	int 1000000000
	*
	frame_dig 3 // b: uint64
	/
	frame_bury 5 // P2: uint64

	// contracts\BiatecCLAMM.algo.ts:349
	// Nom: uint64 = assetBQuantity * assetBDelicmalScale2Scale + P1
	frame_dig -2 // assetBQuantity: uint64
	frame_dig 1 // assetBDelicmalScale2Scale: uint64
	*
	frame_dig 4 // P1: uint64
	+
	frame_bury 6 // Nom: uint64

	// contracts\BiatecCLAMM.algo.ts:350
	// Denom: uint64 = assetAQuantity * assetADelicmalScale2Scale + P2
	frame_dig -1 // assetAQuantity: uint64
	frame_dig 0 // assetADelicmalScale2Scale: uint64
	*
	frame_dig 5 // P2: uint64
	+
	frame_bury 7 // Denom: uint64

	// contracts\BiatecCLAMM.algo.ts:351
	// ret = (Nom * SCALE) / Denom
	frame_dig 6 // Nom: uint64
	int 1000000000
	*
	frame_dig 7 // Denom: uint64
	/
	frame_bury 8 // ret: uint64

	// contracts\BiatecCLAMM.algo.ts:352
	// return ret;
	frame_dig 8 // ret: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 8
	retsub

// removeLiquidity(axfer,uint64,uint64,uint64)void
*abi_route_removeLiquidity:
	// assetB: uint64
	txna ApplicationArgs 3
	btoi

	// assetA: uint64
	txna ApplicationArgs 2
	btoi

	// poolAsset: uint64
	txna ApplicationArgs 1
	btoi

	// txLPXfer: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==
	assert

	// execute removeLiquidity(axfer,uint64,uint64,uint64)void
	callsub removeLiquidity
	int 1
	return

// removeLiquidity(txLPXfer: AssetTransferTxn, poolAsset: AssetID, assetA: AssetID, assetB: AssetID): void
//
// This method retrieves from the liquidity provider LP token and returns Asset A and Asset B from the Automated Market Maker Concentrated Liqudidity Pool
// @param txLPXfer Transfer of the LP token
// @param poolAsset LP pool asset
// @param assetA Asset A
// @param assetB Asset B
removeLiquidity:
	proto 4 0

	// well formed mint
	// contracts\BiatecCLAMM.algo.ts:364
	// assert(assetA === this.assetA.value)
	frame_dig -3 // assetA: AssetID
	byte 0x61 // "a"
	app_global_get
	==
	assert

	// contracts\BiatecCLAMM.algo.ts:365
	// assert(assetB === this.assetB.value)
	frame_dig -4 // assetB: AssetID
	byte 0x62 // "b"
	app_global_get
	==
	assert

	// contracts\BiatecCLAMM.algo.ts:366
	// assert(poolAsset === this.poolToken.value)
	frame_dig -2 // poolAsset: AssetID
	byte 0x70 // "p"
	app_global_get
	==
	assert

	// contracts\BiatecCLAMM.algo.ts:368
	// verifyAssetTransferTxn(txLPXfer, {
	//       assetReceiver: this.app.address,
	//       xferAsset: poolAsset,
	//       assetAmount: { greaterThanEqualTo: 0 },
	//     })
	// verify assetReceiver
	frame_dig -1 // txLPXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert

	// verify xferAsset
	frame_dig -1 // txLPXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -2 // poolAsset: AssetID
	==
	assert

	// verify assetAmount
	frame_dig -1 // txLPXfer: AssetTransferTxn
	gtxns AssetAmount
	int 0
	>=
	assert
	err

// swap(axfer,uint64,uint64,uint64)void
*abi_route_swap:
	// minimumToReceive: uint64
	txna ApplicationArgs 3
	btoi

	// assetB: uint64
	txna ApplicationArgs 2
	btoi

	// assetA: uint64
	txna ApplicationArgs 1
	btoi

	// txSwap: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==
	assert

	// execute swap(axfer,uint64,uint64,uint64)void
	callsub swap
	int 1
	return

// swap(txSwap: AssetTransferTxn, assetA: AssetID, assetB: AssetID, minimumToReceive: uint64): void
//
// Swap Asset A to Asset B or Asset B to Asst A
// @param txSwap Transfer of the token to be deposited to the pool. To the owner the other asset will be sent.
// @param assetA Asset A
// @param assetB Asset B
// @param minimumToReceive If number greater then zero, the check is performed for the output of the other asset
swap:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// well formed swap
	// contracts\BiatecCLAMM.algo.ts:386
	// assert(assetA === this.assetA.value)
	frame_dig -2 // assetA: AssetID
	byte 0x61 // "a"
	app_global_get
	==
	assert

	// contracts\BiatecCLAMM.algo.ts:387
	// assert(assetB === this.assetB.value)
	frame_dig -3 // assetB: AssetID
	byte 0x62 // "b"
	app_global_get
	==
	assert

	// contracts\BiatecCLAMM.algo.ts:389
	// verifyAssetTransferTxn(txSwap, {
	//       assetAmount: { greaterThan: 0 },
	//       assetReceiver: this.app.address,
	//       sender: this.txn.sender,
	//       xferAsset: { includedIn: [assetA, assetB] },
	//     })
	// verify assetAmount
	frame_dig -1 // txSwap: AssetTransferTxn
	gtxns AssetAmount
	int 0
	>
	assert

	// verify assetReceiver
	frame_dig -1 // txSwap: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert

	// verify sender
	frame_dig -1 // txSwap: AssetTransferTxn
	gtxns Sender
	txn Sender
	==
	assert

	// verify xferAsset
	frame_dig -1 // txSwap: AssetTransferTxn
	gtxns XferAsset
	frame_dig -2 // assetA: AssetID
	==
	frame_dig -1 // txSwap: AssetTransferTxn
	gtxns XferAsset
	frame_dig -3 // assetB: AssetID
	==
	||
	assert

	// *if5_condition
	// contracts\BiatecCLAMM.algo.ts:396
	// txSwap.xferAsset === assetA
	frame_dig -1 // txSwap: AssetTransferTxn
	gtxns XferAsset
	frame_dig -2 // assetA: AssetID
	==
	bz *if5_end

	// *if5_consequent
	// contracts\BiatecCLAMM.algo.ts:397
	// toSwap = this.calculateAssetBWithdrawOnAssetADeposit(txSwap.assetAmount, assetA.decimals, assetB.decimals)
	frame_dig -3 // assetB: AssetID
	asset_params_get AssetDecimals
	pop
	frame_dig -2 // assetA: AssetID
	asset_params_get AssetDecimals
	pop
	frame_dig -1 // txSwap: AssetTransferTxn
	gtxns AssetAmount
	callsub calculateAssetBWithdrawOnAssetADeposit
	frame_bury 0 // toSwap: uint64

	// contracts\BiatecCLAMM.algo.ts:398
	// assert(minimumToReceive >= toSwap)
	frame_dig -4 // minimumToReceive: uint64
	frame_dig 0 // toSwap: uint64
	>=
	assert

	// contracts\BiatecCLAMM.algo.ts:399
	// this.doAxfer(this.txn.sender, assetB, toSwap)
	frame_dig 0 // toSwap: uint64
	frame_dig -3 // assetB: AssetID
	txn Sender
	callsub doAxfer

*if5_end:
	retsub

// calculateAssetBWithdrawOnAssetADeposit(uint64,uint64,uint64)uint64
*abi_route_calculateAssetBWithdrawOnAssetADeposit:
	// The ABI return prefix
	byte 0x151f7c75

	// assetBDecimals: uint64
	txna ApplicationArgs 3
	btoi

	// assetADecimals: uint64
	txna ApplicationArgs 2
	btoi

	// inAmount: uint64
	txna ApplicationArgs 1
	btoi

	// execute calculateAssetBWithdrawOnAssetADeposit(uint64,uint64,uint64)uint64
	callsub calculateAssetBWithdrawOnAssetADeposit
	itob
	concat
	log
	int 1
	return

// calculateAssetBWithdrawOnAssetADeposit(inAmount: uint64, assetADecimals: uint64, assetBDecimals: uint64): uint64
calculateAssetBWithdrawOnAssetADeposit:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 13

	// contracts\BiatecCLAMM.algo.ts:424
	// assetADelicmalScale: uint64 = 10 ** assetADecimals
	int 10
	frame_dig -2 // assetADecimals: uint64
	exp
	frame_bury 0 // assetADelicmalScale: uint64

	// contracts\BiatecCLAMM.algo.ts:425
	// assetBDelicmalScale: uint64 = 10 ** assetBDecimals
	int 10
	frame_dig -3 // assetBDecimals: uint64
	exp
	frame_bury 1 // assetBDelicmalScale: uint64

	// contracts\BiatecCLAMM.algo.ts:427
	// x: uint64 = this.assetABalance.value
	byte 0x6162 // "ab"
	app_global_get
	frame_bury 2 // x: uint64

	// contracts\BiatecCLAMM.algo.ts:428
	// y: uint64 = this.assetBBalance.value
	byte 0x6262 // "bb"
	app_global_get
	frame_bury 3 // y: uint64

	// contracts\BiatecCLAMM.algo.ts:429
	// a: uint64 = this.priceMaxASqrt.value
	byte 0x706173 // "pas"
	app_global_get
	frame_bury 4 // a: uint64

	// contracts\BiatecCLAMM.algo.ts:430
	// b: uint64 = this.priceMaxBSqrt.value
	byte 0x706273 // "pbs"
	app_global_get
	frame_bury 5 // b: uint64

	// contracts\BiatecCLAMM.algo.ts:431
	// L: uint64 = this.Liqudity.value
	byte 0x4c // "L"
	app_global_get
	frame_bury 6 // L: uint64

	// contracts\BiatecCLAMM.algo.ts:433
	// P1: uint64 =
	//       (((((a /* 10D */ * b) /* 10D */ / SCALE) * inAmount) /* AD */ / SCALE) * L) /* 10D */ / assetADelicmalScale
	frame_dig 4 // a: uint64
	frame_dig 5 // b: uint64
	*
	int 1000000000
	/
	frame_dig -1 // inAmount: uint64
	*
	int 1000000000
	/
	frame_dig 6 // L: uint64
	*
	frame_dig 0 // assetADelicmalScale: uint64
	/
	frame_bury 7 // P1: uint64

	// contracts\BiatecCLAMM.algo.ts:436
	// P2: uint64 = (((b /* 10D */ * inAmount) /* AD */ / assetADelicmalScale) * y) /* BD */ / SCALE
	frame_dig 5 // b: uint64
	frame_dig -1 // inAmount: uint64
	*
	frame_dig 0 // assetADelicmalScale: uint64
	/
	frame_dig 3 // y: uint64
	*
	int 1000000000
	/
	frame_bury 8 // P2: uint64

	// contracts\BiatecCLAMM.algo.ts:438
	// P3: uint64 = (b /* 10D */ * inAmount) /* AD */ / assetADelicmalScale
	frame_dig 5 // b: uint64
	frame_dig -1 // inAmount: uint64
	*
	frame_dig 0 // assetADelicmalScale: uint64
	/
	frame_bury 9 // P3: uint64

	// contracts\BiatecCLAMM.algo.ts:440
	// P4: uint64 = (b /* 10D */ * x) /* 10D */ / SCALE
	frame_dig 5 // b: uint64
	frame_dig 2 // x: uint64
	*
	int 1000000000
	/
	frame_bury 10 // P4: uint64

	// contracts\BiatecCLAMM.algo.ts:442
	// P12: uint64 = P1 + P2
	frame_dig 7 // P1: uint64
	frame_dig 8 // P2: uint64
	+
	frame_bury 11 // P12: uint64

	// contracts\BiatecCLAMM.algo.ts:444
	// P345: uint64 = P3 + P4 + L
	frame_dig 9 // P3: uint64
	frame_dig 10 // P4: uint64
	+
	frame_dig 6 // L: uint64
	+
	frame_bury 12 // P345: uint64

	// contracts\BiatecCLAMM.algo.ts:446
	// ret: uint64 = (P12 * assetBDelicmalScale) / P345
	frame_dig 11 // P12: uint64
	frame_dig 1 // assetBDelicmalScale: uint64
	*
	frame_dig 12 // P345: uint64
	/
	frame_bury 13 // ret: uint64

	// contracts\BiatecCLAMM.algo.ts:447
	// return ret;
	frame_dig 13 // ret: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 13
	retsub

*create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication
	err

*call_NoOp:
	method "getCurrentPrice()uint64"
	method "getPriceDivider()uint64"
	method "getLPTokenId()uint64"
	method "bootstrap(pay,uint64,uint64,uint32,uint64,uint64,uint64,uint8,uint64,uint64)uint64"
	method "addLiquidity(txn,txn,uint64,uint64,uint64)uint64"
	method "getHypotheticPrice(uint64,uint64,uint64,uint64,uint64,uint64,uint64)uint64"
	method "removeLiquidity(axfer,uint64,uint64,uint64)void"
	method "swap(axfer,uint64,uint64,uint64)void"
	method "calculateAssetBWithdrawOnAssetADeposit(uint64,uint64,uint64)uint64"
	txna ApplicationArgs 0
	match *abi_route_getCurrentPrice *abi_route_getPriceDivider *abi_route_getLPTokenId *abi_route_bootstrap *abi_route_addLiquidity *abi_route_getHypotheticPrice *abi_route_removeLiquidity *abi_route_swap *abi_route_calculateAssetBWithdrawOnAssetADeposit
	err
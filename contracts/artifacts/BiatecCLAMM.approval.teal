#pragma version 10

// This TEAL was generated by TEALScript v0.86.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	err

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	int 1
	return

// createApplication(): void
//
// Initial setup
createApplication:
	proto 0 0

	// contracts\BiatecCLAMM.algo.ts:79
	// log(version)
	byte "CLAMM-01-01-01"
	log

	// contracts\BiatecCLAMM.algo.ts:80
	// this.governor.value = Address.fromBytes(governor)
	byte 0x67 // "g"
	byte "ALGONAUTSPIUHDCX3SLFXOFDUKOE4VY36XV4JX2JHQTWJNKVBKPEBQACRY"
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:81
	// this.scale.value = SCALE
	byte 0x7363616c65 // "scale"
	int 1000000000
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:82
	// this.feeB100000.value = <uint64>0
	byte 0x66 // "f"
	int 0
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:83
	// this.Liqudity.value = <uint256>0
	byte 0x4c // "L"
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	app_global_put
	retsub

// getCurrentPrice()uint64
*abi_route_getCurrentPrice:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getCurrentPrice()uint64
	callsub getCurrentPrice
	itob
	concat
	log
	int 1
	return

// getCurrentPrice(): uint64
getCurrentPrice:
	proto 0 1

	// contracts\BiatecCLAMM.algo.ts:88
	// return this.ratio.value;
	byte 0x72 // "r"
	app_global_get
	retsub

// getPriceDivider()uint64
*abi_route_getPriceDivider:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getPriceDivider()uint64
	callsub getPriceDivider
	itob
	concat
	log
	int 1
	return

// getPriceDivider(): uint64
getPriceDivider:
	proto 0 1

	// contracts\BiatecCLAMM.algo.ts:93
	// return this.scale.value;
	byte 0x7363616c65 // "scale"
	app_global_get
	retsub

// getLPTokenId()uint64
*abi_route_getLPTokenId:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getLPTokenId()uint64
	callsub getLPTokenId
	itob
	concat
	log
	int 1
	return

// getLPTokenId(): uint64
getLPTokenId:
	proto 0 1

	// contracts\BiatecCLAMM.algo.ts:98
	// return this.poolToken.value.id;
	byte 0x70 // "p"
	app_global_get
	retsub

// bootstrap(pay,uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint64,uint64)uint64
*abi_route_bootstrap:
	// The ABI return prefix
	byte 0x151f7c75

	// poolProvider: uint64
	txna ApplicationArgs 9
	btoi

	// identityProvider: uint64
	txna ApplicationArgs 8
	btoi

	// verificationClass: uint8
	txna ApplicationArgs 7
	dup
	len
	int 1
	==
	assert
	btoi

	// currentPrice: uint64
	txna ApplicationArgs 6
	btoi

	// priceMax: uint64
	txna ApplicationArgs 5
	btoi

	// priceMin: uint64
	txna ApplicationArgs 4
	btoi

	// feeB100000: uint64
	txna ApplicationArgs 3
	btoi

	// assetB: uint64
	txna ApplicationArgs 2
	btoi

	// assetA: uint64
	txna ApplicationArgs 1
	btoi

	// txSeed: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute bootstrap(pay,uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint64,uint64)uint64
	callsub bootstrap
	itob
	concat
	log
	int 1
	return

// bootstrap(txSeed: PayTxn, assetA: AssetID, assetB: AssetID, feeB100000: uint64, priceMin: uint64, priceMax: uint64, currentPrice: uint64, verificationClass: uint8, identityProvider: AppID, poolProvider: AppID): AssetID
//
// Anybody can deploy the clamm smart contract
// @param txSeed Seed transaction so that smart contract can opt in to the assets
// @param assetA Asset A ID must be lower then Asset B ID
// @param assetB Asset B
// @param feeB100000 Fee in 100000 base level. value 10000 = 10000/100000 = 0,1 = 10% fee. 1000 = 1%. 100 = 0,1%. 10 = 0,01% = 1 base point
// @param verificationClass Asset B
// @returns LP token ID
bootstrap:
	proto 10 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts\BiatecCLAMM.algo.ts:122
	// verifyPayTxn(txSeed, { receiver: this.app.address, amount: { greaterThanEqualTo: 300_000 } })
	// verify receiver
	frame_dig -1 // txSeed: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // txSeed: PayTxn
	gtxns Amount
	int 300_000
	>=
	assert

	// contracts\BiatecCLAMM.algo.ts:123
	// assert(this.governor.value === Address.fromBytes(governor))
	byte 0x67 // "g"
	app_global_get
	byte "ALGONAUTSPIUHDCX3SLFXOFDUKOE4VY36XV4JX2JHQTWJNKVBKPEBQACRY"
	==
	assert

	// contracts\BiatecCLAMM.algo.ts:124
	// assert(assetA < assetB)
	frame_dig -2 // assetA: AssetID
	frame_dig -3 // assetB: AssetID
	<
	assert

	// contracts\BiatecCLAMM.algo.ts:125
	// assert(feeB100000 < 1000000)
	frame_dig -4 // feeB100000: uint64
	int 1000000
	<
	assert

	// contracts\BiatecCLAMM.algo.ts:126
	// assert(feeB100000 > 0)
	frame_dig -4 // feeB100000: uint64
	int 0
	>
	assert

	// contracts\BiatecCLAMM.algo.ts:127
	// assert(verificationClass < 4)
	frame_dig -8 // verificationClass: uint8
	int 4
	<
	assert

	// contracts\BiatecCLAMM.algo.ts:128
	// assert(!this.ratio.exists)
	txna Applications 0
	byte 0x72 // "r"
	app_global_get_ex
	swap
	pop
	!
	assert

	// contracts\BiatecCLAMM.algo.ts:129
	// assert(assetA.decimals <= SCALE_DECIMALS)
	frame_dig -2 // assetA: AssetID
	asset_params_get AssetDecimals
	pop
	int 9
	<=
	assert

	// contracts\BiatecCLAMM.algo.ts:130
	// assert(assetB.decimals <= SCALE_DECIMALS)
	frame_dig -3 // assetB: AssetID
	asset_params_get AssetDecimals
	pop
	int 9
	<=
	assert

	// contracts\BiatecCLAMM.algo.ts:131
	// s = SCALE as uint256
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	frame_bury 0 // s: uint256

	// contracts\BiatecCLAMM.algo.ts:133
	// assert(this.feeB100000.value <= 0, 'You can bootstrap contract only once')
	byte 0x66 // "f"
	app_global_get
	int 0
	<=

	// You can bootstrap contract only once
	assert

	// contracts\BiatecCLAMM.algo.ts:135
	// this.identityProvider.value = identityProvider
	byte 0x69 // "i"
	frame_dig -9 // identityProvider: AppID
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:136
	// this.poolProvider.value = poolProvider
	byte 0x7070 // "pp"
	frame_dig -10 // poolProvider: AppID
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:138
	// this.priceMin.value = priceMin
	byte 0x704d696e // "pMin"
	frame_dig -5 // priceMin: uint64
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:139
	// this.priceMax.value = priceMax
	byte 0x704d6178 // "pMax"
	frame_dig -6 // priceMax: uint64
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:140
	// this.priceMinSqrt.value = sqrt((priceMin as uint256) * s)
	byte 0x704d696e53 // "pMinS"
	frame_dig -5 // priceMin: uint64
	itob
	frame_dig 0 // s: uint256
	b*
	bsqrt
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:141
	// this.priceMaxSqrt.value = sqrt((priceMax as uint256) * s)
	byte 0x704d617853 // "pMaxS"
	frame_dig -6 // priceMax: uint64
	itob
	frame_dig 0 // s: uint256
	b*
	bsqrt
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:142
	// this.assetABalance.value = <uint256>0
	byte 0x6162 // "ab"
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:143
	// this.assetBBalance.value = <uint256>0
	byte 0x6262 // "bb"
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:144
	// this.ratio.value = currentPrice
	byte 0x72 // "r"
	frame_dig -7 // currentPrice: uint64
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:146
	// this.assetA.value = assetA
	byte 0x61 // "a"
	frame_dig -2 // assetA: AssetID
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:147
	// this.assetB.value = assetB
	byte 0x62 // "b"
	frame_dig -3 // assetB: AssetID
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:148
	// this.poolToken.value = this.doCreatePoolToken(assetA, assetB)
	byte 0x70 // "p"
	frame_dig -3 // assetB: AssetID
	frame_dig -2 // assetA: AssetID
	callsub doCreatePoolToken
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:149
	// this.feeB100000.value = feeB100000
	byte 0x66 // "f"
	frame_dig -4 // feeB100000: uint64
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:150
	// this.doOptIn(assetA)
	frame_dig -2 // assetA: AssetID
	callsub doOptIn

	// contracts\BiatecCLAMM.algo.ts:151
	// this.doOptIn(assetB)
	frame_dig -3 // assetB: AssetID
	callsub doOptIn

	// contracts\BiatecCLAMM.algo.ts:153
	// return this.poolToken.value;
	byte 0x70 // "p"
	app_global_get

	// set the subroutine return value
	frame_bury 0
	retsub

// doAxfer(receiver: Address, asset: AssetID, amount: uint64): void
doAxfer:
	proto 3 0

	// contracts\BiatecCLAMM.algo.ts:157
	// sendAssetTransfer({
	//       assetReceiver: receiver,
	//       xferAsset: asset,
	//       assetAmount: amount,
	//       fee: 0,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts\BiatecCLAMM.algo.ts:158
	// assetReceiver: receiver
	frame_dig -1 // receiver: Address
	itxn_field AssetReceiver

	// contracts\BiatecCLAMM.algo.ts:159
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// contracts\BiatecCLAMM.algo.ts:160
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// contracts\BiatecCLAMM.algo.ts:161
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// doOptIn(asset: AssetID): void
doOptIn:
	proto 1 0

	// *if0_condition
	// contracts\BiatecCLAMM.algo.ts:166
	// asset.id > 0
	frame_dig -1 // asset: AssetID
	int 0
	>
	bz *if0_end

	// *if0_consequent
	// contracts\BiatecCLAMM.algo.ts:168
	// this.doAxfer(this.app.address, asset, 0)
	int 0
	frame_dig -1 // asset: AssetID
	global CurrentApplicationAddress
	callsub doAxfer

*if0_end:
	retsub

// doCreatePoolToken(assetA: AssetID, assetB: AssetID): AssetID
doCreatePoolToken:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts\BiatecCLAMM.algo.ts:176
	// name = 'B-' + assetA.unitName + '-' + assetB.unitName
	byte 0x422d // "B-"
	frame_dig -1 // assetA: AssetID
	asset_params_get AssetUnitName
	pop
	concat
	byte 0x2d // "-"
	concat
	frame_dig -2 // assetB: AssetID
	asset_params_get AssetUnitName
	pop
	concat
	frame_bury 0 // name: byte[]

	// contracts\BiatecCLAMM.algo.ts:178
	// return sendAssetCreation({
	//       configAssetName: name,
	//       configAssetUnitName: 'BLP',
	//       configAssetTotal: TOTAL_SUPPLY,
	//       configAssetDecimals: LP_TOKEN_DECIMALS,
	//       configAssetManager: this.app.address,
	//       configAssetReserve: this.app.address,
	//     });
	itxn_begin
	int acfg
	itxn_field TypeEnum

	// contracts\BiatecCLAMM.algo.ts:179
	// configAssetName: name
	frame_dig 0 // name: byte[]
	itxn_field ConfigAssetName

	// contracts\BiatecCLAMM.algo.ts:180
	// configAssetUnitName: 'BLP'
	byte 0x424c50 // "BLP"
	itxn_field ConfigAssetUnitName

	// contracts\BiatecCLAMM.algo.ts:181
	// configAssetTotal: TOTAL_SUPPLY
	int 10000000000000000
	itxn_field ConfigAssetTotal

	// contracts\BiatecCLAMM.algo.ts:182
	// configAssetDecimals: LP_TOKEN_DECIMALS
	int 6
	itxn_field ConfigAssetDecimals

	// contracts\BiatecCLAMM.algo.ts:183
	// configAssetManager: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetManager

	// contracts\BiatecCLAMM.algo.ts:184
	// configAssetReserve: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetReserve

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn CreatedAssetID

	// set the subroutine return value
	frame_bury 0
	retsub

// addLiquidity(txn,txn,uint64,uint64,uint64)uint64
*abi_route_addLiquidity:
	// The ABI return prefix
	byte 0x151f7c75

	// assetB: uint64
	txna ApplicationArgs 3
	btoi

	// assetA: uint64
	txna ApplicationArgs 2
	btoi

	// assetLP: uint64
	txna ApplicationArgs 1
	btoi

	// txAssetBDeposit: txn
	txn GroupIndex
	int 1
	-

	// txAssetADeposit: txn
	txn GroupIndex
	int 2
	-

	// execute addLiquidity(txn,txn,uint64,uint64,uint64)uint64
	callsub addLiquidity
	itob
	concat
	log
	int 1
	return

// addLiquidity(txAssetADeposit: Txn, txAssetBDeposit: Txn, assetLP: AssetID, assetA: AssetID, assetB: AssetID): uint64
//
// This method adds Asset A and Asset B to the Automated Market Maker Concentrated Liqudidity Pool and send to the liqudidty provider the liqudity token
// @param txAssetADeposit Transfer of asset A to the LP pool
// @param txAssetBDeposit Transfer of asset B to the LP pool
// @param assetLP Liquidity pool asset
// @param assetA Asset A
// @param assetB Asset B
// @returns LP Token quantity distributed
addLiquidity:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 16

	// contracts\BiatecCLAMM.algo.ts:206
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecCLAMM.algo.ts:207
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// well formed mint
	// contracts\BiatecCLAMM.algo.ts:209
	// assert(assetA === this.assetA.value)
	frame_dig -4 // assetA: AssetID
	byte 0x61 // "a"
	app_global_get
	==
	assert

	// contracts\BiatecCLAMM.algo.ts:210
	// assert(assetB === this.assetB.value)
	frame_dig -5 // assetB: AssetID
	byte 0x62 // "b"
	app_global_get
	==
	assert

	// contracts\BiatecCLAMM.algo.ts:211
	// assert(assetLP === this.poolToken.value)
	frame_dig -3 // assetLP: AssetID
	byte 0x70 // "p"
	app_global_get
	==
	assert

	// contracts\BiatecCLAMM.algo.ts:213
	// assetADelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetA.decimals)) as uint256
	int 10
	int 9
	frame_dig -4 // assetA: AssetID
	asset_params_get AssetDecimals
	pop
	-
	exp
	itob
	frame_bury 0 // assetADelicmalScale2Scale: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:215
	// assetBDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetB.decimals)) as uint256
	int 10
	int 9
	frame_dig -5 // assetB: AssetID
	asset_params_get AssetDecimals
	pop
	-
	exp
	itob
	frame_bury 1 // assetBDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:217
	// assetLPDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - LP_TOKEN_DECIMALS)) as uint256
	int 10
	int 3
	exp
	itob
	frame_bury 2 // assetLPDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:219
	// aDepositInBaseScale = (txAssetADeposit.assetAmount as uint256) * assetADelicmalScale2Scale
	frame_dig -1 // txAssetADeposit: Txn
	gtxns AssetAmount
	itob
	frame_dig 0 // assetADelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 3 // aDepositInBaseScale: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:220
	// bDepositInBaseScale = (txAssetBDeposit.assetAmount as uint256) * assetBDelicmalScale2Scale
	frame_dig -2 // txAssetBDeposit: Txn
	gtxns AssetAmount
	itob
	frame_dig 1 // assetBDelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 4 // bDepositInBaseScale: unsafe uint256

	// *if1_condition
	// contracts\BiatecCLAMM.algo.ts:228
	// true
	int 1
	bz *if1_end

	// *if1_consequent
	// contracts\BiatecCLAMM.algo.ts:229
	// xfer = txAssetADeposit as AssetTransferTxn
	frame_dig -1 // txAssetADeposit: Txn
	dup
	gtxns TypeEnum
	int axfer
	==
	assert
	frame_bury 5 // xfer: axfer

	// contracts\BiatecCLAMM.algo.ts:230
	// verifyAssetTransferTxn(xfer, {
	//         assetReceiver: this.app.address,
	//         xferAsset: assetA,
	//         assetAmount: { greaterThanEqualTo: 0 },
	//       })
	// verify axfer
	frame_dig 5 // xfer: axfer
	gtxns TypeEnum
	int axfer
	==
	assert

	// verify assetReceiver
	frame_dig 5 // xfer: axfer
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert

	// verify xferAsset
	frame_dig 5 // xfer: axfer
	gtxns XferAsset
	frame_dig -4 // assetA: AssetID
	==
	assert

	// verify assetAmount
	frame_dig 5 // xfer: axfer
	gtxns AssetAmount
	int 0
	>=
	assert

*if1_end:
	// *if2_condition
	// contracts\BiatecCLAMM.algo.ts:245
	// true
	int 1
	bz *if2_end

	// *if2_consequent
	// contracts\BiatecCLAMM.algo.ts:246
	// xfer = txAssetBDeposit as AssetTransferTxn
	frame_dig -2 // txAssetBDeposit: Txn
	dup
	gtxns TypeEnum
	int axfer
	==
	assert
	frame_bury 6 // xfer: axfer

	// contracts\BiatecCLAMM.algo.ts:247
	// verifyAssetTransferTxn(xfer, {
	//         assetReceiver: this.app.address,
	//         xferAsset: assetB,
	//         assetAmount: { greaterThanEqualTo: 0 },
	//       })
	// verify axfer
	frame_dig 6 // xfer: axfer
	gtxns TypeEnum
	int axfer
	==
	assert

	// verify assetReceiver
	frame_dig 6 // xfer: axfer
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert

	// verify xferAsset
	frame_dig 6 // xfer: axfer
	gtxns XferAsset
	frame_dig -5 // assetB: AssetID
	==
	assert

	// verify assetAmount
	frame_dig 6 // xfer: axfer
	gtxns AssetAmount
	int 0
	>=
	assert

*if2_end:
	// *if3_condition
	// contracts\BiatecCLAMM.algo.ts:256
	// this.app.address.assetBalance(assetA) === txAssetADeposit.assetAmount &&
	//       this.app.address.assetBalance(assetB) === txAssetBDeposit.assetAmount
	global CurrentApplicationAddress
	frame_dig -4 // assetA: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -1 // txAssetADeposit: Txn
	gtxns AssetAmount
	==
	dup
	bz *skip_and0
	global CurrentApplicationAddress
	frame_dig -5 // assetB: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -2 // txAssetBDeposit: Txn
	gtxns AssetAmount
	==
	&&

*skip_and0:
	bz *if3_end

	// *if3_consequent
	// contracts\BiatecCLAMM.algo.ts:276
	// return this.processAddLiqudity(aDepositInBaseScale, bDepositInBaseScale, assetLPDelicmalScale2Scale);
	frame_dig 2 // assetLPDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 4 // bDepositInBaseScale: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 3 // aDepositInBaseScale: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub processAddLiqudity

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 6
	retsub

*if3_end:
	// contracts\BiatecCLAMM.algo.ts:283
	// a = this.calculateAssetADepositOnAssetBDeposit(
	//       aDepositInBaseScale,
	//       bDepositInBaseScale,
	//       this.assetABalance.value,
	//       this.assetBBalance.value
	//     )
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	frame_dig 4 // bDepositInBaseScale: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 3 // aDepositInBaseScale: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub calculateAssetADepositOnAssetBDeposit
	frame_bury 7 // a: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:290
	// b = this.calculateAssetBDepositOnAssetADeposit(
	//       aDepositInBaseScale,
	//       bDepositInBaseScale,
	//       this.assetABalance.value,
	//       this.assetBBalance.value
	//     )
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	frame_dig 4 // bDepositInBaseScale: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 3 // aDepositInBaseScale: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub calculateAssetBDepositOnAssetADeposit
	frame_bury 8 // b: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:296
	// expectedADepositB64 = (a / assetADelicmalScale2Scale) as uint64
	frame_dig 7 // a: unsafe uint256
	frame_dig 0 // assetADelicmalScale2Scale: unsafe uint256
	b/
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	frame_bury 9 // expectedADepositB64: uint64

	// contracts\BiatecCLAMM.algo.ts:297
	// expectedBDepositB64 = (b / assetBDelicmalScale2Scale) as uint64
	frame_dig 8 // b: unsafe uint256
	frame_dig 1 // assetBDelicmalScale2Scale: unsafe uint256
	b/
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	frame_bury 10 // expectedBDepositB64: uint64

	// *if4_condition
	// contracts\BiatecCLAMM.algo.ts:299
	// expectedADepositB64 > txAssetADeposit.assetAmount
	frame_dig 9 // expectedADepositB64: uint64
	frame_dig -1 // txAssetADeposit: Txn
	gtxns AssetAmount
	>
	bz *if4_end

	// *if4_consequent
	// *if5_condition
	// contracts\BiatecCLAMM.algo.ts:306
	// expectedBDepositB64 > txAssetBDeposit.assetAmount
	frame_dig 10 // expectedBDepositB64: uint64
	frame_dig -2 // txAssetBDeposit: Txn
	gtxns AssetAmount
	>
	bz *if5_end

	// *if5_consequent
	// contracts\BiatecCLAMM.algo.ts:307
	// assert(false, 'Dominant is asset B')
	int 0

	// Dominant is asset B
	assert

*if5_end:
	// *if6_condition
	// contracts\BiatecCLAMM.algo.ts:309
	// txAssetBDeposit.assetAmount - expectedBDepositB64 > 0
	frame_dig -2 // txAssetBDeposit: Txn
	gtxns AssetAmount
	frame_dig 10 // expectedBDepositB64: uint64
	-
	int 0
	>
	bz *if6_end

	// *if6_consequent
	// contracts\BiatecCLAMM.algo.ts:311
	// this.doAxfer(this.txn.sender, assetB, txAssetBDeposit.assetAmount - expectedBDepositB64)
	frame_dig -2 // txAssetBDeposit: Txn
	gtxns AssetAmount
	frame_dig 10 // expectedBDepositB64: uint64
	-
	frame_dig -5 // assetB: AssetID
	txn Sender
	callsub doAxfer

*if6_end:
	// contracts\BiatecCLAMM.algo.ts:313
	// realAssetADeposit = aDepositInBaseScale
	frame_dig 3 // aDepositInBaseScale: unsafe uint256
	frame_bury 11 // realAssetADeposit: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:314
	// realAssetBDeposit =
	//         ((txAssetBDeposit.assetAmount - expectedBDepositB64) as uint256) * assetBDelicmalScale2Scale
	frame_dig -2 // txAssetBDeposit: Txn
	gtxns AssetAmount
	frame_dig 10 // expectedBDepositB64: uint64
	-
	itob
	frame_dig 1 // assetBDelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 12 // realAssetBDeposit: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:316
	// return this.processAddLiqudity(realAssetADeposit, realAssetBDeposit, assetLPDelicmalScale2Scale);
	frame_dig 2 // assetLPDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 12 // realAssetBDeposit: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 11 // realAssetADeposit: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub processAddLiqudity

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 12
	retsub

*if4_end:
	// *if7_condition
	// contracts\BiatecCLAMM.algo.ts:319
	// expectedBDepositB64 > txAssetBDeposit.assetAmount
	frame_dig 10 // expectedBDepositB64: uint64
	frame_dig -2 // txAssetBDeposit: Txn
	gtxns AssetAmount
	>
	bz *if7_end

	// *if7_consequent
	// *if8_condition
	// contracts\BiatecCLAMM.algo.ts:326
	// expectedADepositB64 > txAssetADeposit.assetAmount
	frame_dig 9 // expectedADepositB64: uint64
	frame_dig -1 // txAssetADeposit: Txn
	gtxns AssetAmount
	>
	bz *if8_end

	// *if8_consequent
	// contracts\BiatecCLAMM.algo.ts:327
	// assert(false, 'Dominant is asset A')
	int 0

	// Dominant is asset A
	assert

*if8_end:
	// *if9_condition
	// contracts\BiatecCLAMM.algo.ts:329
	// txAssetADeposit.assetAmount - expectedADepositB64 > 0
	frame_dig -1 // txAssetADeposit: Txn
	gtxns AssetAmount
	frame_dig 9 // expectedADepositB64: uint64
	-
	int 0
	>
	bz *if9_end

	// *if9_consequent
	// contracts\BiatecCLAMM.algo.ts:331
	// this.doAxfer(this.txn.sender, assetB, txAssetADeposit.assetAmount - expectedADepositB64)
	frame_dig -1 // txAssetADeposit: Txn
	gtxns AssetAmount
	frame_dig 9 // expectedADepositB64: uint64
	-
	frame_dig -5 // assetB: AssetID
	txn Sender
	callsub doAxfer

*if9_end:
	// contracts\BiatecCLAMM.algo.ts:333
	// realAssetADeposit =
	//         ((txAssetADeposit.assetAmount - expectedADepositB64) as uint256) * assetADelicmalScale2Scale
	frame_dig -1 // txAssetADeposit: Txn
	gtxns AssetAmount
	frame_dig 9 // expectedADepositB64: uint64
	-
	itob
	frame_dig 0 // assetADelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 13 // realAssetADeposit: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:335
	// realAssetBDeposit = bDepositInBaseScale
	frame_dig 4 // bDepositInBaseScale: unsafe uint256
	frame_bury 14 // realAssetBDeposit: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:336
	// return this.processAddLiqudity(realAssetADeposit, realAssetBDeposit, assetLPDelicmalScale2Scale);
	frame_dig 2 // assetLPDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 14 // realAssetBDeposit: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 13 // realAssetADeposit: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub processAddLiqudity

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 14
	retsub

*if7_end:
	// *if10_condition
	// contracts\BiatecCLAMM.algo.ts:338
	// expectedADepositB64 === txAssetADeposit.assetAmount && expectedBDepositB64 === txAssetBDeposit.assetAmount
	frame_dig 9 // expectedADepositB64: uint64
	frame_dig -1 // txAssetADeposit: Txn
	gtxns AssetAmount
	==
	dup
	bz *skip_and1
	frame_dig 10 // expectedBDepositB64: uint64
	frame_dig -2 // txAssetBDeposit: Txn
	gtxns AssetAmount
	==
	&&

*skip_and1:
	bz *if10_end

	// *if10_consequent
	// contracts\BiatecCLAMM.algo.ts:339
	// realAssetADeposit = aDepositInBaseScale
	frame_dig 3 // aDepositInBaseScale: unsafe uint256
	frame_bury 15 // realAssetADeposit: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:340
	// realAssetBDeposit = bDepositInBaseScale
	frame_dig 4 // bDepositInBaseScale: unsafe uint256
	frame_bury 16 // realAssetBDeposit: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:341
	// return this.processAddLiqudity(realAssetADeposit, realAssetBDeposit, assetLPDelicmalScale2Scale);
	frame_dig 2 // assetLPDelicmalScale2Scale: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 16 // realAssetBDeposit: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 15 // realAssetADeposit: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub processAddLiqudity

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 16
	retsub

*if10_end:
	// contracts\BiatecCLAMM.algo.ts:344
	// assert(false, 'failed to calculate exact liqudidity')
	int 0

	// failed to calculate exact liqudidity
	assert

	// contracts\BiatecCLAMM.algo.ts:345
	// return 0;
	int 0

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 16
	retsub

// processAddLiqudity(realAssetADeposit: uint256, realAssetBDeposit: uint256, assetLPDelicmalScale2Scale: uint256): uint64
processAddLiqudity:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 7

	// contracts\BiatecCLAMM.algo.ts:354
	// this.assetABalance.value = this.assetABalance.value + realAssetADeposit
	byte 0x6162 // "ab"
	dup
	app_global_get
	frame_dig -1 // realAssetADeposit: uint256
	b+
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:355
	// this.assetBBalance.value = this.assetBBalance.value + realAssetBDeposit
	byte 0x6262 // "bb"
	dup
	app_global_get
	frame_dig -2 // realAssetBDeposit: uint256
	b+
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:358
	// x = this.assetABalance.value
	byte 0x6162 // "ab"
	app_global_get
	frame_bury 0 // x: uint256

	// contracts\BiatecCLAMM.algo.ts:359
	// y = this.assetBBalance.value
	byte 0x6262 // "bb"
	app_global_get
	frame_bury 1 // y: uint256

	// contracts\BiatecCLAMM.algo.ts:360
	// priceMin = this.priceMin.value as uint256
	byte 0x704d696e // "pMin"
	app_global_get
	itob
	frame_bury 2 // priceMin: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:361
	// priceMax = this.priceMax.value as uint256
	byte 0x704d6178 // "pMax"
	app_global_get
	itob
	frame_bury 3 // priceMax: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:362
	// priceMinSqrt = this.priceMinSqrt.value
	byte 0x704d696e53 // "pMinS"
	app_global_get
	frame_bury 4 // priceMinSqrt: uint256

	// contracts\BiatecCLAMM.algo.ts:363
	// priceMaxSqrt = this.priceMaxSqrt.value
	byte 0x704d617853 // "pMaxS"
	app_global_get
	frame_bury 5 // priceMaxSqrt: uint256

	// contracts\BiatecCLAMM.algo.ts:364
	// newLiqudity = this.calculateLiquidity(x, y, priceMin, priceMax, priceMinSqrt, priceMaxSqrt)
	frame_dig 5 // priceMaxSqrt: uint256
	frame_dig 4 // priceMinSqrt: uint256
	frame_dig 3 // priceMax: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 2 // priceMin: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig 1 // y: uint256
	frame_dig 0 // x: uint256
	callsub calculateLiquidity
	frame_bury 6 // newLiqudity: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:366
	// lpTokensToSend = ((newLiqudity - this.Liqudity.value) / assetLPDelicmalScale2Scale) as uint64
	frame_dig 6 // newLiqudity: unsafe uint256
	byte 0x4c // "L"
	app_global_get
	b-
	frame_dig -3 // assetLPDelicmalScale2Scale: uint256
	b/
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	frame_bury 7 // lpTokensToSend: uint64

	// contracts\BiatecCLAMM.algo.ts:368
	// this.Liqudity.value = newLiqudity
	byte 0x4c // "L"
	frame_dig 6 // newLiqudity: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:370
	// this.doAxfer(this.txn.sender, this.poolToken.value, lpTokensToSend)
	frame_dig 7 // lpTokensToSend: uint64
	byte 0x70 // "p"
	app_global_get
	txn Sender
	callsub doAxfer

	// contracts\BiatecCLAMM.algo.ts:371
	// return lpTokensToSend;
	frame_dig 7 // lpTokensToSend: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 7
	retsub

// testFailVariableSet()uint64
*abi_route_testFailVariableSet:
	// The ABI return prefix
	byte 0x151f7c75

	// execute testFailVariableSet()uint64
	callsub testFailVariableSet
	itob
	concat
	log
	int 1
	return

// testFailVariableSet(): uint64
testFailVariableSet:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts\BiatecCLAMM.algo.ts:376
	// A = <uint256>250000000
	byte 0x000000000000000000000000000000000000000000000000000000000ee6b280
	frame_bury 0 // A: uint256

	// contracts\BiatecCLAMM.algo.ts:377
	// B = <uint256>1000
	byte 0x00000000000000000000000000000000000000000000000000000000000003e8
	frame_bury 1 // B: uint256

	// contracts\BiatecCLAMM.algo.ts:378
	// A = A / B
	frame_dig 0 // A: uint256
	byte 0x00000000000000000000000000000000000000000000000000000000000003e8 // B: uint256
	b/
	frame_bury 0 // A: uint256

	// contracts\BiatecCLAMM.algo.ts:379
	// c = A as uint64
	frame_dig 0 // A: uint256
	dup
	bitlen
	int 64
	<=
	assert
	extract 24 8
	btoi
	frame_bury 2 // c: uint64

	// contracts\BiatecCLAMM.algo.ts:380
	// return c;
	frame_dig 2 // c: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// removeLiquidity(axfer,uint64,uint64,uint64)uint256
*abi_route_removeLiquidity:
	// The ABI return prefix
	byte 0x151f7c75

	// assetB: uint64
	txna ApplicationArgs 3
	btoi

	// assetA: uint64
	txna ApplicationArgs 2
	btoi

	// assetLP: uint64
	txna ApplicationArgs 1
	btoi

	// txLPXfer: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==
	assert

	// execute removeLiquidity(axfer,uint64,uint64,uint64)uint256
	callsub removeLiquidity
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// removeLiquidity(txLPXfer: AssetTransferTxn, assetLP: AssetID, assetA: AssetID, assetB: AssetID): uint256
//
// This method retrieves from the liquidity provider LP token and returns Asset A and Asset B from the Automated Market Maker Concentrated Liqudidity Pool
// @param txLPXfer Transfer of the LP token
// @param assetLP LP pool asset
// @param assetA Asset A
// @param assetB Asset B
// @returns LP position reduced
removeLiquidity:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 12

	// well formed mint
	// contracts\BiatecCLAMM.algo.ts:393
	// assert(assetA === this.assetA.value)
	frame_dig -3 // assetA: AssetID
	byte 0x61 // "a"
	app_global_get
	==
	assert

	// contracts\BiatecCLAMM.algo.ts:394
	// assert(assetB === this.assetB.value)
	frame_dig -4 // assetB: AssetID
	byte 0x62 // "b"
	app_global_get
	==
	assert

	// contracts\BiatecCLAMM.algo.ts:395
	// assert(assetLP === this.poolToken.value)
	frame_dig -2 // assetLP: AssetID
	byte 0x70 // "p"
	app_global_get
	==
	assert

	// contracts\BiatecCLAMM.algo.ts:397
	// verifyAssetTransferTxn(txLPXfer, {
	//       assetReceiver: this.app.address,
	//       xferAsset: assetLP,
	//       assetAmount: { greaterThanEqualTo: 0 },
	//     })
	// verify assetReceiver
	frame_dig -1 // txLPXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert

	// verify xferAsset
	frame_dig -1 // txLPXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -2 // assetLP: AssetID
	==
	assert

	// verify assetAmount
	frame_dig -1 // txLPXfer: AssetTransferTxn
	gtxns AssetAmount
	int 0
	>=
	assert

	// contracts\BiatecCLAMM.algo.ts:404
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecCLAMM.algo.ts:407
	// assetADelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetA.decimals)) as uint256
	int 10
	int 9
	frame_dig -3 // assetA: AssetID
	asset_params_get AssetDecimals
	pop
	-
	exp
	itob
	frame_bury 0 // assetADelicmalScale2Scale: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:409
	// assetBDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetB.decimals)) as uint256
	int 10
	int 9
	frame_dig -4 // assetB: AssetID
	asset_params_get AssetDecimals
	pop
	-
	exp
	itob
	frame_bury 1 // assetBDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:411
	// assetLPDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - LP_TOKEN_DECIMALS)) as uint256
	int 10
	int 3
	exp
	itob
	frame_bury 2 // assetLPDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:413
	// lpDelta = txLPXfer.assetAmount as uint256
	frame_dig -1 // txLPXfer: AssetTransferTxn
	gtxns AssetAmount
	itob
	frame_bury 3 // lpDelta: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:414
	// lpDeltaBase = lpDelta * assetLPDelicmalScale2Scale
	frame_dig 3 // lpDelta: unsafe uint256
	frame_dig 2 // assetLPDelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 4 // lpDeltaBase: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:416
	// aToSend = this.calculateAssetAWithdrawOnLpDeposit(lpDeltaBase, this.assetABalance.value, this.Liqudity.value)
	byte 0x4c // "L"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	frame_dig 4 // lpDeltaBase: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub calculateAssetAWithdrawOnLpDeposit
	frame_bury 5 // aToSend: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:417
	// aToSend64 = (aToSend / assetADelicmalScale2Scale) as uint64
	frame_dig 5 // aToSend: unsafe uint256
	frame_dig 0 // assetADelicmalScale2Scale: unsafe uint256
	b/
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	frame_bury 6 // aToSend64: uint64

	// *if11_condition
	// contracts\BiatecCLAMM.algo.ts:418
	// aToSend64 > 0
	frame_dig 6 // aToSend64: uint64
	int 0
	>
	bz *if11_end

	// *if11_consequent
	// contracts\BiatecCLAMM.algo.ts:419
	// this.doAxfer(this.txn.sender, assetA, aToSend64)
	frame_dig 6 // aToSend64: uint64
	frame_dig -3 // assetA: AssetID
	txn Sender
	callsub doAxfer

*if11_end:
	// contracts\BiatecCLAMM.algo.ts:421
	// bToSend = this.calculateAssetAWithdrawOnLpDeposit(lpDeltaBase, this.assetBBalance.value, this.Liqudity.value)
	byte 0x4c // "L"
	app_global_get
	byte 0x6262 // "bb"
	app_global_get
	frame_dig 4 // lpDeltaBase: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub calculateAssetAWithdrawOnLpDeposit
	frame_bury 7 // bToSend: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:422
	// bToSend64 = (bToSend / assetBDelicmalScale2Scale) as uint64
	frame_dig 7 // bToSend: unsafe uint256
	frame_dig 1 // assetBDelicmalScale2Scale: unsafe uint256
	b/
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	frame_bury 8 // bToSend64: uint64

	// *if12_condition
	// contracts\BiatecCLAMM.algo.ts:423
	// bToSend64 > 0
	frame_dig 8 // bToSend64: uint64
	int 0
	>
	bz *if12_end

	// *if12_consequent
	// contracts\BiatecCLAMM.algo.ts:424
	// this.doAxfer(this.txn.sender, assetB, bToSend64)
	frame_dig 8 // bToSend64: uint64
	frame_dig -4 // assetB: AssetID
	txn Sender
	callsub doAxfer

*if12_end:
	// contracts\BiatecCLAMM.algo.ts:427
	// newAssetA = this.assetABalance.value - aToSend
	byte 0x6162 // "ab"
	app_global_get
	frame_dig 5 // aToSend: unsafe uint256
	b-
	frame_bury 9 // newAssetA: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:428
	// newAssetB = this.assetBBalance.value - bToSend
	byte 0x6262 // "bb"
	app_global_get
	frame_dig 7 // bToSend: unsafe uint256
	b-
	frame_bury 10 // newAssetB: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:429
	// newL = this.Liqudity.value - lpDeltaBase
	byte 0x4c // "L"
	app_global_get
	frame_dig 4 // lpDeltaBase: unsafe uint256
	b-
	frame_bury 11 // newL: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:430
	// this.assetABalance.value = newAssetA
	byte 0x6162 // "ab"
	frame_dig 9 // newAssetA: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:431
	// this.assetBBalance.value = newAssetB
	byte 0x6262 // "bb"
	frame_dig 10 // newAssetB: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:432
	// this.Liqudity.value = newL
	byte 0x4c // "L"
	frame_dig 11 // newL: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:436
	// lAfter = this.calculateLiquidity(
	//       this.assetABalance.value,
	//       this.assetBBalance.value,
	//       this.priceMin.value as uint256, // priceMin: uint256,
	//       this.priceMax.value as uint256, // priceMax: uint256,
	//       this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//       this.priceMaxSqrt.value // priceMaxSqrt: uint256,
	//     )
	byte 0x704d617853 // "pMaxS"
	app_global_get
	byte 0x704d696e53 // "pMinS"
	app_global_get
	byte 0x704d6178 // "pMax"
	app_global_get
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	byte 0x704d696e // "pMin"
	app_global_get
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	callsub calculateLiquidity
	frame_bury 12 // lAfter: unsafe uint256

	// *if13_condition
	// contracts\BiatecCLAMM.algo.ts:444
	// newL !== lAfter
	frame_dig 11 // newL: unsafe uint256
	frame_dig 12 // lAfter: unsafe uint256
	b!=
	bz *if13_end

	// *if13_consequent
	// contracts\BiatecCLAMM.algo.ts:445
	// assert(newL === lAfter, 'New liquidity does not match')
	frame_dig 11 // newL: unsafe uint256
	frame_dig 12 // lAfter: unsafe uint256
	b==

	// New liquidity does not match
	assert

*if13_end:
	// contracts\BiatecCLAMM.algo.ts:448
	// return txLPXfer.assetAmount as uint256;
	frame_dig -1 // txLPXfer: AssetTransferTxn
	gtxns AssetAmount
	itob

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 12
	retsub

// swap(axfer,uint64,uint64,uint64)uint256
*abi_route_swap:
	// The ABI return prefix
	byte 0x151f7c75

	// minimumToReceive: uint64
	txna ApplicationArgs 3
	btoi

	// assetB: uint64
	txna ApplicationArgs 2
	btoi

	// assetA: uint64
	txna ApplicationArgs 1
	btoi

	// txSwap: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==
	assert

	// execute swap(axfer,uint64,uint64,uint64)uint256
	callsub swap
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// swap(txSwap: AssetTransferTxn, assetA: AssetID, assetB: AssetID, minimumToReceive: uint64): uint256
//
// Swap Asset A to Asset B or Asset B to Asst A
// @param txSwap Transfer of the token to be deposited to the pool. To the owner the other asset will be sent.
// @param assetA Asset A
// @param assetB Asset B
// @param minimumToReceive If number greater then zero, the check is performed for the output of the other asset
swap:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 12

	// contracts\BiatecCLAMM.algo.ts:459
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// well formed swap
	// contracts\BiatecCLAMM.algo.ts:461
	// assert(assetA === this.assetA.value)
	frame_dig -2 // assetA: AssetID
	byte 0x61 // "a"
	app_global_get
	==
	assert

	// contracts\BiatecCLAMM.algo.ts:462
	// assert(assetB === this.assetB.value)
	frame_dig -3 // assetB: AssetID
	byte 0x62 // "b"
	app_global_get
	==
	assert

	// contracts\BiatecCLAMM.algo.ts:464
	// verifyAssetTransferTxn(txSwap, {
	//       assetAmount: { greaterThan: 0 },
	//       assetReceiver: this.app.address,
	//       sender: this.txn.sender,
	//       xferAsset: { includedIn: [assetA, assetB] },
	//     })
	// verify assetAmount
	frame_dig -1 // txSwap: AssetTransferTxn
	gtxns AssetAmount
	int 0
	>
	assert

	// verify assetReceiver
	frame_dig -1 // txSwap: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert

	// verify sender
	frame_dig -1 // txSwap: AssetTransferTxn
	gtxns Sender
	txn Sender
	==
	assert

	// verify xferAsset
	frame_dig -1 // txSwap: AssetTransferTxn
	gtxns XferAsset
	frame_dig -2 // assetA: AssetID
	==
	frame_dig -1 // txSwap: AssetTransferTxn
	gtxns XferAsset
	frame_dig -3 // assetB: AssetID
	==
	||
	assert

	// contracts\BiatecCLAMM.algo.ts:471
	// assetADelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetA.decimals)) as uint256
	int 10
	int 9
	frame_dig -2 // assetA: AssetID
	asset_params_get AssetDecimals
	pop
	-
	exp
	itob
	frame_bury 0 // assetADelicmalScale2Scale: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:473
	// assetBDelicmalScale2Scale = (10 ** (SCALE_DECIMALS - assetB.decimals)) as uint256
	int 10
	int 9
	frame_dig -3 // assetB: AssetID
	asset_params_get AssetDecimals
	pop
	-
	exp
	itob
	frame_bury 1 // assetBDelicmalScale2Scale: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:474
	// ret: uint64 = 0
	int 0
	frame_bury 2 // ret: uint64

	// *if14_condition
	// contracts\BiatecCLAMM.algo.ts:475
	// txSwap.xferAsset === assetA
	frame_dig -1 // txSwap: AssetTransferTxn
	gtxns XferAsset
	frame_dig -2 // assetA: AssetID
	==
	bz *if14_end

	// *if14_consequent
	// contracts\BiatecCLAMM.algo.ts:476
	// assetInAssetDecimals = txSwap.assetAmount as uint256
	frame_dig -1 // txSwap: AssetTransferTxn
	gtxns AssetAmount
	itob
	frame_bury 3 // assetInAssetDecimals: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:477
	// inAsset = assetInAssetDecimals * assetADelicmalScale2Scale
	frame_dig 3 // assetInAssetDecimals: unsafe uint256
	frame_dig 0 // assetADelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 4 // inAsset: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:478
	// toSwap = this.calculateAssetBWithdrawOnAssetADeposit(
	//         inAsset,
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMinSqrt.value,
	//         this.priceMaxSqrt.value,
	//         this.Liqudity.value
	//       )
	byte 0x4c // "L"
	app_global_get
	byte 0x704d617853 // "pMaxS"
	app_global_get
	byte 0x704d696e53 // "pMinS"
	app_global_get
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	frame_dig 4 // inAsset: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub calculateAssetBWithdrawOnAssetADeposit
	frame_bury 5 // toSwap: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:487
	// toSwapBDecimals = (toSwap / assetBDelicmalScale2Scale) as uint64
	frame_dig 5 // toSwap: unsafe uint256
	frame_dig 1 // assetBDelicmalScale2Scale: unsafe uint256
	b/
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	frame_bury 6 // toSwapBDecimals: uint64

	// contracts\BiatecCLAMM.algo.ts:488
	// ret = toSwapBDecimals
	frame_dig 6 // toSwapBDecimals: uint64
	frame_bury 2 // ret: uint64

	// *if15_condition
	// contracts\BiatecCLAMM.algo.ts:489
	// minimumToReceive > 0
	frame_dig -4 // minimumToReceive: uint64
	int 0
	>
	bz *if15_end

	// *if15_consequent
	// contracts\BiatecCLAMM.algo.ts:491
	// assert(minimumToReceive >= toSwapBDecimals)
	frame_dig -4 // minimumToReceive: uint64
	frame_dig 6 // toSwapBDecimals: uint64
	>=
	assert

*if15_end:
	// contracts\BiatecCLAMM.algo.ts:494
	// this.doAxfer(this.txn.sender, assetB, toSwapBDecimals)
	frame_dig 6 // toSwapBDecimals: uint64
	frame_dig -3 // assetB: AssetID
	txn Sender
	callsub doAxfer

	// contracts\BiatecCLAMM.algo.ts:496
	// this.assetABalance.value =
	//         (this.app.address.assetBalance(this.assetA.value) as uint256) * assetADelicmalScale2Scale
	byte 0x6162 // "ab"
	global CurrentApplicationAddress
	byte 0x61 // "a"
	app_global_get
	asset_holding_get AssetBalance
	pop
	itob
	frame_dig 0 // assetADelicmalScale2Scale: unsafe uint256
	b*
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:498
	// this.assetBBalance.value =
	//         (this.app.address.assetBalance(this.assetB.value) as uint256) * assetBDelicmalScale2Scale
	byte 0x6262 // "bb"
	global CurrentApplicationAddress
	byte 0x62 // "b"
	app_global_get
	asset_holding_get AssetBalance
	pop
	itob
	frame_dig 1 // assetBDelicmalScale2Scale: unsafe uint256
	b*
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

*if14_end:
	// *if16_condition
	// contracts\BiatecCLAMM.algo.ts:502
	// txSwap.xferAsset === assetB
	frame_dig -1 // txSwap: AssetTransferTxn
	gtxns XferAsset
	frame_dig -3 // assetB: AssetID
	==
	bz *if16_end

	// *if16_consequent
	// contracts\BiatecCLAMM.algo.ts:503
	// assetInAssetDecimals = txSwap.assetAmount as uint256
	frame_dig -1 // txSwap: AssetTransferTxn
	gtxns AssetAmount
	itob
	frame_bury 7 // assetInAssetDecimals: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:504
	// inAsset = assetInAssetDecimals * assetBDelicmalScale2Scale
	frame_dig 7 // assetInAssetDecimals: unsafe uint256
	frame_dig 1 // assetBDelicmalScale2Scale: unsafe uint256
	b*
	frame_bury 8 // inAsset: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:505
	// toSwap = this.calculateAssetAWithdrawOnAssetBDeposit(
	//         inAsset,
	//         this.assetABalance.value,
	//         this.assetBBalance.value,
	//         this.priceMinSqrt.value,
	//         this.priceMaxSqrt.value,
	//         this.Liqudity.value
	//       )
	byte 0x4c // "L"
	app_global_get
	byte 0x704d617853 // "pMaxS"
	app_global_get
	byte 0x704d696e53 // "pMinS"
	app_global_get
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	frame_dig 8 // inAsset: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub calculateAssetAWithdrawOnAssetBDeposit
	frame_bury 9 // toSwap: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:514
	// toSwapADecimals = (toSwap / assetADelicmalScale2Scale) as uint64
	frame_dig 9 // toSwap: unsafe uint256
	frame_dig 0 // assetADelicmalScale2Scale: unsafe uint256
	b/
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	frame_bury 10 // toSwapADecimals: uint64

	// contracts\BiatecCLAMM.algo.ts:515
	// ret = toSwapADecimals
	frame_dig 10 // toSwapADecimals: uint64
	frame_bury 2 // ret: uint64

	// *if17_condition
	// contracts\BiatecCLAMM.algo.ts:516
	// minimumToReceive > 0
	frame_dig -4 // minimumToReceive: uint64
	int 0
	>
	bz *if17_end

	// *if17_consequent
	// contracts\BiatecCLAMM.algo.ts:518
	// assert(minimumToReceive >= toSwapADecimals)
	frame_dig -4 // minimumToReceive: uint64
	frame_dig 10 // toSwapADecimals: uint64
	>=
	assert

*if17_end:
	// contracts\BiatecCLAMM.algo.ts:521
	// this.doAxfer(this.txn.sender, assetA, toSwapADecimals)
	frame_dig 10 // toSwapADecimals: uint64
	frame_dig -2 // assetA: AssetID
	txn Sender
	callsub doAxfer

	// contracts\BiatecCLAMM.algo.ts:523
	// this.assetABalance.value =
	//         (this.app.address.assetBalance(this.assetA.value) as uint256) * assetADelicmalScale2Scale
	byte 0x6162 // "ab"
	global CurrentApplicationAddress
	byte 0x61 // "a"
	app_global_get
	asset_holding_get AssetBalance
	pop
	itob
	frame_dig 0 // assetADelicmalScale2Scale: unsafe uint256
	b*
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:525
	// this.assetBBalance.value =
	//         (this.app.address.assetBalance(this.assetB.value) as uint256) * assetBDelicmalScale2Scale
	byte 0x6262 // "bb"
	global CurrentApplicationAddress
	byte 0x62 // "b"
	app_global_get
	asset_holding_get AssetBalance
	pop
	itob
	frame_dig 1 // assetBDelicmalScale2Scale: unsafe uint256
	b*
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put

*if16_end:
	// contracts\BiatecCLAMM.algo.ts:529
	// newPrice = this.calculatePrice(
	//       this.assetABalance.value, // assetAQuantity: uint256,
	//       this.assetBBalance.value, // assetBQuantity: uint256,
	//       this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//       this.priceMaxSqrt.value, // priceMaxSqrt: uint256,
	//       this.Liqudity.value // liquidity: uint256
	//     )
	byte 0x4c // "L"
	app_global_get
	byte 0x704d617853 // "pMaxS"
	app_global_get
	byte 0x704d696e53 // "pMinS"
	app_global_get
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	callsub calculatePrice
	frame_bury 11 // newPrice: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:536
	// this.ratio.value = newPrice as uint64
	byte 0x72 // "r"
	frame_dig 11 // newPrice: unsafe uint256
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	app_global_put

	// contracts\BiatecCLAMM.algo.ts:540
	// newL = this.calculateLiquidity(
	//       this.assetABalance.value,
	//       this.assetBBalance.value,
	//       this.priceMin.value as uint256, // priceMin: uint256,
	//       this.priceMax.value as uint256, // priceMax: uint256,
	//       this.priceMinSqrt.value, // priceMinSqrt: uint256,
	//       this.priceMaxSqrt.value // priceMaxSqrt: uint256,
	//     )
	byte 0x704d617853 // "pMaxS"
	app_global_get
	byte 0x704d696e53 // "pMinS"
	app_global_get
	byte 0x704d6178 // "pMax"
	app_global_get
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	byte 0x704d696e // "pMin"
	app_global_get
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	byte 0x6262 // "bb"
	app_global_get
	byte 0x6162 // "ab"
	app_global_get
	callsub calculateLiquidity
	frame_bury 12 // newL: unsafe uint256

	// *if18_condition
	// contracts\BiatecCLAMM.algo.ts:548
	// newL !== this.Liqudity.value
	frame_dig 12 // newL: unsafe uint256
	byte 0x4c // "L"
	app_global_get
	b!=
	bz *if18_end

	// *if18_consequent
	// contracts\BiatecCLAMM.algo.ts:549
	// assert(newL === this.Liqudity.value, 'New liquidity does not match')
	frame_dig 12 // newL: unsafe uint256
	byte 0x4c // "L"
	app_global_get
	b==

	// New liquidity does not match
	assert

*if18_end:
	// contracts\BiatecCLAMM.algo.ts:551
	// return ret as uint256;
	frame_dig 2 // ret: uint64
	itob

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 12
	retsub

// calculateLiquidity(uint256,uint256,uint256,uint256,uint256,uint256)uint256
*abi_route_calculateLiquidity:
	// The ABI return prefix
	byte 0x151f7c75

	// priceMaxSqrt: uint256
	txna ApplicationArgs 6
	dup
	len
	int 32
	==
	assert

	// priceMinSqrt: uint256
	txna ApplicationArgs 5
	dup
	len
	int 32
	==
	assert

	// priceMax: uint256
	txna ApplicationArgs 4
	dup
	len
	int 32
	==
	assert

	// priceMin: uint256
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// y: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// x: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute calculateLiquidity(uint256,uint256,uint256,uint256,uint256,uint256)uint256
	callsub calculateLiquidity
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// calculateLiquidity(x: uint256, y: uint256, priceMin: uint256, priceMax: uint256, priceMinSqrt: uint256, priceMaxSqrt: uint256): uint256
//
// Calculates the liquidity  from the x - Asset A position and y - Asset B position
//
// @param x Asset A position balanced on the curve
// @param y Asset B position balanced on the curve
// @param priceMin Minimum price variable in base scale decimals (pa)
// @param priceMax Maximum price variable in base scale decimals (pb)
// @param priceMinSqrt sqrt(priceMin) in base scale decimals Variable pas
// @param priceMaxSqrt sqrt(priceMax) in base scale decimals Variable pbs
// @returns Liquidity is constant in swapping each direction. On deposit the diff between the liquidity is number of LP tokens received by user.
calculateLiquidity:
	proto 6 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 19

	// contracts\BiatecCLAMM.algo.ts:574
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts\BiatecCLAMM.algo.ts:602
	// s = SCALE as uint256
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	frame_bury 0 // s: uint256

	// contracts\BiatecCLAMM.algo.ts:604
	// D1 = (((x * x) / s) * priceMin) / s
	frame_dig -1 // x: uint256
	frame_dig -1 // x: uint256
	b*
	frame_dig 0 // s: uint256
	b/
	frame_dig -3 // priceMin: uint256
	b*
	frame_dig 0 // s: uint256
	b/
	frame_bury 1 // D1: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:606
	// D2 = (y * y) / priceMax
	frame_dig -2 // y: uint256
	frame_dig -2 // y: uint256
	b*
	frame_dig -4 // priceMax: uint256
	b/
	frame_bury 2 // D2: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:608
	// D3 = (((<uint256>2 * x * y) / s) * priceMinSqrt) / s / priceMaxSqrt
	byte 0x0000000000000000000000000000000000000000000000000000000000000002
	frame_dig -1 // x: uint256
	b*
	frame_dig -2 // y: uint256
	b*
	frame_dig 0 // s: uint256
	b/
	frame_dig -5 // priceMinSqrt: uint256
	b*
	frame_dig 0 // s: uint256
	b/
	frame_dig -6 // priceMaxSqrt: uint256
	b/
	frame_bury 3 // D3: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:611
	// D4 = (<uint256>4 * x * y) / s
	byte 0x0000000000000000000000000000000000000000000000000000000000000004
	frame_dig -1 // x: uint256
	b*
	frame_dig -2 // y: uint256
	b*
	frame_dig 0 // s: uint256
	b/
	frame_bury 4 // D4: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:613
	// D5 = (((<uint256>4 * x * y) / s) * priceMinSqrt) / s / priceMaxSqrt
	byte 0x0000000000000000000000000000000000000000000000000000000000000004
	frame_dig -1 // x: uint256
	b*
	frame_dig -2 // y: uint256
	b*
	frame_dig 0 // s: uint256
	b/
	frame_dig -5 // priceMinSqrt: uint256
	b*
	frame_dig 0 // s: uint256
	b/
	frame_dig -6 // priceMaxSqrt: uint256
	b/
	frame_bury 5 // D5: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:614
	// D = D1 + D2 + D3 + D4 - D5
	frame_dig 1 // D1: unsafe uint256
	frame_dig 2 // D2: unsafe uint256
	b+
	frame_dig 3 // D3: unsafe uint256
	b+
	frame_dig 4 // D4: unsafe uint256
	b+
	frame_dig 5 // D5: unsafe uint256
	b-
	frame_bury 6 // D: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:618
	// L1 = (x * priceMinSqrt) / s
	frame_dig -1 // x: uint256
	frame_dig -5 // priceMinSqrt: uint256
	b*
	frame_dig 0 // s: uint256
	b/
	frame_bury 7 // L1: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:621
	// L2 = (y * s) / priceMaxSqrt
	frame_dig -2 // y: uint256
	frame_dig 0 // s: uint256
	b*
	frame_dig -6 // priceMaxSqrt: uint256
	b/
	frame_bury 8 // L2: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:623
	// L3_0 = <uint256>2
	byte 0x0000000000000000000000000000000000000000000000000000000000000002
	frame_bury 9 // L3_0: uint256

	// contracts\BiatecCLAMM.algo.ts:624
	// L3_1 = L3_0 * priceMinSqrt
	byte 0x0000000000000000000000000000000000000000000000000000000000000002 // L3_0: uint256
	frame_dig -5 // priceMinSqrt: uint256
	b*
	frame_bury 10 // L3_1: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:626
	// L3_2 = L3_1 * s
	frame_dig 10 // L3_1: unsafe uint256
	frame_dig 0 // s: uint256
	b*
	frame_bury 11 // L3_2: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:627
	// L3 = L3_2 / priceMaxSqrt
	frame_dig 11 // L3_2: unsafe uint256
	frame_dig -6 // priceMaxSqrt: uint256
	b/
	frame_bury 12 // L3: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:630
	// D_SQRT = sqrt(s * D)
	frame_dig 0 // s: uint256
	frame_dig 6 // D: unsafe uint256
	b*
	bsqrt
	frame_bury 13 // D_SQRT: unsafe uint256

	// *if19_condition
	// contracts\BiatecCLAMM.algo.ts:632
	// <uint256>2 * s > L3
	byte 0x0000000000000000000000000000000000000000000000000000000000000002
	frame_dig 0 // s: uint256
	b*
	frame_dig 12 // L3: unsafe uint256
	b>
	bz *if19_end

	// *if19_consequent
	// contracts\BiatecCLAMM.algo.ts:633
	// nom = L1 + L2 + D_SQRT
	frame_dig 7 // L1: unsafe uint256
	frame_dig 8 // L2: unsafe uint256
	b+
	frame_dig 13 // D_SQRT: unsafe uint256
	b+
	frame_bury 14 // nom: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:634
	// den = <uint256>2 * s - L3
	byte 0x0000000000000000000000000000000000000000000000000000000000000002
	frame_dig 0 // s: uint256
	b*
	frame_dig 12 // L3: unsafe uint256
	b-
	frame_bury 15 // den: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:635
	// ret = (s * nom) / den
	frame_dig 0 // s: uint256
	frame_dig 14 // nom: unsafe uint256
	b*
	frame_dig 15 // den: unsafe uint256
	b/
	frame_bury 16 // ret: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:636
	// return ret;
	frame_dig 16 // ret: unsafe uint256

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 16
	retsub

*if19_end:
	// contracts\BiatecCLAMM.algo.ts:638
	// nom = L1 + L2 - D_SQRT
	frame_dig 7 // L1: unsafe uint256
	frame_dig 8 // L2: unsafe uint256
	b+
	frame_dig 13 // D_SQRT: unsafe uint256
	b-
	frame_bury 17 // nom: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:639
	// den = L3 - <uint256>2 * s
	frame_dig 12 // L3: unsafe uint256
	byte 0x0000000000000000000000000000000000000000000000000000000000000002
	frame_dig 0 // s: uint256
	b*
	b-
	frame_bury 18 // den: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:640
	// ret = (s * nom) / den
	frame_dig 0 // s: uint256
	frame_dig 17 // nom: unsafe uint256
	b*
	frame_dig 18 // den: unsafe uint256
	b/
	frame_bury 19 // ret: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:641
	// return ret;
	frame_dig 19 // ret: unsafe uint256

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 19
	retsub

// calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256
*abi_route_calculatePrice:
	// The ABI return prefix
	byte 0x151f7c75

	// liquidity: uint256
	txna ApplicationArgs 5
	dup
	len
	int 32
	==
	assert

	// priceMaxSqrt: uint256
	txna ApplicationArgs 4
	dup
	len
	int 32
	==
	assert

	// priceMinSqrt: uint256
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// assetBQuantity: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// assetAQuantity: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256
	callsub calculatePrice
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// calculatePrice(assetAQuantity: uint256, assetBQuantity: uint256, priceMinSqrt: uint256, priceMaxSqrt: uint256, liquidity: uint256): uint256
//
// Get the current price when asset a has x
// @param assetAQuantity x
// @param assetBQuantity y
// @param priceMinSqrt sqrt(priceMin)
// @param priceMaxSqrt sqrt(priceMax)
// @param liquidity Current pool liquidity - L variable
// @returns the price with specified quantity with the price range set in the contract
calculatePrice:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 7

	// contracts\BiatecCLAMM.algo.ts:665
	// s = SCALE as uint256
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	frame_bury 0 // s: uint256

	// contracts\BiatecCLAMM.algo.ts:666
	// a = priceMinSqrt
	frame_dig -3 // priceMinSqrt: uint256
	frame_bury 1 // a: uint256

	// contracts\BiatecCLAMM.algo.ts:667
	// b = priceMaxSqrt
	frame_dig -4 // priceMaxSqrt: uint256
	frame_bury 2 // b: uint256

	// contracts\BiatecCLAMM.algo.ts:668
	// P1 = (liquidity * a) / s
	frame_dig -5 // liquidity: uint256
	frame_dig 1 // a: uint256
	b*
	frame_dig 0 // s: uint256
	b/
	frame_bury 3 // P1: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:669
	// P2 = (liquidity * s) / b
	frame_dig -5 // liquidity: uint256
	frame_dig 0 // s: uint256
	b*
	frame_dig 2 // b: uint256
	b/
	frame_bury 4 // P2: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:670
	// Nom = assetBQuantity + P1
	frame_dig -2 // assetBQuantity: uint256
	frame_dig 3 // P1: unsafe uint256
	b+
	frame_bury 5 // Nom: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:671
	// Denom = assetAQuantity + P2
	frame_dig -1 // assetAQuantity: uint256
	frame_dig 4 // P2: unsafe uint256
	b+
	frame_bury 6 // Denom: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:672
	// ret = (Nom * s) / Denom
	frame_dig 5 // Nom: unsafe uint256
	frame_dig 0 // s: uint256
	b*
	frame_dig 6 // Denom: unsafe uint256
	b/
	frame_bury 7 // ret: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:673
	// return ret;
	frame_dig 7 // ret: unsafe uint256

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 7
	retsub

// calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256
*abi_route_calculateAssetBWithdrawOnAssetADeposit:
	// The ABI return prefix
	byte 0x151f7c75

	// liqudity: uint256
	txna ApplicationArgs 6
	dup
	len
	int 32
	==
	assert

	// priceMaxSqrt: uint256
	txna ApplicationArgs 5
	dup
	len
	int 32
	==
	assert

	// priceMinSqrt: uint256
	txna ApplicationArgs 4
	dup
	len
	int 32
	==
	assert

	// assetBBalance: uint256
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// assetABalance: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// inAmount: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256
	callsub calculateAssetBWithdrawOnAssetADeposit
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// calculateAssetBWithdrawOnAssetADeposit(inAmount: uint256, assetABalance: uint256, assetBBalance: uint256, priceMinSqrt: uint256, priceMaxSqrt: uint256, liqudity: uint256): uint256
//
// Calculates how much asset B will be taken from the smart contract on asset A deposit
// @param inAmount Asset A amount in Base decimal representation.. If asset has 6 decimals, 1 is represented as 1000000000
// @param assetABalance Asset A balance. Variable ab, in base scale
// @param assetBBalance Asset B balance. Variable bb, in base scale
// @param priceMinSqrt sqrt(Min price). Variable pMinS, in base scale
// @param priceMaxSqrt sqrt(Max price). Variable pMaxS, in base scale
// @param liqudity sqrt(Max price). Variable L, in base scale
// @returns Amount of asset B to be given to the caller before fees. The result is in Base decimals (9)
calculateAssetBWithdrawOnAssetADeposit:
	proto 6 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 12

	// contracts\BiatecCLAMM.algo.ts:711
	// s = SCALE as uint256
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	frame_bury 0 // s: uint256

	// contracts\BiatecCLAMM.algo.ts:712
	// x = assetABalance
	frame_dig -2 // assetABalance: uint256
	frame_bury 1 // x: uint256

	// contracts\BiatecCLAMM.algo.ts:713
	// y = assetBBalance
	frame_dig -3 // assetBBalance: uint256
	frame_bury 2 // y: uint256

	// contracts\BiatecCLAMM.algo.ts:714
	// a = priceMinSqrt
	frame_dig -4 // priceMinSqrt: uint256
	frame_bury 3 // a: uint256

	// contracts\BiatecCLAMM.algo.ts:715
	// b = priceMaxSqrt
	frame_dig -5 // priceMaxSqrt: uint256
	frame_bury 4 // b: uint256

	// contracts\BiatecCLAMM.algo.ts:716
	// L = liqudity
	frame_dig -6 // liqudity: uint256
	frame_bury 5 // L: uint256

	// contracts\BiatecCLAMM.algo.ts:718
	// P1 = (((((a /* 10D */ * b) /* 10D */ / s) * inAmount) /* AD */ / s) * L) /* 10D */ / s
	frame_dig 3 // a: uint256
	frame_dig 4 // b: uint256
	b*
	frame_dig 0 // s: uint256
	b/
	frame_dig -1 // inAmount: uint256
	b*
	frame_dig 0 // s: uint256
	b/
	frame_dig 5 // L: uint256
	b*
	frame_dig 0 // s: uint256
	b/
	frame_bury 6 // P1: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:720
	// P2 = (((b /* 10D */ * inAmount) /* AD */ / s) * y) /* BD */ / s
	frame_dig 4 // b: uint256
	frame_dig -1 // inAmount: uint256
	b*
	frame_dig 0 // s: uint256
	b/
	frame_dig 2 // y: uint256
	b*
	frame_dig 0 // s: uint256
	b/
	frame_bury 7 // P2: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:722
	// P3 = (b /* 10D */ * inAmount) /* AD */ / s
	frame_dig 4 // b: uint256
	frame_dig -1 // inAmount: uint256
	b*
	frame_dig 0 // s: uint256
	b/
	frame_bury 8 // P3: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:724
	// P4 = (b /* 10D */ * x) /* 10D */ / s
	frame_dig 4 // b: uint256
	frame_dig 1 // x: uint256
	b*
	frame_dig 0 // s: uint256
	b/
	frame_bury 9 // P4: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:726
	// P12 = P1 + P2
	frame_dig 6 // P1: unsafe uint256
	frame_dig 7 // P2: unsafe uint256
	b+
	frame_bury 10 // P12: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:728
	// P345 = P3 + P4 + L
	frame_dig 8 // P3: unsafe uint256
	frame_dig 9 // P4: unsafe uint256
	b+
	frame_dig 5 // L: uint256
	b+
	frame_bury 11 // P345: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:730
	// ret = (P12 * s) / P345
	frame_dig 10 // P12: unsafe uint256
	frame_dig 0 // s: uint256
	b*
	frame_dig 11 // P345: unsafe uint256
	b/
	frame_bury 12 // ret: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:731
	// return ret;
	frame_dig 12 // ret: unsafe uint256

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 12
	retsub

// calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256
*abi_route_calculateAssetAWithdrawOnAssetBDeposit:
	// The ABI return prefix
	byte 0x151f7c75

	// liqudity: uint256
	txna ApplicationArgs 6
	dup
	len
	int 32
	==
	assert

	// priceMaxSqrt: uint256
	txna ApplicationArgs 5
	dup
	len
	int 32
	==
	assert

	// priceMinSqrt: uint256
	txna ApplicationArgs 4
	dup
	len
	int 32
	==
	assert

	// assetBBalance: uint256
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// assetABalance: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// inAmount: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256
	callsub calculateAssetAWithdrawOnAssetBDeposit
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// calculateAssetAWithdrawOnAssetBDeposit(inAmount: uint256, assetABalance: uint256, assetBBalance: uint256, priceMinSqrt: uint256, priceMaxSqrt: uint256, liqudity: uint256): uint256
//
// Calculates how much asset A will be taken from the smart contract on asset B deposit
// @param inAmount Asset B amount in Base decimal representation.. If asset has 6 decimals, 1 is represented as 1000000000
// @param assetABalance Asset A balance. Variable ab, in base scale
// @param assetBBalance Asset B balance. Variable bb, in base scale
// @param priceMinSqrt sqrt(Min price). Variable pMinS, in base scale
// @param priceMaxSqrt sqrt(Max price). Variable pMaxS, in base scale
// @param liqudity sqrt(Max price). Variable L, in base scale
//
// @returns Amount of asset A to be given to the caller before fees. The result is in Base decimals (9)
calculateAssetAWithdrawOnAssetBDeposit:
	proto 6 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 13

	// contracts\BiatecCLAMM.algo.ts:766
	// s = SCALE as uint256
	byte 0x000000000000000000000000000000000000000000000000000000003b9aca00
	frame_bury 0 // s: uint256

	// contracts\BiatecCLAMM.algo.ts:767
	// x = assetABalance
	frame_dig -2 // assetABalance: uint256
	frame_bury 1 // x: uint256

	// contracts\BiatecCLAMM.algo.ts:768
	// y = assetBBalance
	frame_dig -3 // assetBBalance: uint256
	frame_bury 2 // y: uint256

	// contracts\BiatecCLAMM.algo.ts:769
	// a = priceMinSqrt
	frame_dig -4 // priceMinSqrt: uint256
	frame_bury 3 // a: uint256

	// contracts\BiatecCLAMM.algo.ts:770
	// b = priceMaxSqrt
	frame_dig -5 // priceMaxSqrt: uint256
	frame_bury 4 // b: uint256

	// contracts\BiatecCLAMM.algo.ts:771
	// L = liqudity
	frame_dig -6 // liqudity: uint256
	frame_bury 5 // L: uint256

	// contracts\BiatecCLAMM.algo.ts:774
	// P1 = (inAmount * L) / s
	frame_dig -1 // inAmount: uint256
	frame_dig 5 // L: uint256
	b*
	frame_dig 0 // s: uint256
	b/
	frame_bury 6 // P1: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:776
	// P2 = (((b * inAmount) / s) * x) / s
	frame_dig 4 // b: uint256
	frame_dig -1 // inAmount: uint256
	b*
	frame_dig 0 // s: uint256
	b/
	frame_dig 1 // x: uint256
	b*
	frame_dig 0 // s: uint256
	b/
	frame_bury 7 // P2: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:778
	// nom = P1 + P2
	frame_dig 6 // P1: unsafe uint256
	frame_dig 7 // P2: unsafe uint256
	b+
	frame_bury 8 // nom: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:780
	// P3 = (((a * b) / s) * L) / s
	frame_dig 3 // a: uint256
	frame_dig 4 // b: uint256
	b*
	frame_dig 0 // s: uint256
	b/
	frame_dig 5 // L: uint256
	b*
	frame_dig 0 // s: uint256
	b/
	frame_bury 9 // P3: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:782
	// P4 = (b * inAmount) / s
	frame_dig 4 // b: uint256
	frame_dig -1 // inAmount: uint256
	b*
	frame_dig 0 // s: uint256
	b/
	frame_bury 10 // P4: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:784
	// P5 = (b * y) / s
	frame_dig 4 // b: uint256
	frame_dig 2 // y: uint256
	b*
	frame_dig 0 // s: uint256
	b/
	frame_bury 11 // P5: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:786
	// denom = P3 + P4 + P5
	frame_dig 9 // P3: unsafe uint256
	frame_dig 10 // P4: unsafe uint256
	b+
	frame_dig 11 // P5: unsafe uint256
	b+
	frame_bury 12 // denom: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:788
	// ret = (nom * s) / denom
	frame_dig 8 // nom: unsafe uint256
	frame_dig 0 // s: uint256
	b*
	frame_dig 12 // denom: unsafe uint256
	b/
	frame_bury 13 // ret: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:789
	// return ret;
	frame_dig 13 // ret: unsafe uint256

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 13
	retsub

// calculateAssetAWithdrawOnLpDeposit(uint256,uint256,uint256)uint256
*abi_route_calculateAssetAWithdrawOnLpDeposit:
	// The ABI return prefix
	byte 0x151f7c75

	// liqudity: uint256
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// assetABalance: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// inAmount: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute calculateAssetAWithdrawOnLpDeposit(uint256,uint256,uint256)uint256
	callsub calculateAssetAWithdrawOnLpDeposit
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// calculateAssetAWithdrawOnLpDeposit(inAmount: uint256, assetABalance: uint256, liqudity: uint256): uint256
//
// Calculates how much asset A will be taken from the smart contract on LP asset deposit
// @param inAmount LP Asset amount in Base decimal representation..
// @param assetABalance Asset A balance. Variable ab, in base scale
// @param liqudity Current liqudity. Variable L, in base scale
//
// @returns Amount of asset A to be given to the caller before fees. The result is in Base decimals (9)
calculateAssetAWithdrawOnLpDeposit:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts\BiatecCLAMM.algo.ts:805
	// ret = (assetABalance * inAmount) / liqudity
	frame_dig -2 // assetABalance: uint256
	frame_dig -1 // inAmount: uint256
	b*
	frame_dig -3 // liqudity: uint256
	b/
	frame_bury 0 // ret: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:806
	// return ret;
	frame_dig 0 // ret: unsafe uint256

	// set the subroutine return value
	frame_bury 0
	retsub

// calculateAssetBWithdrawOnLpDeposit(uint256,uint256,uint256)uint256
*abi_route_calculateAssetBWithdrawOnLpDeposit:
	// The ABI return prefix
	byte 0x151f7c75

	// liqudity: uint256
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// assetBBalance: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// inAmount: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute calculateAssetBWithdrawOnLpDeposit(uint256,uint256,uint256)uint256
	callsub calculateAssetBWithdrawOnLpDeposit
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// calculateAssetBWithdrawOnLpDeposit(inAmount: uint256, assetBBalance: uint256, liqudity: uint256): uint256
//
// Calculates how much asset B will be taken from the smart contract on LP asset deposit
// @param inAmount LP Asset amount in Base decimal representation..
// @param assetBBalance Asset B balance. Variable ab, in base scale
// @param liqudity Current liqudity. Variable L, in base scale
//
// @returns Amount of asset B to be given to the caller before fees. The result is in Base decimals (9)
calculateAssetBWithdrawOnLpDeposit:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts\BiatecCLAMM.algo.ts:822
	// ret = (assetBBalance * inAmount) / liqudity
	frame_dig -2 // assetBBalance: uint256
	frame_dig -1 // inAmount: uint256
	b*
	frame_dig -3 // liqudity: uint256
	b/
	frame_bury 0 // ret: unsafe uint256

	// contracts\BiatecCLAMM.algo.ts:823
	// return ret;
	frame_dig 0 // ret: unsafe uint256

	// set the subroutine return value
	frame_bury 0
	retsub

// calculateAssetBDepositOnAssetADeposit(uint256,uint256,uint256,uint256)uint256
*abi_route_calculateAssetBDepositOnAssetADeposit:
	// The ABI return prefix
	byte 0x151f7c75

	// assetBBalance: uint256
	txna ApplicationArgs 4
	dup
	len
	int 32
	==
	assert

	// assetABalance: uint256
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// inAmountB: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// inAmountA: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute calculateAssetBDepositOnAssetADeposit(uint256,uint256,uint256,uint256)uint256
	callsub calculateAssetBDepositOnAssetADeposit
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// calculateAssetBDepositOnAssetADeposit(inAmountA: uint256, inAmountB: uint256, assetABalance: uint256, assetBBalance: uint256): uint256
//
// Calculates how much asset B should be deposited when user deposit asset a and b.
//
// On deposit min(calculateAssetBDepositOnAssetADeposit, calculateAssetADepositOnAssetBDeposit) should be considered for the real deposit and rest should be swapped or returned back to user
//
// @param inAmountA Asset A amount in Base decimal representation
// @param inAmountB Asset B amount in Base decimal representation
// @param assetABalance Asset A balance. Variable ab, in base scale
// @param assetBBalance Asset B balance. Variable bb, in base scale
//
// @returns Amount of asset B to be given to the caller before fees. The result is in Base decimals (9)
calculateAssetBDepositOnAssetADeposit:
	proto 4 1

	// *if20_condition
	// contracts\BiatecCLAMM.algo.ts:845
	// assetABalance > <uint256>0
	frame_dig -3 // assetABalance: uint256
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	bz *if20_end

	// *if20_consequent
	// contracts\BiatecCLAMM.algo.ts:846
	// return (inAmountA * assetBBalance) / assetABalance;
	frame_dig -1 // inAmountA: uint256
	frame_dig -4 // assetBBalance: uint256
	b*
	frame_dig -3 // assetABalance: uint256
	b/
	retsub

*if20_end:
	// contracts\BiatecCLAMM.algo.ts:849
	// return inAmountB;
	frame_dig -2 // inAmountB: uint256
	retsub

// calculateAssetADepositOnAssetBDeposit(uint256,uint256,uint256,uint256)uint256
*abi_route_calculateAssetADepositOnAssetBDeposit:
	// The ABI return prefix
	byte 0x151f7c75

	// assetBBalance: uint256
	txna ApplicationArgs 4
	dup
	len
	int 32
	==
	assert

	// assetABalance: uint256
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// inAmountB: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// inAmountA: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute calculateAssetADepositOnAssetBDeposit(uint256,uint256,uint256,uint256)uint256
	callsub calculateAssetADepositOnAssetBDeposit
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// calculateAssetADepositOnAssetBDeposit(inAmountA: uint256, inAmountB: uint256, assetABalance: uint256, assetBBalance: uint256): uint256
//
// Calculates how much asset A should be deposited when user deposit asset a and b
//
// On deposit min(calculateAssetBDepositOnAssetADeposit, calculateAssetADepositOnAssetBDeposit) should be considered for the real deposit and rest should be swapped or returned back to user
//
// @param inAmountA Asset A amount in Base decimal representation
// @param inAmountB Asset B amount in Base decimal representation
// @param assetABalance Asset A balance. Variable ab, in base scale
// @param assetBBalance Asset B balance. Variable bb, in base scale
//
// @returns Amount of asset A to be deposited. The result is in Base decimals (9)
calculateAssetADepositOnAssetBDeposit:
	proto 4 1

	// *if21_condition
	// contracts\BiatecCLAMM.algo.ts:871
	// assetBBalance > <uint256>0
	frame_dig -4 // assetBBalance: uint256
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	bz *if21_end

	// *if21_consequent
	// contracts\BiatecCLAMM.algo.ts:872
	// return (inAmountB * assetABalance) / assetBBalance;
	frame_dig -2 // inAmountB: uint256
	frame_dig -3 // assetABalance: uint256
	b*
	frame_dig -4 // assetBBalance: uint256
	b/
	retsub

*if21_end:
	// contracts\BiatecCLAMM.algo.ts:875
	// return inAmountA;
	frame_dig -1 // inAmountA: uint256
	retsub

*create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication
	err

*call_NoOp:
	method "getCurrentPrice()uint64"
	method "getPriceDivider()uint64"
	method "getLPTokenId()uint64"
	method "bootstrap(pay,uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint64,uint64)uint64"
	method "addLiquidity(txn,txn,uint64,uint64,uint64)uint64"
	method "testFailVariableSet()uint64"
	method "removeLiquidity(axfer,uint64,uint64,uint64)uint256"
	method "swap(axfer,uint64,uint64,uint64)uint256"
	method "calculateLiquidity(uint256,uint256,uint256,uint256,uint256,uint256)uint256"
	method "calculatePrice(uint256,uint256,uint256,uint256,uint256)uint256"
	method "calculateAssetBWithdrawOnAssetADeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256"
	method "calculateAssetAWithdrawOnAssetBDeposit(uint256,uint256,uint256,uint256,uint256,uint256)uint256"
	method "calculateAssetAWithdrawOnLpDeposit(uint256,uint256,uint256)uint256"
	method "calculateAssetBWithdrawOnLpDeposit(uint256,uint256,uint256)uint256"
	method "calculateAssetBDepositOnAssetADeposit(uint256,uint256,uint256,uint256)uint256"
	method "calculateAssetADepositOnAssetBDeposit(uint256,uint256,uint256,uint256)uint256"
	txna ApplicationArgs 0
	match *abi_route_getCurrentPrice *abi_route_getPriceDivider *abi_route_getLPTokenId *abi_route_bootstrap *abi_route_addLiquidity *abi_route_testFailVariableSet *abi_route_removeLiquidity *abi_route_swap *abi_route_calculateLiquidity *abi_route_calculatePrice *abi_route_calculateAssetBWithdrawOnAssetADeposit *abi_route_calculateAssetAWithdrawOnAssetBDeposit *abi_route_calculateAssetAWithdrawOnLpDeposit *abi_route_calculateAssetBWithdrawOnLpDeposit *abi_route_calculateAssetBDepositOnAssetADeposit *abi_route_calculateAssetADepositOnAssetBDeposit
	err